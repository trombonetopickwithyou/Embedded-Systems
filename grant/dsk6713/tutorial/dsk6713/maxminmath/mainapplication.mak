#!/bin/sh
# Generated by Code Composer Studio

# Files exported for this project:
# C:\unzipped\TestedTutorialSRCv1\TestedSRCv1\sim64xx\MaxMinMath\Source\MainApplication.Debug.lkf

# Makefile for C:\unzipped\TestedTutorialSRCv1\TestedSRCv1\sim64xx\MaxMinMath\Source\MainApplication.pjt without subprojects
#  FORMAT OF THIS MAKEFILE
#
#   This makefile is intended to be compatible with
# any version of make. It works on the assumption that
# there is a "active configuration", the name of which
# is stored in the macro ACTIVE_CONFIG. When you call
# make and do not specify which configuration you want
# to make, then the active configuration is used. Valid
# build configurations are: all, Debug

#   There are three operations that can be performed on
# any build configuration: make, clean, and rebuild. To
# make the configuration ${CFG}, type make ${CFG}. To
# clean it, type make ${CFG}clean. To rebuild it, type
# make ${CFG}rebuild. A rebuild forces all files in the
# configuration to be rebuilt.
#   Rebuilding is done with the following standard trick.
# each target in this makefile has a dependency on the
# macro ${FRC}. This macro is normally empty, meaning that
# the dependency does nothing. When rebuilding, make is
# called recursively, with ${FRC} defined to be "force_rebuild". 
# This causes everything to be rebuilt, because force_rebuild
# is a phony target (meaning no file by that name exists).
#   Every file in the project is specified explicitly, with
# all pathnames relative to the "project root directory".
# This is the default directory where the project source files
# are located. This makefile assumes that it is located in the
# root project directory. If you don't want to put the makefile
# in the root project directory, you should be able to redefine 
# the ROOT_DIR macro to explicitly specify the project root
# directory.
#   One consequence of all path names being relative is that
# system-wide header files and libraries may not be in the
# same relative place. For this reason, when the makefile is
# exported, all directories which are not subdirectories of the
# project root directory are parameterized wherever they occur,
# and placed in macros. You can modify these macros to reflect
# the actual locations of the required files on this system.
#
#   In order for this makefile to work, you must have the path
# configured properly. Unlike CCS V2.0, this makefile depends upon
# the path environment variable to function. Specifically, the include
# paths for system-wide include files, and the path to the build tools
# must be set. In Windows, a batch file, DosRun.bat, is included with
# Code Composer Studio to set up these environment variables. In UNIX,
# you must set up these environment variables yourself. The "PATH"
# variable must include the path to the CCS build tools, and you 
# must have set the c_dir and a_dir environment variables properly.
#
# ${ACTIVE_CONFIG} is the configuration built when you call make
# with no parameters, make clean, or make rebuild. This can be
# the name of any valid build configuration (including "all")
# Multiple values are not allowed 
ACTIVE_CONFIG= Debug
# To rebuild or clean a configuration explicitly, call
# make <cfgName>rebuild or make <cfgName>clean
# where <cfgName> is the name of a build configuration.

# The MKFLAGS macro takes the place of the MFLAGS or
# MAKEFLAGS macro. If it gives you any trouble, just
# delete the macro. It is used when recursively calling
# make (ie. when rebuilding)
MKFLAGS= ${MFLAGS}${MAKEFLAGS}
# All filenames are relative to ${ROOT_DIR}. MAKE SURE that there
# are no trailing spaces after ROOT_DIR, or the makefile will not work
#   WINDOWS users--if you want to build files in a different
#    directory, you must change ROOT_DIR. WARNING: ROOT_DIR MUST
#    be an absolute path (!)
#   *NIX users--if you want to change this to an absolute path
#    you can, or if you want to move this makefile or invoke it
#    from another place, then change ROOT_DIR. This is supposed
#    to be an environment variable storing the current path. If
#    it isn't, please let us (Texas Instruments) know.
ROOT_DIR= ${PWD}



#  What follows are macro definitions for all directories which
# were detected in your project but may not be compatible between
# systems. Preceding each directory is a list of files which are
# expected to be in that directory. If these files are not located
# in the same place on this system, then modify the appropriate
# macros. MAKE SURE that there are no trailing spaces after these
# macros, or the makefile will not work.

#Directory for: stdio.h
STRANGE_DIR1= ../../../../../../ti/c6000/cgtools/include

#Directory for: cl6x
STRANGE_DIR2= ../../../../../../ti/c6000/cgtools/bin

active_config: ${ACTIVE_CONFIG}

clean: ${ACTIVE_CONFIG}clean

rebuild: ${ACTIVE_CONFIG}rebuild

force_rebuild: 

all: Debug 

allclean: Debugclean 

allrebuild: Debugrebuild 



Debugclean: 
	-cd ${ROOT_DIR};rm -f ${ROOT_DIR}/testApp.obj 
	-cd ${ROOT_DIR};rm -f ${ROOT_DIR}/Debug/MainApplication.out 

Debugrebuild: 
	${MAKE} ${MFLAGS} -f MainApplication.mak Debug FRC=force_rebuild 

Debug: ${ROOT_DIR}/Debug/MainApplication.out

${ROOT_DIR}/testApp.obj: ${FRC} ${STRANGE_DIR1}/stdio.h ${ROOT_DIR}/testApp.c 
	cd ${ROOT_DIR}/;echo Building Test Application File (testApp.c) 
	cd ${ROOT_DIR}/;${STRANGE_DIR2}/cl6x -g -q "testApp.c"  
	cd ${ROOT_DIR}/;echo Finished Building Test Application File (testApp.c) 

${ROOT_DIR}/Debug/MainApplication.out: ${FRC} ${ROOT_DIR}/Debug/MaxMinLibrary.lib ${ROOT_DIR}/rts6400.lib ${ROOT_DIR}/testApp.obj 
	cd ${ROOT_DIR}/;c:\ti\c6000\cgtools\bin\cl6x ${ROOT_DIR}/MainApplication.Debug.lkf 
