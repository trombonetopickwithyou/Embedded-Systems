!<arch>
_csl_irq.c/     1030611949  0     0     0       4477      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... _csl_irq.c
* DATE CREATED.. 02/02/2001
\******************************************************************************/
#include "csl_irq.h"

#if (IRQ_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/* We need to use the runtime library intrinsic _lmbd() function but */
extern far Uint32 _lmbd(Uint32 src1, Uint32 src2);

extern far void _IRQ_vecs();

/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/
static void dummyIsr(Uint32 arg, Uint32 eventId);


/******************************************************************************\
* static variable definitions
\******************************************************************************/

/******************************************************************************\
* static function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
void dummyIsr(Uint32 arg, Uint32 eventId) {
}

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/
_IRQ_Dispatch _IRQ_internalDispatchTable[_IRQ_DISPATCHTABLE_CNT] = {
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000},
  {dummyIsr, IRQ_IEMASK_DEFAULT, IRQ_CCMASK_DEFAULT, 0x00000000}
};

/******************************************************************************\
* global function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
void IRQ_dispatcherSetup() {

  int gie;

  gie = IRQ_globalDisable();

  _IRQ_init(IRQ_biosPresent(), _IRQ_internalDispatchTable);
  IRQ_setVecs(_IRQ_vecs);
  IRQ_nmiEnable();
  gie = 1;

  IRQ_globalRestore(gie);
  
}

/*----------------------------------------------------------------------------*/


#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of _csl_irq.c
\******************************************************************************/


csl.c/          1092218715  0     0     0       5620      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl.c
* DATE CREATED.. 06/13/2000  
* LAST MODIFIED. 08/02/2004  Adding support for C6418
*                07/24/2004 - Re-introduced BIOS dependency due to compatibility issues
*                02/05/2004  Modified _CSL_init()definition to remove bios component 
*                06/17/2003  Added CHIP_6712C
*                05/28/2003  Added CHIP_6711C
*                02/12/2002  _TIMER_hBios capture
*                11/05/2001  addition 6412, DM642 CSL libraries
*                10/04/2001  addition 6712, 6713, 6414, 6415, 6415 
\******************************************************************************/
#define _CSL_MOD_

#include "csl_irq.h"
#include "csl_timer.h"
#include "csl.h"
#include "csl_edma.h"

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static char dateStamp[] = "DATE STAMP ["__DATE__"] ["__TIME__"]";

static int initialized = 0;


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/
void _CSL_init(_CSL_Config *config) {

  Uint32 gie;
  TIMER_Handle hTimer;
  Uint32 biosPresent;
  _IRQ_Dispatch *dispatchTable;
  Uint32 timerUsed;
  Uint32 timerNum;

  UNREFERENCED_PARAMETER(dateStamp[0]);

  gie = IRQ_globalDisable(); 

  if (!initialized) {
    #if (EDMA_SUPPORT)
      /* intialize the EDMA NULL parameter table */
      EDMA_configArgs(EDMA_hNull,0,0,0,0,0,0);
    #endif
    initialized = 1;
  }

  if (config != INV) {
    hTimer         = (TIMER_Handle)INV;
    biosPresent    = config->args.biosPresent;
    dispatchTable  = config->args.dispatchTable;
    timerUsed      = config->args.timerUsed;
    timerNum       = config->args.timerNum;
    _IRQ_init(biosPresent, dispatchTable);
    

    if (timerUsed) {
        hTimer = TIMER_open(timerNum,0);  
        _TIMER_hBios = hTimer; 
    }
    config->ret.hTimer = hTimer;
    config->ret.event2IntTbl = (Uint32*)_IRQ_eventTable;
    config->ret.int2EventTbl = (Uint32*)_IRQ_intTable;
  } else {
    _IRQ_init(0,INV);
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/

  /* Here we will define a function whose name matches the library name  */
  /* It will be called by CSL_init() and is used to detect when the      */
  /* incorrect library is linked in.                                     */

#if (CHIP_6201)
  void CSL6201_LIB_() {}

#elif (CHIP_6202)
  void CSL6202_LIB_() {}

#elif (CHIP_6203)
  void CSL6203_LIB_() {}

#elif (CHIP_6204)
  void CSL6204_LIB_() {}

#elif (CHIP_6205)
  void CSL6205_LIB_() {}

#elif (CHIP_6211)
  void CSL6211_LIB_() {}

#elif (CHIP_6701)
  void CSL6701_LIB_() {}

#elif (CHIP_6711)
  void CSL6711_LIB_() {}

#elif (CHIP_6712)
  void CSL6712_LIB_() {}

#elif (CHIP_6713)
  void CSL6713_LIB_() {} 

#elif (CHIP_DA610)
  void CSLDA610_LIB_() {} 

#elif (CHIP_DM642)
  void CSLDM642_LIB_() {}

#elif (CHIP_DM640)
  void CSLDM640_LIB_() {}

#elif (CHIP_DM641)
  void CSLDM641_LIB_() {}

#elif (CHIP_6412)
  void CSL6412_LIB_() {}

#elif (CHIP_6414)
  void CSL6414_LIB_() {}

#elif (CHIP_6415)
  void CSL6415_LIB_() {}

#elif (CHIP_6416)
  void CSL6416_LIB_() {}

#elif (CHIP_6711C)
  void CSL6711C_LIB_() {}

#elif (CHIP_6712C)
  void CSL6712C_LIB_() {}

#elif (CHIP_6411)
  void CSL6411_LIB_() {}

/* next two libaries are DRI300 variants */
#elif (CHIP_6410)
  void CSL6410_LIB_() {}

#elif (CHIP_6413)
  void CSL6413_LIB_() {}

#elif (CHIP_6418)
  void CSL6418_LIB_() {}

#endif

/*----------------------------------------------------------------------------*/


/******************************************************************************\
* End of csl.c
\******************************************************************************/

csl_cache.c/    1092218716  0     0     0       31074     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_cache.c
* DATE CREATED.. 06/11/1999
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                05/31/2002
*------------------------------------------------------------------------------
* DESCRIPTION:  (body file for the CACHE module)
*
*   Supported Cache Operations:
*                      +-----+-----+-----+
*                      | L2  | L1P | L1D |
*   +------------------+-----+-----+-----+
*   | invalidate range |     |  X  |     |
*   | invalidate all   |     |  X  |  X  |
*   +------------------+-----+-----+-----+
*   | flush range      |  X  |     |  X  |
*   | flush all        |  X  |     |     |
*   +------------------+-----+-----+-----+
*   | clean range      |  X  |     |     |
*   | clean all        |  X  |     |     |
*   +------------------+-----+-----+-----+
*
*   invalidate range L1P - use L1PFBAR/L1PFWC
*   invalidate all L1P   - use CCFG.IP
*   invalidate all L1D   - use CCFG.ID
*   flush range L2       - use L2FBAR/L2FWC
*   flush range L1D      - use L1DFBAR/L1DFWC
*   flush all L2         - use L2FLUSH
*   clean range L2       - use L2CBAR/L2CWC
*   clean all L2         - use L2CLEAN
*
*   L2 Cache Mode Switching Guidelines
*     Decrease L2 SRAM:
*       1) Perform flush of L2 cache (all). Spin on completion.
*       2) Write new L2 mode / Read back.
*       3) NOP 8
*
*
*     Increase L2 SRAM:
*       1) Perform flush of L2 cache (all). Spin on completion.
*       2) Write new L2 mode / Read back.
*       3) NOP 8
*
\******************************************************************************/
#define _CACHE_MOD_
#include "csl_cache.h"
#include "csl_edma.h"


#if (CACHE_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/

static Uint32 busyMaskCache = 0x00000000;

/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/

void CACHE_reset() {

  #if (L2CACHE_SUPPORT && C64_SUPPORT)
      volatile Uint32 addr;
      #if (CHIP_6414|CHIP_6415|CHIP_6416)
      /* Reset EMIFB regions */
       for (addr=0x01848180u; addr<0x018481C0; addr+=4)
            REG32(addr) = REG32(addr)&0xFFFFFFFE;
      #endif
      /* Reset EMIFA regions */
       for (addr=0x01848200u; addr<0x01848300; addr+=4)
            REG32(addr) = REG32(addr)&0xFFFFFFFE;

       /* Set entire cache region as SRAM */
       CACHE_setL2Mode(0);
  #endif

  /* Invalidate Program and Data cache */
  CHIP_FSET(CSR,PCC,0);
  CHIP_FSET(CSR,DCC,0);

  #if (L2CACHE_SUPPORT && !C64_SUPPORT)
    CACHE_RSET(MAR0,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR1,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR2,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR3,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR4,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR5,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR6,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR7,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR8,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR9,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR10,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR11,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR12,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR13,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR14,CACHE_MAR_DEFAULT);
    CACHE_RSET(MAR15,CACHE_MAR_DEFAULT);
    //CACHE_RSET(CCFG,CACHE_CCFG_DEFAULT);
  #endif /* (L2CACHE_SUPPORT) */
}
/*----------------------------------------------------------------------------*/
#if (L2CACHE_SUPPORT && (CHIP_6414|CHIP_6415|CHIP_6416))
void CACHE_resetEmifb() {

    volatile Uint32 addr;

    for (addr=0x01848180u; addr<0x018481C0; addr+=4) {
      REG32(addr) = REG32(addr)&0xFFFFFFFE;
    }
}
#endif
/*----------------------------------------------------------------------------*/
void CACHE_resetEmifa() {

  volatile Uint32 addr;

   #if (L2CACHE_SUPPORT && (CHIP_6414|CHIP_6415|CHIP_6416|CHIP_DM642|CHIP_DM641|CHIP_DM640|CHIP_6412|CHIP_6411|CHIP_6410|CHIP_6413|CHIP_6418))
      for (addr=0x01848200u; addr<0x01848300; addr+=4) {
          REG32(addr) = REG32(addr)&0xFFFFFFFE;
      }
  #endif
}
/*----------------------------------------------------------------------------*/
CACHE_L2Mode CACHE_getL2Mode() {

  #if (L2CACHE_SUPPORT)
    return (CACHE_L2Mode)CACHE_FGET(CCFG,L2MODE);
  #else
    return (CACHE_L2Mode)CACHE_0KCACHE;
  #endif
}

/*----------------------------------------------------------------------------*/
CACHE_L2Mode CACHE_setL2Mode(CACHE_L2Mode newMode) {

  #if (L2CACHE_SUPPORT)
  Uint32 gie;
  Uint32 base_address;
  Uint32 byte_count;
  Uint32 curMode = CACHE_FGET(CCFG,L2MODE);
  #if (CHIP_6211 | CHIP_6711 | CHIP_6712 | CHIP_6711C | CHIP_6712C) //....
  Uint32 start_of_cache[] =
  {
    0x00010000,         /* 000 =   64K SRAM,   0K cache   */
    0x0000C000,         /* 001 =   48K SRAM,  16K cache   */
    0x00008000,         /* 010 =   32K SRAM,  32K cache   */
    0x00004000,         /* 011 =   16K SRAM,  48K cache   */
    0x00000000,         /* 100 -- undefined, treat as 111 */
    0x00000000,         /* 101 -- undefined, treat as 111 */
    0x00000000,         /* 110 -- undefined, treat as 111 */
    0x00000000          /* 111 =    0K SRAM,  64K cache   */
  };
  #endif

  #if (CHIP_6713 | CHIP_DA610)
  Uint32 start_of_cache[] =
  {
    0x00040000,         /* 000 =  256K SRAM,   0K cache   */
    0x0003C000,         /* 001 =  240K SRAM,  16K cache   */
    0x00038000,         /* 010 =  224K SRAM,  32K cache   */
    0x00034000,         /* 011 =  208K SRAM,  48K cache   */
    0x00030000,         /* 100 -- undefined, treat as 111 */
    0x00030000,         /* 101 -- undefined, treat as 111 */
    0x00030000,         /* 110 -- undefined, treat as 111 */
    0x00030000          /* 111 =  192K SRAM,  64K cache   */
  };
  #endif

  #if (CHIP_6414 | CHIP_6415 | CHIP_6416)
  Uint32 start_of_cache[] =
  {
    0x00100000,         /* 000 = 1024K SRAM,   0K cache   */
    0x000F8000,         /* 001 =  992K SRAM,  32K cache   */
    0x000F0000,         /* 010 =  960K SRAM,  64K cache   */
    0x000E0000,         /* 011 =  896K SRAM, 128K cache   */
    0x000C0000,         /* 100 -- undefined, treat as 111 */
    0x000C0000,         /* 101 -- undefined, treat as 111 */
    0x000C0000,         /* 110 -- undefined, treat as 111 */
    0x000C0000          /* 111 =  768K SRAM, 256K cache   */
  };
  #endif

 #if (CHIP_DM642 | CHIP_6412 | CHIP_6411)
  Uint32 start_of_cache[] =
  {
    0x00040000,         /* 000 =  256K SRAM,   0K cache   */
    0x00038000,         /* 001 =  224K SRAM,  32K cache   */
    0x00030000,         /* 010 =  192K SRAM,  64K cache   */
    0x00020000,         /* 011 =  128K SRAM, 128K cache   */
    0x00000000,         /* 100 -- undefined, treat as 111 */
    0x00000000,         /* 101 -- undefined, treat as 111 */
    0x00000000,         /* 110 -- undefined, treat as 111 */
    0x00000000          /* 111 =    0K SRAM, 256K cache   */
  };
 #endif

 #if (CHIP_6418)
  Uint32 start_of_cache[] =
  {
    0x00080000,         /* 000 =  512K SRAM,   0K cache   */
    0x00078000,         /* 001 =  480K SRAM,  32K cache   */
    0x00070000,         /* 010 =  448K SRAM,  64K cache   */
    0x00060000,         /* 011 =  384K SRAM, 128K cache   */
    0x00040000,         /* 100 -- undefined, treat as 111 */
    0x00040000,         /* 101 -- undefined, treat as 111 */
    0x00040000,         /* 110 -- undefined, treat as 111 */
    0x00040000          /* 111 =  256K SRAM, 256K cache   */
  };
 #endif

 #if (CHIP_6413)
  Uint32 start_of_cache[] =
  {
    0x00040000,         /* 000 =  256K SRAM,   0K cache   */
    0x00038000,         /* 001 =  224K SRAM,  32K cache   */
    0x00030000,         /* 010 =  192K SRAM,  64K cache   */
    0x00020000,         /* 011 =  128K SRAM, 128K cache   */
    0x00000000,         /* 100 -- undefined, treat as 111 */
    0x00000000,         /* 101 -- undefined, treat as 111 */
    0x00000000,         /* 110 -- undefined, treat as 111 */
    0x00000000          /* 111 =  256K cache              */
  };
 #endif
  
 #if (CHIP_6410 | CHIP_DM641 | CHIP_DM640)
  Uint32 start_of_cache[] =
  {
    0x00020000,         /* 000 =  128K SRAM,   0K cache   */
    0x00018000,         /* 001 =  96K SRAM,   32K cache   */
    0x00010000,         /* 010 =  64K SRAM,   64K cache   */
    0x00000000,         /* 011 =  128K cache              */
    0x00000000,         /* 100 -- undefined, treat as 011 */
    0x00000000,         /* 101 -- undefined, treat as 011 */
    0x00000000,         /* 110 -- undefined, treat as 011 */
    0x00000000          /* 111 =  undefined, treat as 011 */
  };
 #endif

  gie = IRQ_globalDisable();


    /* switch cache modes and flush as needed */
    
    /* To take care of the invalid L2MODE entries, map them to the mode with highest cache configuration   *
     * This is just so that no unnecessary cache clean is done if an invalide mode is given.               */

  #if (!(CHIP_6410|CHIP_DM640|CHIP_DM641))
    if (newMode & 0x4) {
       newMode = 0x7; 
    }
  #else
    if (newMode & 0x4) {
        newMode = 0x3; /* max cache size is 128 K */
    }
  #endif

    if (newMode < curMode) {    /* increase SRAM size */

      /* Clean all L2 and wait for completion */
     CACHE_clean(CACHE_L2ALL, 0, 0);

      /* Switch L2 mode */
      CACHE_FSET(CCFG,L2MODE,newMode);
      CACHE_FGET(CCFG,L2MODE);
      asm(" NOP 4");
      asm(" NOP 4");

    } else if (newMode > curMode) {   /* decrease SRAM size */

      /* Writeback Invalidate L1D */
        base_address = start_of_cache[newMode];
        byte_count   = start_of_cache[curMode] - start_of_cache[newMode];

		/* If 256K Cache is to be configured */
		if (byte_count == 0x40000)
		{
                    /* wbInvL1d 0xFFFF words from base_address */
	   	    CACHE_wbInvL1d((void *)base_address, 0x3FFFC, CACHE_WAIT);
		    /* wbInvL1d last word */
		    CACHE_wbInvL1d((void *)((Uint32)base_address + 0x3FFFC), 0x4, CACHE_WAIT);
		} else
                    CACHE_wbInvL1d((void *)base_address, byte_count, CACHE_WAIT);

	  //      CACHE_invalidate(CACHE_L1DALL, 0, 0);
      /* Clean L2 and wait for completion */
      CACHE_clean(CACHE_L2ALL, 0, 0);
      /* Switch L2 mode */
      CACHE_FSET(CCFG,L2MODE,newMode);
      CACHE_FGET(CCFG,L2MODE);
      asm(" NOP 4");
      asm(" NOP 4");
    }
    IRQ_globalRestore(gie);

    return (CACHE_L2Mode)(curMode);

  #else
    UNREFERENCED_PARAMETER(newMode);
    return (CACHE_L2Mode)0;
  #endif /* (L2CACHE_SUPPORT) */
}

/*----------------------------------------------------------------------------*/
CACHE_Pcc CACHE_setPccMode(CACHE_Pcc newMode) {

  #if !(L2CACHE_SUPPORT)
    Uint32 curMode = CHIP_FGET(CSR,PCC);
    CHIP_FSET(CSR,PCC,newMode);
    return (CACHE_Pcc)curMode;
  #else
    Uint32 curMode = CHIP_FGET(CSR,PCC);
    UNREFERENCED_PARAMETER(newMode);
    return (CACHE_Pcc)curMode;
  #endif
}

/*----------------------------------------------------------------------------*/
void CACHE_flush(CACHE_Region region, void *addr, Uint32 wordCnt) {

  #if (L2CACHE_SUPPORT)

    /* flush specified region of cache then wait for completion */
    switch (region) {
      case CACHE_L2:
      {
        Uint32 gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

        CACHE_RSET(L2FBAR,addr);
        CACHE_RSET(L2FWC,wordCnt);

        IRQ_globalRestore(gie);

        while (CACHE_RGET(L2FWC))
                    ;
        break;
      }

      case CACHE_L2ALL:
      {
        int i = 0;

        CACHE_FSET(L2FLUSH,F,1);
        while (CACHE_FGET(L2FLUSH,F))
                  i++;

    #if     C64_SUPPORT == 0
        UNREFERENCED_PARAMETER(i);
    #else
        /* -------------------------------------------------------------- */
        /*  Workaround for L2FLUSH errata on C641x Rev 1.03 and earlier.  */
        /*  See CACHE_clean() for description of the workaround.          */
        /* -------------------------------------------------------------- */
        if (i < 4)
        {
        CACHE_FSET(L2FLUSH,F,1);
          while (CACHE_FGET(L2FLUSH,F))
                        ;
        }
   #endif
        break;
      }

      case CACHE_L1D:
      {
        Uint32 gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

        CACHE_RSET(L1DFBAR,addr);
        CACHE_RSET(L1DFWC,wordCnt);

        IRQ_globalRestore(gie);

        while (CACHE_RGET(L1DFWC))
                    ;
        break;
    }
    }

  #else
    UNREFERENCED_PARAMETER(region);
    UNREFERENCED_PARAMETER(addr);
    UNREFERENCED_PARAMETER(wordCnt);
  #endif /* (L2CACHE_SUPPORT) */
}

/*----------------------------------------------------------------------------*/
void CACHE_clean(CACHE_Region region, void *addr, Uint32 wordCnt) {

  #if (L2CACHE_SUPPORT)

    /* clean specified region of cache then wait for completion */
    switch (region) {
      case CACHE_L2:
      {
        Uint32 gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

        CACHE_RSET(L2CBAR,addr);
        asm(" NOP");
        CACHE_RSET(L2CWC,wordCnt);

        IRQ_globalRestore(gie);

        while (CACHE_RGET(L2CWC))
                   ;
        break;
      }

      case CACHE_L2ALL:
      {
        int i = 0;

        CACHE_FSET(L2CLEAN,C,1);
        while (CACHE_FGET(L2CLEAN,C))  /*if executed,L2CLEAN takes a minimum of 5500 cys*/
                  i++;                 /*if broken, L2CLEAN takes 500 cys.CPU is stalled, won't iterate*/

      #if     C64_SUPPORT == 0
        UNREFERENCED_PARAMETER(i);
      #else
        /* ---------------------------------------------------------------- */
        /*  Workaround for L2CLEAN errata on C641x Rev 1.03 and earlier:    */
        /*  Every second L2CLEAN doesn't clean L2, and thus the poll        */
        /*  loop above won't iterate more than once or twice.  We           */
        /*  only issue the extra clean if we detect L2CLEAN didn't work.    */
        /*  This allows the same code to operate correctly on Rev <= 1.03   */
        /*  and Rev > 1.03 parts with the same object code, and without     */
        /*  unnecessary cleans.  A similar fix is required for L2FLUSH.     */
        /*                                                                  */
        /*  Compiler aside:  We don't need to #ifdef the i++ as the         */
        /*  compiler will deadcode it for us.                               */
        /* ---------------------------------------------------------------- */
        if (i < 4)
        {
          CACHE_FSET(L2CLEAN,C,1);
          while (CACHE_FGET(L2CLEAN,C))
                       ;
        }
     #endif
        break;
    }
    }
  #else
    UNREFERENCED_PARAMETER(region);
    UNREFERENCED_PARAMETER(addr);
    UNREFERENCED_PARAMETER(wordCnt);
  #endif /* (L2CACHE_SUPPORT) */
}

/*----------------------------------------------------------------------------*/
void CACHE_invalidate(CACHE_Region region, void *addr, Uint32 wordCnt) {

  #if (L2CACHE_SUPPORT)

    /* invalidate specified region of cache then wait for completion */
    switch (region) {
      case CACHE_L1P:
    {
        Uint32 gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

        CACHE_RSET(L1PFBAR,addr);
        CACHE_RSET(L1PFWC,wordCnt);

        IRQ_globalRestore(gie);

        while (CACHE_RGET(L1PFWC))
                     ;
        break;
    }

      case CACHE_L1PALL:
     {
        CACHE_FSET(CCFG,IP,1);
//        while (CACHE_FGET(CCFG,IP));
        break;
     }

/*
      case CACHE_L1DALL:
     {
        CACHE_FSET(CCFG,ID,1);
        while (CACHE_FGET(CCFG,ID));
        break;
    }
*/
  }
  #else
    UNREFERENCED_PARAMETER(region);
    UNREFERENCED_PARAMETER(addr);
    UNREFERENCED_PARAMETER(wordCnt);
  #endif /* (L2CACHE_SUPPORT) */
}

/*----------------------------------------------------------------------------*/
Uint32 CACHE_getL2SramSize() {

  #if (L2CACHE_SUPPORT)

    Uint32 curMode = CACHE_FGET(CCFG,L2MODE);
    Uint32 size;

   #if C11_SUPPORT
    switch (curMode) {
    case 7:   size = 0x00000000; break;
    case 3:   size = 0x00004000; break;
    case 2:   size = 0x00008000; break;
    case 1:   size = 0x0000C000; break;
    case 0:   size = 0x00010000; break;
    }
   #endif

    #if (CHIP_6414|CHIP_6415|CHIP_6416)
    switch (curMode) {
    case 7:   size = 0x000C0000; break;
    case 3:   size = 0x000E0000; break;
    case 2:   size = 0x000F0000; break;
    case 1:   size = 0x000F8000; break;
    case 0:   size = 0x00100000; break;
    }
   #endif

    #if (CHIP_6713 | CHIP_DA610)
      switch (curMode) {
    case 7:   size = 0x00030000; break; /* + 192K SRAM OFFSET*/
    case 3:   size = 0x00034000; break;
    case 2:   size = 0x00038000; break;
    case 1:   size = 0x0003C000; break;
    case 0:   size = 0x00040000; break;
    }
    #endif

    #if (CHIP_DM642 | CHIP_6412 | CHIP_6411)
      switch (curMode) {
    case 7:   size = 0x00000000; break; /* 64Kbyte Bank */
    case 3:   size = 0x00020000; break;
    case 2:   size = 0x00030000; break;
    case 1:   size = 0x00038000; break;
    case 0:   size = 0x00040000; break;
    }
   #endif

   #if (CHIP_6418)
      switch (curMode) {
    case 7:   size = 0x00040000; break; /* 256Kbyte Offset */
    case 3:   size = 0x00060000; break;
    case 2:   size = 0x00070000; break;
    case 1:   size = 0x00078000; break; 
    case 0:   size = 0x00080000; break;
    }
   #endif

   #if (CHIP_6413)
      switch (curMode) {
    case 7:   size = 0x00000000; break; /* 256Kbyte Offset */
    case 3:   size = 0x00020000; break;
    case 2:   size = 0x00030000; break;
    case 1:   size = 0x00038000; break; 
    case 0:   size = 0x00040000; break; 
    }
   #endif

   #if (CHIP_6410 | CHIP_DM641 | CHIP_DM640)
      switch (curMode) {
    case 3:   size = 0x00000000; break;
    case 2:   size = 0x00010000; break;
    case 1:   size = 0x00018000; break; 
    case 0:   size = 0x00020000; break; 
    }
   #endif

    return size;

  #else
    return (Uint32)0;
  #endif
}

/*----------------------------------------------------------------------------*/
void CACHE_wbL2(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait){

  #if (L2CACHE_SUPPORT)

	  Uint32 gie;

	  CACHE_wait();
	  gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

      CACHE_RSET(L2WBAR,blockPtr);
      CACHE_RSET(L2WWC,(byteCnt+3)>>2);

      IRQ_globalRestore(gie);

	  if (wait)
             while (CACHE_RGET(L2WWC))
                        ;
	  else
	     busyMaskCache = CACHE_WAIT_L2WB;

  #else
    UNREFERENCED_PARAMETER(blockPtr);
    UNREFERENCED_PARAMETER(byteCnt);
    UNREFERENCED_PARAMETER(wait);
  #endif /* (L2CACHE_SUPPORT) */

}
/*----------------------------------------------------------------------------*/
#if (C64_SUPPORT)
void CACHE_invL2(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait){

  #if (L2CACHE_SUPPORT)

	  Uint32 gie;

	  CACHE_wait();
	  gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */


      CACHE_RSET(L2IBAR,blockPtr);
      CACHE_RSET(L2IWC,(byteCnt+3)>>2);

      IRQ_globalRestore(gie);

	  if (wait)
             while (CACHE_RGET(L2IWC))
                          ;
	  else
             busyMaskCache = CACHE_WAIT_L2INV;

  #else
    UNREFERENCED_PARAMETER(blockPtr);
    UNREFERENCED_PARAMETER(byteCnt);
    UNREFERENCED_PARAMETER(wait);
  #endif /* (L2CACHE_SUPPORT) */

}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
void CACHE_wbInvL2(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait){


  #if (L2CACHE_SUPPORT)

	  Uint32 gie;

	  CACHE_wait();
	  gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */


      CACHE_RSET(L2WIBAR,blockPtr);
      CACHE_RSET(L2WIWC,(byteCnt+3)>>2);

      IRQ_globalRestore(gie);

	  if (wait)
             while (CACHE_RGET(L2WIWC))
                          ;
	  else
	     busyMaskCache = CACHE_WAIT_L2WBINV;


  #else
    UNREFERENCED_PARAMETER(blockPtr);
    UNREFERENCED_PARAMETER(byteCnt);
    UNREFERENCED_PARAMETER(wait);
  #endif /* (L2CACHE_SUPPORT) */

}
/*----------------------------------------------------------------------------*/
void CACHE_wbAllL2(CACHE_Wait wait){

  #if (L2CACHE_SUPPORT)

      int i = 0;
	  Uint32 gie = IRQ_globalDisable();

      CACHE_FSET(L2WB,C,1);

      IRQ_globalRestore(gie);

      if (wait){
         while (CACHE_FGET(L2WB,C))
                i++;

    #if     C64_SUPPORT == 0
        UNREFERENCED_PARAMETER(i);
    #else
        /* -------------------------------------------------------------- */
        /*  Workaround for L2FLUSH errata on C641x Rev 1.03 and earlier.  */
        /*  See CACHE_clean() for description of the workaround.          */
        /* -------------------------------------------------------------- */
        if (i < 4)
        {
           CACHE_FSET(L2WB,C,1);
           while (CACHE_FGET(L2WB,C))
                        ;
        }
    #endif

      }
      else
        busyMaskCache = CACHE_WAIT_L2WBALL;



  #else
    UNREFERENCED_PARAMETER(wait);
  #endif /* (L2CACHE_SUPPORT) */

}
/*----------------------------------------------------------------------------*/
void CACHE_wbInvAllL2(CACHE_Wait wait){

  #if (L2CACHE_SUPPORT)

      int i = 0;

	  Uint32 gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

      CACHE_FSET(L2WBINV,C,1);

      IRQ_globalRestore(gie);

      if (wait){
         while (CACHE_FGET(L2WBINV,C))
		  i++;

      #if     C64_SUPPORT == 0
        UNREFERENCED_PARAMETER(i);
      #else
        /* ---------------------------------------------------------------- */
        /*  Workaround for L2CLEAN errata on C641x Rev 1.03 and earlier:    */
        /*  Every second L2CLEAN doesn't clean L2, and thus the poll        */
        /*  loop above won't iterate more than once or twice.  We           */
        /*  only issue the extra clean if we detect L2CLEAN didn't work.    */
        /*  This allows the same code to operate correctly on Rev <= 1.03   */
        /*  and Rev > 1.03 parts with the same object code, and without     */
        /*  unnecessary cleans.  A similar fix is required for L2FLUSH.     */
        /*                                                                  */
        /*  Compiler aside:  We don't need to #ifdef the i++ as the         */
        /*  compiler will deadcode it for us.                               */
        /* ---------------------------------------------------------------- */
        if (i < 4)
        {
          CACHE_FSET(L2WBINV,C,1);
          while (CACHE_FGET(L2WBINV,C))
             ;
        }
     #endif
      }
       else
         busyMaskCache = CACHE_WAIT_L2WBINVALL;

  #else
    UNREFERENCED_PARAMETER(wait);
  #endif /* (L2CACHE_SUPPORT) */

}
/*----------------------------------------------------------------------------*/
#if (C64_SUPPORT)
void CACHE_invL1d(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait){

  #if (L2CACHE_SUPPORT)

	  Uint32 gie;

	  CACHE_wait();
	  gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

      CACHE_RSET(L1DIBAR,blockPtr);
      CACHE_RSET(L1DIWC,(byteCnt+3)>>2);

      IRQ_globalRestore(gie);

      if (wait)
         while (CACHE_RGET(L1DIWC))
                      ;
      else
        busyMaskCache = CACHE_WAIT_L1DINV;

  #else
    UNREFERENCED_PARAMETER(blockPtr);
    UNREFERENCED_PARAMETER(byteCnt);
    UNREFERENCED_PARAMETER(wait);
  #endif /* (L2CACHE_SUPPORT) */

}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
void CACHE_wbInvL1d(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait){

  #if (L2CACHE_SUPPORT)

	  Uint32 gie;

	  CACHE_wait();
	  gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

      CACHE_RSET(L1DWIBAR,blockPtr);
      CACHE_RSET(L1DWIWC,(byteCnt+3)>>2);

      IRQ_globalRestore(gie);

      if (wait)
         while (CACHE_RGET(L1DWIWC))
                      ;
      else
        busyMaskCache = CACHE_WAIT_L1DWBINV;

  #else
    UNREFERENCED_PARAMETER(blockPtr);
    UNREFERENCED_PARAMETER(byteCnt);
    UNREFERENCED_PARAMETER(wait);
  #endif /* (L2CACHE_SUPPORT && C64_SUPPORT) */

}
/*----------------------------------------------------------------------------*/
/*
void CACHE_invAllL1d(){

  #if (L2CACHE_SUPPORT)

      Uint32 gie = IRQ_globalDisable();

      CACHE_FSET(CCFG,ID,1);

      IRQ_globalRestore(gie);

  #endif

}
*/
/*----------------------------------------------------------------------------*/
void CACHE_invL1p(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait){

  #if (L2CACHE_SUPPORT)

	  Uint32 gie;

	  CACHE_wait();
	  gie = IRQ_globalDisable(); /* treat BAR/WC as crit section */

      CACHE_RSET(L1PIBAR,blockPtr);
      CACHE_RSET(L1PIWC,(byteCnt+3)>>2);

      IRQ_globalRestore(gie);

      if (wait)
         while (CACHE_RGET(L1PIWC))
                      ;
      else
         busyMaskCache = CACHE_WAIT_L1PINV;

  #else
    UNREFERENCED_PARAMETER(blockPtr);
    UNREFERENCED_PARAMETER(byteCnt);
    UNREFERENCED_PARAMETER(wait);
  #endif /* (L2CACHE_SUPPORT && C64_SUPPORT) */


}
/*----------------------------------------------------------------------------*/
void CACHE_invAllL1p(){

  #if (L2CACHE_SUPPORT)

      Uint32 gie = IRQ_globalDisable();

      CACHE_FSET(CCFG,IP,1);

      IRQ_globalRestore(gie);
  #endif

}
/*----------------------------------------------------------------------------*/
void CACHE_wait(){

  #if (L2CACHE_SUPPORT)

    switch (busyMaskCache) {
      case CACHE_WAIT_L2WB:
	  {
        while(CACHE_RGET(L2WWC));

        break;
	  }
    #if(C64_SUPPORT)
	  case CACHE_WAIT_L2INV:
	  {
             while(CACHE_RGET(L2IWC))
                         ;
             break;
	  }
    #endif /* C64_SUPPORT */
	  case CACHE_WAIT_L2WBINV:
	  {
             while(CACHE_RGET(L2WIWC))
                         ;
             break;
	  }
      case CACHE_WAIT_L2WBALL:
	  {
             while(CACHE_RGET(L2WB))
                         ;
             break;
	  }
      case CACHE_WAIT_L2WBINVALL:
	  {
             while(CACHE_RGET(L2WBINV))
                         ;
             break;
	  }
    #if (C64_SUPPORT)
      case CACHE_WAIT_L1DINV:
	  {
             while(CACHE_RGET(L1DIWC))
                         ;
             break;
	  }
    #endif /* C64_SUPPORT */
      case CACHE_WAIT_L1DWBINV:
	  {
             while(CACHE_RGET(L1DWIWC))
                         ;
             break;
	  }
      case CACHE_WAIT_L1PINV:
	  {
             while(CACHE_RGET(L1PIWC))
                         ;
             break;
	  }
   }

	busyMaskCache = 0;

  #endif /* (L2CACHE_SUPPORT) */

}

/*----------------------------------------------------------------------------*/

void CACHE_wbInvL2_blocks(void *blockPtr,Uint32 byteCnt, Uint32 blockSize){

  #if(L2CACHE_SUPPORT)
    Uint32 i, loopCnt, wordCnt, remCnt;
    Uint32 gie;

    CACHE_wait();
 
    /* convert to words, round up to next word */ 

    blockSize = (blockSize + 3) >> 2;       
    wordCnt   = (byteCnt   + 3) >> 2;       

    /* number of full blocks to operate on */

    loopCnt = wordCnt / blockSize; 

    /* number of words in last block  */    

    remCnt = wordCnt - blockSize*loopCnt;           

    if (remCnt) loopCnt++;

    for(i = 0; i < loopCnt; i++) {

       /* treat BAR/WC as critical section */

       gie = IRQ_globalDisable();

       /* calculate the starting address for each consecutive block */

       CACHE_RSET(L2WIBAR,(void *)((Uint32)blockPtr + 4*blockSize*i));  

       if (remCnt && (i==(loopCnt-1)))
          CACHE_RSET(L2WIWC, remCnt);
       else
          CACHE_RSET(L2WIWC, blockSize);
                
       IRQ_globalRestore(gie);
        
       while (CACHE_RGET(L2WIWC));

    }
  #else 
      UNREFERENCED_PARAMETER(blockPtr);
      UNREFERENCED_PARAMETER(byteCnt);
  #endif /* (L2CACHE_SUPPORT) */

}


/*----------------------------------------------------------------------------*/

void CACHE_wbL2_blocks(void *blockPtr,Uint32 byteCnt, Uint32 blockSize){

  #if (L2CACHE_SUPPORT)

    Uint32 i, loopCnt, wordCnt, remCnt;
    Uint32 gie;

    CACHE_wait();
 
    /* convert to words, round up to next word */ 

    blockSize = (blockSize + 3) >> 2;       
    wordCnt   = (byteCnt   + 3) >> 2;       

    /* number of full blocks to operate on */

    loopCnt = wordCnt / blockSize; 

    /* number of words in last block  */    

    remCnt = wordCnt - blockSize*loopCnt;           

    if (remCnt) loopCnt++;

    for(i = 0; i < loopCnt; i++) {

       /* treat BAR/WC as critical section */

       gie = IRQ_globalDisable();

       /* calculate the starting address for each consecutive block */

       CACHE_RSET(L2WBAR,(void *)((Uint32)blockPtr + 4*blockSize*i));  

       if (remCnt && (i==(loopCnt-1)))
          CACHE_RSET(L2WWC, remCnt);
       else
          CACHE_RSET(L2WWC, blockSize);
                
       IRQ_globalRestore(gie);
        
       while (CACHE_RGET(L2WWC));

    }
  #else 
      UNREFERENCED_PARAMETER(blockPtr);
      UNREFERENCED_PARAMETER(byteCnt);
  #endif /* (L2CACHE_SUPPORT) */

}

/*----------------------------------------------------------------------------*/

#endif /* CACHE_SUPPORT */
/******************************************************************************\
* End of csl_cache.c
\******************************************************************************/

csl_chip.c/     1030611952  0     0     0       2602      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_chip.c
* DATE CREATED.. 08/19/1999 
* LAST MODIFIED. 10/03/2000
\******************************************************************************/
#define _CHIP_MOD_
#include "csl_chip.h"


/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/******************************************************************************\
* global variable definitions
\******************************************************************************/

/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/


/******************************************************************************\
* End of csl_chip.c
\******************************************************************************/

csl_dat.c/      1030611954  0     0     0       14620     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_dat.c
* DATE CREATED.. 11/11/1999 
* LAST MODIFIED. 10/03/2000 from csl 1.86
\******************************************************************************/
#define _DAT_MOD_
#include "csl_dat.h"
#include "csl_legacy.h"

extern far Uint32 _lmbd(Uint32 src1, Uint32 src2);

#if (DAT_SUPPORT)
#pragma DATA_SECTION(_DAT_stateStruct, ".far:_DAT_stateStruct");

#if (DMA_SUPPORT)                                
/******************************************************************************\
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
\******************************************************************************/

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/
#define DEFAULT_CHA DAT_CHAANY
#define DEFAULT_PRI DAT_PRI_HIGH


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static DMA_Handle hDma     = INV;
static Uint32     eventId  = 0x00000000;
static Uint32     openFlag = 0;
static Uint32     gblidxId = 0;
static Uint32     gblcntId = 0;


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/
far Uint16 _DAT_serialTable[] = {
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000
}; 

far _DAT_StateStruct _DAT_stateStruct = {
  0x00000400,
  _DMA_BASE_CHA0,
  DMA_ADDR(GBLCNTA),
  DMA_ADDR(GBLIDXA),
  0x03000000
}; 


/******************************************************************************\
* global function definitions
\******************************************************************************/
int DAT_open(int chaNum, int priority, Uint32 flags) {

  Uint32 success = FALSE;
  Uint32 gie;
  int slotNum;

  gie = IRQ_globalDisable();

  if (!openFlag) {

    hDma = DMA_open(chaNum,DMA_OPEN_RESET);

    if (hDma != INV) {
      eventId = DMA_getEventId(hDma);
      _DAT_stateStruct.baseAddr  = (Uint32)(hDma->baseAddr);
      _DAT_stateStruct.useMask   = _IRQ_eventTable[eventId];
      gblidxId = 0;
      gblcntId = 0;
      success  = TRUE;

      IRQ_disable(eventId);
      IRQ_clear(eventId);
      IRQ_set(eventId);

      slotNum = 31-_lmbd(1,_DAT_stateStruct.useMask);
      if (slotNum >= 0) {
        _DAT_serialTable[slotNum] = 0;
      }
    
      if (flags & DAT_OPEN_2D) {

        gblcntId = DMA_allocGlobalReg(DMA_GBL_CNTRLD,0);
        if (gblcntId != 0x00000000) {
          _DAT_stateStruct.gblcntAddr=_DMA_gblRegTbl[gblcntId&_DMA_GBLREG_MASK];
        } else {
          success = FALSE;
        }

        gblidxId = DMA_allocGlobalReg(DMA_GBL_INDEX,0);
        if (gblidxId != 0x00000000) {
          _DAT_stateStruct.gblidxAddr=_DMA_gblRegTbl[gblidxId&_DMA_GBLREG_MASK];
        } else {
          success = FALSE;
        }

      }
    
      _DAT_stateStruct.initPrictl = DMA_PRICTL_RMK(
        DMA_PRICTL_DSTRLD_NONE,
        DMA_PRICTL_SRCRLD_NONE,
        DMA_PRICTL_EMOD_NOHALT,
        DMA_PRICTL_FS_DISABLE,
        DMA_PRICTL_TCINT_ENABLE,
        DMA_PRICTL_PRI_OF(priority),
        DMA_PRICTL_WSYNC_NONE,
        DMA_PRICTL_RSYNC_NONE,
        DMA_PRICTL_INDEX_OF(gblidxId),
        DMA_PRICTL_CNTRLD_OF(gblcntId),
        DMA_PRICTL_SPLIT_DISABLE,
        DMA_PRICTL_ESIZE_32BIT,
        DMA_PRICTL_DSTDIR_NONE,
        DMA_PRICTL_SRCDIR_NONE,
        DMA_PRICTL_START_NORMAL
      );          

      if (success) {
        openFlag = TRUE;
      } else {
        openFlag = FALSE;
        DMA_close(hDma);
        if (gblidxId) DMA_freeGlobalReg(gblidxId);
        if (gblcntId) DMA_freeGlobalReg(gblcntId);
      }  
    }
  }

  IRQ_globalRestore(gie);

  return success;
}

/*----------------------------------------------------------------------------*/
void DAT_close() {

  Uint32 gie;

  gie = IRQ_globalDisable();

  if (openFlag) {
    /* wait for any pending transfers to complete */
    while ((IFR & _DAT_stateStruct.useMask) != _DAT_stateStruct.useMask);
    DMA_close(hDma);
    DMA_freeGlobalReg(gblidxId);
    DMA_freeGlobalReg(gblcntId);
    openFlag = 0;
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
#endif /* DMA_SUPPORT */


#if (EDMA_SUPPORT)
/******************************************************************************\
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/
#define DEFAULT_CHA DAT_CHAANY
#define DEFAULT_PRI DAT_PRI_HIGH 
#define TCC_CNT 4


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static Uint32 openFlag = 0;
static char tccCodes[TCC_CNT];

/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/
far Uint16 _DAT_serialTable[] = {
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000
};

far _DAT_StateStruct _DAT_stateStruct = {
  0x00000000,
  EDMA_ADDR(QOPT),
  0x00000000
};


/******************************************************************************\
* global function definitions
\******************************************************************************/
int DAT_open(int chaNum, int priority, Uint32 flags) {

  int success = FALSE;
  int x,tcc;
  Uint32 useMask,gie;
  volatile Uint32 dummySrc, dummyDst;

  UNREFERENCED_PARAMETER(flags);
  UNREFERENCED_PARAMETER(chaNum);
  UNREFERENCED_PARAMETER(priority);

  gie = IRQ_globalDisable();

  if (!openFlag) {
    
    success = TRUE;

    /* We need to allocate a transfer complete code for each slot.   */
    /* We'll also generate the useMask based on these TCC codes.     */
    /* We also want to make sure the TCC codes are within the lower  */
    /* 32 codes so we only have to use CIPRL in the 64x case.        */
    for (x=0; x<TCC_CNT; x++) {
      tccCodes[x] = -1;
    }
      
    useMask = 0x00000000;
    for (x=0; x<TCC_CNT; x++) {
      tcc = 32;
      while ((tcc>=32)&&success) {
        tcc = EDMA_intAlloc(-1);
        if (tcc == -1) {
          success = 0; /* error, couldn't allocate TCC code */
          break;
        } else if (tcc >= 32) {
          EDMA_intFree(tcc);
        } else {
          tccCodes[x] = tcc;
        }
      }
      useMask = useMask | (1<<tcc);
    }
    _DAT_stateStruct.useMask = useMask;

    
    if (success) {
      /* We need to get the completion code bits set and the only way */
      /* to do this is to submit transfers and let the hardware do it */
      EDMA_RSET(CIER,EDMA_RGET(CIER) & ~useMask);
      EDMA_RSET(CIPR,useMask);

      /* submit a dummy transfer for each bit in the useMask */
      x = 31-_lmbd(1,useMask);
      while (x>=0) {
        _DAT_serialTable[x] = 0;
        /* do dummy transfer using X as TCC value */
        EDMA_RSET(QSRC,  (Uint32)(&dummySrc));
        EDMA_RSET(QDST,  (Uint32)(&dummyDst));
        EDMA_RSET(QCNT,  (Uint32)0x00000001);
        EDMA_RSET(QIDX,  (Uint32)0x00000000);
        EDMA_RSET(QSOPT, (Uint32)0x20100000 | (x<<16));
        useMask = useMask & ~(1<<x);
        x = 31-_lmbd(1,useMask);
      }

      /* wait for all dummy transfers to complete */
      //while ((EDMA_RGET(CIPR) & _DAT_stateStruct.useMask)!=_DAT_stateStruct.useMask);
      DAT_wait(DAT_XFRID_WAITALL);

      /* assemble the baseline OPT value */
      #if (C64_SUPPORT)
        _DAT_stateStruct.initOpt = EDMA_OPT_RMK(
          EDMA_OPT_PRI_OF(priority),
          EDMA_OPT_ESIZE_32BIT,
          EDMA_OPT_2DS_NO,
          EDMA_OPT_SUM_NONE,
          EDMA_OPT_2DD_NO,
          EDMA_OPT_DUM_NONE,
          EDMA_OPT_TCINT_YES,
          EDMA_OPT_TCC_OF(0),
          EDMA_OPT_TCCM_OF(0),
          EDMA_OPT_ATCINT_NO,
          EDMA_OPT_ATCC_OF(0),
          EDMA_OPT_PDTS_DISABLE,
          EDMA_OPT_PDTD_DISABLE,
          EDMA_OPT_LINK_NA,
          EDMA_OPT_FS_NO
        );
      #else
        _DAT_stateStruct.initOpt = EDMA_OPT_RMK(
          EDMA_OPT_PRI_OF(priority),
          EDMA_OPT_ESIZE_32BIT,
          EDMA_OPT_2DS_NO,
          EDMA_OPT_SUM_NONE,
          EDMA_OPT_2DD_NO,
          EDMA_OPT_DUM_NONE,
          EDMA_OPT_TCINT_YES,
          EDMA_OPT_TCC_OF(0),
          EDMA_OPT_LINK_NA,
          EDMA_OPT_FS_NO
        );
      #endif
    }  

    if (success) {
      openFlag = 1;
    } else {
      for (x=0; x<TCC_CNT; x++) {
        if (tccCodes[x] != -1) {
          EDMA_intFree(tccCodes[x]);
        }
      }
    } 

  }

  IRQ_globalRestore(gie);

  return success;
}

/*----------------------------------------------------------------------------*/
void DAT_close() {

  Uint32 gie;
  int x;

  gie = IRQ_globalDisable();

  if (openFlag) {
    /* wait for all pending transfers to complete */
    DAT_wait(DAT_XFRID_WAITALL);

    #if (EDMA_SUPPORT)
      for (x=0; x<TCC_CNT; x++) {
        if (tccCodes[x] != -1) {
          EDMA_intFree(tccCodes[x]);
        }
      }
    #endif
    
    openFlag = 0;
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
#endif /* EDMA_SUPPORT */


/*----------------------------------------------------------------------------*/


#endif /* DAT_SUPPORT */
/******************************************************************************\
* End of csl_dat.c
\******************************************************************************/

csl_dma.c/      1030611955  0     0     0       7765      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_dma.c
* DATE CREATED.. 06/11/1999 
* LAST MODIFIED. 09/19/2000
*
\******************************************************************************/
#define _DMA_MOD_
#include "csl_dma.h"


#if (DMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/
#define CHANNEL_ENTRY(chaNum) { \
  FALSE, \
  IRQ_EVT_DMAINT##chaNum##,\
  (volatile Uint32*)_DMA_BASE_CHA##chaNum##, \
}

/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static Uint32 gblAllocMask = 0x00000000;

static DMA_Obj channelTbl[DMA_CHA_CNT] = {
  CHANNEL_ENTRY(0),
  CHANNEL_ENTRY(1),
  CHANNEL_ENTRY(2),
  CHANNEL_ENTRY(3)
};

static Uint32 globalAllocMask = 0x00000000;


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/
Uint32 _DMA_gblRegTbl[_DMA_GBLREG_CNT] = {
  /* [0x00] DMA_GBL_ADDRRLD 0 */ 0xFFFFFFFFu,
  /* [0x01] DMA_GBL_ADDRRLD 1 */ DMA_ADDR(GBLADDRB),
  /* [0x02] DMA_GBL_ADDRRLD 2 */ DMA_ADDR(GBLADDRC),
  /* [0x03] DMA_GBL_ADDRRLD 3 */ DMA_ADDR(GBLADDRD),
  /* [0x04] DMA_GBL_INDEX   0 */ DMA_ADDR(GBLIDXA),
  /* [0x05] DMA_GBL_INDEX   1 */ DMA_ADDR(GBLIDXB),
  /* [0x06] DMA_GBL_INDEX   2 */ 0xFFFFFFFFu,
  /* [0x07] DMA_GBL_INDEX   3 */ 0xFFFFFFFFu,
  /* [0x08] DMA_GBL_CNTRLD  0 */ DMA_ADDR(GBLCNTA),
  /* [0x09] DMA_GBL_CNTRLD  1 */ DMA_ADDR(GBLCNTB),
  /* [0x0A] DMA_GBL_CNTRLD  2 */ 0xFFFFFFFFu,
  /* [0x0B] DMA_GBL_CNTRLD  3 */ 0xFFFFFFFFu,
  /* [0x0C] DMA_GBL_SPLIT   0 */ 0xFFFFFFFFu,
  /* [0x0D] DMA_GBL_SPLIT   1 */ DMA_ADDR(GBLADDRA),
  /* [0x0E] DMA_GBL_SPLIT   2 */ DMA_ADDR(GBLADDRB),
  /* [0x0F] DMA_GBL_SPLIT   3 */ DMA_ADDR(GBLADDRC)
};

/* Predefined channel handles, these are only here for legacy    */
/* purposes and shoul not be used.                               */
DMA_Handle _DMA_hCha0 = (DMA_Handle)&channelTbl[0];
DMA_Handle _DMA_hCha1 = (DMA_Handle)&channelTbl[1];
DMA_Handle _DMA_hCha2 = (DMA_Handle)&channelTbl[2];
DMA_Handle _DMA_hCha3 = (DMA_Handle)&channelTbl[3];


/******************************************************************************\
* global function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
void DMA_reset(DMA_Handle hDma) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hDma == INV) {
    DMA_reset(&(channelTbl[0]));
    DMA_reset(&(channelTbl[1]));
    DMA_reset(&(channelTbl[2]));
    DMA_reset(&(channelTbl[3]));
  } else {
    IRQ_disable(hDma->eventId);
    DMA_RSETH(hDma,PRICTL,DMA_PRICTL_DEFAULT);
    DMA_RSETH(hDma,SECCTL,
       DMA_SECCTL_DEFAULT
      |DMA_FMK(SECCTL,WSYNCCLR,DMA_SECCTL_WSYNCCLR_CLEAR)
      |DMA_FMK(SECCTL,RSYNCCLR,DMA_SECCTL_RSYNCCLR_CLEAR)
    );
    DMA_RSETH(hDma,SRC,DMA_SRC_DEFAULT);
    DMA_RSETH(hDma,DST,DMA_DST_DEFAULT);
    DMA_RSETH(hDma,XFRCNT,DMA_XFRCNT_DEFAULT);
    DMA_RSETH(hDma,PRICTL,DMA_PRICTL_DEFAULT);
    IRQ_clear(hDma->eventId);
  }
  IRQ_globalRestore(gie);
  return;
}

/*----------------------------------------------------------------------------*/
DMA_Handle DMA_open(int chaNum, Uint32 flags) {

  DMA_Handle hDma = (DMA_Handle)INV;
  Uint32 cha,gie;

  gie = IRQ_globalDisable();

  if (chaNum==-1) {
    for (cha=0; cha<DMA_CHA_CNT; cha++) {
      if (!channelTbl[cha].allocated) {
        hDma = (DMA_Handle)&(channelTbl[cha]);
        break;
      }
    }
  } else if (!channelTbl[chaNum].allocated) {
    hDma = (DMA_Handle)&(channelTbl[chaNum]);
  }

  if (hDma != INV) {
    hDma->allocated = TRUE;
    if (flags & DMA_OPEN_RESET) {
      DMA_reset(hDma);
    }
  }

  IRQ_globalRestore(gie);

  return hDma;
}

/*----------------------------------------------------------------------------*/
void DMA_close(DMA_Handle hDma) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  DMA_reset(hDma);
  hDma->allocated = FALSE;
  IRQ_globalRestore(gie);
  return;
}

/*----------------------------------------------------------------------------*/
Uint32 DMA_allocGlobalReg(DMA_Gbl regType, Uint32 initVal) {

  Uint32 gie;
  Uint32 regId = 0x00000000;
  Uint32 regNum0=0,regNum1=0,regNum=0;
  Uint32 mask = 0x00000000;

  gie = IRQ_globalDisable();

  switch (regType) {
    case DMA_GBL_ADDRRLD: regNum0=0x01; regNum1=0x03; mask = 0x20000000; break;
    case DMA_GBL_INDEX:   regNum0=0x04; regNum1=0x05; mask = 0x01000000; break;
    case DMA_GBL_CNTRLD:  regNum0=0x08; regNum1=0x09; mask = 0x00100000; break;
    case DMA_GBL_SPLIT:   regNum0=0x0D; regNum1=0x0F; mask = 0x10000000; break;
  }

  for (regNum=regNum0; regNum<=regNum1; regNum++) {
    if ((gblAllocMask & mask)==0) {
      gblAllocMask |= mask;
      regId = mask | regNum;
      DMA_setGlobalReg(regId,initVal);
      break;
    }
    mask = mask << 1;
  }
 
  IRQ_globalRestore(gie);

  return regId;
}

/*----------------------------------------------------------------------------*/
void DMA_freeGlobalReg(Uint32 regId) {

  Uint32 gie = IRQ_globalDisable();
  gblAllocMask &= ~(regId & 0xFFFF0000);
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
Uint32 DMA_globalAlloc(Uint32 regs) {
  
  Uint32 mask,gie;
  gie = IRQ_globalDisable();
  mask = (globalAllocMask^regs)&regs;
  if (mask == regs) {
    globalAllocMask = globalAllocMask | mask;
  }
  IRQ_globalRestore(gie);
  return mask;
}

/*----------------------------------------------------------------------------*/
void DMA_globalFree(Uint32 regs) {

  Uint32 gie;
  gie = IRQ_globalDisable();
  globalAllocMask = globalAllocMask & ~regs;
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/


#endif /* DMA_SUPPORT */
/******************************************************************************\
* End of csl_dma.c
\******************************************************************************/


csl_edma.c/     1092390312  0     0     0       13069     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_edma.c
* DATE CREATED.. 06/11/1999
* LAST MODIFIED. 08/13/2004 Modified tccAllocTable type from static to global. 
*                06/17/2003 Added support for 6712C
*                05/28/2003 Added support for 6711C
*                12/05/2000
\******************************************************************************/
#define _EDMA_MOD_
#include "csl_edma.h"

/* We need to use the runtime library intrinsic _lmbd() function but */
/* want to declare it as far.                                        */
extern far Uint32 _lmbd(Uint32 src1, Uint32 src2);


#if (EDMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
#if (C64_SUPPORT)
  static Uint32 allocMaskCL = 0x00000000;
  static Uint32 allocMaskCH = 0x00000000;
#else
  static Uint32 allocMaskC  = 0x00000000;
#endif

static Uint32 allocMaskT[4] = {0,0,0,0};



/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/
Uint8 tccAllocTable[64] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

/******************************************************************************\
* global function definitions
\******************************************************************************/
void EDMA_reset(EDMA_Handle hEdma) {

  Uint32 gie = IRQ_globalDisable();

  if (hEdma != EDMA_HINV) {
    EDMA_disableChannel(hEdma);
    EDMA_clearChannel(hEdma);
    EDMA_RSETH(hEdma,OPT,EDMA_OPT_DEFAULT);
    EDMA_RSETH(hEdma,SRC,EDMA_SRC_DEFAULT);
    EDMA_RSETH(hEdma,DST,EDMA_DST_DEFAULT);
    EDMA_RSETH(hEdma,CNT,EDMA_CNT_DEFAULT);
    EDMA_RSETH(hEdma,RLD,EDMA_RLD_DEFAULT);
    EDMA_RSETH(hEdma,IDX,EDMA_IDX_DEFAULT);
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void EDMA_resetAll() {

 //int gie;
 int gie,x;

 Uint32 *pram = (Uint32*)_EDMA_PRAM_START;

 gie = IRQ_globalDisable();

  /* we're going to reset the entire EDMA system */

  /* start by disabling and clearing EDMA channels */
  #if (C64_SUPPORT)
    EDMA_RSET(EERL,  EDMA_EERL_DEFAULT);
    EDMA_RSET(EERH,  EDMA_EERH_DEFAULT);
    EDMA_RSET(CCERL, EDMA_CCERL_DEFAULT);
    EDMA_RSET(CCERH, EDMA_CCERH_DEFAULT);
    EDMA_RSET(ECRL,  0xFFFFFFFF);
    EDMA_RSET(ECRH,  0xFFFFFFFF);
  #endif

  #if(CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
    EDMA_RSET(EER,  EDMA_EER_DEFAULT);
    EDMA_RSET(CCER, EDMA_CCER_DEFAULT);
    EDMA_RSET(ECR,  0xFFFFFFFF);
	EDMA_RSET(ESEL0, EDMA_ESEL0_DEFAULT);
	EDMA_RSET(ESEL1, EDMA_ESEL1_DEFAULT);
    /* ESEL2 reserved */
	EDMA_RSET(ESEL3, EDMA_ESEL3_DEFAULT);
  #endif

  #if(CHIP_6201|CHIP_6202|CHIP_6203|CHIP_6204|CHIP_6205|CHIP_6211| \
      CHIP_6701|CHIP_6711|CHIP_6712)
    EDMA_RSET(EER,  EDMA_EER_DEFAULT);
    EDMA_RSET(CCER, EDMA_CCER_DEFAULT);
    EDMA_RSET(ECR,  0xFFFFFFFF);
  #endif

  /* now disable and clear all interrupts */
  #if (C64_SUPPORT)
    EDMA_RSET(CIERL, EDMA_CIERL_DEFAULT);
    EDMA_RSET(CIERH, EDMA_CIERH_DEFAULT);
    EDMA_RSET(CIPRL, 0xFFFFFFFF);
    EDMA_RSET(CIPRH, 0xFFFFFFFF);
  #else
    EDMA_RSET(CIER, EDMA_CIER_DEFAULT);
    EDMA_RSET(CIPR, 0xFFFFFFFF);
  #endif

  /* reset the EDMA CPU interrupt */
  IRQ_reset(IRQ_EVT_EDMAINT);

  /* now let's clear out the parameter RAM */
  //EDMA_clearPram(0x00000000);

  for (x=0; x<_EDMA_PRAM_ERASE>>2; x++) {
    pram[x] = 0x00000000;
  }

 for (x=0; x<4; ++x) {
     allocMaskT[x] = 0;
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
EDMA_Handle EDMA_open(int channel, Uint32 flags) {

  Uint32 gie,addr;
  EDMA_Handle hEdma = EDMA_HINV;
  int cha;

  gie = IRQ_globalDisable();

  if (channel==EDMA_CHA_ANY) {
    for (cha=0; cha<EDMA_CHA_CNT; cha++) {
      #if (C64_SUPPORT)
        if (cha < 32) {
          if (!(allocMaskCL & (1<<cha))) {
            allocMaskCL |= (1<<cha);
            addr = (cha*_EDMA_ENTRY_SIZE)+_EDMA_PRAM_START;
            hEdma=_EDMA_MK_HANDLE(addr,cha,_EDMA_TYPE_C);
            break;
          }
        } else {
          if (!(allocMaskCH & (1<<(cha-32)))) {
            allocMaskCH |= (1<<(cha-32));
            addr = (cha*_EDMA_ENTRY_SIZE)+_EDMA_PRAM_START;
            hEdma=_EDMA_MK_HANDLE(addr,cha,_EDMA_TYPE_C);
            break;
          }
        }
      #else
        if (!(allocMaskC & (1<<cha))) {
          allocMaskC |= (1<<cha);
          addr = (cha*_EDMA_ENTRY_SIZE)+_EDMA_PRAM_START;
          hEdma=_EDMA_MK_HANDLE(addr,cha,_EDMA_TYPE_C);
          break;
        }
      #endif
    }
  } else {
    #if (C64_SUPPORT)
      if (channel < 32) {
        if (!(allocMaskCL & (1<<channel))) {
          allocMaskCL |= (1<<channel);
          addr = (channel*_EDMA_ENTRY_SIZE)+_EDMA_PRAM_START;
          hEdma=_EDMA_MK_HANDLE(addr,channel,_EDMA_TYPE_C);
        }
      } else {
        if (!(allocMaskCH & (1<<(channel-32)))) {
          allocMaskCH |= (1<<(channel-32));
          addr = (channel*_EDMA_ENTRY_SIZE)+_EDMA_PRAM_START;
          hEdma=_EDMA_MK_HANDLE(addr,channel,_EDMA_TYPE_C);
        }
      }
    #else
      if (!(allocMaskC & (1<<channel))) {
        allocMaskC |= (1<<channel);
        addr = (channel*_EDMA_ENTRY_SIZE)+_EDMA_PRAM_START;
        hEdma=_EDMA_MK_HANDLE(addr,channel,_EDMA_TYPE_C);
      }
    #endif
  }

  IRQ_globalRestore(gie);

  if (hEdma != (EDMA_Handle)INV) {
    if (flags & EDMA_OPEN_RESET) {
      EDMA_reset(hEdma);
    }

    if (flags & EDMA_OPEN_ENABLE) {
      EDMA_enableChannel(hEdma);
    }
  }

  return hEdma;
}

/*----------------------------------------------------------------------------*/
void EDMA_close(EDMA_Handle hEdma) {

  Uint32 gie,cha;

  gie = IRQ_globalDisable();
  if (hEdma & _EDMA_TYPE_C) {
    cha  = ((((Uint32)hEdma)&0x00FF0000)>>16);
    #if (C64_SUPPORT)
      if (cha < 32) allocMaskCL &= ~(1<<cha);
      else allocMaskCH &= ~(1<<(cha-32));
    #else
      allocMaskC &= ~(1<<cha);
    #endif
    EDMA_reset(hEdma);
  }
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
EDMA_Handle EDMA_allocTable(int tableNum) {

  Uint32 gie,addr;
  EDMA_Handle hEdma = EDMA_HINV;
  int tbl,major,minor;

  gie = IRQ_globalDisable();

  if (tableNum==EDMA_ALLOC_ANY) {
    for (tbl=0; tbl<EDMA_TABLE_CNT; tbl++) {
      major = ((tbl)&(~0x1F))>>5;
      minor = (tbl)&(0x1F);
      if (!(allocMaskT[major] & (1<<minor))) {
        allocMaskT[major] |= (1<<minor);
        addr = (tbl*_EDMA_ENTRY_SIZE)+_EDMA_LINK_START;
        hEdma=_EDMA_MK_HANDLE(addr,tbl,_EDMA_TYPE_T);
        break;
      }
    }
  } else {
   if ((tableNum < EDMA_TABLE_CNT)) {
    major = ((tableNum)&(~0x1F))>>5;
    minor = (tableNum)&(0x1F);
    if (!(allocMaskT[major] & (1<<minor))) {
      allocMaskT[major] |= (1<<minor);
      addr = (tableNum*_EDMA_ENTRY_SIZE)+_EDMA_LINK_START;
      hEdma=_EDMA_MK_HANDLE(addr,tableNum,_EDMA_TYPE_T);
    }
   }
  }

  IRQ_globalRestore(gie);

  return hEdma;
}

/*----------------------------------------------------------------------------*/
void EDMA_freeTable(EDMA_Handle hEdma) {

  Uint32 gie,tbl,major,minor;

  gie = IRQ_globalDisable();
  if (hEdma & _EDMA_TYPE_T) {
    tbl = ((((Uint32)hEdma)&0x00FF0000)>>16);
    major = ((tbl)&(~0x1F))>>5;
    minor = (tbl)&(0x1F);
    allocMaskT[major] &= ~(1<<minor);
  }
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
int EDMA_allocTableEx(int cnt, EDMA_Handle *array) {

  int gie,x,numAllocated=0;
  EDMA_Handle hEdma;

  gie = IRQ_globalDisable();
  for (x=0; x<cnt; x++) {
    hEdma = EDMA_allocTable(EDMA_ALLOC_ANY);
    if (hEdma != EDMA_HINV) {
      numAllocated++;
      array[x] = hEdma;
    } else {
      EDMA_freeTableEx(numAllocated,array);
      numAllocated = 0;
    }
  }
  IRQ_globalRestore(gie);
  return numAllocated;
}

/*----------------------------------------------------------------------------*/
void EDMA_freeTableEx(int cnt, EDMA_Handle *array) {

  int gie,x;
  gie = IRQ_globalDisable();
  for (x=0; x<cnt; x++) {
    EDMA_freeTable(array[x]);
    array[x] = EDMA_HINV;
  }
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void EDMA_clearPram(Uint32 val) {

  int gie,x;

  Uint32 *pram = (Uint32*)_EDMA_PRAM_START;

  gie = IRQ_globalDisable();

  for (x=0; x<_EDMA_PRAM_SIZE>>2; x++) {
    pram[x] = val;
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
int EDMA_intAlloc(int tcc) {

  int gie;
  int tccReturn = -1;

  gie = IRQ_globalDisable();
  if (tcc == -1) {
    for (tcc=0; tcc<EDMA_CHA_CNT; tcc++) {
      if (tccAllocTable[tcc] == 0) {
        tccAllocTable[tcc] = 1;
        tccReturn = tcc;
        break;
      }
    }
  } else {
    if (tccAllocTable[tcc] == 0) {
      tccAllocTable[tcc] = 1;
      tccReturn = tcc;
    }
  }
  IRQ_globalRestore(gie);

  return tccReturn;
}

/*----------------------------------------------------------------------------*/
void EDMA_intFree(int tcc) {

  int gie;
  gie = IRQ_globalDisable();
  tccAllocTable[tcc] = 0;
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
int EDMA_map(int eventNum,int chaNum){
  int chaSelected = -1;

  if(chaNum == 0){
	  EDMA_FSET(ESEL0,EVTSEL0,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 1){
	  EDMA_FSET(ESEL0,EVTSEL1,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 2){
	  EDMA_FSET(ESEL0,EVTSEL2,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 3){
	  EDMA_FSET(ESEL0,EVTSEL3,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 4){
	  EDMA_FSET(ESEL1,EVTSEL4,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 5){
	  EDMA_FSET(ESEL1,EVTSEL5,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 6){
	  EDMA_FSET(ESEL1,EVTSEL6,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 7){
	  EDMA_FSET(ESEL1,EVTSEL7,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 12){
	  EDMA_FSET(ESEL3,EVTSEL12,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 13){
	  EDMA_FSET(ESEL3,EVTSEL13,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 14){
	  EDMA_FSET(ESEL3,EVTSEL14,eventNum);
      chaSelected = chaNum;
  }
  else if(chaNum == 15){
	  EDMA_FSET(ESEL3,EVTSEL15,eventNum);
      chaSelected = chaNum;
  }

  return chaSelected;
}
#endif
/*----------------------------------------------------------------------------*/
#endif /* EDMA_SUPPORT */
/******************************************************************************\
* End of csl_edma.c
\******************************************************************************/


csl_edmadsptr.c/1065163502  0     0     0       7044      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_edmaDsptr.c
* DATE CREATED.. 06/03/2002
* LAST MODIFIED. 07/12/2002
\******************************************************************************/

#define __EDMA_MOD_
#include <csl_edma.h>

/* We need to use the runtime library intrinsic _lmbd() function but */
/* want to declare it as far.                                        */
extern far Uint32 _lmbd(Uint32 src1, Uint32 src2);


#if (EDMA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/

/******************************************************************************\
* static variable definitions
\******************************************************************************/

#if (!C64_SUPPORT)
  static EDMA_IntHandler funcTable[16] = {
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler
  };
#endif

#if (C64_SUPPORT)
  static EDMA_IntHandler funcTableLow[32] = {
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler
  };

  static EDMA_IntHandler funcTableHigh[32] = {
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler,
    EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler, EDMA_intDefaultHandler
  };
#endif

/******************************************************************************\
* static function definitions
\******************************************************************************/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/
EDMA_IntHandler EDMA_intHook(int tccNum, EDMA_IntHandler funcAddr) {

  int gie;
  EDMA_IntHandler oldIsr = (EDMA_IntHandler)INV;
  
  gie = IRQ_globalDisable();

  #if (C64_SUPPORT)
    if ((tccNum>=0)&&(tccNum<=31)) {
      oldIsr = funcTableLow[tccNum];
      funcTableLow[tccNum] = funcAddr;
    } else if ((tccNum>=32)&&(tccNum<=63)) {
      oldIsr = funcTableHigh[tccNum-32];
      funcTableHigh[tccNum-32] = funcAddr;
    }
  #endif
  
  #if (!C64_SUPPORT)
    oldIsr = funcTable[tccNum];
    funcTable[tccNum] = funcAddr;
  #endif

  IRQ_globalRestore(gie);
  
  return oldIsr;
}

/*----------------------------------------------------------------------------*/
void EDMA_intDefaultHandler(int tccNum) {
  return;
}

/*----------------------------------------------------------------------------*/
void EDMA_intDispatcher() {
  register Uint32 mask,tcc;                     // try to stuff vars into regs for performance

  #if (!C64_SUPPORT)
    /* dispatcher for 621x/671x devices */
    mask = EDMA_RGET(CIPR) & EDMA_RGET(CIER);   // determine all pending and enabled interrupts
    EDMA_RSET(CIPR,mask);                       // clear all detected bits in pending register
    while (mask) {                              // loop and dispatch while pending/enabled ints exist
      tcc = 31-_lmbd(1,mask);                   // find left-most bit number
      funcTable[tcc](tcc);                      // call the user function
      mask ^= 1<<tcc;                           // clear this bit in the mask
    }
  #endif

  #if (C64_SUPPORT)
    /* dispatcher for 64x devices */
    mask = EDMA_RGET(CIPRH) & EDMA_RGET(CIERH);
    EDMA_RSET(CIPRH,mask);
    while (mask) {
      tcc = 31-_lmbd(1,mask);
        funcTableHigh[tcc](tcc+32);
      mask ^= 1<<tcc;
      }
    mask = EDMA_RGET(CIPRL) & EDMA_RGET(CIERL);
    EDMA_RSET(CIPRL,mask);
    while (mask) {
      tcc = 31-_lmbd(1,mask);
      funcTableLow[tcc](tcc);
      mask ^= 1<<tcc;
    }
  #endif
}

/*----------------------------------------------------------------------------*/

#endif /* EDMA_SUPPORT */
/******************************************************************************\
* End of csl_edmadsptr.c
\******************************************************************************/

csl_emac.c/     1076583462  0     0     0       48346     `
/*****************************************************************************\
*           Copyright (C) 1999-2003 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emac.c
* DATE CREATED.. 02/08/2002
* LAST MODIFIED. 01/08/2004  Modified emacDequeueRx() function-fixed the problem 
*                            with RX overflow.  
*------------------------------------------------------------------------------
* NOTE:
*   When used in an multitasking environment, no EMAC function may be
*   called while another EMAC function is operating on the same device
*   handle in another thread. It is the responsibility of the application
*   to assure adherence to this restriction.
*
\******************************************************************************/

/* Include the EMAC file from CSL */
#include <csl_emachal.h>
#include <csl_emac.h>
#include <csl_mdio.h>

#if (EMAC_SUPPORT)
extern void   *memset(void *_mem, int _ch, uint _n);

/*
// We keep a local packet queue for transmit and receive packets.
// The queue structure is OS independent.
*/

/*
// Packet Queue
*/
typedef struct _pktq {
  uint              Count;      // Number of packets in queue
  EMAC_Pkt          *pHead;     // Pointer to first packet
  EMAC_Pkt          *pTail;     // Pointer to last packet
} PKTQ;

/*
// Queue Helper Functions
*/
static EMAC_Pkt *pqPop( PKTQ *pq );
static void pqPush( PKTQ *pq, EMAC_Pkt *pPktHdr );
static void pqPushChain( PKTQ *pq, EMAC_Pkt *pPktHdrFirst,
                         EMAC_Pkt *pPktHdrLast, uint Count );


/*
// Transmit/Receive Descriptor Channel Structure
// (One receive and up to 8 transmit in this driver)
*/
typedef struct _EMAC_DescCh {
    struct _EMAC_Device *pd;      /* Pointer to parent structure   */
    PKTQ            DescQueue;    /* Packets queued as desc        */
    PKTQ            WaitQueue;    /* Packets waiting for TX desc   */
    uint            ChannelIndex; /* Channel index 0-7             */
    uint            DescMax;      /* Max number of desc (buffs)    */
    uint            DescCount;    /* Current number of desc        */
    EMAC_Desc       *pDescFirst;  /* First desc location           */
    EMAC_Desc       *pDescLast;   /* Last desc location            */
    EMAC_Desc       *pDescRead;   /* Location to read next desc    */
    EMAC_Desc       *pDescWrite;  /* Location to write nest desc   */
} EMAC_DescCh;


/*
// Main Device Instance Structure
*/
typedef struct _EMAC_Device {
    Uint32          DevMagic;     /* Magic ID for this instance    */
    Handle          hApplication; /* Calling Application's Handle  */
    Handle          hMDIO;        /* Handle to MDIO Module      */
    uint            RxFilter;     /* Current RX filter value       */
    uint            PktMTU;       /* Max physical packet size      */
    Uint32          MacHash1;     /* Hash value cache              */
    Uint32          MacHash2;     /* Hash value cache              */
    Uint32          FatalError;   /* Fatal Error Code              */
    EMAC_Config     Config;       /* Original User Configuration   */
    EMAC_Statistics Stats;        /* Current running statistics    */
    EMAC_DescCh     RxCh;         /* Receive channel status        */
    EMAC_DescCh     TxCh[8];      /* Transmit channel status       */
} EMAC_Device;


/*
// Although the EMAC API is defined to support multiple device instances,
// this version supports a single device instance
*/

/* Local copy of the EMAC device instance */
static uint             openFlag = 0;
static EMAC_Device      localDev;
#define EMAC_DEVMAGIC   0x0aceface
#define EMAC_NUMSTATS   36         /* The number of statistics regs */

/*
// Local Helper Functions
*/
static void emacUpdateStats( EMAC_Device *pd );
static void emacEnqueueTx( EMAC_DescCh *pdc );
static void emacDequeueTx( EMAC_DescCh *pdc, EMAC_Desc *pDescLast );
static void emacEnqueueRx( EMAC_DescCh *pdc, uint fRestart );
static void emacDequeueRx( EMAC_DescCh *pdc, EMAC_Desc *pDescAck );


/*--------------------------------------------------------------------*\
* pqPop()
*
* Pop a desc buffer off a queue
\*--------------------------------------------------------------------*/
static EMAC_Pkt *pqPop( PKTQ *pq )
{
    EMAC_Pkt *pPktHdr;

    pPktHdr = pq->pHead;

    if( pPktHdr )
    {
        pq->pHead = pPktHdr->pNext;
        pq->Count--;
    }

    pPktHdr->pPrev = pPktHdr->pNext = 0;

    return( pPktHdr );
}

/*--------------------------------------------------------------------*\
* pqPush()
*
* Push a desc buffer onto a queue
\*--------------------------------------------------------------------*/
static void pqPush( PKTQ *pq, EMAC_Pkt *pPktHdr )
{
    pPktHdr->pNext = 0;

    if( !pq->pHead )
    {
        // Queue is empty - Initialize it with this one packet
        pq->pHead = pPktHdr;
        pq->pTail = pPktHdr;
    }
    else
    {
        // Queue is not empty - Push onto END
        pq->pTail->pNext = pPktHdr;
        pq->pTail        = pPktHdr;
    }
    pq->Count++;
}

/*--------------------------------------------------------------------*\
* pqPushChain()
*
* Push a desc buffer chain onto a queue
\*--------------------------------------------------------------------*/
static void pqPushChain( PKTQ *pq, EMAC_Pkt *pPktHdrFirst,
                         EMAC_Pkt *pPktHdrLast, uint Count )
{
    pPktHdrLast->pNext = 0;

    if( !pq->pHead )
    {
        // Queue is empty - Initialize it with this one packet
        pq->pHead = pPktHdrFirst;
        pq->pTail = pPktHdrLast;
    }
    else
    {
        // Queue is not empty - Push onto END
        pq->pTail->pNext = pPktHdrFirst;
        pq->pTail        = pPktHdrLast;
    }
    pq->Count += Count;
}


/*--------------------------------------------------------------------*\
* emacUpdateStats()
*
* Update our local copy of the statistics
\*--------------------------------------------------------------------*/
static void emacUpdateStats( EMAC_Device *pd )
{
    int             i;
    volatile Uint32 *pRegAddr;
    Uint32          *pStatAddr;
    Uint32          statval;

    pRegAddr = EMAC_ADDR(RXGOODFRAMES);
    pStatAddr = (Uint32 *)(&pd->Stats);

    /*
    // There are "EMAC_NUMSTATS" statistics registers
    // Note that when MIIEN is set in MACCONTROL, these registers
    // are "write to decrement".
    */
    for( i=0; i<EMAC_NUMSTATS; i++ )
    {
        statval = *pRegAddr;
        *pRegAddr++ = statval;
        statval += *pStatAddr;
        *pStatAddr++ = statval;
    }
}

/*--------------------------------------------------------------------*\
* emacEnqueueTx()
*
* Enqueue a TX packet and restart transmitter as needed
\*--------------------------------------------------------------------*/
static void emacEnqueueTx( EMAC_DescCh *pdc )
{
    EMAC_Desc   *pDescOrg,*pDescThis;
    EMAC_Pkt     *pPkt;
    uint        PktFrags;
    uint        CountOrg;

    /*
    // We need to be careful that we don't post half a packet to
    // the list. Otherwise; we just fill in as much packet descriptor
    // stuff as we can.
    */
    pDescOrg = pdc->pDescWrite;
    CountOrg = pdc->DescCount;

    /* Try to post any waiting packets */
    while( pdc->WaitQueue.Count )
    {
        /* See if we have enough room for a new packet */
        pPkt = pdc->WaitQueue.pHead;
        PktFrags = pPkt->PktFrags;

        /* If we don't have room, break out */
        if( (PktFrags+pdc->DescCount) > pdc->DescMax )
            break;

        /* The next packet will fit, post it. */
        while( PktFrags )
        {
            /* Pop the next frag off the wait queue */
            pPkt = pqPop( &pdc->WaitQueue );

            /* Assign the pointer to "this" desc */
            pDescThis = pdc->pDescWrite;

            /* Move the write pointer and bump count */
            if( pdc->pDescWrite == pdc->pDescLast )
                pdc->pDescWrite = pdc->pDescFirst;
            else
                pdc->pDescWrite++;
            pdc->DescCount++;

            /*
            // If this is the last frag, the forward pointer is NULL
            // Otherwise; this desc points to the next frag's desc
            */
            if( PktFrags==1 )
                pDescThis->pNext = 0;
            else
                pDescThis->pNext = pdc->pDescWrite;

            pDescThis->pBuffer   = pPkt->pDataBuffer + pPkt->DataOffset;
            pDescThis->BufOffLen = pPkt->ValidLen;

            if( pPkt->Flags & EMAC_PKT_FLAGS_SOP )
                pDescThis->PktFlgLen = ((pPkt->Flags&
                                       (EMAC_PKT_FLAGS_SOP|EMAC_PKT_FLAGS_EOP))
                                       |pPkt->PktLength|EMAC_DSC_FLAG_OWNER);
            else
                pDescThis->PktFlgLen = (pPkt->Flags&EMAC_PKT_FLAGS_EOP)
                                       |EMAC_DSC_FLAG_OWNER;

            /* Enqueue this frag onto the desc queue */
            pqPush( &pdc->DescQueue, pPkt );
            PktFrags--;
        }
    }

    /* If we posted anything, chain on the list or start the transmitter */
    if( CountOrg != pdc->DescCount )
    {
        if( CountOrg )
        {
            /*
            // Transmitter is already running. Just tack this packet on
            // to the end of the list (we need to "back up" one descriptor)
            */
            if( pDescOrg == pdc->pDescFirst )
                pDescThis = pdc->pDescLast;
            else
                pDescThis = pDescOrg - 1;
            pDescThis->pNext = pDescOrg;
        }
        else
        {
            /* Transmitter is not running, start it up */
            EMAC_RSETI( TXHDP, pdc->ChannelIndex, (Uint32)pDescOrg );
        }
    }
}

/*--------------------------------------------------------------------*\
* emacDequeueTx()
*
* Dequeue all completed TX packets and return buffers to application
\*--------------------------------------------------------------------*/
static void emacDequeueTx( EMAC_DescCh *pdc, EMAC_Desc *pDescAck )
{
    EMAC_Pkt     *pPkt;
    Uint32      PktFlgLen;
    register uint  i,j = (uint)pdc->pDescRead;

    /* Get the status of the ACK descriptor */
    PktFlgLen = pDescAck->PktFlgLen;

    /* Calc the new "Read" descriptor */
    if( pDescAck == pdc->pDescLast )
        pdc->pDescRead = pdc->pDescFirst;
    else
        pdc->pDescRead = pDescAck+1;

    i = (uint)pdc->pDescRead;

    /* Turn i into a descriptor count */
    if( j < i )
        i = (i-j)/sizeof(EMAC_Desc);
    else
        i = pdc->DescMax - ((j-i)/sizeof(EMAC_Desc));

    pdc->DescCount-=i;

    /* Pop & Free Buffers 'till the last Descriptor */
    while(i--)
    {
        /* Recover the buffer and free it */
        pPkt = pqPop( &pdc->DescQueue );
        if( pPkt )
            (*localDev.Config.pfcbFreePacket)(pdc->pd->hApplication,pPkt);
    }

    /* If the transmitter stopped and we have more descriptors, then restart */
    if( (PktFlgLen & EMAC_DSC_FLAG_EOQ) && pdc->DescCount )
        EMAC_RSETI( TXHDP, pdc->ChannelIndex, (Uint32)pdc->pDescRead );

    /* Try to post any waiting TX packets */
    if( pdc->WaitQueue.Count )
        emacEnqueueTx( pdc );
}


/*--------------------------------------------------------------------*\
* emacEnqueueRx()
*
* Fill any empty RX descriptors with new buffers from the application
\*--------------------------------------------------------------------*/
static void emacEnqueueRx( EMAC_DescCh *pdc, uint fRestart )
{
    EMAC_Pkt     *pPkt;
    EMAC_Desc   *pDesc;
    uint        CountOrg;

    /* Keep the old count around */
    CountOrg = pdc->DescCount;

    /* Fill RX Packets Until Full */
    while( pdc->DescCount < pdc->DescMax )
    {
        /* Get a buffer from the application */
        pPkt = (*localDev.Config.pfcbGetPacket)(pdc->pd->hApplication);

        /* If no more buffers are available, break out of loop */
        if( !pPkt )
            break;

        /* Fill in the descriptor for this buffer */
        pDesc = pdc->pDescWrite;

        /* Move the write pointer and bump count */
        if( pdc->pDescWrite == pdc->pDescLast )
            pdc->pDescWrite = pdc->pDescFirst;
        else
            pdc->pDescWrite++;
        pdc->DescCount++;

        /* Supply buffer pointer with application supplied offset */
        pDesc->pNext     = 0;
        pDesc->pBuffer   = pPkt->pDataBuffer + pPkt->DataOffset;
        pDesc->BufOffLen = localDev.PktMTU;
        pDesc->PktFlgLen = EMAC_DSC_FLAG_OWNER;

        /* Make the previous buffer point to us */
        if( pDesc == pdc->pDescFirst )
             pdc->pDescLast->pNext = pDesc;
        else
            (pDesc-1)->pNext = pDesc;

        /* Push the packet buffer on the local descriptor queue */
        pqPush( &pdc->DescQueue, pPkt );
    }

    /* Restart RX if we had ran out of descriptors and got some here */
    if( fRestart && !CountOrg && pdc->DescCount )
        EMAC_RSET( RX0HDP, (Uint32)pdc->pDescRead );
}

/*--------------------------------------------------------------------*\
* emacDequeueRx()
*
* Dequeue all completed RX packets and give buffers to application
\*--------------------------------------------------------------------*/
static void emacDequeueRx( EMAC_DescCh *pdc, EMAC_Desc *pDescAck )
{
    EMAC_Pkt     *pPkt;
    EMAC_Pkt     *pPktNew;
    EMAC_Desc   *pDescNewRxFirst,*pDescNewRxLast=0,*pTemp;
    uint        tmp;
    Uint32      PktFlgLen;

    /* Remember the first new descriptor slot */
    pDescNewRxFirst = pdc->pDescWrite;

    /*
    // Pop & Free Buffers 'till the last Descriptor
    // One thing we know for sure is that all the decriptors from
    // the read pointer to pDescAsk are linked to each other via
    // their pNext field.
    */
    for( tmp=1; tmp; )
    {
        /* Get the status of this descriptor */
        PktFlgLen = pdc->pDescRead->PktFlgLen;

        /* Recover the buffer and free it */
        pPkt = pqPop( &pdc->DescQueue );
        if( pPkt )
        {
            /* Fill in the necessary packet header fields */
            pPkt->Flags = PktFlgLen & 0xFFFF0000;
            pPkt->ValidLen = pPkt->PktLength = PktFlgLen & 0xFFFF;
            pPkt->PktChannel = 0;
            pPkt->PktFrags = 1;

            /* Pass the packet to the application */
            pPktNew = (*localDev.Config.pfcbRxPacket)
                                           (pdc->pd->hApplication,pPkt);
        }

        /* See if this was the last buffer */
        if( pdc->pDescRead == pDescAck )
            tmp = 0;

        /* Move the read pointer and decrement count */
        if( pdc->pDescRead == pdc->pDescLast )
            pdc->pDescRead = pdc->pDescFirst;
        else
            pdc->pDescRead++;
        pdc->DescCount--;

        /* See if we got a replacement packet */
        if( pPktNew )
        {
            /* We know we can immediately queue this packet */

            /* Fill in the descriptor for this buffer */
            pDescNewRxLast = pdc->pDescWrite;

            /* Move the write pointer and bump count */
            if( pdc->pDescWrite == pdc->pDescLast )
                pdc->pDescWrite = pdc->pDescFirst;
            else
                pdc->pDescWrite++;
            pdc->DescCount++;

            /* Supply buffer pointer with application supplied offset */
            pDescNewRxLast->pBuffer   = pPktNew->pDataBuffer + pPktNew->DataOffset;
            pDescNewRxLast->BufOffLen = localDev.PktMTU;
            pDescNewRxLast->PktFlgLen = EMAC_DSC_FLAG_OWNER;

            /* Push the packet buffer on the local descriptor queue */
            pqPush( &pdc->DescQueue, pPktNew );
        }
    }

    /*
    // If we added descriptors, make the pNext of the last NULL, and
    // make the previous descriptor point to the new list we added.
    */
    if( pDescNewRxLast )
    {
        pDescNewRxLast->pNext = 0;

        /* Make the previous buffer point to us */
        if( pDescNewRxFirst == pdc->pDescFirst )
            pTemp = pdc->pDescLast;
        else
            pTemp = pDescNewRxFirst-1;

        /*
        // If these pointers wrapped, the RX engine is stopped
        // Otherwise; tack the new list to the old
        */
        if( pTemp != pDescNewRxLast )
            pTemp->pNext = pDescNewRxFirst;
    }

    /* If the receiver stopped and we have more descriptors, then restart */
    if( (PktFlgLen & EMAC_DSC_FLAG_EOQ) && pdc->DescCount )
        EMAC_RSET( RX0HDP, (Uint32)pdc->pDescRead );
}


/*-----------------------------------------------------------------------*\
* STANDARD API FUNCTIONS
*
* Note on Exclusion (Serialization):
*   The application is charged with verifying that only one of the
* following API calls may only be executing at a given time across
* all threads and all interrupt functions.
*
\*-----------------------------------------------------------------------*/


/*-----------------------------------------------------------------------*\
* EMAC_enumerate()
*
* Enumerates the EMAC peripherals installed in the system and returns an
* integer count. The EMAC devices are enumerated in a consistent
* fashion so that each device can be later referenced by its physical
* index value ranging from "1" to "n" where "n" is the count returned
* by this function.
\*-----------------------------------------------------------------------*/
uint EMAC_enumerate( void )
{
    return(1);
}


/*-----------------------------------------------------------------------*\
* EMAC_open()
*
* Opens the EMAC peripheral at the given physical index and initializes
* it to an embryonic state.
*
* The calling application must supply a operating configuration that
* includes a callback function table. Data from this config structure is
* copied into the device's internal instance structure so the structure
* may be discarded after EMAC_open() returns. In order to change an item
* in the configuration, the the EMAC device must be closed and then
* re-opened with the new configuration.
*
* The application layer may pass in an hApplication callback handle,
* that will be supplied by the EMAC device when making calls to the
* application callback functions.
*
* An EMAC device handle is written to phEMAC. This handle must be saved
* by the caller and then passed to other EMAC device functions.
*
* The default receive filter prevents normal packets from being received
* until the receive filter is specified by calling EMAC_receiveFilter().
*
* A device reset is achieved by calling EMAC_close() followed by EMAC_open().
*
* The function returns zero on success, or an error code on failure.
*
* Possible error codes include:
*   EMAC_ERROR_ALREADY   - The device is already open
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_open( int physicalIndex, Handle hApplication,
                EMAC_Config *pEMACConfig, Handle *phEMAC )
{
    int             i;
    volatile Uint32 *pRegAddr;
    Uint32          tmpval;
    EMAC_Pkt        *pPkt;
    uint            utemp1;
    EMAC_Desc       *pDesc;

    /* We only handle a single instance */
    if( physicalIndex != 1 )
        return( EMAC_ERROR_INVALID );

    /* If the device is alread open, return an error */
    if( openFlag )
        return( EMAC_ERROR_ALREADY );

    /*
    //  Validate the supplied configuration structure
    */
    if( !pEMACConfig || !phEMAC )
        return( EMAC_ERROR_INVALID );

    /* Rx pool must be at least 8 to 192 */
    if( pEMACConfig->RxMaxPktPool < 8 || pEMACConfig->RxMaxPktPool > 192 )
        return( EMAC_ERROR_INVALID );

    /* MAC address must be supplied and not a multicast address */
    if( pEMACConfig->MacAddr[0] & 1 )
        return( EMAC_ERROR_INVALID );
    for( i=0; i<6 && !(pEMACConfig->MacAddr[i]); i++ )
    if( i==6 )
        return( EMAC_ERROR_INVALID );

    /* Tx Channels must be 1-8 */
    if( pEMACConfig->TxChannels < 1 || pEMACConfig->TxChannels > 8 )
        return( EMAC_ERROR_INVALID );

    /* Callback functions must be supplied */
    if( !pEMACConfig->pfcbGetPacket || !pEMACConfig->pfcbFreePacket ||
            !pEMACConfig->pfcbRxPacket || !pEMACConfig->pfcbStatus ||
            !pEMACConfig->pfcbStatistics )
        return( EMAC_ERROR_INVALID );


    /* MDIO settings must be valid - at least one bit must be set */
    if( !(pEMACConfig->MdioModeFlags & ( MDIO_MODEFLG_AUTONEG |
                MDIO_MODEFLG_HD10  | MDIO_MODEFLG_FD10 |
                MDIO_MODEFLG_HD100 | MDIO_MODEFLG_FD100 )) )
        return( EMAC_ERROR_INVALID );

    /*
    // Init the instance structure
    */

    /* Default everything in our instance structure to zero */
    memset( &localDev, 0, sizeof(EMAC_Device) );

    /* Set the hApplication and RxFilter */
    localDev.hApplication = hApplication;
    localDev.RxFilter     = EMAC_RXFILTER_NOTHING;

    /* Setup the new configuration */
    localDev.Config = *pEMACConfig;


    /*
    //  Initialize the EMAC and MDIO devices
    */

    /*
    // Globally disable EMAC/MDIO interrupts in wrapper and put both
    // EMAC and MDIO modules into reset
    */
    EMAC_RSET( EWCTL, EMAC_FMKS( EWCTL, INTEN, DISABLE ) |
                      EMAC_FMKS( EWCTL, EMACRST, YES ) |
                      EMAC_FMKS( EWCTL, MDIORST, YES ) );

    /* Wait about 100 cycles */
    for( i=0; i<5; i++ )
        tmpval = EMAC_RGET( EWCTL );

    /* Leave EMAC/MDIO interrupts disabled and take both
       EMAC and MDIO modules out of reset */
    EMAC_RSET( EWCTL, EMAC_FMKS( EWCTL, INTEN, DISABLE ) |
                      EMAC_FMKS( EWCTL, EMACRST, NO ) |
                      EMAC_FMKS( EWCTL, MDIORST, NO ) );

    /* Wait about 100 cycles */
    for( i=0; i<5; i++ )
        tmpval = EMAC_RGET( EWCTL );

    /* Start the MII Configuration */
    localDev.hMDIO = MDIO_open( pEMACConfig->MdioModeFlags );

    /*
    //  Setup the EMAC
    */

    /* Reset MAC Control */
    EMAC_RSET( MACCONTROL, 0 );

    /* Must manually init HDPs to NULL */
    pRegAddr = EMAC_ADDR(TX0HDP);
    for( i=0; i<8; i++ )
        *pRegAddr++ = 0;
    pRegAddr = EMAC_ADDR(RX0HDP);
    for( i=0; i<8; i++ )
        *pRegAddr++ = 0;

    /*
    // While MIIEN is clear in MACCONTROL, we can write directly to
    // the statistics registers (there are "EMAC_NUMSTATS" of them).
    */
    pRegAddr = EMAC_ADDR(RXGOODFRAMES);
    for( i=0; i<EMAC_NUMSTATS; i++ )
        *pRegAddr++ = 0;

    /* Setup device MAC address */
    EMAC_RSET( MACADDRL0, localDev.Config.MacAddr[5] );
    EMAC_RSET( MACADDRM, localDev.Config.MacAddr[4] );
    tmpval = 0;
    for( i=3; i>=0; i-- )
        tmpval = (tmpval<<8) | localDev.Config.MacAddr[i];
    EMAC_RSET( MACADDRH, tmpval );

    /*
    // Setup Special Receive Conditions (loopback, error frames, etc)
    */

    /* For us buffer offset will always be zero */
    EMAC_RSET( RXBUFFEROFFSET, 0 );

    /* Reset RX (M)ulticast (B)roadcast (P)romiscuous Enable register */
    EMAC_RSET( RXMBPENABLE, 0 );
    EMAC_RSET( MACHASH1, 0 );
    EMAC_RSET( MACHASH2, 0 );

    /* Clear Unicast RX on channel 0-7 */
    EMAC_RSET( RXUNICASTCLEAR, 0xFF );

    /* Set the pass RX CRC mode and adjust max buffer accordingly */
    if( localDev.Config.ModeFlags & EMAC_CONFIG_MODEFLG_RXCRC )
    {
        EMAC_FSETS( RXMBPENABLE, RXPASSCRC, INCLUDE );
        localDev.PktMTU = 1518;
    }
    else
        localDev.PktMTU = 1514;

    /* If PASSERROR is set, enable both ERROR and short frames */
    if( localDev.Config.ModeFlags & EMAC_CONFIG_MODEFLG_PASSERROR )
    {
        EMAC_FSETS( RXMBPENABLE, RXCEFEN, ENABLE );
        EMAC_FSETS( RXMBPENABLE, RXCSFEN, ENABLE );
    }

    /* If PASSCONTROL is set, enable control frames */
    if( localDev.Config.ModeFlags & EMAC_CONFIG_MODEFLG_PASSCONTROL )
        EMAC_FSETS( RXMBPENABLE, RXCMFEN, ENABLE );

    /* Set the channel configuration to priority if requested */
    if( localDev.Config.ModeFlags & EMAC_CONFIG_MODEFLG_CHPRIORITY )
        EMAC_FSETS( MACCONTROL, TXPTYPE, CHANNELPRI );

    /* Set MAC loopback if requested */
    if( localDev.Config.ModeFlags & EMAC_CONFIG_MODEFLG_MACLOOPBACK )
        EMAC_FSETS( MACCONTROL, LOOPBACK, ENABLE );

    /*
    // Enable TX and RX channel interrupts (set mask bits)
    // Enable Host interrupts
    */
    EMAC_RSET( RXINTMASKCLEAR, 0xFF );
    EMAC_RSET( TXINTMASKCLEAR, 0xFF );
    EMAC_RSET( RXINTMASKSET, 1 );
    for(i=0; i<localDev.Config.TxChannels; i++)
        EMAC_RSET( TXINTMASKSET, (1<<i) );
    EMAC_RSET( MACINTMASKSET, EMAC_FMK(MACINTMASKSET,HOSTERRINT,1) |
                              EMAC_FMK(MACINTMASKSET,STATINT,1) );


    /*
    // Setup Receive Buffers
    */

    /*
    // We give the first descriptors to RX The rest of the descriptors
    // will be divided evenly among the TX channels. Odds are this
    // will leave TX with a very large number of TX descriptors, but
    // we'll only use what we need (driven from the application send
    // requests). The RX descriptors are always kept fully populated.
    */

    /* Pointer to first descriptor to use on RX */
    pDesc = (EMAC_Desc *)_EMAC_DSC_BASE_ADDR;

    /* Number of descriptors for RX channel */
    utemp1 = localDev.Config.RxMaxPktPool;

    /* Init Rx */
    localDev.RxCh.pd         = &localDev;
    localDev.RxCh.DescMax    = utemp1;
    localDev.RxCh.pDescFirst = pDesc;
    localDev.RxCh.pDescLast  = pDesc + (utemp1 - 1);
    localDev.RxCh.pDescRead  = pDesc;
    localDev.RxCh.pDescWrite = pDesc;

    /* Fill the descriptor table */
    emacEnqueueRx( &localDev.RxCh, 0 );

    /*
    // If we didn't get the number of descriptor buffers that the
    // application said we should, then the app lied to us. This is
    // bad because we'll be constantly calling to the app to fill
    // up our buffers. So we'll close now to make the problem
    // obvious.
    */
    if( localDev.RxCh.DescCount < utemp1 )
    {
        /* Free all RX descriptors */
        while( pPkt = pqPop( &localDev.RxCh.DescQueue ) )
            (*localDev.Config.pfcbFreePacket)(localDev.hApplication, pPkt);

        /* Close the MDIO Module */
        MDIO_close( localDev.hMDIO );

        /* Return the error condition */
        return( EMAC_ERROR_INVALID );
    }

    /*
    // Setup Transmit Buffers
    */

    /* Pointer to first descriptor to use on TX */
    pDesc += utemp1;

    /* Number of descriptors (max) per channel */
    utemp1 = (_EDMA_DSC_ENTRY_COUNT-utemp1)/localDev.Config.TxChannels;

    /* Init all TX channels in use */
    for( i=0; i<(int)localDev.Config.TxChannels; i++)
    {
        localDev.TxCh[i].pd         = &localDev;
        localDev.TxCh[i].DescMax    = utemp1;
        localDev.TxCh[i].pDescFirst = pDesc;
        localDev.TxCh[i].pDescLast  = pDesc + (utemp1 - 1);
        localDev.TxCh[i].pDescRead  = pDesc;
        localDev.TxCh[i].pDescWrite = pDesc;

        pDesc += utemp1;
    }


    /*
    // Enable RX, TX, and MII
    //
    // Note in full duplex mode we also need to set the FULLDUPLEX
    // bit in MACCRONTROL. However, we don't know what to set until
    // we have a link. Also, we must be able to dynamically change
    // this bit if the cable is unplugged and re-linked with a different
    // duplex.
    */
    EMAC_FSETS( TXCONTROL, TXEN, ENABLE );
    EMAC_FSETS( RXCONTROL, RXEN, ENABLE );
    EMAC_FSETS( MACCONTROL, MIIEN, ENABLE );

    /* Startup RX */
    EMAC_RSET( RX0HDP, (Uint32)localDev.RxCh.pDescRead );

    /* Validate the device handle */
    localDev.DevMagic = EMAC_DEVMAGIC;

    /* Set the open flag */
    openFlag = 1;

    /* Give a handle back to the caller */
    *phEMAC = &localDev;

    /* Enable global interrupt in wrapper */
    EMAC_FSETS( EWCTL, INTEN, ENABLE );

    /* Return Success */
    return( 0 );
}


/*-----------------------------------------------------------------------*\
* EMAC_close()
*
* Closed the EMAC peripheral indicated by the supplied instance handle.
* When called, the EMAC device will shutdown both send and receive
* operations, and free all pending transmit and receive packets.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_close( Handle hEMAC )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;
    Uint32      i,tmp;
    EMAC_Pkt     *pPkt;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC )
        return( EMAC_ERROR_INVALID );

    /* Disable EMAC/MDIO interrupts in wrapper */
    EMAC_FSETS( EWCTL, INTEN, DISABLE );

    /*
    // The close process consists of tearing down all the active
    // channels (RX and TX) and then waiting for the teardown
    // complete indication from the MAC. Then, all queued packets
    // will be returned.
    */

        /* Teardown RX */
        EMAC_RSET( RXTEARDOWN, 0 );

        /* Teardown TX channels in use */
    for( i=0; i<pd->Config.TxChannels; i++)
        EMAC_RSET( TXTEARDOWN, i );

    /* Only check teardown status if there was no fatal error         */
    /* Otherwise; the EMAC is halted and cant be shutdown gracefully */
    if( !pd->FatalError )
    {
        /* Wait for the teardown to complete */
        for( tmp=0; tmp!=0xFFFFFFFC; tmp=EMAC_RGET(RX0INTACK) );
        EMAC_RSET( RX0INTACK, tmp );

            for( i=0; i<pd->Config.TxChannels; i++ )
        {
            for( tmp=0; tmp!=0xFFFFFFFC; tmp=EMAC_RGETI(TXINTACK,i) );
            EMAC_RSETI( TXINTACK, i, tmp );
        }
    }

    /* Disable RX, TX, and Clear MACCONTROL */
    EMAC_FSETS( TXCONTROL, TXEN, DISABLE );
    EMAC_FSETS( RXCONTROL, RXEN, DISABLE );
    EMAC_RSET( MACCONTROL, 0 );

    /* Free all RX buffers */
    while( pPkt = pqPop( &pd->RxCh.DescQueue ) )
        (*pd->Config.pfcbFreePacket)(localDev.hApplication, pPkt);

    /* Free all TX buffers */
    for( i=0; i<pd->Config.TxChannels; i++)
    {
        while( pPkt = pqPop( &pd->TxCh[i].DescQueue ) )
            (*pd->Config.pfcbFreePacket)(localDev.hApplication, pPkt);
        while( pPkt = pqPop( &pd->TxCh[i].WaitQueue ) )
            (*pd->Config.pfcbFreePacket)(localDev.hApplication, pPkt);
    }

    /* Close the MDIO Module */
    MDIO_close( pd->hMDIO );

    /* Invalidate the EMAC handle */
    pd->DevMagic = 0;

    /* Clear the open flag */
    openFlag = 0;

    /* Exit with interrupts still disabled in the wrapper */
    return(0);
}


/*-----------------------------------------------------------------------*\
* EMAC_getStatus()
*
* Called to get the current status of the device. The device status
* is copied into the supplied data structure.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_getStatus( Handle hEMAC, EMAC_Status *pStatus )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;
    uint        i,tmp;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC || !pStatus )
        return( EMAC_ERROR_INVALID );

    /* Get the MDIO status */
    MDIO_getStatus(pd->hMDIO, &pStatus->PhyDev, &pStatus->MdioLinkStatus );

    /* Number of rx packets held */
    pStatus->RxPktHeld = pd->RxCh.DescCount;

    /* Number of tx packets held */
    tmp = 0;
    for( i=0; i<pd->Config.TxChannels; i++)
    {
        tmp += pd->TxCh[i].DescCount;
        tmp += pd->TxCh[i].WaitQueue.Count;
    }
    pStatus->TxPktHeld = tmp;

    /* Fatal error value */
    pStatus->FatalError = pd->FatalError;

    return(0);
}


/*-----------------------------------------------------------------------*\
* EMAC_setReceiveFilter()
*
* Called to set the packet filter for received packets. The filtering
* level is inclusive, so BROADCAST would include both BROADCAST and
* DIRECTED (UNICAST) packets.
*
* Available filtering modes include the following:
*  EMAC_RXFILTER_NOTHING      - Receive nothing
*  EMAC_RXFILTER_DIRECT       - Receive only Unicast to local MAC addr
*  EMAC_RXFILTER_BROADCAST    - Receive direct and Broadcast
*  EMAC_RXFILTER_MULTICAST    - Receive above plus multicast in mcast list
*  EMAC_RXFILTER_ALLMULTICAST - Receive above plus all multicast
*  EMAC_RXFILTER_ALL          - Receive all packets
*
* Note that if error frames and control frames are desired, reception of
* these must be specified in the device configuration.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_setReceiveFilter( Handle hEMAC, uint ReceiveFilter )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC || ReceiveFilter > EMAC_RXFILTER_ALL )
        return( EMAC_ERROR_INVALID );

    /*
    // The following code relies on the numberic relation of the filter
    // value such that the higher filter values receive more types of
    // packets.
    */

    /* Disable Section */
    if( ReceiveFilter < EMAC_RXFILTER_ALL )
        EMAC_FSETS( RXMBPENABLE, RXCAFEN, DISABLE );
    if( ReceiveFilter < EMAC_RXFILTER_ALLMULTICAST )
    {
        EMAC_RSET( MACHASH1, pd->MacHash1 );
        EMAC_RSET( MACHASH2, pd->MacHash2 );
    }
    if( ReceiveFilter < EMAC_RXFILTER_MULTICAST )
        EMAC_FSETS( RXMBPENABLE, MULTEN, DISABLE );
    if( ReceiveFilter < EMAC_RXFILTER_BROADCAST )
        EMAC_FSETS( RXMBPENABLE, BROADEN, DISABLE );
    if( ReceiveFilter < EMAC_RXFILTER_DIRECT )
        EMAC_RSET( RXUNICASTCLEAR, 1 );

    /* Enable Section */
    if( ReceiveFilter >= EMAC_RXFILTER_DIRECT )
        EMAC_RSET( RXUNICASTSET, 1 );
    if( ReceiveFilter >= EMAC_RXFILTER_BROADCAST )
        EMAC_FSETS( RXMBPENABLE, BROADEN, ENABLE );
    if( ReceiveFilter >= EMAC_RXFILTER_MULTICAST )
        EMAC_FSETS( RXMBPENABLE, MULTEN, ENABLE );
    if( ReceiveFilter >= EMAC_RXFILTER_ALLMULTICAST )
    {
        EMAC_RSET( MACHASH1, 0xffffffff );
        EMAC_RSET( MACHASH1, 0xffffffff );
    }
    if( ReceiveFilter == EMAC_RXFILTER_ALL )
        EMAC_FSETS( RXMBPENABLE, RXCAFEN, ENABLE );

    pd->RxFilter = ReceiveFilter;
    return(0);
}


/*-----------------------------------------------------------------------*\
* EMAC_getReceiveFilter()
*
* Called to get the current packet filter setting for received packets.
* The filter values are the same as those used in EMAC_setReceiveFilter().
*
* The current filter value is writter to the pointer supplied in
* pReceiveFilter.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_getReceiveFilter( Handle hEMAC, uint *pReceiveFilter )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC || !pReceiveFilter )
        return( EMAC_ERROR_INVALID );

    *pReceiveFilter = pd->RxFilter;
    return(0);
}


/*-----------------------------------------------------------------------*\
* EMAC_getStatistics()
*
* Called to get the current device statistics. The statistics structure
* contains a collection of event counts for various packet sent and
* receive properties. Reading the statistics also clears the current
* statistic counters, so the values read represent a delta from the last
* call.
*
* The statistics information is copied into the structure pointed to
* by the pStatistics argument.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_getStatistics( Handle hEMAC, EMAC_Statistics *pStatistics )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC || !pStatistics )
        return( EMAC_ERROR_INVALID );

    /* Update the stats */
    emacUpdateStats( pd );

    /* Copy the updated stats to the application */
    *pStatistics = pd->Stats;

    /* Clear our copy */
    memset( &pd->Stats, 0, sizeof(EMAC_Statistics) );

    return(0);
}


/*-----------------------------------------------------------------------*\
* EMAC_setMulticast()
*
* This function is called to install a list of multicast addresses for
* use in multicast address filtering. Each time this function is called,
* any current multicast configuration is discarded in favor of the new
* list. Thus a set with a list size of zero will remove all multicast
* addresses from the device.
*
* Note that the multicast list configuration is stateless in that the
* list of multicast addresses used to build the configuration is not
* retained. Thus it is impossible to examine a list of currently installed
* addresses.
*
* The addresses to install are pointed to by pMCastList. The length of
* this list in bytes is 6 times the value of AddrCnt. When AddrCnt is
* zero, the pMCastList parameter can be NULL.
*
* The function returns zero on success, or an error code on failure.
* The multicast list settings are not altered in the event of a failure
* code.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_setMulticast( Handle hEMAC, uint AddrCnt, Uint8 *pMCastList )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;
    uint        tmp1,tmp2;
    Uint8       HashVal,tmpval;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC || (AddrCnt && !pMCastList) )
        return( EMAC_ERROR_INVALID );

    /* Clear the hash bits */
    pd->MacHash1 = 0;
    pd->MacHash2 = 0;

    /* For each address in the list, hash and set the bit */
    for( tmp1=0; tmp1<AddrCnt; tmp1++ )
    {
        HashVal=0;

        for( tmp2=0; tmp2<2; tmp2++ )
        {
            tmpval = *pMCastList++;
            HashVal ^= (tmpval>>2)^(tmpval<<4);
            tmpval = *pMCastList++;
            HashVal ^= (tmpval>>4)^(tmpval<<2);
            tmpval = *pMCastList++;
            HashVal ^= (tmpval>>6)^(tmpval);
        }

        if( HashVal & 0x20 )
            pd->MacHash2 |= (1<<(HashVal&0x1f));
        else
            pd->MacHash1 |= (1<<(HashVal&0x1f));
    }

    /* We only write the hash table if the filter setting allows */
    if( pd->RxFilter < EMAC_RXFILTER_ALLMULTICAST )
    {
        EMAC_RSET( MACHASH1, pd->MacHash1 );
        EMAC_RSET( MACHASH2, pd->MacHash2 );
    }

    return(0);
}


/*-----------------------------------------------------------------------*\
* EMAC_sendPacket()
*
* Sends a Ethernet data packet out the EMAC device. On a non-error return,
* the EMAC device takes ownership of the packet. The packet is returned
* to the application's free pool once it has been transmitted.
*
* The function returns zero on success, or an error code on failure.
* When an error code is returned, the EMAC device has not taken ownership
* of the packet.
*
* Possible error codes include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*   EMAC_ERROR_BADPACKET - The packet structure is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_sendPacket( Handle hEMAC, EMAC_Pkt *pPkt )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;
    uint        fragcnt,pktlen;
    EMAC_Pkt     *pPktLast;
    EMAC_DescCh  *pdc;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC || !pPkt )
        return( EMAC_ERROR_INVALID );

    /* Do some packet validation */
    if( !(pPkt->Flags & EMAC_PKT_FLAGS_SOP) )
        return( EMAC_ERROR_BADPACKET );

    if( pPkt->PktChannel >= pd->Config.TxChannels )
        return( EMAC_ERROR_BADPACKET );

    if( pPkt->PktLength < 14 || pPkt->PktLength > pd->PktMTU )
        return( EMAC_ERROR_BADPACKET );

    /* Count the number of frags in this packet */
    fragcnt = 1;
    pktlen  = pPkt->PktLength;
    pPktLast = pPkt;
    while( !(pPktLast->Flags & EMAC_PKT_FLAGS_EOP) )
    {
        if( !pPktLast->pNext )
            return( EMAC_ERROR_INVALID );
        pktlen -= pPktLast->ValidLen;
        pPktLast = pPktLast->pNext;
        fragcnt++;

        /* At this point we can't have another SOP */
        if( pPktLast->Flags & EMAC_PKT_FLAGS_SOP )
            return( EMAC_ERROR_INVALID );
    }

    /* Make sure PktLength and ValidLen agree */
    if( pktlen != pPkt->ValidLen )
        return( EMAC_ERROR_BADPACKET );

    /* The final packet frag must be the last in the list */
    if( pPktLast->pNext )
        return( EMAC_ERROR_BADPACKET );

    /* The frag count must be correct */
    if( fragcnt != pPkt->PktFrags )
        return( EMAC_ERROR_BADPACKET );

    /* Now pad for 60 byte min size. We only pad the last fragment */
    if( pPkt->PktLength < 60 )
    {
        pktlen = 60 - pPkt->PktLength;
        pPkt->PktLength = 60;
        pPktLast->ValidLen += pktlen;
    }

    /* Get a local pointer to the descriptor channel */
    pdc = &(pd->TxCh[pPkt->PktChannel]);

    /* Make sure this packet does not have too many frags to fit */
    if( fragcnt > pdc->DescMax )
        return( EMAC_ERROR_BADPACKET );

    /*
    // Queue and packet and service transmitter
    */
    pqPushChain( &pdc->WaitQueue, pPkt, pPktLast, fragcnt );
    emacEnqueueTx( pdc );

    return(0);
}


/*-----------------------------------------------------------------------*\
* EMAC_serviceCheck()
*
* This function should be called every time there is an EMAC device
* interrupt. It maintains the status the EMAC.
*
* Note that the application has the responsibility for mapping the
* physical device index to the correct EMAC_serviceCheck() function. If
* more than one EMAC device is on the same interrupt, the function must be
* called for each device.
*
* Possible error codes include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*   EMAC_ERROR_MACFATAL  - Fatal error in the MAC - Call EMAC_close()
*
\*-----------------------------------------------------------------------*/
uint EMAC_serviceCheck( Handle hEMAC )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;
    Uint32      intflags,Desc,mask;
    uint        tmp;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC )
        return( EMAC_ERROR_INVALID );

    /* Disable EMAC/MDIO interrupts in wrapper */
    EMAC_FSETS( EWCTL, INTEN, DISABLE );

    /* Read the interrupt cause */
    intflags = EMAC_RGET( MACINVECTOR );

    /* Look for fatal errors first */
    if( intflags & EMAC_FMK( MACINVECTOR, HOSTPEND, 1 ) )
    {
        /* Read the error status - we'll decode it by hand */
        pd->FatalError = EMAC_RGET( MACSTATUS );

        /* Tell the application */
        (*localDev.Config.pfcbStatus)(pd->hApplication);

        /* return with interrupt disabled in the wrapper */
        return( EMAC_ERROR_MACFATAL );
    }

    /* Look for statistics interrupt */
    if( intflags & EMAC_FMK( MACINVECTOR, STATPEND, 1 ) )
    {
        /* Read the stats and reset to zero         */
        /* This is necessary to clear the interrupt */
        emacUpdateStats( pd );

        /* Tell the application */
        (*localDev.Config.pfcbStatistics)(pd->hApplication);
    }

    /* Look for TX interrupt (channel 0-max) */
    for( tmp=0; tmp<pd->Config.TxChannels; tmp++ )
    {
        mask = EMAC_FMK( MACINVECTOR, TXPEND, 1<<tmp );
        if( intflags & mask )
        {
            /*
            // For multichannel operation, we need to
            // apply an errata workaround.
            */
            do
            {
                Desc = EMAC_RGETI( TXINTACK, tmp );
                EMAC_RSETI( TXINTACK, tmp, Desc );
            } while( pd->Config.TxChannels>1 && (EMAC_RGET(MACINVECTOR)&mask) );

            emacDequeueTx( &pd->TxCh[tmp], (EMAC_Desc *)Desc );
        }
    }

    /* Look for RX interrupt (channel 0) */
    if( intflags & EMAC_FMK( MACINVECTOR, RXPEND, 1<<0 ) )
    {
        /*
        // For multichannel operation, we need to apply the
        // same errata workaround as TX. However this driver
        // example only supports one RX channel.
        */
        Desc = EMAC_RGET( RX0INTACK );
        EMAC_RSET( RX0INTACK, Desc );

        emacDequeueRx( &pd->RxCh, (EMAC_Desc *)Desc );
    }

    /* Enable EMAC/MDIO interrupts in wrapper */
    EMAC_FSETS( EWCTL, INTEN, ENABLE );

    return(0);
}

/*-----------------------------------------------------------------------*\
* EMAC_timerTick()
*
* This function should be called for each device in the system on a
* periodic basis of 100mS (10 times a second). It is used to check the
* status of the EMAC and MDIO device, and to potentially recover from
* low Rx buffer conditions.
*
* Strict timing is not required, but the application should make a
* reasonable attempt to adhere to the 100mS mark. A missed call should
* not be "made up" by making mulitple sequential calls.
*
* A "polling" driver (one that calls EMAC_serviceCheck() in a tight loop),
* must also adhere to the 100mS timing on this function.
*
* Possible error codes include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
uint EMAC_timerTick( Handle hEMAC )
{
    EMAC_Device  *pd = (EMAC_Device *)hEMAC;
    uint         mdioStatus,linkStatus;

    /* Validate our handle */
    if( !pd || pd->DevMagic != EMAC_DEVMAGIC )
        return( EMAC_ERROR_INVALID );

    /* Signal the MDIO */
    mdioStatus = MDIO_timerTick( pd->hMDIO );

    /* On a new link, set the EMAC duplex */
    if( mdioStatus == MDIO_EVENT_LINKUP )
    {
        MDIO_getStatus( pd->hMDIO, 0, &linkStatus );

        if( linkStatus == MDIO_LINKSTATUS_FD10 ||
            linkStatus == MDIO_LINKSTATUS_FD100 )
        {
            EMAC_FSETS( MACCONTROL, FULLDUPLEX, ENABLE );
        }
        else
        {
            EMAC_FSETS( MACCONTROL, FULLDUPLEX, DISABLE );
        }
    }

    if( mdioStatus != MDIO_EVENT_NOCHANGE )
        (*localDev.Config.pfcbStatus)(pd->hApplication);

    /* Re-fill Rx buffer queue if needed */
    if( pd->RxCh.DescCount != pd->RxCh.DescMax )
        emacEnqueueRx( &pd->RxCh, 1 );

    return ( 0 );
}


#endif /* EMAC_SUPPORT */
/******************************************************************************\
* End of emac.c
\******************************************************************************/
csl_emif.c/     1036043947  0     0     0       2586      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emif.c
* DATE CREATED.. 06/11/1999 
* LAST MODIFIED. 10/03/2000
\******************************************************************************/
#define _EMIF_MOD_
#include "csl_emif.h"


#if (EMIF_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
/******************************************************************************\
* End of csl_emif.c
\******************************************************************************/

csl_emifa.c/    1030611959  0     0     0       2651      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emifa.c
* DATE CREATED.. 03/27/2001
* LAST MODIFIED. 03/27/2001
\******************************************************************************/
#define _EMIFA_MOD_
#include "csl_emifa.h"


#if (EMIFA_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/

#endif /* EMIFA_SUPPORT */
/******************************************************************************\
* End of csl_emifa.c
\******************************************************************************/


csl_emifb.c/    1030611961  0     0     0       2650      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emifb.c
* DATE CREATED.. 03/27/2001
* LAST MODIFIED. 03/27/2001
\******************************************************************************/
#define _EMIFB_MOD_
#include "csl_emifb.h"


#if (EMIF_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/

#endif /* EMIFB_SUPPORT */
/******************************************************************************\
* End of csl_emifb.c
\******************************************************************************/

csl_emu.c/      1055323621  0     0     0       4088      `
/**************************************************************************\
*              Copyright (C) 2002 Texas Instruments Incorporated.
*                             All Rights Reserved
*--------------------------------------------------------------------------
* MODULE NAME... EMU
* FILENAME...... csl_emu.c
* DATE CREATED.. 05/12/2003
* LAST MODIFIED. 05/20/2003
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITES.
\**************************************************************************/

/**************************************************************************\
* Private Macro and Include files
\**************************************************************************/
#define _EMU_MOD_

#include <csl_emu.h>

#if (EMU_SUPPORT)

/**************************************************************************\
*                          L O C A L   S E C T I O N
\**************************************************************************/

/**************************************************************************\
* EMU static macro declarations
\**************************************************************************/

/**************************************************************************\
* EMU static typedef declarations
\**************************************************************************/

/**************************************************************************\
* EMU static function declarations
\**************************************************************************/

/**************************************************************************\
*                         G L O B A L   S E C T I O N
\**************************************************************************/

/**************************************************************************\
* EMU global function definitions
\**************************************************************************/

CSLAPI Uint32  EMU_setDBGM(
    void
)
{
	EMU_RSET(MFREG0, EMU_MFREG0_RMK(1, 1, 0, 0, 0, 0));

	if(EMU_FGET(DBGSTAT, DBGMST) == 1)
	{
		return EMU_SUCCESS;
	}
	else
	{
		return EMU_FAILURE;
	}

}

/*------------------------------------------------------------------------*/

CSLAPI Uint32  EMU_clrDBGM(
    void
)
{

	EMU_RSET(MFREG0, EMU_MFREG0_RMK(1, 0, 0, 0, 0, 0));

	if(EMU_FGET(DBGSTAT, DBGMST) == 0)
	{
		return EMU_SUCCESS;
	}
	else
	{
		return EMU_FAILURE;
	}

}

/*------------------------------------------------------------------------*/

CSLAPI Uint32  EMU_getDBGM(
    void
)
{
	return(EMU_FGET(DBGSTAT, DBGMST));
}

/*------------------------------------------------------------------------*/

CSLAPI void  EMU_setABORTI(
    void
)
{
	EMU_RSET(MFREG0, EMU_MFREG0_RMK(0, 0, 1, 1, 0, 0));
}

/*------------------------------------------------------------------------*/

CSLAPI void  EMU_clrABORTI(
    void
)
{
	EMU_RSET(MFREG0, EMU_MFREG0_RMK(0, 0, 1, 0, 0, 0));
}

/*------------------------------------------------------------------------*/

CSLAPI Uint32  EMU_setEALLOW(
    void
)
{
	EMU_RSET(MFREG0, EMU_MFREG0_RMK(0, 0, 0, 0, 1, 1));

	if(EMU_FGET(DBGSTAT, EALLOWST) == 1)
	{
		return EMU_SUCCESS;
	}
	else
	{
		return EMU_FAILURE;
	}

}

/*------------------------------------------------------------------------*/

CSLAPI Uint32  EMU_clrEALLOW(
    void
)
{
	EMU_RSET(MFREG0, EMU_MFREG0_RMK(0, 0, 0, 0, 1, 0));

	if(EMU_FGET(DBGSTAT, EALLOWST) == 0)
	{
		return EMU_SUCCESS;
	}
	else
	{
		return EMU_FAILURE;
	}

}

/*------------------------------------------------------------------------*/

CSLAPI Uint32  EMU_getEALLOW(
    void
)
{
	return(EMU_FGET(DBGSTAT, EALLOWST));
}

/*------------------------------------------------------------------------*/

CSLAPI Uint32  EMU_getDBGSTAT(
    void
)
{
	return(EMU_RGET(DBGSTAT));
}

/*------------------------------------------------------------------------*/

#endif /* EMU_SUPPORT */

/**************************************************************************\
* End of csl_emu.c
\**************************************************************************/
csl_gpio.c/     1092218720  0     0     0       5033      `
/******************************************************************************\
*      Copyright (C) 2000-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_gpio.c
* DATE CREATED.. 12/04/2000
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                06/17/2003   - Added support for 6712C
*                06/09/2003   - Added support for 6711C
*                02/11/2002
*
\******************************************************************************/

#define _GPIO_MOD_

#include "csl_gpio.h"

#if (GPIO_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/**********************************************\
*  GPIO static macro declarations
\**********************************************/
#if (CHIP_DA610 || CHIP_6713 || CHIP_6416 || CHIP_6415 || CHIP_6414 || CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_6412 || \
     CHIP_6411 || CHIP_6410 || CHIP_6413 || CHIP_6418)
#define _PIN_ALLOCATION_MASK  0x0000FFFFu
#elif (CHIP_6711C || CHIP_6712C)
#define _PIN_ALLOCATION_MASK  0x000000F4u
#endif

#if (CHIP_DA610)
#define _GPIO_DEV_CNT  2
#else
  #define _GPIO_DEV_CNT  1
#endif


#define DEVICE_ENTRY(devNum) { \
  FALSE,\
 (volatile Uint32*)_GPIO_BASE_ADDR##devNum##,\
  _PIN_ALLOCATION_MASK \
}



/**********************************************\
*  GPIO static typedef declarations
\**********************************************/

/**********************************************\
*  GPIO static function declarations
\**********************************************/

/**********************************************\
*  GPIO static variable definitions
\**********************************************/
static GPIO_Obj _GPIO_deviceTable[_GPIO_DEV_CNT] = {
  DEVICE_ENTRY(0)
   #if (CHIP_DA610)
    ,DEVICE_ENTRY(1)
  #endif
};


/**********************************************\
*  GPIO static function definitions
\**********************************************/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                    G L O B A L   S E C T I O N
\******************************************************************************/

/**********************************************\
* Step  GPIO global variable definitions
\**********************************************/
  Uint32 _GPIO_intTable[GPIO_INT_CNT] = {
  GPIO_MASK_00,
  GPIO_MASK_04,
  GPIO_MASK_05,
  GPIO_MASK_06,
  GPIO_MASK_07
};

GPIO_Handle _hGpioDev0 = (GPIO_Handle) (&(_GPIO_deviceTable[0]));

/**********************************************\
* Step  GPIO global function definitions
\**********************************************/

/*----------------------------------------------------------------------------*/
IDEF void GPIO_reset(GPIO_Handle hGpio) {
   Uint32 gie;

    gie = IRQ_globalDisable();

     GPIO_RSETH(hGpio,GPGC,GPIO_GPGC_DEFAULT);
     GPIO_RSETH(hGpio,GPDIR,GPIO_GPDIR_DEFAULT);
     GPIO_RSETH(hGpio,GPPOL,GPIO_GPPOL_DEFAULT);
     GPIO_RSETH(hGpio,GPHM,GPIO_GPHM_DEFAULT);
     GPIO_RSETH(hGpio,GPLM,GPIO_GPLM_DEFAULT);
     GPIO_RSETH(hGpio,GPEN,GPIO_GPEN_DEFAULT);  /* 0xF9 for 64x*/

     GPIO_RSETH(hGpio,GPDH,0xFFFFFFFF);
     GPIO_RSETH(hGpio,GPDL,0xFFFFFFFF);

     GPIO_RSETH(hGpio,GPVAL,GPIO_GPVAL_DEFAULT);

    IRQ_globalRestore(gie);

}


/*---------------------------------------------------------------------------*/

IDEF void GPIO_clear( GPIO_Handle hGpio ) {

    Uint32 gie;

    gie = IRQ_globalDisable();

     GPIO_RSETH(hGpio,GPDH,0xFFFFFFFF);
     GPIO_RSETH(hGpio,GPDL,0xFFFFFFFF);

   IRQ_globalRestore(gie);
}


/*----------------------------------------------------------------------------*/


GPIO_Handle GPIO_open(int devNum, Uint32 flags) {

  Uint32 gie;

  GPIO_Handle hGpio = INV;

  gie = IRQ_globalDisable();
  if (!_GPIO_deviceTable[devNum].allocated) {
    hGpio = &(_GPIO_deviceTable[devNum]);
    _GPIO_deviceTable[devNum].allocated = TRUE;

    if (hGpio != INV) {
      if (flags & GPIO_OPEN_RESET) {
        GPIO_reset(hGpio);
      }
    }
  }
  IRQ_globalRestore(gie);

  return hGpio;
}
/*----------------------------------------------------------------------------*/
void GPIO_close(GPIO_Handle hGpio) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hGpio != INV) {
    GPIO_reset(hGpio);
    hGpio->allocated = FALSE;
  }
  IRQ_globalRestore(gie);
  return;
}



#endif /* GPIO_SUPPORT */
/******************************************************************************\
* End of csl_gpio.c
\******************************************************************************/

csl_hpi.c/      1030611964  0     0     0       2647      `
/******************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_hpi.c
* DATE CREATED.. 09/01/1999 
* LAST MODIFIED. 10/03/2000
\******************************************************************************/
#define _HPI_MOD_

#include "csl_hpi.h"


#if (HPI_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/

#endif /* HPI_SUPPORT */
/******************************************************************************\
* End of csl_hpi.c
\******************************************************************************/


csl_i2c.c/      1092218720  0     0     0       5266      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_i2c.c
* DATE CREATED.. 10/17/2001
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                11/09/2001
\******************************************************************************/
#define _I2C_MOD_
#include <csl_i2c.h>


#if (I2C_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/
#define DEVICE_ENTRY(devNum) { \
  FALSE, \
  IRQ_EVT_I2CINT##devNum##, \
  (volatile Uint32*)_I2C_BASE_PORT##devNum##, \
  _I2C_I2CDRR##devNum##_ADDR, \
  _I2C_I2CDXR##devNum##_ADDR \
}


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static I2C_Obj _I2C_deviceTable[_I2C_PORT_CNT] = {
#if (CHIP_6713 | CHIP_DA610 | CHIP_6413 | CHIP_6418 | CHIP_6410)
   DEVICE_ENTRY(0)
  ,DEVICE_ENTRY(1)
#endif
#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412)
   DEVICE_ENTRY(0)
#endif
  };




/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/

/******************************************************************************\
* global function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
void I2C_reset(I2C_Handle hI2c) {
  
  Uint32 gie;

  gie = IRQ_globalDisable();

  if (hI2c == INV) {
    I2C_reset((I2C_Handle)(&(_I2C_deviceTable[0])));
  #if (CHIP_6713 | CHIP_DA610 | CHIP_6413 | CHIP_6418 | CHIP_6410)
    I2C_reset((I2C_Handle)(&(_I2C_deviceTable[1])));
  #endif
  } else {
    I2C_RSETH(hI2c,I2COAR,I2C_I2COAR_DEFAULT);
    I2C_RSETH(hI2c,I2CIER,I2C_I2CIER_DEFAULT);
    I2C_RSETH(hI2c,I2CSTR,I2C_I2CSTR_DEFAULT);
    I2C_RSETH(hI2c,I2CCLKL,I2C_I2CCLKL_DEFAULT);
    I2C_RSETH(hI2c,I2CCLKH,I2C_I2CCLKH_DEFAULT);
    I2C_RSETH(hI2c,I2CCNT,I2C_I2CCNT_DEFAULT);
    I2C_RSETH(hI2c,I2CSAR,I2C_I2CSAR_DEFAULT);
    I2C_RSETH(hI2c,I2CPSC,I2C_I2CPSC_DEFAULT);
    I2C_RSETH(hI2c,I2CDXR,I2C_I2CDXR_DEFAULT);
    
    while(I2C_RGETH(hI2c,I2CISRC))  /* Reading I2CISRC clears the interrupt flag */
              ;

    I2C_RSETH(hI2c,I2CMDR,I2C_I2CMDR_DEFAULT); /* I2C is reset mode  IRS=0 */

#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
    I2C_RSETH(hI2c,I2CEMDR,I2C_I2CEMDR_DEFAULT);
    I2C_RSETH(hI2c,I2CPFUNC,I2C_I2CPFUNC_DEFAULT);
    I2C_RSETH(hI2c,I2CPDIR,I2C_I2CPDIR_DEFAULT);
    I2C_RSETH(hI2c,I2CPDOUT,I2C_I2CPDOUT_DEFAULT);
#endif    
	IRQ_reset(hI2c->eventId);
  }
  
  IRQ_globalRestore(gie);
  
  return;
}
/*----------------------------------------------------------------------------*/
void I2C_resetAll() {
  I2C_reset(INV);
}
/*----------------------------------------------------------------------------*/
I2C_Handle I2C_open(int devNum, Uint32 flags) {

  Uint32 gie;

  I2C_Handle hI2c = INV;

  gie = IRQ_globalDisable();
  if (!_I2C_deviceTable[devNum].allocated) {
    hI2c = &(_I2C_deviceTable[devNum]);
    _I2C_deviceTable[devNum].allocated = TRUE;

    if (hI2c != INV) {
      if (flags & I2C_OPEN_RESET) {
        I2C_reset(hI2c);
      }
    }
  }

  IRQ_globalRestore(gie);

  return hI2c;
}
/*----------------------------------------------------------------------------*/
void I2C_close(I2C_Handle hI2c) {

  Uint32 gie;

  gie = IRQ_globalDisable();

  if (hI2c != INV) {
    I2C_reset(hI2c);
    hI2c->allocated = FALSE;
  }
  
  IRQ_globalRestore(gie);
  
  return;
}
/*----------------------------------------------------------------------------*/

#endif /* I2C_SUPPORT */
/******************************************************************************\
* End of csl_i2c.c
\******************************************************************************/

csl_irq.c/      1090821493  0     0     0       12788     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_irq.c
* DATE CREATED.. 06/09/1999 
* LAST MODIFIED. 07/24/2004 - Re-introduced BIOS dependency due to compatibility issues
*                02/05/2004    Removed bios related components
*                10/03/2001
*                - CHIP_RSET()/CHIP_RGET() replaced by CHIP_CRSET()/CHIP_CRGET()
\******************************************************************************/
#define _IRQ_MOD_
#include <csl_irq.h>
#include <csl_edmahal.h>

#if (IRQ_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/* We need to use the runtime library intrinsic _lmbd() function but */
extern far Uint32 _lmbd(Uint32 src1, Uint32 src2);


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/
static void mux2Tables();
static int getMux(int intNum);
static void setMux(int intNum, int val);


/******************************************************************************\
* static variable definitions
\******************************************************************************/

/* NOTE: _IRQ_init() must be called to initialize these items */
static Uint32 _IRQ_biosPresent = 0;

static char dateStamp[] = "DATE STAMP ["__DATE__"] ["__TIME__"]";

/******************************************************************************\
* static function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
static void mux2Tables() {

  int x;
  
  for (x=0; x<IRQ_EVENT_CNT+1; x++) {
    _IRQ_eventTable[x] = IRQ_MASK_NA;
  }
  
  for (x=4; x<IRQ_INT_CNT; x++) {
    _IRQ_intTable[x] = getMux(x);
    _IRQ_eventTable[_IRQ_intTable[x]] = (1<<x);
  }                              
}


/*----------------------------------------------------------------------------*/
static int getMux(int intNum) {

  Uint32 shift,mask,addr;
  int eventId = 0x1F;

  if ((intNum >= 4) && (intNum <= 9)) {
    addr  = _IRQ_MUXL_ADDR;
    shift = 5*(intNum-4)+(intNum>6 ? 1: 0);
  } else if ((intNum >= 10) && (intNum <= 15)) {
    addr  = _IRQ_MUXH_ADDR;
    shift = 5*(intNum-10)+(intNum>12 ? 1: 0);
  } else {
    addr = 0xFFFFFFFFu;
  }

  /* Go ahead and update the MUX register to reflect the new mapping */
  if (addr != 0xFFFFFFFFu) {
    mask  = 31<<shift;
    eventId = ((*(volatile Uint32*)addr) & mask) >> shift;
  }  
  return eventId;
}

/*----------------------------------------------------------------------------*/
static void setMux(int intNum, int eventId) {

  Uint32 shift,mask,addr,v;

  if ((intNum >= 4) && (intNum <= 9)) {
    addr  = _IRQ_MUXL_ADDR;
    shift = 5*(intNum-4)+(intNum>6 ? 1: 0);
  } else if ((intNum >= 10) && (intNum <= 15)) {
    addr  = _IRQ_MUXH_ADDR;
    shift = 5*(intNum-10)+(intNum>12 ? 1: 0);
  } else {
    addr = 0xFFFFFFFFu;
  }

  /* Go ahead and update the MUX register to reflect the new mapping */
  if (addr != 0xFFFFFFFFu) {
    mask  = 31<<shift;
    v = *(volatile Uint32*)addr;
    v = v & ~mask;
    v = v | ((eventId<<shift)&mask);
    *(volatile Uint32*)addr = v;
  }  
}

/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/

Uint32 _IRQ_eventTable[IRQ_EVENT_CNT+1] = {
  IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA,
  IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA,
  IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA,
  IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA,
  IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA,
  IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA,
  IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA,
  IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA, IRQ_MASK_NA
};

Uint32 _IRQ_intTable[IRQ_INT_CNT] = {
  IRQ_EVT_NA, IRQ_EVT_NA, IRQ_EVT_NA, IRQ_EVT_NA,
  IRQ_EVT_NA, IRQ_EVT_NA, IRQ_EVT_NA, IRQ_EVT_NA,
  IRQ_EVT_NA, IRQ_EVT_NA, IRQ_EVT_NA, IRQ_EVT_NA,
  IRQ_EVT_NA, IRQ_EVT_NA, IRQ_EVT_NA, IRQ_EVT_NA
};

_IRQ_Dispatch *_IRQ_dispatchTable = (_IRQ_Dispatch*)INV; 


/******************************************************************************\
* global function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
void _IRQ_init(Uint32 biosPresent, _IRQ_Dispatch *dispatchTable) {

  int gie;
  static int initialized = 0;

  UNREFERENCED_PARAMETER(dateStamp[0]);

  gie = IRQ_globalDisable(); 

  if (!initialized) {
    initialized = 1;
    _IRQ_biosPresent   = biosPresent;
    _IRQ_dispatchTable = dispatchTable;
  }  

  mux2Tables();

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void IRQ_map(Uint32 eventId, Uint32 intNum) {

  int gie,x,i;
  int oldIntNum;

  gie = IRQ_globalDisable(); 
  
  /* Find out which interrupt eventId is currently mapped to then */
  /* wipe out it's entry in the MUX registers and the eventTable. */
  oldIntNum = 31-_lmbd(1,_IRQ_eventTable[eventId]);
  if (oldIntNum >= 0) {
    _IRQ_intTable[oldIntNum] = IRQ_EVT_NA;
    setMux(oldIntNum, 0x1F);
  }
  
  /* Also need to unmap any other events that are mapped to this interrupt */
  for (x=0; x<IRQ_EVENT_CNT; x++) {
    i = 31-_lmbd(1,_IRQ_eventTable[x]);
    if (i == intNum) {
      _IRQ_eventTable[x] = IRQ_MASK_NA;
    } 
  }
  
  /* Now it's ok to go ahead and map the new eventId to intNum */
  _IRQ_intTable[intNum] = eventId;
  _IRQ_eventTable[eventId] = 1<<intNum;
  setMux(intNum, eventId);
  
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
Uint32 IRQ_biosPresent() {
  return _IRQ_biosPresent;
}

/*----------------------------------------------------------------------------*/
void IRQ_config(Uint32 eventId, IRQ_Config *config) {

  /* This is a dispatcher only function */

  Uint32 gie,ie_mask;
  int intNum;

  gie = IRQ_globalDisable();

  if (_IRQ_dispatchTable != INV) {

    intNum = 31-_lmbd(1,_IRQ_eventTable[eventId]);

    if (intNum >= 0) {

      if (config->ieMask & IRQ_IEMASK_SELF) {
        ie_mask = _IRQ_eventTable[eventId];
      } else {
        ie_mask = config->ieMask;
      }
  
      _IRQ_dispatchTable[intNum].funcAddr = config->funcAddr;
      _IRQ_dispatchTable[intNum].funcArg  = config->funcArg;
      _IRQ_dispatchTable[intNum].ccMask   = config->ccMask;
      _IRQ_dispatchTable[intNum].ieMask   = ie_mask;
    }
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void IRQ_configArgs(Uint32 eventId, void *funcAddr, Uint32 funcArg, 
  Uint32 ccMask, Uint32 ieMask) {

  /* This is a dispatcher only function */

  Uint32 gie,ie_mask;
  int intNum;

  gie = IRQ_globalDisable();

  if (_IRQ_dispatchTable != INV) {

    intNum = 31-_lmbd(1,_IRQ_eventTable[eventId]);

    if (intNum >= 0) {

      if (ieMask & IRQ_IEMASK_SELF) {
        ie_mask = _IRQ_eventTable[eventId];
      } else {
        ie_mask = ieMask;
      }
  
      _IRQ_dispatchTable[intNum].funcAddr = funcAddr;
      _IRQ_dispatchTable[intNum].funcArg  = funcArg;
      _IRQ_dispatchTable[intNum].ccMask   = ccMask;
      _IRQ_dispatchTable[intNum].ieMask   = ie_mask;
    }
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void IRQ_getConfig(Uint32 eventId, IRQ_Config *config) {

  /* This is a dispatcher only function */

  Uint32 gie;
  int intNum;

  gie = IRQ_globalDisable();

  if (_IRQ_dispatchTable != INV) {

    intNum = 31-_lmbd(1,_IRQ_eventTable[eventId]);

    if (intNum >= 0) {
      config->funcAddr = _IRQ_dispatchTable[intNum].funcAddr;
      config->funcArg  = _IRQ_dispatchTable[intNum].funcArg;
      config->ccMask   = _IRQ_dispatchTable[intNum].ccMask;
      config->ieMask   = _IRQ_dispatchTable[intNum].ieMask;
    }
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
Uint32 IRQ_getArg(Uint32 eventId) {

  /* This is a dispatcher only function */

  Uint32 gie;
  int intNum;
  Uint32 arg = 0x00000000;

  gie = IRQ_globalDisable();

  if (_IRQ_dispatchTable != INV) {

    intNum = 31-_lmbd(1,_IRQ_eventTable[eventId]);

    if (intNum >= 0) {
      arg = _IRQ_dispatchTable[intNum].funcArg;
    }
  }

  IRQ_globalRestore(gie);

  return arg;
}

/*----------------------------------------------------------------------------*/
void IRQ_setArg(Uint32 eventId, Uint32 arg) {

  /* This is a dispatcher only function */

  Uint32 gie;
  int intNum;

  gie = IRQ_globalDisable();

  if (_IRQ_dispatchTable != INV) {

    intNum = 31-_lmbd(1,_IRQ_eventTable[eventId]);

    if (intNum >= 0) {
      _IRQ_dispatchTable[intNum].funcArg = arg;
    }
  }

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void *IRQ_setVecs(void *vecs) {

  void *oldVecs;

  oldVecs = (void*)(CHIP_CRGET(ISTP) & _CHIP_ISTP_ISTB_MASK);
  CHIP_CRSET(ISTP,(Uint32)vecs & _CHIP_ISTP_ISTB_MASK);

  return oldVecs;
}

/*----------------------------------------------------------------------------*/
extern far void _IRQ_hookFetchPacket();

  asm(" .global __IRQ_hookFetchPacket");
  asm("__IRQ_hookFetchPacket:");
  asm("  STW  B0, *--B15");
  asm("  MVKL 0x00000000, B0");
  asm("  MVKH 0x00000000, B0");
  asm("  B    B0");
  asm("  LDW  *B15++, B0");
  asm("  NOP  4");
  asm("  NOP");
  asm("  NOP");

/*----------------------------------------------------------------------------*/
void IRQ_hook(int intNum, void *func) {
  
  int gie;
  Uint32 vector;
  Uint32 *work,*fetchPacket;

  gie = IRQ_globalDisable();

  #if (C11_SUPPORT || C64_SUPPORT)
    work = (Uint32*)_EDMA_RSVD_PARAM;
    fetchPacket = (Uint32*)_IRQ_hookFetchPacket;

    /* copy the fixed assembled fetch packet over to the work area */
    work[0] = fetchPacket[0];
    work[1] = fetchPacket[1];
    work[2] = fetchPacket[2];
    work[3] = fetchPacket[3];
    work[4] = fetchPacket[4];
    work[5] = fetchPacket[5];

    /* patch in the function address directly into the MVKL/H opcodes */
    work[1] = (work[1] & 0xFF80007F) | (((Uint32)func & 0x0000FFFF) << 7);
    work[2] = (work[2] & 0xFF80007F) | (((Uint32)func & 0xFFFF0000) >> 9);
    
    /* this is where the fetch packet will be copied to in the IST */
    vector = (CHIP_CRGET(ISTP) & _CHIP_ISTP_ISTB_MASK) + 8*4*intNum;
  
    /* copy the fetch packet using QDMA in two steps */
    EDMA_RSET(CIER, EDMA_RGET(CIER) & ~0x00000001);

    EDMA_RSET(CIPR, 0x00000001);
    EDMA_RSET(QSRC, work);
    EDMA_RSET(QDST, vector);
    EDMA_RSET(QCNT, 6);
    EDMA_RSET(QIDX, 4);
    EDMA_RSET(QSOPT, 0x41300001);
    while (!EDMA_RGET(CIPR) & 0x00000001);

    work[0] = fetchPacket[6];
    work[1] = fetchPacket[7];
    EDMA_RSET(CIPR, 0x00000001);
    EDMA_RSET(QSRC, work);
    EDMA_RSET(QDST, vector+4*6);
    EDMA_RSET(QCNT, 2);
    EDMA_RSET(QIDX, 4);
    EDMA_RSET(QSOPT, 0x41300001);
    while (!EDMA_RGET(CIPR) & 0x00000001);
    EDMA_RSET(CIPR, 0x00000001);
  #else
    UNREFERENCED_PARAMETER(vector);
    UNREFERENCED_PARAMETER(work);
    UNREFERENCED_PARAMETER(fetchPacket);
  #endif

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/


#endif /* IRQ_SUPPORT */
/******************************************************************************\
* End of csl_irq.c
\******************************************************************************/

csl_legacy.c/   1030611968  0     0     0       6127      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_legacy.c
* DATE CREATED.. 09/07/2000 
* LAST MODIFIED. 10/03/2000
\******************************************************************************/
#define _LEGACY_MOD_
#include "csl_legacy.h"


/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
#if (DMA_SUPPORT&&0)
  static Uint32 gblAllocMask = 0x00000000;
#endif


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/
#if (DMA_SUPPORT&&0)
  Uint32 _DMA_gblRegTbl[_DMA_GBLREG_CNT] = {
    /* [0x00] DMA_GBL_ADDRRLD 0 */ 0xFFFFFFFFu,
    /* [0x01] DMA_GBL_ADDRRLD 1 */ HDMA_GBLADDRB_ADDR,
    /* [0x02] DMA_GBL_ADDRRLD 2 */ HDMA_GBLADDRC_ADDR,
    /* [0x03] DMA_GBL_ADDRRLD 3 */ HDMA_GBLADDRD_ADDR,
    /* [0x04] DMA_GBL_INDEX   0 */ HDMA_GBLIDXA_ADDR,
    /* [0x05] DMA_GBL_INDEX   1 */ HDMA_GBLIDXB_ADDR,
    /* [0x06] DMA_GBL_INDEX   2 */ 0xFFFFFFFFu,
    /* [0x07] DMA_GBL_INDEX   3 */ 0xFFFFFFFFu,
    /* [0x08] DMA_GBL_CNTRLD  0 */ HDMA_GBLCNTA_ADDR,
    /* [0x09] DMA_GBL_CNTRLD  1 */ HDMA_GBLCNTB_ADDR,
    /* [0x0A] DMA_GBL_CNTRLD  2 */ 0xFFFFFFFFu,
    /* [0x0B] DMA_GBL_CNTRLD  3 */ 0xFFFFFFFFu,
    /* [0x0C] DMA_GBL_SPLIT   0 */ 0xFFFFFFFFu,
    /* [0x0D] DMA_GBL_SPLIT   1 */ HDMA_GBLADDRA_ADDR,
    /* [0x0E] DMA_GBL_SPLIT   2 */ HDMA_GBLADDRB_ADDR,
    /* [0x0F] DMA_GBL_SPLIT   3 */ HDMA_GBLADDRC_ADDR
  };
#endif


/******************************************************************************\
* global function definitions
\******************************************************************************/
#if (DMA_SUPPORT&&0)
/*----------------------------------------------------------------------------*/
Uint32 DMA_allocGlobalReg(DMA_Gbl regType, Uint32 initVal) {

  Uint32 gie;
  Uint32 regId = 0x00000000;
  Uint32 regNum0=0,regNum1=0,regNum=0;
  Uint32 mask = 0x00000000;

  gie = IRQ_globalDisable();

  switch (regType) {
    case DMA_GBL_ADDRRLD: regNum0=0x01; regNum1=0x03; mask = 0x20000000; break;
    case DMA_GBL_INDEX:   regNum0=0x04; regNum1=0x05; mask = 0x01000000; break;
    case DMA_GBL_CNTRLD:  regNum0=0x08; regNum1=0x09; mask = 0x00100000; break;
    case DMA_GBL_SPLIT:   regNum0=0x0D; regNum1=0x0F; mask = 0x10000000; break;
  }

  for (regNum=regNum0; regNum<=regNum1; regNum++) {
    if ((gblAllocMask & mask)==0) {
      gblAllocMask |= mask;
      regId = mask | regNum;
      DMA_setGlobalReg(regId,initVal);
      break;
    }
    mask = mask << 1;
  }

  IRQ_globalRestore(gie);

  return regId;
}

/*----------------------------------------------------------------------------*/
void DMA_freeGlobalReg(Uint32 regId) {

  Uint32 gie = IRQ_globalDisable();
  gblAllocMask &= ~(regId & 0xFFFF0000);
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
#endif /* DMA_SUPPORT */

#if (EMIF_SUPPORT)
/*----------------------------------------------------------------------------*/
void EMIF_ConfigA(EMIF_CONFIG *Config) {

  HEMIF_CECTL_SET(HEMIF_CE0CTL_ADDR, Config->ce0ctl);
  HEMIF_CECTL_SET(HEMIF_CE1CTL_ADDR, Config->ce1ctl);
  HEMIF_CECTL_SET(HEMIF_CE2CTL_ADDR, Config->ce2ctl);
  HEMIF_CECTL_SET(HEMIF_CE3CTL_ADDR, Config->ce3ctl);
  HEMIF_SDCTL_SET(HEMIF_SDCTL_ADDR, Config->sdctl);
  HEMIF_SDTIM_SET(HEMIF_SDTIM_ADDR, Config->sdtim);
  HEMIF_SDEXT_SET(HEMIF_SDEXT_ADDR, Config->sdext);
  HEMIF_GBLCTL_SET(HEMIF_GBLCTL_ADDR, Config->gblctl);
}

/*----------------------------------------------------------------------------*/
void EMIF_ConfigB(UINT32 gblctl, UINT32 ce0ctl, UINT32 ce1ctl,
  UINT32 ce2ctl, UINT32 ce3ctl, UINT32 sdctl, UINT32 sdtim, UINT32 sdext) {

  HEMIF_CECTL_SET(HEMIF_CE0CTL_ADDR, ce0ctl);
  HEMIF_CECTL_SET(HEMIF_CE1CTL_ADDR, ce1ctl);
  HEMIF_CECTL_SET(HEMIF_CE2CTL_ADDR, ce2ctl);
  HEMIF_CECTL_SET(HEMIF_CE3CTL_ADDR, ce3ctl);
  HEMIF_SDCTL_SET(HEMIF_SDCTL_ADDR, sdctl);
  HEMIF_SDTIM_SET(HEMIF_SDTIM_ADDR, sdtim);
  HEMIF_SDEXT_SET(HEMIF_SDEXT_ADDR, sdext);
  HEMIF_GBLCTL_SET(HEMIF_GBLCTL_ADDR, gblctl);
}
/*----------------------------------------------------------------------------*/
#endif /* EMIF_SUPPORT */


/******************************************************************************\
* End of csl_legacy.c
\******************************************************************************/


csl_mcasp.c/    1091195462  0     0     0       31991     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mcasp.c
* DATE CREATED.. 06/10/2001 
* LAST MODIFIED. 04/16/2004 - Fixed MCASP_getPins() bug
*                02/28/2002 - Zeno update
*                02/19/2002 - addition _enableHclk()
*                           - clear RSTAT/XSTAT register in reset function  
*                           - set all the XDTM/RDTM bits to 1 in ditConfig()
*                             correction of XROT value
*                11/27/2001 - addition MCASP_ditConfig()
\******************************************************************************/
#define _MCASP_MOD_
#include <csl_mcasp.h>

#if (MCASP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/******************************************************************************\
* static macro declarations
\******************************************************************************/

/*This should match the Mcasp_Obj structure in csl_mcasp.h*/

//NOTE:  currently, the MCASP event IDs are being used!
//This needs to be changed to MCASP event IDs once they are finalized
//Please remove this comment when the new event IDs are put in

#define DEVICE_ENTRY(devNum) { \
  FALSE, \
  IRQ_EVT_AXINT##devNum##, \
  IRQ_EVT_ARINT##devNum##, \
  (volatile Uint32*)_MCASP_BASE_PORT##devNum##, \
  _MCASP_XBUF##devNum##_ADDR, \
  _MCASP_XBUF0##devNum##_ADDR, \
  _MCASP_RBUF##devNum##_ADDR, \
  _MCASP_RBUF0##devNum##_ADDR, \
  _MCASP_DITCSR##devNum##_ADDR, \
  _MCASP_DITUDR##devNum##_ADDR \
}


/******************************************************************************\
* static typedef declarations
\******************************************************************************/

/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static MCASP_Obj _MCASP_deviceTable[_MCASP_PORT_CNT] = {
   DEVICE_ENTRY(0)
 #if (_MCASP_PORT_CNT == 2)
  ,DEVICE_ENTRY(1)
#endif
};

/* table to set transmit mask data - DIT mode - see MCASP_ditConfig() */
static Uint32 _MCASP_xmaskIntTable[9]= {
      0x0000FFFF,0x0001FFFF,0x0003FFFF,0x0007FFFF,0x000FFFFF,
      0x001FFFFF,0x003FFFFF,0x007FFFFF,0x00FFFFFF};

static Uint32 _MCASP_xmaskQTable[9]= {
      0xFFFF0000u,0xFFFF1000u,0xFFFF3000u,0xFFFF7000u,0xFFFFF000u,
      0xFFFFF100u,0xFFFFF300u,0xFFFFF700u,0xFFFFFF00u };


/******************************************************************************\
* static function definitions
\******************************************************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/******************************************************************************\
* global variable definitions
\******************************************************************************/



/******************************************************************************\
* global function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
void MCASP_reset(MCASP_Handle hMcasp) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hMcasp == INV) {
    MCASP_reset((MCASP_Handle)(&(_MCASP_deviceTable[0])));

    #if (_MCASP_PORT_CNT==2)
    MCASP_reset((MCASP_Handle)(&(_MCASP_deviceTable[1])));
    #endif

  } else {
    
    MCASP_RSETH(hMcasp,PFUNC,   	MCASP_PFUNC_DEFAULT);
    MCASP_RSETH(hMcasp,PDIR,    	MCASP_PDIR_DEFAULT);          
    MCASP_RSETH(hMcasp,AMUTE,   	MCASP_AMUTE_DEFAULT);          
    MCASP_RSETH(hMcasp,DLBCTL,   	MCASP_DLBCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,DITCTL, 	        MCASP_DITCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,RMASK,   	MCASP_RMASK_DEFAULT);          
    MCASP_RSETH(hMcasp,RFMT, MCASP_RFMT_DEFAULT);          
    MCASP_RSETH(hMcasp,AFSRCTL, MCASP_AFSRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,ACLKRCTL,MCASP_ACLKRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,AHCLKRCTL,MCASP_AHCLKRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,RTDM,MCASP_RTDM_DEFAULT);          
    MCASP_RSETH(hMcasp,RINTCTL,MCASP_RINTCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,RCLKCHK,MCASP_RCLKCHK_DEFAULT);          
    MCASP_RSETH(hMcasp,XMASK, MCASP_XMASK_DEFAULT);     
    MCASP_RSETH(hMcasp,XFMT,MCASP_XFMT_DEFAULT);          
    MCASP_RSETH(hMcasp,AFSXCTL,MCASP_AFSXCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,ACLKXCTL,MCASP_ACLKXCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,AHCLKXCTL,MCASP_AHCLKXCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,XTDM,MCASP_XTDM_DEFAULT);          
    MCASP_RSETH(hMcasp,XINTCTL,MCASP_XINTCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,XCLKCHK,MCASP_XCLKCHK_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL0,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL1,MCASP_SRCTL_DEFAULT);     
    MCASP_RSETH(hMcasp,SRCTL2,MCASP_SRCTL_DEFAULT);     
    MCASP_RSETH(hMcasp,SRCTL3,MCASP_SRCTL_DEFAULT);
 /* Entries for _MCASP_CHANNEL_CNT == 4 end here*/

 #if (_MCASP_CHANNEL_CNT > 4)
    MCASP_RSETH(hMcasp,SRCTL4,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL5,MCASP_SRCTL_DEFAULT);
 #endif /* _MCASP_CHANNEL_CNT == 6 */

 #if (_MCASP_CHANNEL_CNT > 6)
    MCASP_RSETH(hMcasp,SRCTL6,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL7,MCASP_SRCTL_DEFAULT);          
 #endif /* _MCASP_CHANNEL_CNT == 8 */

 #if (_MCASP_CHANNEL_CNT == 16)
    MCASP_RSETH(hMcasp,SRCTL8,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL9,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL10,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL11,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL12,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL13,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL14,MCASP_SRCTL_DEFAULT);          
    MCASP_RSETH(hMcasp,SRCTL15,MCASP_SRCTL_DEFAULT);  
 #endif 
 
    MCASP_RSETH(hMcasp,RSTAT,0x01F7);
    MCASP_RSETH(hMcasp,XSTAT,0x01F7);
    MCASP_RSETH(hMcasp,GBLCTL,MCASP_GBLCTL_DEFAULT);
    IRQ_reset(hMcasp->xmtEventId);
    IRQ_reset(hMcasp->rcvEventId);
  }                    
  IRQ_globalRestore(gie);
  return;              
}                      

/*----------------------------------------------------------------------------*/
void MCASP_resetAll() 
{
  MCASP_reset(INV);
}

/*----------------------------------------------------------------------------*/
MCASP_Handle MCASP_open(int devNum, Uint32 flags) {
                       
  Uint32 gie;          
                       
  MCASP_Handle hMcasp = INV;
                       
  gie = IRQ_globalDisable();
  if (!_MCASP_deviceTable[devNum].allocated) {
    hMcasp = &(_MCASP_deviceTable[devNum]);
    _MCASP_deviceTable[devNum].allocated = TRUE;
                       
    if (hMcasp != INV) {
      if (flags & MCASP_OPEN_RESET) {
        MCASP_reset(hMcasp);
      }                
    }                  
  }
  IRQ_globalRestore(gie);

  return hMcasp;
}
/*----------------------------------------------------------------------------*/
MCASP_Handle MCASP_getHandle(int devNum) {
                       
  Uint32 gie;          
                       
  MCASP_Handle hMcasp = INV;
                       
  gie = IRQ_globalDisable();
  if (_MCASP_deviceTable[devNum].allocated) {
     hMcasp = &(_MCASP_deviceTable[devNum]);
  } 
  
 IRQ_globalRestore(gie);
  
  return hMcasp;
}

/*----------------------------------------------------------------------------*/
void MCASP_close(MCASP_Handle hMcasp) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hMcasp != INV) {
    MCASP_reset(hMcasp);
    hMcasp->allocated = FALSE;
  }
  IRQ_globalRestore(gie);
  return;
}

/*----------------------------------------------------------------------------*/
Uint32 MCASP_getPins(MCASP_Handle hMcasp) {

  return MCASP_RGETH(hMcasp,PDIN);
}

/*----------------------------------------------------------------------------*/
void MCASP_setPins(MCASP_Handle hMcasp, Uint32 pins) {


#if (_MCASP_CHANNEL_CNT == 16) 
  MCASP_RSETH(hMcasp,PDSET, 
	(
       MCASP_FMK(PDSET, AXR0,  pins>>_MCASP_PDSET_AXR0_SHIFT)
      |MCASP_FMK(PDSET, AXR1,  pins>>_MCASP_PDSET_AXR1_SHIFT)                
      |MCASP_FMK(PDSET, AXR2,  pins>>_MCASP_PDSET_AXR2_SHIFT)                
      |MCASP_FMK(PDSET, AXR3,  pins>>_MCASP_PDSET_AXR3_SHIFT)                
      |MCASP_FMK(PDSET, AXR4,  pins>>_MCASP_PDSET_AXR4_SHIFT)                
      |MCASP_FMK(PDSET, AXR5,  pins>>_MCASP_PDSET_AXR5_SHIFT)                
      |MCASP_FMK(PDSET, AXR6,  pins>>_MCASP_PDSET_AXR6_SHIFT)                
      |MCASP_FMK(PDSET, AXR7,  pins>>_MCASP_PDSET_AXR7_SHIFT)                
      |MCASP_FMK(PDSET, AXR8,  pins>>_MCASP_PDSET_AXR8_SHIFT)                
      |MCASP_FMK(PDSET, AXR9,  pins>>_MCASP_PDSET_AXR9_SHIFT)                
      |MCASP_FMK(PDSET, AXR10,  pins>>_MCASP_PDSET_AXR10_SHIFT)             
      |MCASP_FMK(PDSET, AXR11,  pins>>_MCASP_PDSET_AXR11_SHIFT)                
      |MCASP_FMK(PDSET, AXR12,  pins>>_MCASP_PDSET_AXR12_SHIFT)                
      |MCASP_FMK(PDSET, AXR13,  pins>>_MCASP_PDSET_AXR13_SHIFT)                
      |MCASP_FMK(PDSET, AXR14,  pins>>_MCASP_PDSET_AXR14_SHIFT)                
      |MCASP_FMK(PDSET, AXR15,  pins>>_MCASP_PDSET_AXR15_SHIFT)    
      |MCASP_FMK(PDSET, AMUTE,    pins>>_MCASP_PDSET_AMUTE_SHIFT)  
      |MCASP_FMK(PDSET, ACLKX,    pins>>_MCASP_PDSET_ACLKX_SHIFT)                            
      |MCASP_FMK(PDSET, AHCLKX,   pins>>_MCASP_PDSET_AHCLKX_SHIFT)                            
      |MCASP_FMK(PDSET, AFSX,     pins>>_MCASP_PDSET_AFSX_SHIFT)
      |MCASP_FMK(PDSET, ACLKR,    pins>>_MCASP_PDSET_ACLKR_SHIFT)                            
      |MCASP_FMK(PDSET, AHCLKR,   pins>>_MCASP_PDSET_AHCLKR_SHIFT)                            
      |MCASP_FMK(PDSET, AFSR,     pins>>_MCASP_PDSET_AFSR_SHIFT)                                                      
    )
  );
#endif /* _MCASP_CHANNEL_CNT == 16 */
  
#if (_MCASP_CHANNEL_CNT == 8)

MCASP_RSETH(hMcasp,PDSET, 
	(
       MCASP_FMK(PDSET, AXR0,  pins>>_MCASP_PDSET_AXR0_SHIFT)
      |MCASP_FMK(PDSET, AXR1,  pins>>_MCASP_PDSET_AXR1_SHIFT)                
      |MCASP_FMK(PDSET, AXR2,  pins>>_MCASP_PDSET_AXR2_SHIFT)                
      |MCASP_FMK(PDSET, AXR3,  pins>>_MCASP_PDSET_AXR3_SHIFT)                
      |MCASP_FMK(PDSET, AXR4,  pins>>_MCASP_PDSET_AXR4_SHIFT)                
      |MCASP_FMK(PDSET, AXR5,  pins>>_MCASP_PDSET_AXR5_SHIFT)                
      |MCASP_FMK(PDSET, AXR6,  pins>>_MCASP_PDSET_AXR6_SHIFT)                
      |MCASP_FMK(PDSET, AXR7,  pins>>_MCASP_PDSET_AXR7_SHIFT)                
      |MCASP_FMK(PDSET, AMUTE,    pins>>_MCASP_PDSET_AMUTE_SHIFT)  
      |MCASP_FMK(PDSET, ACLKX,    pins>>_MCASP_PDSET_ACLKX_SHIFT)                            
      |MCASP_FMK(PDSET, AHCLKX,   pins>>_MCASP_PDSET_AHCLKX_SHIFT)                            
      |MCASP_FMK(PDSET, AFSX,     pins>>_MCASP_PDSET_AFSX_SHIFT)
      |MCASP_FMK(PDSET, ACLKR,    pins>>_MCASP_PDSET_ACLKR_SHIFT)                            
      |MCASP_FMK(PDSET, AHCLKR,   pins>>_MCASP_PDSET_AHCLKR_SHIFT)                            
      |MCASP_FMK(PDSET, AFSR,     pins>>_MCASP_PDSET_AFSR_SHIFT)                                                      
    )
  );
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)

MCASP_RSETH(hMcasp,PDSET, 
     (
       MCASP_FMK(PDSET, AXR0,  pins>>_MCASP_PDSET_AXR0_SHIFT)
      |MCASP_FMK(PDSET, AXR1,  pins>>_MCASP_PDSET_AXR1_SHIFT)
      |MCASP_FMK(PDSET, AXR2,  pins>>_MCASP_PDSET_AXR2_SHIFT)
      |MCASP_FMK(PDSET, AXR3,  pins>>_MCASP_PDSET_AXR3_SHIFT)
      |MCASP_FMK(PDSET, AXR4,  pins>>_MCASP_PDSET_AXR4_SHIFT)
      |MCASP_FMK(PDSET, AXR5,  pins>>_MCASP_PDSET_AXR5_SHIFT)
      |MCASP_FMK(PDSET, AMUTE,    pins>>_MCASP_PDSET_AMUTE_SHIFT)
      |MCASP_FMK(PDSET, ACLKX,    pins>>_MCASP_PDSET_ACLKX_SHIFT)
      |MCASP_FMK(PDSET, AHCLKX,   pins>>_MCASP_PDSET_AHCLKX_SHIFT)
      |MCASP_FMK(PDSET, AFSX,     pins>>_MCASP_PDSET_AFSX_SHIFT) 
      |MCASP_FMK(PDSET, ACLKR,    pins>>_MCASP_PDSET_ACLKR_SHIFT)
      |MCASP_FMK(PDSET, AHCLKR,   pins>>_MCASP_PDSET_AHCLKR_SHIFT)
      |MCASP_FMK(PDSET, AFSR,     pins>>_MCASP_PDSET_AFSR_SHIFT)
    )
  );
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)

MCASP_RSETH(hMcasp,PDSET, 
     (
       MCASP_FMK(PDSET, AXR0,  pins>>_MCASP_PDSET_AXR0_SHIFT)
      |MCASP_FMK(PDSET, AXR1,  pins>>_MCASP_PDSET_AXR1_SHIFT)
      |MCASP_FMK(PDSET, AXR2,  pins>>_MCASP_PDSET_AXR2_SHIFT)
      |MCASP_FMK(PDSET, AXR3,  pins>>_MCASP_PDSET_AXR3_SHIFT)
      |MCASP_FMK(PDSET, AMUTE,    pins>>_MCASP_PDSET_AMUTE_SHIFT)
      |MCASP_FMK(PDSET, ACLKX,    pins>>_MCASP_PDSET_ACLKX_SHIFT)
      |MCASP_FMK(PDSET, AHCLKX,   pins>>_MCASP_PDSET_AHCLKX_SHIFT)
      |MCASP_FMK(PDSET, AFSX,     pins>>_MCASP_PDSET_AFSX_SHIFT) 
      |MCASP_FMK(PDSET, ACLKR,    pins>>_MCASP_PDSET_ACLKR_SHIFT)
      |MCASP_FMK(PDSET, AHCLKR,   pins>>_MCASP_PDSET_AHCLKR_SHIFT)
      |MCASP_FMK(PDSET, AFSR,     pins>>_MCASP_PDSET_AFSR_SHIFT)
    )
  );
#endif /* _MCASP_CHANNEL_CNT == 4 */

}

/*----------------------------------------------------------------------------*/
void MCASP_clearPins(MCASP_Handle hMcasp, Uint32 pins) {


#if (_MCASP_CHANNEL_CNT == 16)
  MCASP_RSETH(hMcasp,PDCLR, 
	(
       MCASP_FMK(PDCLR, AXR0,  pins>>_MCASP_PDCLR_AXR0_SHIFT)
      |MCASP_FMK(PDCLR, AXR1,  pins>>_MCASP_PDCLR_AXR1_SHIFT)                
      |MCASP_FMK(PDCLR, AXR2,  pins>>_MCASP_PDCLR_AXR2_SHIFT)                
      |MCASP_FMK(PDCLR, AXR3,  pins>>_MCASP_PDCLR_AXR3_SHIFT)                
      |MCASP_FMK(PDCLR, AXR4,  pins>>_MCASP_PDCLR_AXR4_SHIFT)                
      |MCASP_FMK(PDCLR, AXR5,  pins>>_MCASP_PDCLR_AXR5_SHIFT)                
      |MCASP_FMK(PDCLR, AXR6,  pins>>_MCASP_PDCLR_AXR6_SHIFT)                
      |MCASP_FMK(PDCLR, AXR7,  pins>>_MCASP_PDCLR_AXR7_SHIFT)                
      |MCASP_FMK(PDCLR, AXR8,  pins>>_MCASP_PDCLR_AXR8_SHIFT)                
      |MCASP_FMK(PDCLR, AXR9,  pins>>_MCASP_PDCLR_AXR9_SHIFT)                
      |MCASP_FMK(PDCLR, AXR10,  pins>>_MCASP_PDCLR_AXR10_SHIFT)             
      |MCASP_FMK(PDCLR, AXR11,  pins>>_MCASP_PDCLR_AXR11_SHIFT)                
      |MCASP_FMK(PDCLR, AXR12,  pins>>_MCASP_PDCLR_AXR12_SHIFT)                
      |MCASP_FMK(PDCLR, AXR13,  pins>>_MCASP_PDCLR_AXR13_SHIFT)                
      |MCASP_FMK(PDCLR, AXR14,  pins>>_MCASP_PDCLR_AXR14_SHIFT)                
      |MCASP_FMK(PDCLR, AXR15,  pins>>_MCASP_PDCLR_AXR15_SHIFT)   
      |MCASP_FMK(PDCLR, AMUTE,    pins>>_MCASP_PDCLR_AMUTE_SHIFT)  
      |MCASP_FMK(PDCLR, ACLKX,    pins>>_MCASP_PDCLR_ACLKX_SHIFT)                            
      |MCASP_FMK(PDCLR, AHCLKX,   pins>>_MCASP_PDCLR_AHCLKX_SHIFT)                            
      |MCASP_FMK(PDCLR, AFSX,     pins>>_MCASP_PDCLR_AFSX_SHIFT)
      |MCASP_FMK(PDCLR, ACLKR,    pins>>_MCASP_PDCLR_ACLKR_SHIFT)                            
      |MCASP_FMK(PDCLR, AHCLKR,   pins>>_MCASP_PDCLR_AHCLKR_SHIFT)                            
      |MCASP_FMK(PDCLR, AFSR,     pins>>_MCASP_PDCLR_AFSR_SHIFT)                                                                   
    )
  );
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)

  MCASP_RSETH(hMcasp,PDCLR, 
	(
       MCASP_FMK(PDCLR, AXR0,  pins>>_MCASP_PDCLR_AXR0_SHIFT)
      |MCASP_FMK(PDCLR, AXR1,  pins>>_MCASP_PDCLR_AXR1_SHIFT)                
      |MCASP_FMK(PDCLR, AXR2,  pins>>_MCASP_PDCLR_AXR2_SHIFT)                
      |MCASP_FMK(PDCLR, AXR3,  pins>>_MCASP_PDCLR_AXR3_SHIFT)                
      |MCASP_FMK(PDCLR, AXR4,  pins>>_MCASP_PDCLR_AXR4_SHIFT)                
      |MCASP_FMK(PDCLR, AXR5,  pins>>_MCASP_PDCLR_AXR5_SHIFT)                
      |MCASP_FMK(PDCLR, AXR6,  pins>>_MCASP_PDCLR_AXR6_SHIFT)                
      |MCASP_FMK(PDCLR, AXR7,  pins>>_MCASP_PDCLR_AXR7_SHIFT)                
      |MCASP_FMK(PDCLR, AMUTE,    pins>>_MCASP_PDCLR_AMUTE_SHIFT)  
      |MCASP_FMK(PDCLR, ACLKX,    pins>>_MCASP_PDCLR_ACLKX_SHIFT)                            
      |MCASP_FMK(PDCLR, AHCLKX,   pins>>_MCASP_PDCLR_AHCLKX_SHIFT)                            
      |MCASP_FMK(PDCLR, AFSX,     pins>>_MCASP_PDCLR_AFSX_SHIFT)
      |MCASP_FMK(PDCLR, ACLKR,    pins>>_MCASP_PDCLR_ACLKR_SHIFT)                            
      |MCASP_FMK(PDCLR, AHCLKR,   pins>>_MCASP_PDCLR_AHCLKR_SHIFT)                            
      |MCASP_FMK(PDCLR, AFSR,     pins>>_MCASP_PDCLR_AFSR_SHIFT)                                                                   
    )
  );
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
  MCASP_RSETH(hMcasp,PDCLR, 
     (
       MCASP_FMK(PDCLR, AXR0,  pins>>_MCASP_PDCLR_AXR0_SHIFT)
      |MCASP_FMK(PDCLR, AXR1,  pins>>_MCASP_PDCLR_AXR1_SHIFT)                
      |MCASP_FMK(PDCLR, AXR2,  pins>>_MCASP_PDCLR_AXR2_SHIFT)                
      |MCASP_FMK(PDCLR, AXR3,  pins>>_MCASP_PDCLR_AXR3_SHIFT)                
      |MCASP_FMK(PDCLR, AXR4,  pins>>_MCASP_PDCLR_AXR4_SHIFT)                
      |MCASP_FMK(PDCLR, AXR5,  pins>>_MCASP_PDCLR_AXR5_SHIFT)                
      |MCASP_FMK(PDCLR, AMUTE,    pins>>_MCASP_PDCLR_AMUTE_SHIFT)  
      |MCASP_FMK(PDCLR, ACLKX,    pins>>_MCASP_PDCLR_ACLKX_SHIFT)                            
      |MCASP_FMK(PDCLR, AHCLKX,   pins>>_MCASP_PDCLR_AHCLKX_SHIFT)                            
      |MCASP_FMK(PDCLR, AFSX,     pins>>_MCASP_PDCLR_AFSX_SHIFT)
      |MCASP_FMK(PDCLR, ACLKR,    pins>>_MCASP_PDCLR_ACLKR_SHIFT)                            
      |MCASP_FMK(PDCLR, AHCLKR,   pins>>_MCASP_PDCLR_AHCLKR_SHIFT)                            
      |MCASP_FMK(PDCLR, AFSR,     pins>>_MCASP_PDCLR_AFSR_SHIFT)                                                                   
    )
  );
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
  MCASP_RSETH(hMcasp,PDCLR, 
     (
       MCASP_FMK(PDCLR, AXR0,  pins>>_MCASP_PDCLR_AXR0_SHIFT)
      |MCASP_FMK(PDCLR, AXR1,  pins>>_MCASP_PDCLR_AXR1_SHIFT)                
      |MCASP_FMK(PDCLR, AXR2,  pins>>_MCASP_PDCLR_AXR2_SHIFT)                
      |MCASP_FMK(PDCLR, AXR3,  pins>>_MCASP_PDCLR_AXR3_SHIFT)                
      |MCASP_FMK(PDCLR, AMUTE,    pins>>_MCASP_PDCLR_AMUTE_SHIFT)  
      |MCASP_FMK(PDCLR, ACLKX,    pins>>_MCASP_PDCLR_ACLKX_SHIFT)                            
      |MCASP_FMK(PDCLR, AHCLKX,   pins>>_MCASP_PDCLR_AHCLKX_SHIFT)                            
      |MCASP_FMK(PDCLR, AFSX,     pins>>_MCASP_PDCLR_AFSX_SHIFT)
      |MCASP_FMK(PDCLR, ACLKR,    pins>>_MCASP_PDCLR_ACLKR_SHIFT)                            
      |MCASP_FMK(PDCLR, AHCLKR,   pins>>_MCASP_PDCLR_AHCLKR_SHIFT)                            
      |MCASP_FMK(PDCLR, AFSR,     pins>>_MCASP_PDCLR_AFSR_SHIFT)                                                                   
    )
  );
#endif /* _MCASP_CHANNEL_CNT == 4 */


}
/*----------------------------------------------------------------------------*/
void MCASP_enableClk(MCASP_Handle hMcasp, Uint32 direction)
{
	Uint32 rsrgr = 0;
	Uint32 xsrgr = 0;
	
	if (direction & MCASP_RCV)
	{
	  rsrgr = (MCASP_FMKS(GBLCTL,RCLKRST,ACTIVE));
	}
	if (direction & MCASP_XMT)
	{
	  xsrgr = (MCASP_FMKS(GBLCTL,XCLKRST,ACTIVE));
	}	  	
	if (direction){
	  MCASP_RSETH(hMcasp,GBLCTL,(MCASP_RGETH(hMcasp,GBLCTL)|rsrgr|xsrgr));
	  }
}
/*----------------------------------------------------------------------------*/
void MCASP_enableHclk(MCASP_Handle hMcasp, Uint32 direction)
{
	Uint32 rsrgr = 0;
	Uint32 xsrgr = 0;
	
	if (direction & MCASP_RCV)
	{
		rsrgr = ( MCASP_FMKS(GBLCTL,RHCLKRST,ACTIVE)) ;
      }

	if (direction & MCASP_XMT)
	{
		xsrgr = (MCASP_FMKS(GBLCTL,XHCLKRST,ACTIVE) );
	}
	
	if (direction){
	  MCASP_RSETH(hMcasp,GBLCTL,(MCASP_RGETH(hMcasp,GBLCTL)|rsrgr|xsrgr));
	 }
}


/*----------------------------------------------------------------------------*/
void MCASP_enableSers(MCASP_Handle hMcasp, Uint32 direction)
{
	Uint32 rsers = 0;
	Uint32 xsers = 0;
	
	if (direction & MCASP_RCV)
	{
		rsers = (MCASP_FMKS(GBLCTL,RSRCLR,ACTIVE));
	}

	if (direction & MCASP_XMT)
	{
		xsers = (MCASP_FMKS(GBLCTL,XSRCLR,ACTIVE));
	}
	
	if (direction)
	  MCASP_RSETH(hMcasp,GBLCTL,(MCASP_RGETH(hMcasp,GBLCTL)|rsers| xsers));
	  
}

/*----------------------------------------------------------------------------*/
void MCASP_enableSm(MCASP_Handle hMcasp, Uint32 direction)
{
	Uint32 rsmchn = 0;
	Uint32 xsmchn = 0;
	
	if (direction & MCASP_RCV)
	{
		rsmchn = (MCASP_FMKS(GBLCTL,RSMRST,ACTIVE));
	}

	if (direction & MCASP_XMT)
	{
		xsmchn = (MCASP_FMKS(GBLCTL,XSMRST,ACTIVE));
	}
	
	if (direction)
	  MCASP_RSETH(hMcasp,GBLCTL,(MCASP_RGETH(hMcasp,GBLCTL)|rsmchn|xsmchn));
}

/*----------------------------------------------------------------------------*/
void MCASP_enableFsync(MCASP_Handle hMcasp, Uint32 direction)
{
	Uint32 rfsync = 0;
	Uint32 xfsync = 0;
	
	if (direction & MCASP_RCV)
	{
		rfsync = (MCASP_FMKS(GBLCTL,RFRST,ACTIVE));
	}

	if (direction & MCASP_XMT)
	{
		xfsync = (MCASP_FMKS(GBLCTL,XFRST,ACTIVE));
	}
	
	if (direction)
	  MCASP_RSETH(hMcasp,GBLCTL,(MCASP_RGETH(hMcasp,GBLCTL)|rfsync|xfsync));
}

/*----------------------------------------------------------------------------*/
void MCASP_setupClk(MCASP_Handle hMcasp,MCASP_SetupClk *setupclk, 
                    Uint32 direction) 
{
 Uint32 gie;
 
 gie = IRQ_globalDisable();
    if (direction & MCASP_XMT) 
    {
        MCASP_RSETH(hMcasp,ACLKXCTL,
                    MCASP_ACLKXCTL_RMK(setupclk->xclkpol,
                                       setupclk->syncmode, 
                                       setupclk->xclksrc, 
                                       (setupclk->xclkdiv)-1));
}
/* asynchronous mode */
    if (direction & MCASP_RCV) 
    {
        MCASP_RSETH(hMcasp,ACLKRCTL,
                    MCASP_ACLKRCTL_RMK(setupclk->rclkpol, 
                                       setupclk->rclksrc, 
                                       (setupclk->rclkdiv)-1));
 }
 IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void MCASP_setupHclk(MCASP_Handle hMcasp,MCASP_SetupHclk *setuphclk, 
                     Uint32 direction) 
{
 
 Uint32 gie;
 
 gie = IRQ_globalDisable();
    if (direction & MCASP_XMT) 
    {
        MCASP_RSETH(hMcasp,AHCLKXCTL,
                    MCASP_AHCLKXCTL_RMK(setuphclk->xhclksrc,
                                        setuphclk->xhclkpol, 
                                        (setuphclk->xhclkdiv)-1));
 }
    if (direction & MCASP_RCV) 
    {
        MCASP_RSETH(hMcasp,AHCLKRCTL,
                    MCASP_AHCLKRCTL_RMK(setuphclk->rhclksrc,
                                        setuphclk->rhclkpol, 
                                       (setuphclk->rhclkdiv)-1));
 }
 
 IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void MCASP_setupFsync(MCASP_Handle hMcasp,MCASP_SetupFsync *setupfsync,
                      Uint32 direction) 
{
 Uint32 xslotsize,rslotsize,gie;
 
 gie = IRQ_globalDisable();
 
 if (direction & MCASP_XMT) {
 if (setupfsync->xmode == MCASP_MODE_BURST) { 
     xslotsize  =    0;
 } else {
     xslotsize  =   setupfsync->xslotsize;
 }
 
        MCASP_RSETH(hMcasp,AFSXCTL,
                    MCASP_AFSXCTL_RMK(xslotsize,setupfsync->fxwid,
                                      setupfsync->xfssrc,setupfsync-> xfspol));
}
if (direction & MCASP_RCV) {
  if (setupfsync->rmode == MCASP_MODE_BURST) { 
     rslotsize  =    0;
  } else {
     rslotsize  =   setupfsync->rslotsize;
  }
        MCASP_RSETH(hMcasp,AFSRCTL,
                    MCASP_AFSRCTL_RMK(rslotsize,setupfsync->frwid, 
                                      setupfsync->rfssrc,setupfsync-> rfspol));
 }
 IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void MCASP_setupFormat(MCASP_Handle hMcasp,MCASP_SetupFormat *setupformat, 
                       Uint32 direction) 
{
 Uint32 gie,rrot,xrot;
 Uint32 xslotval,rslotval;
 Uint32 xrotval,rrotval;
 
 gie = IRQ_globalDisable();


/*** Transmitter format **************************************************/
if (direction & MCASP_XMT) {

 if (setupformat->xdsprep == MCASP_DSP_Q31) {
  if (    setupformat->xorder == MCASP_FORMAT_MSB) { 
       if (setupformat->xalign == MCASP_FORMAT_LEFT  ) {  
                  xrot = 0;                         /* 0 */ 
          } else { /* right aligned - (SLOT - WORD) */
                  xrot = (setupformat->xslotsize - setupformat->xwordsize);
          }
     }else { /* LSB first */                
          if (setupformat->xalign == MCASP_FORMAT_LEFT  ) {  
                  xrot =(32 - setupformat->xwordsize); /* 32-WORD */
          } else { /* right aligned */
                  xrot = (32-setupformat->xslotsize); /* 32-SLOT */
          }
     }     
  }else  { /* DSP Integer Representation */    
     if (  setupformat->xorder == MCASP_FORMAT_MSB) { 
       if (setupformat->xalign == MCASP_FORMAT_LEFT  ) {  
                  xrot = (setupformat->xwordsize); /* WORD */ 
          } else { /* right aligned  */
                  xrot = (setupformat->xslotsize); /* SLOT */ 
          }
     }else { /* LSB first */                
          if (setupformat->xalign == MCASP_FORMAT_LEFT  ) {  
                  xrot = 0; 
          } else { /* right aligned (32-(slot-word))%32 */
                  xrot = (32 -(setupformat->xslotsize-setupformat->xwordsize))%32; 
          }
     }
  }       
/* Translation of rslotsize/xslotsize              *\
   MCASP_XFMT_XSSZ_8BITS            	0x00000003u
   MCASP_XFMT_XSSZ_12BITS            	0x00000005u
   MCASP_XFMT_XSSZ_16BITS            	0x00000007u
   MCASP_XFMT_XSSZ_20BITS            	0x00000009u
   MCASP_XFMT_XSSZ_24BITS            	0x0000000Bu
   MCASP_XFMT_XSSZ_28BITS            	0x0000000Du
\* MCASP_XFMT_XSSZ_32BITS                 0x0000000Fu */
   xslotval =((setupformat->xslotsize-8)/2) + 3;
      
           
 /* MCASP_XFMT_XROT_4BITS            	0x00000001u*\
    MCASP_XFMT_XROT_8BITS            	0x00000002u
    MCASP_XFMT_XROT_12BITS            	0x00000003u
    MCASP_XFMT_XROT_16BITS            	0x00000004u
    MCASP_XFMT_XROT_20BITS            	0x00000005u
    MCASP_XFMT_XROT_24BITS            	0x00000006u
 \* MCASP_XFMT_XROT_28BITS            	0x00000007u*/
   xrotval=((xrot-4)/4)+1; 

 MCASP_RSETH(hMcasp,XFMT,
  MCASP_FMK(XFMT,XDATDLY,setupformat->xdelay) |
  MCASP_FMK(XFMT,XRVRS,setupformat->xorder) |
  MCASP_FMK(XFMT,XPAD,setupformat->xpad) |
  MCASP_FMK(XFMT,XPBIT,setupformat->xpbit) |
  MCASP_FMK(XFMT,XSSZ,xslotval) |
  MCASP_FMK(XFMT,XBUSEL,setupformat->xbusel) |
  MCASP_FMK(XFMT,XROT,xrotval)
  );
 } /* end of transmitter */
 
 
  /****** Receiver format *************************************************/
 if (direction & MCASP_RCV) {
     
 if (setupformat->rdsprep == MCASP_DSP_Q31) {
  if (    setupformat->rorder == MCASP_FORMAT_MSB) { 
       if (setupformat->ralign == MCASP_FORMAT_LEFT  ) {  
                rrot = (setupformat->rslotsize); /* SLOT */ 
          } else { /* right aligned - (WORD) */
                rrot = setupformat->rwordsize;
          }
     }else { /* LSB first */                
          if (setupformat->xalign == MCASP_FORMAT_LEFT  ) {  
                /* (32-(slot-word))%32 */
                rrot = (32 -(setupformat->rslotsize-setupformat->rwordsize))%32; 
     
          } else { /* right aligned */
                rrot = 0;
          }
     }     
  }else  { /* DSP Integer Representation */    
     if (  setupformat->rorder == MCASP_FORMAT_MSB) { 
       if (setupformat->ralign == MCASP_FORMAT_LEFT  ) {  
                  rrot = (setupformat->rslotsize-setupformat->rwordsize); 
     
          } else { /* right aligned  */
                  rrot = 0 ;
          }
     }else { /* LSB first */                
          if (setupformat->ralign == MCASP_FORMAT_LEFT  ) {  
                  rrot = (32 -setupformat->rslotsize);
          } else { /* right aligned (32-(slot-word))%32 */
                  rrot = (32 -setupformat->rwordsize); 
          }
     }
  }               
  
/* Translation of rslotsize/xslotsize              *\
   MCASP_XFMT_XSSZ_8BITS            	0x00000003u
   MCASP_XFMT_XSSZ_12BITS            	0x00000005u
   MCASP_XFMT_XSSZ_16BITS            	0x00000007u
   MCASP_XFMT_XSSZ_20BITS            	0x00000009u
   MCASP_XFMT_XSSZ_24BITS            	0x0000000Bu
   MCASP_XFMT_XSSZ_28BITS            	0x0000000Du
\* MCASP_XFMT_XSSZ_32BITS               0x0000000Fu */
  
  rslotval =((setupformat->rslotsize-8)/2) + 3; 
  
  /* MCASP_XFMT_XROT_4BITS            	0x00000001u*\
   MCASP_XFMT_XROT_8BITS            	0x00000002u
   MCASP_XFMT_XROT_12BITS            	0x00000003u
   MCASP_XFMT_XROT_16BITS            	0x00000004u
   MCASP_XFMT_XROT_20BITS            	0x00000005u
   MCASP_XFMT_XROT_24BITS            	0x00000006u
\* MCASP_XFMT_XROT_28BITS            	0x00000007u*/

  rrotval=((rrot-4)/4)+1;


  MCASP_RSETH(hMcasp,RFMT,
  MCASP_FMK(RFMT,RDATDLY,setupformat->rdelay) |
  MCASP_FMK(RFMT,RRVRS,setupformat->rorder) |
  MCASP_FMK(RFMT,RPAD,setupformat->rpad) |
  MCASP_FMK(RFMT,RPBIT,setupformat->rpbit) |
  MCASP_FMK(RFMT,RSSZ,rslotval) |
  MCASP_FMK(RFMT,RBUSEL,setupformat->rbusel) |
  MCASP_FMK(RFMT,RROT,rrotval)
  );
  
} /* end of rcv format */

 IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void MCASP_configDit(MCASP_Handle hMcasp,MCASP_Dsprep dsprep, Uint32 datalen){
 Uint32 maskval;

 maskval=datalen-16;

/* required configuration */
/*****************************************\
  * XMOD  =   384 tdm slot                
  * FSWID= 0 (bit duration 1 bit) 
  * FSXM=  1 (internal)
  * FSXP = 0 (polarity rising edge)
 \****************************************/
 
  MCASP_RSETH(hMcasp,AFSXCTL,MCASP_AFSXCTL_RMK(0x180u,0,1,0));
  MCASP_FSETH(hMcasp,ACLKXCTL,ASYNC,1);
  
/* Transmit DIT and Receiver DIR and TDM mode */
  MCASP_RSETH(hMcasp,XTDM,0xFFFFFFFF);
  //MCASP_RSETH(hMcasp,RTDM,MCASP_FMKS(RTDM,RTDMS0,ACTIVE)| MCASP_FMKS(RTDM,RTDMS1,ACTIVE));

/*  Only 24 bits data - XFORMAT unit : ROT / ORD / MASK */
  if ( dsprep == 0) {
 /* set data format 0x000000F0 */
  MCASP_RSETH(hMcasp,XFMT,\
         MCASP_FMKS(XFMT,XRVRS,LSBFIRST) |
         MCASP_FMKS(XFMT,XPAD,ZERO) |
         MCASP_FMKS(XFMT,XROT,NONE) | 
         MCASP_FMKS(XFMT,XSSZ,32BITS) \
           );

 
 /* set mask */
  MCASP_RSETH(hMcasp,XMASK,_MCASP_xmaskIntTable[maskval]);

  } else  {  /* Q31 data */
   /* set data format 0x000000F3*/
    MCASP_RSETH(hMcasp,XFMT,\
         MCASP_FMKS(XFMT,XRVRS,LSBFIRST) |
         MCASP_FMKS(XFMT,XPAD,ZERO) |
         MCASP_FMKS(XFMT,XROT,8BITS) | 
         MCASP_FMKS(XFMT,XSSZ,32BITS) \
        );
    /* set mask */
 
   MCASP_RSETH(hMcasp,XMASK,_MCASP_xmaskQTable[maskval]);
  }
}

#endif /* MCASP_SUPPORT */
/******************************************************************************\
* End of csl_mcasp.c
\******************************************************************************/



csl_mcbsp.c/    1092218723  0     0     0       7626      `
/******************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mcbsp.c
* DATE CREATED.. 06/11/1999 
* LAST MODIFIED. 09/07/2001 
*                    - MCBSP_start() added
\******************************************************************************/
#define _MCBSP_MOD_

#include <csl_mcbsp.h>


#if (MCBSP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/
#define DEVICE_ENTRY(devNum) { \
  FALSE, \
  IRQ_EVT_XINT##devNum##, \
  IRQ_EVT_RINT##devNum##, \
  (volatile Uint32*)_MCBSP_BASE_PORT##devNum##, \
  _MCBSP_DRR##devNum##_ADDR, \
  _MCBSP_DXR##devNum##_ADDR \
}

#define PIN_MASK (Uint32)(\
  _MCBSP_PCR_CLKXP_MASK| \
  _MCBSP_PCR_FSXP_MASK| \
  _MCBSP_PCR_DXSTAT_MASK| \
  _MCBSP_PCR_CLKRP_MASK| \
  _MCBSP_PCR_FSRP_MASK| \
  _MCBSP_PCR_DRSTAT_MASK| \
  _MCBSP_PCR_CLKSSTAT_MASK \
)


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static MCBSP_Obj _MCBSP_deviceTable[_MCBSP_PORT_CNT] = {
  DEVICE_ENTRY(0),
  DEVICE_ENTRY(1)
  #if (_MCBSP_PORT_CNT==3)
    ,DEVICE_ENTRY(2)
  #endif
};


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/
/* predefined handles for legacy - should not be used */
MCBSP_Handle _MCBSP_hDev0=(MCBSP_Handle)(&(_MCBSP_deviceTable[0]));
MCBSP_Handle _MCBSP_hDev1=(MCBSP_Handle)(&(_MCBSP_deviceTable[1]));
#if (_MCBSP_PORT_CNT == 3)
  MCBSP_Handle _MCBSP_hDev2=(MCBSP_Handle)(&(_MCBSP_deviceTable[2]));
#endif



/******************************************************************************\
* global function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
void MCBSP_reset(MCBSP_Handle hMcbsp) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hMcbsp == INV) {
    MCBSP_reset((MCBSP_Handle)(&(_MCBSP_deviceTable[0])));
    MCBSP_reset((MCBSP_Handle)(&(_MCBSP_deviceTable[1])));
    #if (_MCBSP_PORT_CNT==3)
      MCBSP_reset((MCBSP_Handle)(&(_MCBSP_deviceTable[2])));
    #endif
  } else {
    MCBSP_RSETH(hMcbsp,SPCR,MCBSP_SPCR_DEFAULT);
    MCBSP_RSETH(hMcbsp,RCR, MCBSP_RCR_DEFAULT);
    MCBSP_RSETH(hMcbsp,XCR, MCBSP_XCR_DEFAULT);
    MCBSP_RSETH(hMcbsp,SRGR,MCBSP_SRGR_DEFAULT);
    MCBSP_RSETH(hMcbsp,MCR, MCBSP_MCR_DEFAULT);
    #if (!C64_SUPPORT) /* ?? added C64_SUPPORT */
    MCBSP_RSETH(hMcbsp,RCER,MCBSP_RCER_DEFAULT);
    MCBSP_RSETH(hMcbsp,XCER,MCBSP_XCER_DEFAULT);
    #else /*if(C64_SUPPORT)*/
    MCBSP_RSETH(hMcbsp,RCERE0,MCBSP_RCERE0_DEFAULT);
    MCBSP_RSETH(hMcbsp,RCERE1,MCBSP_RCERE1_DEFAULT);
    MCBSP_RSETH(hMcbsp,RCERE2,MCBSP_RCERE2_DEFAULT);
    MCBSP_RSETH(hMcbsp,RCERE3,MCBSP_RCERE3_DEFAULT);
    MCBSP_RSETH(hMcbsp,XCERE0,MCBSP_XCERE0_DEFAULT);
    MCBSP_RSETH(hMcbsp,XCERE1,MCBSP_XCERE1_DEFAULT);
    MCBSP_RSETH(hMcbsp,XCERE2,MCBSP_XCERE2_DEFAULT);
    MCBSP_RSETH(hMcbsp,XCERE3,MCBSP_XCERE3_DEFAULT);
    #endif
    MCBSP_RSETH(hMcbsp,PCR, MCBSP_PCR_DEFAULT);
    IRQ_reset(hMcbsp->xmtEventId);
    IRQ_reset(hMcbsp->rcvEventId);
  }
  IRQ_globalRestore(gie);
  return;
}

/*----------------------------------------------------------------------------*/
void MCBSP_resetAll() {

  MCBSP_reset(INV);
}

/*----------------------------------------------------------------------------*/
MCBSP_Handle MCBSP_open(int devNum, Uint32 flags) {

  Uint32 gie;

  MCBSP_Handle hMcbsp = INV;

  gie = IRQ_globalDisable();
  if (!_MCBSP_deviceTable[devNum].allocated) {
    hMcbsp = &(_MCBSP_deviceTable[devNum]);
    _MCBSP_deviceTable[devNum].allocated = TRUE;

    if (hMcbsp != INV) {
      if (flags&MCBSP_OPEN_RESET) {
        MCBSP_reset(hMcbsp);
      }
    }
  }
  IRQ_globalRestore(gie);

  return hMcbsp;
}

/*----------------------------------------------------------------------------*/
void MCBSP_close(MCBSP_Handle hMcbsp) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hMcbsp != INV) {
    MCBSP_reset(hMcbsp);
    hMcbsp->allocated = FALSE;
  }
  IRQ_globalRestore(gie);
  return;
}

/*----------------------------------------------------------------------------*/
void MCBSP_start(MCBSP_Handle hMcbsp, Uint32 startMask, Uint32 sampleratedelay) {

  /* compiler should not optimize delay loop after setting GRST under -o3 switch */
  volatile count = sampleratedelay;
  

  if (startMask & MCBSP_SRGR_START) {
    MCBSP_FSETSH(hMcbsp,SPCR,GRST,NO);
    while(count > 0) {
        --count;
    }
  }

  if (startMask & MCBSP_RCV_START) {
    MCBSP_FSETSH(hMcbsp,SPCR,RRST,NO);
  }
  
  if (startMask & MCBSP_XMIT_START) {
    MCBSP_FSETSH(hMcbsp,SPCR,XRST,NO);
  }

  if (startMask & MCBSP_SRGR_FRAMESYNC) {
     MCBSP_FSETSH(hMcbsp,SPCR,FRST,NO);
  }
  
}


/*----------------------------------------------------------------------------*/

Uint32 MCBSP_getPins(MCBSP_Handle hMcbsp) {

  return (MCBSP_RGETH(hMcbsp,PCR)& PIN_MASK);
}

/*----------------------------------------------------------------------------*/
void MCBSP_setPins(MCBSP_Handle hMcbsp, Uint32 pins) {

  MCBSP_RSETH(hMcbsp,PCR, 
    (MCBSP_RGETH(hMcbsp,PCR)&~PIN_MASK)
    |(
       MCBSP_FMK(PCR, CLKXP,    pins>>_MCBSP_PCR_CLKXP_SHIFT)
      |MCBSP_FMK(PCR, FSXP,     pins>>_MCBSP_PCR_FSXP_SHIFT)
      |MCBSP_FMK(PCR, DXSTAT,   pins>>_MCBSP_PCR_DXSTAT_SHIFT)
      |MCBSP_FMK(PCR, CLKRP,    pins>>_MCBSP_PCR_CLKRP_SHIFT)
      |MCBSP_FMK(PCR, FSRP,     pins>>_MCBSP_PCR_FSRP_SHIFT)
      |MCBSP_FMK(PCR, DRSTAT,   pins>>_MCBSP_PCR_DRSTAT_SHIFT)
      |MCBSP_FMK(PCR, CLKSSTAT, pins>>_MCBSP_PCR_CLKSSTAT_SHIFT)
    )
  );
}

/*----------------------------------------------------------------------------*/


#endif /* MCBSP_SUPPORT */
/******************************************************************************\
* End of csl_mcbsp.c
\******************************************************************************/

csl_mdio.c/     1057236663  0     0     0       22652     `
/*****************************************************************************\
*           Copyright (C) 1999-2003 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mdio.c
* DATE CREATED.. 02/08/2002
* LAST MODIFIED. 05/09/2003
*------------------------------------------------------------------------------
* NOTE:
*   When used in an multitasking environment, no MDIO function may be
*   called while another MDIO function is operating on the same device
*   handle in another thread. It is the responsibility of the application
*   to assure adherence to this restriction.
*
* ALSO NOTE:
*   When using the CSL EMAC module, the EMAC module will make use of this
*   MDIO module. It is not necessary for the application to call any MDIO
*   functions directly when the CSL EMAC module is in use.
*
\******************************************************************************/

/* Include the MDIO file from CSL */
#include <csl_mdiohal.h>
#include <csl_mdio.h>

#if (MDIO_SUPPORT)
/*
 * Standard defines/assumptions for MDIO interface
 */
#define VBUSCLK     150     /* VBUS Clock Rate in MHz (1-255) */

/*-----------------------------------------------------------------------*\
* PHY Control Registers
*
* Used by MDIO to configure a MII compliant PHY
\*-----------------------------------------------------------------------*/
#define PHYREG_CONTROL              0
#define PHYREG_CONTROL_RESET        (1<<15)
#define PHYREG_CONTROL_LOOPBACK     (1<<14)
#define PHYREG_CONTROL_SPEED100     (1<<13)
#define PHYREG_CONTROL_AUTONEGEN    (1<<12)
#define PHYREG_CONTROL_POWERDOWN    (1<<11)
#define PHYREG_CONTROL_ISOLATE      (1<<10)
#define PHYREG_CONTROL_AUTORESTART  (1<<9)
#define PHYREG_CONTROL_DUPLEXFULL   (1<<8)

#define PHYREG_STATUS               1
#define PHYREG_STATUS_FD100         (1<<14)
#define PHYREG_STATUS_HD100         (1<<13)
#define PHYREG_STATUS_FD10          (1<<12)
#define PHYREG_STATUS_HD10          (1<<11)
#define PHYREG_STATUS_NOPREAMBLE    (1<<6)
#define PHYREG_STATUS_AUTOCOMPLETE  (1<<5)
#define PHYREG_STATUS_REMOTEFAULT   (1<<4)
#define PHYREG_STATUS_AUTOCAPABLE   (1<<3)
#define PHYREG_STATUS_LINKSTATUS    (1<<2)
#define PHYREG_STATUS_JABBER        (1<<1)
#define PHYREG_STATUS_EXTENDED      (1<<0)

#define PHYREG_ID1                  2

#define PHYREG_ID2                  3

#define PHYREG_ADVERTISE            4
#define PHYREG_ADVERTISE_NEXTPAGE   (1<<15)
#define PHYREG_ADVERTISE_ACK        (1<<14)
#define PHYREG_ADVERTISE_FAULT      (1<<13)
#define PHYREG_ADVERTISE_PAUSE      (1<<10)
#define PHYREG_ADVERTISE_FD100      (1<<8)
#define PHYREG_ADVERTISE_HD100      (1<<7)
#define PHYREG_ADVERTISE_FD10       (1<<6)
#define PHYREG_ADVERTISE_HD10       (1<<5)
#define PHYREG_ADVERTISE_MSGMASK    (0x1F)
#define PHYREG_ADVERTISE_MSG        (1)

#define PHYREG_PARTNER              5
#define PHYREG_PARTNER_NEXTPAGE     (1<<15)
#define PHYREG_PARTNER_ACK          (1<<14)
#define PHYREG_PARTNER_FAULT        (1<<13)
#define PHYREG_PARTNER_PAUSE        (1<<10)
#define PHYREG_PARTNER_FD100        (1<<8)
#define PHYREG_PARTNER_HD100        (1<<7)
#define PHYREG_PARTNER_FD10         (1<<6)
#define PHYREG_PARTNER_HD10         (1<<5)
#define PHYREG_PARTNER_MSGMASK      (0x1F)


/*-----------------------------------------------------------------------*\
* PHY Control Register Macros
*
* These MACROS provide an easy way to read/write PHY registers
\*-----------------------------------------------------------------------*/
#define PHYREG_read(regadr, phyadr)                         \
            MDIO_RSET( USERACCESS0,                         \
                    MDIO_FMK(USERACCESS0,GO,1u)         |   \
                    MDIO_FMK(USERACCESS0,REGADR,regadr) |   \
                    MDIO_FMK(USERACCESS0,PHYADR,phyadr) )

#define PHYREG_write(regadr, phyadr, data)                  \
            MDIO_RSET( USERACCESS0,                         \
                    MDIO_FMK(USERACCESS0,GO,1u)         |   \
                    MDIO_FMK(USERACCESS0,WRITE,1u)      |   \
                    MDIO_FMK(USERACCESS0,REGADR,regadr) |   \
                    MDIO_FMK(USERACCESS0,PHYADR,phyadr) |   \
                    MDIO_FMK(USERACCESS0,DATA, data) )

#define PHYREG_wait()                                       \
            while( MDIO_FGET(USERACCESS0,GO) )

#define PHYREG_waitResults( results )  {                    \
            while( MDIO_FGET(USERACCESS0,GO) );             \
            results = MDIO_FGET(USERACCESS0,DATA); }

#define PHYREG_waitResultsAck( results, ack )  {            \
            while( MDIO_FGET(USERACCESS0,GO) );             \
            results = MDIO_FGET(USERACCESS0,DATA);          \
            ack = MDIO_FGET(USERACCESS0,ACK); }


/*-----------------------------------------------------------------------*\
* PHY State Machine
*
* When using auto-negotiation, the software must keep the MAC in
* sync with the PHY (for duplex). This module will also attempt to
* "auto-select" the PHY from a potential list of 32 based on which is
* first to get a link.
*
* On detection of a good link, the link speed and duplex settings will be
* used to update the EMAC configuration (done external to this module).
\*-----------------------------------------------------------------------*/

/* States in the PHY State Machine */
#define PHYSTATE_MDIOINIT       0
#define PHYSTATE_NWAYSTART      1
#define PHYSTATE_NWAYWAIT       2
#define PHYSTATE_LINKWAIT       3
#define PHYSTATE_LINKED         4

/*
// Tick counts for timeout of each state
// Note that NWAYSTART falls through to NWAYWAIT which falls through
// to LINKWAIT. The timeout is not reset progressing from one state
// to the next, so the system has 5 seconds total to find a link.
*/
static uint PhyStateTimeout[] = { 2,  /* PHYSTATE_MDIOINIT   - min-delay */
                                  41, /* PHYSTATE_NWAYSTART  - 4 seconds */
                                  41, /* PHYSTATE_NWAYWAIT   - 4 seconds */
                                  51, /* PHYSTATE_LINKWAIT   - 5 seconds */
                                  0 };/* PHYSTATE_LINKED     - no timeout*/


typedef struct _MDIO_Device {
    uint            ModeFlags;      /* User specified configuration flgs */
    uint            phyAddr;        /* Current (or next) PHY addr (0-31) */
    uint            phyState;       /* PHY State                         */
    uint            phyStateTicks;  /* Ticks elapsed in this PHY state   */
    uint            PendingStatus;  /* Pending Link Status               */
    uint            LinkStatus;     /* Link State EMI_STATUS_LINKSTATUS  */
} MDIO_Device;

static void mdioInitStateMachine();
static MDIO_Device localDev;

/*-----------------------------------------------------------------------*\
* mdioInitStateMachine()
*
* Internal function to initialize the state machine. It is referred to
* often in the code as it is called in case of a PHY error
\*-----------------------------------------------------------------------*/
static void mdioInitStateMachine()
{
    /* Setup the state machine defaults */
    localDev.phyAddr       = 0;                  /* The next PHY to try  */
    localDev.phyState      = PHYSTATE_MDIOINIT;  /* PHY State            */
    localDev.phyStateTicks = 0;                  /* Ticks elapsed        */
    localDev.LinkStatus    = MDIO_LINKSTATUS_NOLINK;
}

/*-----------------------------------------------------------------------*\
* MDIO_open()
*
* Opens the MDIO peripheral and start searching for a PHY device.
*
* It is assumed that the MDIO module is reset prior to calling this
* function.
\*-----------------------------------------------------------------------*/
Handle MDIO_open( uint mdioModeFlags )
{
    /* Get the mode flags from the user - clear our reserved flag */
    localDev.ModeFlags = mdioModeFlags & ~MDIO_MODEFLG_NWAYACTIVE;

    /* Setup the MDIO state machine */
    mdioInitStateMachine();

    /* Enable MDIO and setup divider */
    MDIO_RSET( CONTROL, MDIO_FMKS(CONTROL,ENABLE,YES) |
                        MDIO_FMK(CONTROL,CLKDIV,VBUSCLK) );

    /* We're done for now - all the rest is done via MDIO_event() */
    return( &localDev );
}


/*-----------------------------------------------------------------------*\
* MDIO_close()
*
* Close the  MDIO peripheral and disable further operation.
\*-----------------------------------------------------------------------*/
void MDIO_close( Handle hMDIO )
{
    Uint32         ltmp1;
    uint           i;

    (void)hMDIO;

    /*
    // We really don't care what state anything is in at this point,
    // but to be safe, we'll isolate all the PHY devices.
    */
    ltmp1 = MDIO_RGET( ALIVE );
    for( i=0; ltmp1; i++,ltmp1>>=1 )
    {
        if( ltmp1 & 1 )
        {
            PHYREG_write( PHYREG_CONTROL, i, PHYREG_CONTROL_ISOLATE |
                                             PHYREG_CONTROL_POWERDOWN );
            PHYREG_wait();
        }
    }
}


/*-----------------------------------------------------------------------*\
* MDIO_getStatus()
*
* Called to get the status of the MDIO/PHY
\*-----------------------------------------------------------------------*/
void MDIO_getStatus( Handle hMDIO, uint *pPhy, uint *pLinkStatus )
{
    MDIO_Device *pd = (MDIO_Device *)hMDIO;

    if( pPhy )
        *pPhy = pd->phyAddr;
    if( pLinkStatus )
        *pLinkStatus = pd->LinkStatus;
}


/*-----------------------------------------------------------------------*\
* MDIO_timerTick()
*
* Called to signify that approx 100mS have elapsed
*
* Returns an MDIO event code (see MDIO Events in CSL_MDIO.H).
\*-----------------------------------------------------------------------*/
uint MDIO_timerTick( Handle hMDIO )
{
    MDIO_Device *pd = (MDIO_Device *)hMDIO;
    Uint16      tmp1,tmp2,ack;
    Uint32         ltmp1;
    uint        RetVal = MDIO_EVENT_NOCHANGE;

    /*
    // If we are linked, we just check to see if we lost link. Otherwise;
    // we keep treking through our state machine.
    */
    if( pd->phyState == PHYSTATE_LINKED )
    {
        /*
        // Here we check for a "link-change" status indication or a link
        // down indication.
        */
        ltmp1 = MDIO_RGET( LINKINTRAW ) & 1;
        MDIO_RSET( LINKINTRAW, ltmp1 );
        if( ltmp1 || !(MDIO_RGET(LINK)&(1<<pd->phyAddr)) )
        {
            /*
            // There has been a change in link (or it is down)
            // If we do not auto-neg, then we just wait for a new link
            // Otherwise, we enter NWAYSTART or NWAYWAIT
            */

            pd->LinkStatus = MDIO_LINKSTATUS_NOLINK;
            RetVal = MDIO_EVENT_LINKDOWN;
            pd->phyStateTicks = 0;  /* Reset timeout */

            /* If not NWAY, just wait for link */
            if( !(pd->ModeFlags & MDIO_MODEFLG_NWAYACTIVE) )
                pd->phyState = PHYSTATE_LINKWAIT;
            else
            {
                /* Handle NWAY condition */

                /* First see if link is really down */
                PHYREG_read( PHYREG_STATUS, pd->phyAddr );
                PHYREG_wait();
                PHYREG_read( PHYREG_STATUS, pd->phyAddr );
                PHYREG_waitResultsAck( tmp1, ack );
                if( !ack )
                {
                    /* No PHY response, maybe it was unplugged */
                    mdioInitStateMachine();
                }
                else if( !(tmp1 & PHYREG_STATUS_LINKSTATUS) )
                {
                    /* No Link - restart NWAY */
                    pd->phyState = PHYSTATE_NWAYSTART;

                    PHYREG_write( PHYREG_CONTROL, pd->phyAddr,
                                  PHYREG_CONTROL_AUTONEGEN |
                                  PHYREG_CONTROL_AUTORESTART );
                    PHYREG_wait();
                }
                else
                {
                    /* We have a Link - re-read NWAY params  */
                    pd->phyState = PHYSTATE_NWAYWAIT;
                }
            }
        }
    }

    /*
    // If running in a non-linked state, execute the next
    // state of the state machine.
    */
    if( pd->phyState != PHYSTATE_LINKED )
    {
        /* Bump the time counter */
        pd->phyStateTicks++;

        /* Process differently based on state */
        switch( pd->phyState )
        {
        case PHYSTATE_MDIOINIT:
CheckTimeout:
            /* Here we just check timeout and try to find a PHY */
            if( pd->phyStateTicks >= PhyStateTimeout[pd->phyState] )
            {
                // Try the next PHY if anything but a MDIOINIT condition
                if( pd->phyState != PHYSTATE_MDIOINIT )
                    if( ++pd->phyAddr == 32 )
                        pd->phyAddr = 0;
                ltmp1 = MDIO_RGET( ALIVE );
                for( tmp1=0; tmp1<32; tmp1++ )
                {
                    if( ltmp1 & (1<<pd->phyAddr) )
                    {
                        if( MDIO_initPHY( pd, pd->phyAddr ) )
                            break;
                    }

                    if( ++pd->phyAddr == 32 )
                        pd->phyAddr = 0;
                }

                // If we didn't find a PHY, try again
                if( tmp1 == 32 )
                {
                    pd->phyAddr       = 0;
                    pd->phyState      = PHYSTATE_MDIOINIT;
                    pd->phyStateTicks = 0;
                    RetVal = MDIO_EVENT_PHYERROR;
                }
            }
            break;

        case PHYSTATE_NWAYSTART:
            /*
            // Here we started NWAY. We check to see if NWAY is done.
            // If not done and timeout occured, we find another PHY.
            */

            /* Read the CONTROL reg to verify "restart" isn't set */
            PHYREG_read( PHYREG_CONTROL, pd->phyAddr );
            PHYREG_waitResultsAck( tmp1, ack );
            if( !ack )
            {
                mdioInitStateMachine();
                break;
            }
            if( tmp1 & PHYREG_CONTROL_AUTORESTART )
                goto CheckTimeout;

            /* Flush latched "link status" from the STATUS reg */
            PHYREG_read( PHYREG_STATUS, pd->phyAddr );
            PHYREG_wait();

            pd->phyState = PHYSTATE_NWAYWAIT;

            /* Fallthrough */

        case PHYSTATE_NWAYWAIT:
            /*
            // Here we are waiting for NWAY to complete.
            */

            /* Read the STATUS reg to check for "complete" */
            PHYREG_read( PHYREG_STATUS, pd->phyAddr );
            PHYREG_waitResultsAck( tmp1, ack );
            if( !ack )
            {
                mdioInitStateMachine();
                break;
            }
            if( !(tmp1 & PHYREG_STATUS_AUTOCOMPLETE) )
                goto CheckTimeout;

            /* We can now check the negotiation results */
            PHYREG_read( PHYREG_ADVERTISE, pd->phyAddr );
            PHYREG_waitResults( tmp1 );
            PHYREG_read( PHYREG_PARTNER, pd->phyAddr );
            PHYREG_waitResults( tmp2 );

            /* Use the "best" results */
            tmp2 &= tmp1;
            if( tmp2 & PHYREG_ADVERTISE_FD100 )
                pd->PendingStatus = MDIO_LINKSTATUS_FD100;
            else if( tmp2 & PHYREG_ADVERTISE_HD100 )
                pd->PendingStatus = MDIO_LINKSTATUS_HD100;
            else if( tmp2 & PHYREG_ADVERTISE_FD10 )
                pd->PendingStatus = MDIO_LINKSTATUS_FD10;
            else if( tmp2 & PHYREG_ADVERTISE_HD10 )
                pd->PendingStatus = MDIO_LINKSTATUS_HD10;
            /*
            // If we get here the negotiation failed
            // We just use HD 100 or 10 - the best we think we can do
            */
            else if( tmp1 & PHYREG_ADVERTISE_HD100 )
                pd->PendingStatus = MDIO_LINKSTATUS_HD100;
            else
                pd->PendingStatus = MDIO_LINKSTATUS_HD10;

            pd->phyState = PHYSTATE_LINKWAIT;

            /* Fallthrough */

        case PHYSTATE_LINKWAIT:
            /*
            // Here we are waiting for LINK
            */

            /* Read the STATUS reg to check for "link" */
            PHYREG_read( PHYREG_STATUS, pd->phyAddr );
            PHYREG_waitResultsAck( tmp1, ack );
            if( !ack )
            {
                mdioInitStateMachine();
                break;
            }
            if( !(tmp1 & PHYREG_STATUS_LINKSTATUS) )
                goto CheckTimeout;

            /* Make sure we're linked in the MDIO module as well */
            ltmp1 = MDIO_RGET( LINK );
            if( !(ltmp1&(1<<pd->phyAddr)) )
                goto CheckTimeout;

            /* Start monitoring this PHY */
            MDIO_RSET( USERPHYSEL0, pd->phyAddr );

            /* Clear the link change flag so we can detect a "re-link" later */
            MDIO_RSET( LINKINTRAW, 1 );

            /* Setup our linked state */
            pd->phyState   = PHYSTATE_LINKED;
            pd->LinkStatus = pd->PendingStatus;
            RetVal = MDIO_EVENT_LINKUP;

            break;
        }
    }

    return( RetVal );
}


/*-----------------------------------------------------------------------*\
* MDIO_initPHY()
*
* Force a switch to the specified PHY, and start the negotiation process.
*
* Returns 1 if the PHY selection completed OK, else 0
\*-----------------------------------------------------------------------*/
uint MDIO_initPHY( Handle hMDIO, volatile uint phyAddr )
{
    MDIO_Device *pd = (MDIO_Device *)hMDIO;
    Uint16         tmp1,tmp2;
    Uint32         ltmp1;
    uint           i;

    /* Switch the PHY */
    pd->phyAddr = phyAddr;

    /* There will be no link when we're done with this PHY */
    pd->LinkStatus = MDIO_LINKSTATUS_NOLINK;

    /* Shutdown all other PHYs */
    ltmp1 = MDIO_RGET( ALIVE );
    for( i=0; ltmp1; i++,ltmp1>>=1 )
    {
        if( (ltmp1 & 1) && (i != phyAddr) )
        {
            PHYREG_write( PHYREG_CONTROL, i, PHYREG_CONTROL_ISOLATE |
                                             PHYREG_CONTROL_POWERDOWN );
            PHYREG_wait();
        }
    }

    /* Reset the PHY we plan to use */
    PHYREG_write( PHYREG_CONTROL, phyAddr, PHYREG_CONTROL_RESET );
    PHYREG_wait();

    /* Wait for reset to go low (but not forever) */
    for( i=0; i<5000; i++ )
    {
        PHYREG_read( PHYREG_CONTROL, phyAddr );
        PHYREG_waitResults( tmp1 );
        if( !(tmp1 & PHYREG_CONTROL_RESET) )
            break;
    }
    if( i == 5000 )
        return(0);

    /* Read the STATUS reg to check autonegotiation capability */
    PHYREG_read( PHYREG_STATUS, phyAddr );
    PHYREG_waitResults( tmp1 );

    /* See if we auto-neg or not */
    if( (pd->ModeFlags & MDIO_MODEFLG_AUTONEG) &&
                                     (tmp1 & PHYREG_STATUS_AUTOCAPABLE) )
    {
        /* We will use NWAY */

        /* Shift down the capability bits */
        tmp1 >>= 6;

        /* Mask with the capabilities */
        tmp1 &= ( PHYREG_ADVERTISE_FD100 | PHYREG_ADVERTISE_HD100 |
                  PHYREG_ADVERTISE_FD10 | PHYREG_ADVERTISE_HD10 );

        /* Set Ethernet message bit */
        tmp1 |= PHYREG_ADVERTISE_MSG;

        /* Write out advertisement */
        PHYREG_write( PHYREG_ADVERTISE, phyAddr, tmp1 );
        PHYREG_wait();

        /* Start NWAY */
        PHYREG_write( PHYREG_CONTROL, phyAddr, PHYREG_CONTROL_AUTONEGEN );
        PHYREG_wait();

        PHYREG_write( PHYREG_CONTROL, phyAddr,
                      PHYREG_CONTROL_AUTONEGEN|PHYREG_CONTROL_AUTORESTART );
        PHYREG_wait();

        /* Setup current state */
        pd->ModeFlags |= MDIO_MODEFLG_NWAYACTIVE;
        pd->phyState = PHYSTATE_NWAYSTART;
        pd->phyStateTicks = 0;  /* Reset timeout */
    }
    else
    {
        /* We will use a fixed configuration */

        /* Shift down the capability bits */
        tmp1 >>= 10;

        /* Mask with possible modes */
        tmp1 &= ( MDIO_MODEFLG_HD10 | MDIO_MODEFLG_FD10 |
                  MDIO_MODEFLG_HD100 | MDIO_MODEFLG_FD100 );

        /* Mask with what the User wants to allow */
        tmp1 &= pd->ModeFlags;

        /* If nothing if left, move on */
        if( !tmp1 )
            return(0);

        /* Setup Control word and pending status */
        if( tmp1 & MDIO_MODEFLG_FD100 )
        {
            tmp2 = PHYREG_CONTROL_SPEED100 | PHYREG_CONTROL_DUPLEXFULL;
            pd->PendingStatus = MDIO_LINKSTATUS_FD100;
        }
        else if( tmp1 & MDIO_MODEFLG_HD100 )
        {
            tmp2 = PHYREG_CONTROL_SPEED100;
            pd->PendingStatus = MDIO_LINKSTATUS_HD100;
        }
        else if( tmp1 & MDIO_MODEFLG_FD10 )
        {
            tmp2 = PHYREG_CONTROL_DUPLEXFULL;
            pd->PendingStatus = MDIO_LINKSTATUS_FD10;
        }
        else
        {
            tmp2 = 0;
            pd->PendingStatus = MDIO_LINKSTATUS_HD10;
        }

        /* Add in loopback if user wanted it */
        if( pd->ModeFlags & MDIO_MODEFLG_LOOPBACK )
            tmp2 |= PHYREG_CONTROL_LOOPBACK;

        /* Configure PHY */
        PHYREG_write( PHYREG_CONTROL, phyAddr, tmp2 );
        PHYREG_wait();

        /* Setup current state */
        pd->ModeFlags &= ~MDIO_MODEFLG_NWAYACTIVE;
        pd->phyState = PHYSTATE_LINKWAIT;
        pd->phyStateTicks = 0;  /* Reset timeout */
    }

    return(1);
}


/*-----------------------------------------------------------------------*\
* MDIO_phyRegRead()
*
* Raw data read of a PHY register.
*
* Returns 1 if the PHY ACK'd the read, else 0
\*-----------------------------------------------------------------------*/
uint MDIO_phyRegRead( volatile uint phyIdx, volatile uint phyReg, Uint16 *pData )
{
    uint data,ack;

    PHYREG_read( phyReg, phyIdx );
    PHYREG_waitResultsAck( data, ack );
    if( !ack )
        return(0);
    if( pData )
        *pData = data;
    return(1);
}


/*-----------------------------------------------------------------------*\
* MDIO_phyRegWrite()
*
* Raw data write of a PHY register.
*
* Returns 1 if the PHY ACK'd the write, else 0
\*-----------------------------------------------------------------------*/
uint MDIO_phyRegWrite( volatile uint phyIdx, volatile uint phyReg, Uint16 data )
{
    uint ack;

    PHYREG_write( phyReg, phyIdx, data );
    PHYREG_waitResultsAck( data, ack );
    if( !ack )
        return(0);
    return(1);
}

#endif /* MDIO_SUPPORT */
/******************************************************************************\
* End of mdio.c
\******************************************************************************/

csl_pci.c/      1030611973  0     0     0       9061      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_pci.c
* DATE CREATED.. Mon 06/12/2000 
* LAST MODIFIED. Fri 10/13/2000 
*
\******************************************************************************/
#define _PCI_MOD_
#include "csl_pci.h"

#if (PCI_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/****************************************\
* PCI static macro declarations
\****************************************/

/****************************************\
* PCI static typedef declarations
\****************************************/

/****************************************\
* PCI static function declarations
\****************************************/

/****************************************\
* PCI static variable definitions
\****************************************/

/****************************************\
* PCI static function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/****************************************\
* PCI global variable definitions
\****************************************/
  Uint32 _PCI_maskTable[13] = {
 _PCI_PCIIEN_PWRMGMT_MASK,
 _PCI_PCIIEN_PCITARGET_MASK,
 _PCI_PCIIEN_PCIMASTER_MASK,
 _PCI_PCIIEN_HOSTSW_MASK,
 _PCI_PCIIEN_PWRLH_MASK,
 _PCI_PCIIEN_PWRHL_MASK,
 _PCI_PCIIEN_MASTEROK_MASK,
 _PCI_PCIIEN_CFGDONE_MASK,
 _PCI_PCIIEN_CFGERR_MASK,
 _PCI_PCIIEN_EERDY_MASK, 
  0,
 _PCI_PCIIEN_PRST_MASK,   
 _PCI_PCIIS_DMAHALTED_MASK  
 };
  
  
/****************************************\
* PCI global function definitions
\****************************************/
/*----------------------------------------------------------------------------*/
Uint32 PCI_eepromWrite(Uint32 eeaddr,Uint16 eedata) {
  
  Uint32 success = 0;
 
 /* Enable write */  
    while ( _PCI_eepromEnableWrite() == 0);
     
  
/* Write */ 
  if ( PCI_FGET(EECTL,EESZ)!=0)
   {
    while( !(PCI_FGET(RSTSRC,CFGDONE)));       /* wait for EEPROM ready */
    PCI_FSET(EEADD,EEADD,eeaddr);             /* address EEprom into EEADD */ 
    PCI_FSET(EEDAT,EEDAT,eedata);             /* 16-bit data into EEDAT  */
    PCI_FSET(EECTL,EECNT,0x1);                 /* Op-code for WRITE command  */
    while( PCI_FGET(EECTL,READY) == 0);        /* wait for READY is to 1*/
 
/* Read back the data */
    if ( PCI_eepromRead(eeaddr) == eedata) 
         { 
          success= 1;
         }
   } 
  
  /* Disable Write */
  PCI_FSET(EEADD,EEADD,0x0);                 /* address 0x0 into EEADD */ 
  PCI_FSET(EECTL,EECNT,0x0);                /* Op-code for Disable 0x0  */
  while( PCI_FGET(EECTL,READY) == 0); 
       
  return (success);
}      

/*----------------------------------------------------------------------------*/
Uint32 PCI_eepromWriteAll(Uint16 eedata) {
  
  Uint32 success = 0;
  Uint32 DATASZ,eeaddr;
 
 /* Enable Write ALL*/  
   while ( _PCI_eepromEnableWrite() == 0);
 
 /* Select the eeaddr  */  
   DATASZ=PCI_FGET(EECTL,EESZ);
   if ( DATASZ == 1) { eeaddr=0x010;}
   else if ( DATASZ == 2) { eeaddr=0x080;} 
   else if ( DATASZ == 3) { eeaddr=0x040;}
   else if ( DATASZ == 4) { eeaddr = 0x100;}
   else { return 0;}
     
         
 /* Write all with eedata value */      
  if ( PCI_FGET(EECTL,EESZ)!=0)
   {
    while( !(PCI_FGET(RSTSRC,CFGDONE)));          /* wait for READY is to 1*/
    PCI_FSET(EEADD,EEADD,eeaddr);                /* address EEprom into EEADD 0x10 */ 
    PCI_FSET(EEDAT,EEDAT,eedata);               /* 16-bit data into EEDAT  */
    PCI_FSET(EECTL,EECNT,0x00);                 /* Op-code for WRITE ALL command  */
    while( PCI_FGET(EECTL,READY) == 0);         /* wait for READY is to 1*/
    success= 1;
   } 
  
  /* Disable Write ALL */
  PCI_FSET(EEADD,EEADD,0x0);                /* address EEprom into EEADD 0x0*/ 
  PCI_FSET(EECTL,EECNT,0x0);                 /* Op-code for Disable 0x0  */
  while( PCI_FGET(EECTL,READY) == 0); 
 

   return (success);
}
/*----------------------------------------------------------------------------*/
Uint16 PCI_eepromRead(Uint32 eeaddr) {
  if ( PCI_FGET(EECTL,EESZ)!=0)
   {
    while( !(PCI_FGET(RSTSRC,CFGDONE)));
    PCI_FSET(EEADD,EEADD,eeaddr);             /* address EEprom into EEADD */                 PCI_FSET(EECTL,EECNT,0x2);               /* Op-code for READ command  0x2*/
    while( PCI_FGET(EECTL,READY) == 0);   /* Wait for READY is set to 1*/
    return(PCI_FGET(EEDAT,EEDAT));  
   }
  else {
  return(0xFFFF);
  }
}
/*----------------------------------------------------------------------------*/
Uint32 PCI_eepromErase(Uint32 eeaddr) {
  Uint32 success=0;  
  
  /* Enable Erase */  
   while ( _PCI_eepromEnableWrite() == 0);
   
   /* Erase Data */
  if ( PCI_FGET(EECTL,EESZ)!=0)
   {
   
    PCI_FSET(EEADD,EEADD,eeaddr);             /* address EEprom into EEADD */             
    while( !(PCI_FGET(RSTSRC,CFGDONE)));     /* Wait the EEPROM is ready for next command */ 
    PCI_FSET(EECTL,EECNT,0x3);               /* Op-code for ERASE command 0x3 */
    while( !(PCI_FGET(EECTL,READY)));        /* Wait for READY is set to 1*/
    success = 1;
   }    
   
  /* Disable Write */
   PCI_FSET(EEADD,EEADD,0x0);                /* address EEprom into EEADD 0x0 */ 
   PCI_FSET(EECTL,EECNT,0x0);                 /* Op-code for Disable command 0x0 */
   while( PCI_FGET(EECTL,READY) == 0); 
   
   return(success);
}    
/*----------------------------------------------------------------------------*/
Uint32 PCI_eepromEraseAll() {
  Uint32 success=0; 
  Uint32 DATASZ,eeaddr; 
  
  /* Enable Write (Erase) */   
   while ( _PCI_eepromEnableWrite() == 0);     
   
  /* Select address */ 
   DATASZ=PCI_FGET(EECTL,EESZ);
   if ( DATASZ == 1) { eeaddr=0x020;}
   else if ( DATASZ == 2) { eeaddr=0x100;} 
   else if ( DATASZ == 3) { eeaddr=0x080;}
   else if ( DATASZ == 4) { eeaddr = 0x200;}
   else { return 0;}
     
 


  /* Erase All setup */     
  if ( PCI_FGET(EECTL,EESZ)!=0)
   {
    PCI_FSET(EEADD,EEADD,eeaddr);             /* address EEprom into EEADD 0x20*/ 
    PCI_FSET(EECTL,EECNT,0x0);                 /* Op-code for ERAL command 0x0 */
    while( PCI_FGET(EECTL,READY) == 0);                  
     success = 1;
   }    
   
  /* Disable Erase ALL */
   PCI_FSET(EEADD,EEADD,0x0);             /* address EEprom into EEADD */ 
   PCI_FSET(EECTL,EECNT,0x0);                 /* Op-code for WRITE command  */
   while( PCI_FGET(EECTL,READY) == 0); 
   
   return(success);
}
/*----------------------------------------------------------------------------*/
 Uint32 _PCI_eepromEnableWrite() {
 Uint32 success = 1;
 volatile Uint32 DATASZ; 
 
 DATASZ=PCI_FGET(EECTL,EESZ);
 

if (DATASZ ==  1 )
      {  
       PCI_FSET(EEADD,EEADD,0x030);             /* 1K: address EEprom into EEADD 0x30*/ 
       PCI_FSET(EECTL,EECNT,0x0);                 /* Op-code for EWEN command 0x0 */
       while( PCI_FGET(EECTL,READY) == 0);  
      }
else if (DATASZ ==  2)
      {  
       PCI_FSET(EEADD,EEADD,0x0180);             /*  2K: address EEprom into EEADD 0x180*/ 
       PCI_FSET(EECTL,EECNT,0x0);                 /* Op-code for EWEN command 0x0 */
       while( PCI_FGET(EECTL,READY) == 0);  
      }
else if (DATASZ ==  3)
      {  
       PCI_FSET(EEADD,EEADD,0x0C0);             /* 4K: address EEprom into EEADD 0x180*/ 
       PCI_FSET(EECTL,EECNT,0x0);                 /* Op-code for EWEN command 0x0 */
       while( PCI_FGET(EECTL,READY) == 0);  
      }
else if (DATASZ ==  4)
      {  
       PCI_FSET(EEADD,EEADD,0x300);             /* 16k: address EEprom into EEADD 0x300*/ 
       PCI_FSET(EECTL,EECNT,0x0);                 /* Op-code for EWEN command 0x0 */
       while( PCI_FGET(EECTL,READY) == 0);  
      }                
else { 
      success = 0;
      }
  
  return success;
}    
/*----------------------------------------------------------------------------*/
 
#endif /* PCI_SUPPORT */
/******************************************************************************\
* End of csl_pci.c
\******************************************************************************/


csl_pll.c/      1030611974  0     0     0       3031      `
/******************************************************************************\
*  Step 1.    Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_pll.c
* DATE CREATED.. 10/29/2001
* LAST MODIFIED. 10/29/2001 
*
\******************************************************************************/
/******************************************************************************\
*  Step 2. Private Macro and Include files *
\******************************************************************************/
#define _PLL_MOD_

#include "csl_pll.h"

#if (PLL_SUPPORT)
/******************************************************************************\
* Step 3.                        L O C A L   S E C T I O N
\******************************************************************************/
Uint32 _PLL_divAddr[4] = {
  _PLL_PLLDIV0_ADDR,
  _PLL_PLLDIV1_ADDR,
  _PLL_PLLDIV2_ADDR,
  _PLL_PLLDIV3_ADDR
};

/**********************************************\
* Step 3.1 PLL static macro declarations
\**********************************************/

/**********************************************\
* Step 3.2 PLL static typedef declarations
\**********************************************/

/**********************************************\
* Step 3.3 PLL static function declarations
\**********************************************/

/**********************************************\
* Step 3.4 PLL static variable definitions
\**********************************************/

/**********************************************\
* Step 3.5 PLL static function definitions
\**********************************************/
/*----------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------*/
/******************************************************************************\
* Step 4.                    G L O B A L   S E C T I O N
\******************************************************************************/

/**********************************************\
* Step 4.1 PLL global variable definitions
\**********************************************/

/**********************************************\
* Step 4.2 PLL global function definitions
\**********************************************/
void PLL_wait100() {
 volatile Uint32 x;

 for(x=0;x<80;x++) {
   asm(" NOP 1");
  } ;
}
  
Uint32 PLL_wait1() {
 PLL_FGET(PLLCSR,PLLRST);
 return ((Uint32) PLL_FGET(PLLDIV0,RATIO));
     
}
/**********************************************\
* Step 5. #endif PLL_SUPPORT + Footer
\**********************************************/
#endif /* PLL_SUPPORT */
/******************************************************************************\
* End of csl_pll.c
\******************************************************************************/

csl_pwr.c/      1030611975  0     0     0       2645      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_pwr.c
* DATE CREATED.. 11/11/1999 
* LAST MODIFIED. 10/03/2000
\******************************************************************************/
#define _PWR_MOD_
#include "csl_pwr.h"


#if (PWR_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/

#endif /* PWR_SUPPORT */
/******************************************************************************\
* End of csl_pwr.c
\******************************************************************************/


csl_tcp.c/      1030611977  0     0     0       69198     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_tcp.c
* DATE CREATED.. 02/23/2001 
* LAST MODIFIED. 05/30/2001
\******************************************************************************/
#define _TCP_MOD_
#include "csl_tcp.h"

#if (TCP_SUPPORT)
#ifndef OPT_LE
 #ifndef OPT_BE
  #ifndef OPT_BE32
   #define NO_OPT
  #endif
 #endif
#endif

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/

void TCP_tailConfig(TCP_Standard standard,
        TCP_Mode mode,
        TCP_Map map,
        TCP_Rate rate,
        TCP_UserData *restrict xabData,
        TCP_ConfigIc *restrict configIc) {

  if (standard == TCP_STANDARD_3GPP) TCP_tailConfig3GPP(mode, map, xabData,
                    configIc);
  else TCP_tailConfigIs2000(mode, map, rate, xabData, configIc);
  
} /* end TCP_tailConfig() */
/*----------------------------------------------------------------------------*/

void TCP_tailConfig3GPP(TCP_Mode mode,
        TCP_Map map,
        TCP_UserData *restrict xabData,
        TCP_ConfigIc *restrict configIc) {
  Int32 gie;
  Uint32 tail1, tail2, tail3, tail4, tail5, tail6;

  gie = IRQ_globalDisable();

  if ((mode == TCP_MODE_SP) && (map == TCP_MAP_MAP2)){
    /* tail1 = 0, x_t_2, x_t_1, x_t_0 */
    /* tail2 = 0, a_t_2, a_t_1, a_t_0 */
    /* tail3 = 0,   0  ,   0  ,   0   */
    /* tail4 = 0,   0  ,   0  ,   0   */
    /* tail5 = 0,   0  ,   0  ,   0   */
    /* tail6 = 0,   0  ,   0  ,   0   */
    tail1 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
    tail2 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
    tail3 = 0;
    tail4 = 0;
    tail5 = 0;
    tail6 = 0;
  } /* end if SPMAP2 */
  else if (mode == TCP_MODE_SP){
    /* tail1 = 0, xt_2, xt_1, xt_0 */
    /* tail2 = 0, at_2, at_1, at_0 */
    /* tail3 = 0,   0  ,   0  ,   0   */
    /* tail4 = 0,   0  ,   0  ,   0   */
    /* tail5 = 0,   0  ,   0  ,   0   */
    /* tail6 = 0,   0  ,   0  ,   0   */
    tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
    tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
    tail3 = 0;
    tail4 = 0;
    tail5 = 0;
    tail6 = 0;
  } /* end if SPMAP1 */
  else { /* if (mode == TCP_MODE_SA) */
    /* tail1 = 0,  xt_2,  xt_1,  xt_0 */
    /* tail2 = 0,  at_2,  at_1,  at_0 */
    /* tail3 = 0,   0  ,   0  ,   0   */
    /* tail4 = 0, x_t_2, x_t_1, x_t_0 */
    /* tail5 = 0, a_t_2, a_t_1, a_t_0 */
    /* tail6 = 0,   0  ,   0  ,   0   */
    tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
    tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
    tail3 = 0;
    tail4 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
    tail5 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
    tail6 = 0;
  } /* end if SA */
  configIc->ic6  = tail1;
  configIc->ic7  = tail2;
  configIc->ic8  = tail3;
  configIc->ic9  = tail4;
  configIc->ic10 = tail5;
  configIc->ic11 = tail6;

  IRQ_globalRestore(gie);
} /* end TCP_tailConfig3GPP */
/*----------------------------------------------------------------------------*/

void TCP_tailConfigIs2000(TCP_Mode mode,
        TCP_Map map,
        TCP_Rate rate,
        TCP_UserData *restrict xabData,
        TCP_ConfigIc *restrict configIc) {

  Int32 gie;
  Uint32 tail1, tail2, tail3, tail4, tail5, tail6;

  gie = IRQ_globalDisable();

  if ((mode == TCP_MODE_SP) && (map == TCP_MAP_MAP2)) {
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0, x_t_2, x_t_1, x_t_0 */
        /* tail2 = 0, a_t_2, a_t_1, a_t_0 */
        tail1 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
        tail2 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        tail1 = TCP_makeTailArgs(        0                 , (xabData[15]), \
                                (xabData[12]), (xabData[9]));
        tail2 = TCP_makeTailArgs(0, xabData[17], xabData[14], xabData[11]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       b_t_2     ,       b_t_1     ,       b_t_0      */
        /* tail3 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        tail1 = TCP_makeTailArgs(        0                 , (xabData[20]), \
                                (xabData[16]), (xabData[12]));
        tail2 = TCP_makeTailArgs(0, xabData[23], xabData[19], xabData[15]);
        tail3 = TCP_makeTailArgs(0, xabData[22], xabData[18], xabData[14]);
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    } /* end switch rate */
  } /* end if mode == TCP_MODE_SPMAP2 */
  /*--------------------------------------------------------------------------*/
  else if (mode == TCP_MODE_SP) { /*  && (map == TCP_MAP1) */
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0, xt_2, xt_1, xt_0 */
        /* tail2 = 0, at_2, at_1, at_0 */
        tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
        tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        tail1 = TCP_makeTailArgs(        0               , (xabData[6]), \
                                (xabData[3]), (xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[8], xabData[5], xabData[2]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, (xt_2 + _xt_2), (xt_1 + _xt_1), (xt_0 + _xt_0) */
        /* tail2 = 0,      at_2     ,      at_1     ,      at_0      */
        /* tail3 = 0,      bt_2     ,      bt_1     ,      bt_0      */
        tail1 = TCP_makeTailArgs(        0               , (xabData[8]), \
                                (xabData[4]), (xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[10], xabData[6], xabData[2]);
        tail3 = TCP_makeTailArgs(0, xabData[11], xabData[7], xabData[3]);
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    } /* end switch (rate) */
  } /* end if mode == TCP_MODE_SPMAP1 */
  /*--------------------------------------------------------------------------*/
  else { /* (mode == TCP_MODE_SA) */
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0,  xt_2,  xt_1,  xt_0 */
        /* tail2 = 0,  at_2,  at_1,  at_0 */
        /* tail3 = 0,   0  ,   0  ,   0   */
        /* tail4 = 0, x_t_2, x_t_1, x_t_0 */
        /* tail5 = 0, a_t_2, a_t_1, a_t_0 */
        /* tail6 = 0,   0  ,   0  ,   0   */
        tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
        tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
        tail3 = 0;
        tail4 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
        tail5 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, ( xt_2 +  _xt_2), ( xt_1 +  _xt_1), ( xt_0 +  _xt_0) */
        /* tail2 = 0,        at_2     ,        at_1     ,        at_0      */
        /* tail3 = 0,         0       ,         0       ,         0        */
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        /* tail3 = 0,         0       ,         0       ,         0        */
        tail1 = TCP_makeTailArgs(        0               , (xabData[6]), \
                                (xabData[3]), (xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[8], xabData[5], xabData[2]);
        tail3 = 0;
        tail4 = TCP_makeTailArgs(        0                 , (xabData[15]), \
                                (xabData[12]), (xabData[9]));
        tail5 = TCP_makeTailArgs(0, xabData[17], xabData[14], xabData[11]);
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, ( xt_2 +  _xt_2), ( xt_1 +  _xt_1), ( xt_0 +  _xt_0) */
        /* tail2 = 0,       at_2      ,       at_1      ,       at_0       */
        /* tail3 = 0,       bt_2      ,       bt_1      ,       bt_0       */
        /* tail4 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail5 = 0,      a_t_2      ,      a_t_1      ,      a_t_0       */
        /* tail6 = 0,      b_t_2      ,      b_t_1      ,      b_t_0       */
        tail1 = TCP_makeTailArgs(        0               , (xabData[8]), \
                                (xabData[4]), (xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[10], xabData[6], xabData[2]);
        tail3 = TCP_makeTailArgs(0, xabData[11], xabData[7], xabData[3]);
        tail4 = TCP_makeTailArgs(        0                 , (xabData[20]), \
                                (xabData[16]), (xabData[12]));
        tail5 = TCP_makeTailArgs(0, xabData[22], xabData[18], xabData[14]);
        tail6 = TCP_makeTailArgs(0, xabData[23], xabData[19], xabData[15]);
        break;
    } /* end switch (rate) */
  } /* end if mode == TCP_MODE_SA */
  /*--------------------------------------------------------------------------*/
  
  configIc->ic6  = tail1;
  configIc->ic7  = tail2;
  configIc->ic8  = tail3;
  configIc->ic9  = tail4;
  configIc->ic10 = tail5;
  configIc->ic11 = tail6;

  IRQ_globalRestore(gie);
} /* end TCP_tailConfig */

/*----------------------------------------------------------------------------*/
void TCP_setParams(TCP_Params *restrict configParms,
        TCP_ConfigIc *restrict configIc) {

  Uint32 gie;
  //TCP_Standard standard  = configParms->standard;
  TCP_Mode mode          = configParms->mode;
  TCP_Map  map           = configParms->map;
  TCP_Rate rate          = configParms->rate - 1;
  Uint32 intFlag         = configParms->intFlag;
  Uint32 outParmFlag     = configParms->outParmFlag;
  Uint32 frameLen        = configParms->frameLen;
  Uint32 subFrameLen     = configParms->subFrameLen;
  Uint32 relLen          = configParms->relLen;
  Uint32 relLenLast      = configParms->relLenLast;
  Uint32 prologSize      = configParms->prologSize;
  Uint32 numSubBlock     = configParms->numSubBlock;
  Uint32 numSubBlockLast = configParms->numSubBlockLast;
  Uint32 maxIter         = configParms->maxIter;
  Uint32 snr             = configParms->snr;
  Uint32 numInter        = configParms->numInter;
  Uint32 numSysPar       = configParms->numSysPar;
  Uint32 numApriori      = configParms->numApriori;
  Uint32 numExt          = configParms->numExt;
  Uint32 numHd           = configParms->numHd;
  Uint32 ic0, ic1, ic2, ic3, ic4, ic5;

  gie = IRQ_globalDisable();

  if (mode) mode = (mode << 2) + map;
  
  ic0 = TCP_IC0_RMK(frameLen,outParmFlag,intFlag,rate,mode);
  ic1 = TCP_IC1_RMK(relLenLast,relLen,subFrameLen);
  ic2 = TCP_IC2_RMK(snr,maxIter,numSubBlockLast,numSubBlock,prologSize);
  ic3 = TCP_IC3_RMK(numSysPar,numInter);
  ic4 = TCP_IC4_RMK(numExt,numApriori);
  ic5 = TCP_IC5_RMK(numHd);

  configIc->ic0 = ic0;
  configIc->ic1 = ic1;
  configIc->ic2 = ic2;
  configIc->ic3 = ic3;
  configIc->ic4 = ic4;
  configIc->ic5 = ic5;
  
  IRQ_globalRestore(gie);
} /* end TCP_genParamIc */

/*----------------------------------------------------------------------------*/

void TCP_genIc(TCP_Params *restrict configParms,
               TCP_UserData *restrict xabData,
               TCP_ConfigIc *restrict configIc) {

  TCP_Standard standard = configParms->standard;
  TCP_Mode mode         = configParms->mode;
  TCP_Map  map          = configParms->map;
  TCP_Rate rate         = configParms->rate;

  TCP_setParams(configParms, configIc);
  if (standard == TCP_STANDARD_3GPP) TCP_tailConfig3GPP(mode, map, xabData, configIc);
  else TCP_tailConfig(standard, mode, map, rate, xabData, configIc);
} /* end TCP_genIc */

/*----------------------------------------------------------------------------*/

Uint32 TCP_genParams(TCP_BaseParams *configBase, TCP_Params *configParms)
{
Uint32 numSubFrame = 0;
Uint32 frameLen = configBase->frameLen;

    configParms->standard    = configBase->standard;
    configParms->rate        = configBase->rate;
    configParms->intFlag     = configBase->intFlag;
    configParms->outParmFlag = configBase->outParmFlag;
    configParms->frameLen    = frameLen;
    configParms->prologSize  = configBase->prologSize;
    configParms->maxIter     = configBase->maxIter;
    configParms->snr         = configBase->snr;

    if (frameLen <= 5114){             /* Configure for Standalone processing */
      configParms->mode = TCP_MODE_SA;
      TCP_calcSubBlocksSA(configParms);
      TCP_calcCountsSA(configParms);
    } /* end if standalone */
    else {                             /* Configure for Shared processing     */
      configParms->mode = TCP_MODE_SP;
      numSubFrame = TCP_calcSubBlocksSP(configParms);
      TCP_calcCountsSP(configParms);
    } /* end if shared processing */

    /* Return the number of sub frames */
    return(numSubFrame);
    
} /* end TCP_genParams() */
    
/*----------------------------------------------------------------------------*/

void TCP_calcSubBlocksSA(TCP_Params *configParms)
{
Uint16 frameLen   = configParms->frameLen;
//Uint8  prologSize = configParms->prologSize;  - not used
Uint16 winSize;
Uint16 numSlidingWindow;
Uint16 relLen;
Uint16 numSubBlock;

    if (frameLen <= 128) numSlidingWindow = 1;
    else if (frameLen <= 256) numSlidingWindow = 2;
    else numSlidingWindow = 4;
    
    winSize = frameLen;
    winSize = TCP_normalCeil(winSize, numSlidingWindow);
    numSubBlock = TCP_normalCeil(winSize, TCP_RLEN_MAX);
    relLen = TCP_normalCeil(winSize, numSubBlock) - 1;
    
    if(relLen < 39) relLen = 39;
    
    configParms->relLen          = relLen;
    configParms->numSubBlock     = numSubBlock;
    configParms->subFrameLen     = 0;
    configParms->relLenLast      = 0;
    configParms->numSubBlockLast = 0;
    
} /* end TCP_calcSubBlocksSA() */

/*----------------------------------------------------------------------------*/

void TCP_calcCountsSA(TCP_Params *configParms)
{
Uint16 frameLen = configParms->frameLen;
TCP_Rate rate   = configParms->rate;
Uint16 numSysPar;
Uint16 numInter;
Uint16 numHd;

    numSysPar = TCP_ceil((frameLen * rate), 4);
    numInter  = TCP_ceil( frameLen        , 1);
    numHd     = TCP_ceil( frameLen        , 5);
	
    configParms->numSysPar  = numSysPar;
    configParms->numInter   = numInter;
    configParms->numHd      = numHd;	
    configParms->numApriori = 0;
    configParms->numExt     = 0;

} /* end TCP_calcCountsSA() */

/*----------------------------------------------------------------------------*/


Uint32 TCP_calcSubBlocksSP(TCP_Params *configParms)
{
Uint16 frameLen   = configParms->frameLen;
Uint8  prologSize = configParms->prologSize;
TCP_Rate rate     = configParms->rate;
Uint16 numSubFrame;
Uint16 subFrameLen;
Uint16 subFrameLenLast;
Uint16 winSize;
Uint16 numSlidingWindow;
Uint16 relLen;
Uint16 relLenLast;
Uint16 numSubBlock;
Uint16 numSubBlockLast;

    numSubFrame = (frameLen / (TCP_FLEN_MAX - 2 * prologSize)) + 1;
    subFrameLen = frameLen / numSubFrame;
    if (rate == TCP_RATE_1_4) subFrameLen = TCP_ceil(subFrameLen, 4) << 4;
    else subFrameLen = TCP_ceil(subFrameLen, 3) << 3;
    subFrameLenLast = frameLen - (numSubFrame - 1) * subFrameLen;

    if (subFrameLen <= 128) numSlidingWindow = 1;
    else if (subFrameLen <= 256) numSlidingWindow = 2;
    else numSlidingWindow = 4;
    
    winSize = subFrameLen;
    subFrameLen += 2 * prologSize;
    winSize = TCP_normalCeil(winSize, numSlidingWindow);
    numSubBlock = TCP_normalCeil(winSize, TCP_RLEN_MAX);
    relLen = TCP_normalCeil(winSize, numSubBlock) - 1;
    if(relLen < 39) relLen = 39;
    
    if (subFrameLenLast <= 128) numSlidingWindow = 1;
    else if (subFrameLenLast <= 256) numSlidingWindow = 2;
    else numSlidingWindow = 4;
    
    winSize = subFrameLenLast; 
    subFrameLenLast += 2 * prologSize;
    winSize = TCP_normalCeil(winSize, numSlidingWindow);
    numSubBlockLast = TCP_normalCeil(winSize, TCP_RLEN_MAX);
    relLenLast = TCP_normalCeil(winSize, numSubBlockLast) - 1;
    if (relLenLast < 39) relLenLast = 39;
    
    configParms->subFrameLen     = subFrameLen;
    configParms->relLen          = relLen;
    configParms->relLenLast      = relLenLast;
    configParms->numSubBlock     = numSubBlock;
    configParms->numSubBlockLast = numSubBlockLast;
    
    return(numSubFrame);

} /* end TCP_calcSubBlocksSP() */

/*----------------------------------------------------------------------------*/

void TCP_calcCountsSP(TCP_Params *configParms)
{
Uint32 numApriori = configParms->numApriori;
Uint32 numSysPar = configParms->numSysPar;
Uint32 numExt = configParms->numExt;
Uint32 numHd = configParms->numHd;
Uint32 subFrameLen = configParms->subFrameLen;
Uint32 prologSize = configParms->prologSize;
Uint32 frameLen = configParms->frameLen;

    if (configParms->rate == 4){
      numSysPar = TCP_ceil((subFrameLen * 10), 4);
    } /* end if rate == 4 */
    else { /* if rate != 4 */
      numSysPar = TCP_ceil(subFrameLen, 1);
    } /* end if rate != 4 */
	
	numApriori = TCP_ceil(subFrameLen, 2);
	numExt = TCP_ceil(subFrameLen - 2 * prologSize, 2);
	numHd = TCP_ceil(frameLen, 5);

    configParms->numApriori = numApriori;
    configParms->numSysPar  = numSysPar;
    configParms->numExt     = numExt;
    configParms->numHd      = numHd;
    configParms->numInter   = 0;

} /* end TCP_calcCountsSP() */

/*----------------------------------------------------------------------------*/
#ifdef NO_OPT

void TCP_interleaveExt(TCP_ExtrinsicData *restrict aprioriMap2, 
                              const TCP_ExtrinsicData *restrict extrinsicsMap1, 
                              const Uint16 *restrict interleaverTable, 
                              Uint32  numExt)
{   
Uint32 i;
    
    /* interleaving extrinsics */
    for (i=0; i<numExt; i++)
    {
      aprioriMap2[i]=*(extrinsicsMap1 + interleaverTable[i]);
    }
} /* end TCP_interleaveExt() */

/*----------------------------------------------------------------------------*/

void TCP_deinterleaveExt(TCP_ExtrinsicData *restrict aprioriMap1, 
                                const TCP_ExtrinsicData *restrict extrinsicsMap2, 
                                const Uint16 *restrict interleaverTable, 
                                 Uint32  numExt)
{
Uint32 i;
    
    /* deinterleave extrinsics */
    for (i=0; i<numExt; i++)
    {
      aprioriMap1[interleaverTable[i]]=*(extrinsicsMap2 + i);
    }
} /* end TCP_deinterleaveExt() */

/*----------------------------------------------------------------------------*/

void TCP_calculateHd(const TCP_ExtrinsicData *restrict extrinsicsMap1, 
                     const TCP_ExtrinsicData *restrict apriori, 
                     const TCP_UserData *restrict channel_data, 
                     Uint32 *restrict hardDecisions,
                     Uint16 numExt,
                     Uint8  rate)
{
Uint32 i;
Int32  extInt;
Int32  apInt;
Int32  inputInt;
Int32  softDecision;
Uint32 wordCount = 0;
Uint32 hdCount = 0;
    
    hardDecisions[0] = 0;
    
    for (i = 0; i < numExt; i++) 
    { 
      if((extrinsicsMap1[i]<<1)&0x80) 
        extInt = (extrinsicsMap1[i]<<1) | 0xffffff00; 
      else 
        extInt = (Int32)(extrinsicsMap1[i]<<1); 
             
      if((apriori[i]<<1)&0x80) 
        apInt = (apriori[i]<<1) | 0xffffff00; 
      else 
        apInt = (Int32)(apriori[i]<<1); 
  
      inputInt = (Int32)channel_data[i*rate];
          
      if(inputInt & 0x80) inputInt |= 0xFFFFFF00;
                   
      softDecision = inputInt + extInt + apInt; 
              
      if(hdCount == 32)
        {    
          hdCount = 0;
          wordCount++;
          hardDecisions[wordCount] = 0;
        }
          
      if((softDecision & 0x200) == 0)
        hardDecisions[wordCount] |= 1 << hdCount; 
         
      hdCount++; 
          
    } 
} /* end TCP_calculateHd() */

/*----------------------------------------------------------------------------*/

void TCP_demuxInput(Uint32 rate,
                        Uint32 frameLen,
                        const TCP_UserData *restrict input,
                        const Uint16 *restrict interleaver,
                        TCP_ExtrinsicData *restrict nonInterleaved,
                        TCP_ExtrinsicData *restrict interleaved)
{
Int32 i,j,k;
Uint32 tmp0, tmp1;
Uint32* output0 = (Uint32 *)nonInterleaved;
Uint32* output1 = (Uint32 *)interleaved;

/*
'interleaver' is a buffer of frameLen 16-bit indices
'input' is a buffer of frameLen * rate 8-bit elements
'output[2]' is the 2 de-multiplexed buffers :
            .out[0] buffer which is the TCP input buffer for LOG-MAP 1 decoding
            .out[1] buffer which is the TCP input buffer for LOG-MAP 2 decoding
*/
    
    switch(rate)
    {
      case 2:
/*
rate 1/2: 
input are taken by set of 8 symbols
input[...] :
00000000h    X0
00000001h    A0
00000002h    X1
00000003h    A'1
00000004h    X2
00000005h    A2
00000006h    X3
00000007h    A'3

Output are created by set of 8 symbols ordered as follow:
output[0][...]=
00000000h    X0
00000001h    X1
00000002h    X2
00000003h    X3
00000004h    A0
00000005h    A2
00000006h    0
00000007h    0

output[1][...]=
00000000h    X'0
00000001h    X'1
00000002h    X'2
00000003h    X'3
00000004h    A'1
00000005h    A'3
00000006h    0
00000007h    0
*/
      j=0;
      k=0;
        
      for (i=0; i < frameLen*rate; i+=8)
      {
        /* X0 */
        tmp0=input[i]; 
        /* X1 */
        tmp0|=input[i+2]<<8;
        /* X2 */
        tmp0|=input[i+4]<<16;
        /* X3 */
        tmp0|=input[i+6]<<24;
        /* tmp0 contains systematics X3 X2 X1 X0 */
        output0[j] = tmp0;

        /* A0 */
        tmp0=input[i+1];
        /* A2 */
        tmp0|=input[i+5]<<8;
        /* tmp0 contains parities 0 0 A2 A0*/
        output0[j+1] = tmp0;

        /* X'0 */
        tmp1=input[interleaver[k]*rate];
        /* X'1 */
        tmp1|=input[interleaver[k+1]*rate]<<8;
        /* X'2 */
        tmp1|=input[interleaver[k+2]*rate]<<16;
        /* X'3 */
        tmp1|=input[interleaver[k+3]*rate]<<24;
        /* tmp1 contains interleaved systematics X'3 X'2 X'1 X'0*/
        output1[j] = tmp1;

        k+=4;
        /* A'1 */
        tmp1=input[i+3];    
        /* A'3 */
        tmp1|=input[i+7]<<8;
        /* tmp1 contains interleaved parities 0 0 A'3 A'1 */
        output1[j+1] = tmp1;
       
        j+=2;
      }  
     
      break;
     
     
      case 3:
/*
rate 1/3:  
input are taken by set of 12 symbols
input[...] :
00000000h    X0
00000001h    A0
00000002h    A'0
00000003h    X1
00000004h    A1
00000005h    A'1
00000006h    X2
00000007h    A2
00000008h    A'2
00000009h    X3
0000000Ah    A3
0000000Bh    A'3

Output are created by set of 8 symbols ordered as follow:
output[0][...]=
00000000h    X0
00000001h    X1
00000002h    X2
00000003h    X3
00000004h    A0
00000005h    A1
00000006h    A2
00000007h    A3

output[1][...]=
00000000h    X'0
00000001h    X'1
00000002h    X'2
00000003h    X'3
00000004h    A'0
00000005h    A'1
00000006h    A'2
00000007h    A'3

*/
      j = 0;
      k=0;
     
      for (i=0;i<frameLen*rate;i+=12)
      {
        /* X0 */
        tmp0=input[i];
        /* X1 */
        tmp0|=input[i+3]<<8;
        /* X2 */
        tmp0|=input[i+6]<<16;
        /* X3 */
        tmp0|=input[i+9]<<24;
        /* tmp0 contains systematics X3 X2 X1 X0 */
        output0[j] = tmp0;

        /* A0 */
        tmp0=input[i+1];
        /* A1 */
        tmp0|=input[i+4]<<8;
        /* A2 */
        tmp0|=input[i+7]<<16;
        /* A3 */
        tmp0|=input[i+10]<<24;
        /* tmp0 contains parities A3 A2 A1 A0*/
        output0[j+1] = tmp0;
    
        /* X'0 */
        tmp1=input[interleaver[k]*rate];
        /* X'1 */
        tmp1|=input[interleaver[k+1]*rate]<<8;
        /* X'2 */
        tmp1|=input[interleaver[k+2]*rate]<<16;
        /* X'3 */
        tmp1|=input[interleaver[k+3]*rate]<<24;
        /* tmp1 contains interleaved systematics X'3 X'2 X'1 X'0 */
        output1[j] = tmp1;
    
        k+=4;

        /* A'0 */
        tmp1=input[i+2];
        /* A'1 */
        tmp1|=input[i+5]<<8;
        /* A'2 */
        tmp1|=input[i+8]<<16;
        /* A'3 */
        tmp1|=input[i+11]<<24;
        /* tmp1 contains interleaved parities A'3 A'2 A'1 A'0 */
        output1[j+1] = tmp1;
        
        j+=2;
      }  
     
      break;
     
     
      case 4:
/*
rate 1/4:
input are taken by set of 32 symbols   
input[...] :
00000000h    X0
00000001h    A0
00000002h    B0
00000003h    B'0
00000004h    X1
00000005h    A1
00000006h    A'1
00000007h    B'1
00000008h    X2
00000009h    A2
0000000Ah    B2
0000000Bh    B'2
0000000Ch    X3
0000000Dh    A3
0000000Eh    A'3
0000000Fh    B'3

Output are created by set of 10 symbols ordered as follow:
output[0][...]=
00000000h    X0
00000001h    X1
00000002h    X2
00000003h    X3
00000004h    A0
00000005h    A1
00000006h    A2
00000007h    A3
00000008h    B0
00000009h    B2

output[1][...]=
00000000h    X'0
00000001h    X'1
00000002h    X'2
00000003h    X'3
00000004h    A'1
00000005h    A'3
00000006h    B'0
00000007h    B'1
00000008h    B'2
00000009h    B'3

*/
      j = 0;
      k=0;
     
      for (i=0;i<frameLen*rate;i+=32)
      {
        /* X0 */
        tmp0=input[i];
        /* X1 */
        tmp0|=input[i+4]<<8;
        /* X2 */
        tmp0|=input[i+8]<<16;
        /* X3 */
        tmp0|=input[i+12]<<24;
        /* tmp0 contains systematics X3 X2 X1 X0 */
        output0[j] = tmp0;
        
        /* A0 */
        tmp0=input[i+1];
        /* A1 */
        tmp0|=input[i+5]<<8;
        /* A2 */
        tmp0|=input[i+9]<<16;
        /* A3 */
        tmp0|=input[i+13]<<24;
        /* tmp0 contains parities A3 A2 A1 A0 */
        output0[j+1] = tmp0;
        
        /* B0 */
        tmp0=input[i+2];
        /* B2 */
        tmp0|=input[i+10]<<8;
        /* X4 */
        tmp0|=input[i+16]<<16;  
        /* X5 */
        tmp0|=input[i+4+16]<<24;
        /* tmp0 contains systematics and parities X5 X4 B2 B0 */
        output0[j+2] = tmp0;
        
        /* X6 */
        tmp0=input[i+8+16];
        /* X7 */
        tmp0|=input[i+12+16]<<8;
        /* A4 */
        tmp0|=input[i+1+16]<<16;
        /* A5 */
        tmp0|=input[i+5+16]<<24;
        /* temp 0 contains systematics and parities A5 A4 X7 X6 */
        output0[j+3] = tmp0;
        
        /* A6 */
        tmp0=input[i+9+16];
        /* A7 */
        tmp0|=input[i+13+16]<<8;
        /* B4 */
        tmp0|=input[i+2+16]<<16;
        /* B6 */
        tmp0|=input[i+10+16]<<24;
        /* tmp0 contains parities B6 B4 A7 A6 */
        output0[j+4] = tmp0;

        /* X'0 */
        tmp1=input[interleaver[k]*rate];
        /* X'1 */
        tmp1|=input[interleaver[k+1]*rate]<<8;
        /* X'2 */
        tmp1|=input[interleaver[k+2]*rate]<<16;
        /* X'3 */
        tmp1|=input[interleaver[k+3]*rate]<<24;
        /* tmp1 contains systematics X'3 X'2 X'1 X'0 */
        output1[j] = tmp1;
        
        k+=4;

        /* B'0 */
        tmp1=input[i+3];
        /* B'1 */
        tmp1|=input[i+7]<<8;
        /* B'2 */
        tmp1|=input[i+11]<<16;
        /* B'3 */
        tmp1|=input[i+15]<<24;
        /* tmp1 contains parities B'3 B'2 B'1 B'0 */
        output1[j+1] = tmp1;
        
        /* A'1 */
        tmp1=input[i+6];
        /* A'3 */
        tmp1|=input[i+14]<<8;
        /* X'4 */
        tmp1|=input[interleaver[k]*rate]<<16;
        /* X'5 */
        tmp1|=input[interleaver[k+1]*rate]<<24;
        /* tmp1 contains parities X'5 X'4 A'3 A'1 */
        output1[j+2] = tmp1;
        
        k+=2;

        /* X'6 */
        tmp1=input[interleaver[k]*rate];
        /* X'7 */
        tmp1|=input[interleaver[k+1]*rate]<<8;
        /* B'4 */
        tmp1|=input[i+3+16]<<16;
        /* B'5 */
        tmp1|=input[i+7+16]<<24;
        /* tmp1 contains parities B'5 B'4 X'7 X'6 */
        output1[j+3] = tmp1;

        k+=2;

        /* B'6 */
        tmp1=input[i+11+16];
        /* B'7 */
        tmp1|=input[i+15+16]<<8;
        /* A'5 */
        tmp1|=input[i+6+16]<<16;
        /* A'7 */
        tmp1|=input[i+14+16]<<24;
        /* tmp1 contains parities A'7 A'5 B'7 B'6 */
        output1[j+4] = tmp1;

        j+=5;
      }
         
    /*break;
    default:
    return(-1);*/
    } 

  /*return(0);*/

} /* end TCP_demuxInput() */

#else
 #ifdef OPT_LE

/******************************************************************************\
 * TCP_demuxInput() function definition for SP mode
 * Optimized for LITTLE ENDIAN data
 * interleaver table will be read in half-words
 * input channel data in words or double words depending on the rate
 * apriori will be written in words
 * demux buffers will be written as double-words
 * demux buffer size in bytes must therefore be a multiple of 8
 *
 * Coding Rate    Code Size    Number of Cycles
 *     1/2           2448            14713
 *     1/3           2448            25037
 *     1/4           2448            35214
 *
\******************************************************************************/
void TCP_demuxInput(Uint32 rate,
                        Uint32 frameLen,
                        const TCP_UserData *restrict input,
                        const Uint16 *restrict interleaver,
                        TCP_ExtrinsicData *restrict nonInterleaved,
                        TCP_ExtrinsicData *restrict interleaved)                      
{
 
Int32 i,k;
double* out0 = (double *)nonInterleaved;
double* out1 = (double *)interleaved;
Uint8 *out0rate4=nonInterleaved;
Uint8 *out1rate4=interleaved;
const Uint8 *inputForInterleave=input;

 
    double ap3x3a2x2ap1x1a0x0, z00a2a0x3x2x1x0,z00ap3ap1xp3xp2xp1xp0;
    Uint32 ap3x3a2x2,ap1x1a0x0,x3x2x1x0,ap3a2ap1a0,z00a2a0,z00ap3ap1,xp3xp2xp1xp0;
      
    Uint32  x1ap0a0x0, x2ap1a1x1, x3ap2a2x2, yap3a3x3, a1x1a0x0, a3x3a2x2,  \
            x2ap1x1ap0, yap3x3ap2, a3a2a1a0, ap3ap2ap1ap0;
    double a3a2a1a0x3x2x1x0,ap3ap2ap1ap0xp3xp2xp1xp0;
 
    Uint32 bp1ap1bp0b0, bp3ap3bp2b2, bp3bp2bp1bp0, \
               bp2b2bp0b0, bp3ap3bp1ap1, ap3ap1b2b0, bp1ap1a1x1, bp0b0a0x0, \
               bp3ap3a3x3, bp2b2a2x2;
    double bp3bp2bp1bp0xp3xp2xp1xp0;
    double bp1ap1a1x1bp0b0a0x0, bp3ap3a3x3bp2b2a2x2;
 

/*
'interleaver' is a buffer of frameLen 16-bit indices
'input' is a buffer of frameLen * rate 8-bit elements
'interleaved' and 'nonInterleaved' are the 2 de-multiplexed buffers :
                  .nonInterleaved buffer which is the TCP input buffer for LOG-MAP 1 decoding
                  .interleaved buffer which is the TCP input buffer for LOG-MAP 2 decoding
*/

      
    switch(rate)
    {
            
      /*
      rate 1/2:                          
      input are taken by set of 8 symbols
      Output are created by set of 8 symbols ordered as follow:
            
      input[...] :          out0[...]=                   out1[...]=
      00000000h      X0        00000000h      X0          00000000h      X'0
      00000001h      A0        00000001h      X1          00000001h      X'1
      00000002h      X1        00000002h      X2          00000002h      X'2
      00000003h      A'1       00000003h      X3          00000003h      X'3
      00000004h      X2        00000004h      A0          00000004h      A'1
      00000005h      A2        00000005h      A2          00000005h      A'3
      00000006h      X3        00000006h      0           00000006h      0
      00000007h      A'3       00000007h      0           00000007h      0
      */

      case 2:
        k=0;
            
        for (i=0;i<frameLen*rate;i+=8)
        {
          ap3x3a2x2ap1x1a0x0 = _memd8((void *)input); 
          input+=8;
            
          ap3x3a2x2   = _hi(ap3x3a2x2ap1x1a0x0);
          ap1x1a0x0   = _lo(ap3x3a2x2ap1x1a0x0);
            
          x3x2x1x0    = _packl4(ap3x3a2x2,ap1x1a0x0);
          ap3a2ap1a0  = _packh4(ap3x3a2x2,ap1x1a0x0);
            
          z00a2a0      = _packl4(0,ap3a2ap1a0);
          z00ap3ap1    = _packh4(0,ap3a2ap1a0);

          /* X'0 */
          xp3xp2xp1xp0 = inputForInterleave[interleaver[k]*rate];
          /* X'1 */
          xp3xp2xp1xp0 |=inputForInterleave[interleaver[k+1]*rate]<<8;
          /* X'2 */
          xp3xp2xp1xp0 |=inputForInterleave[interleaver[k+2]*rate]<<16;
          /* X'3 */
          xp3xp2xp1xp0 |=inputForInterleave[interleaver[k+3]*rate]<<24;
          k+=4;

          z00a2a0x3x2x1x0       = _itod(z00a2a0,x3x2x1x0);
          z00ap3ap1xp3xp2xp1xp0 = _itod(z00ap3ap1,xp3xp2xp1xp0);
            
          *out0++ = z00a2a0x3x2x1x0;         
          *out1++ = z00ap3ap1xp3xp2xp1xp0;
            
        }
       
        break;


      /*
      rate 1/3:  
      input are taken by set of 12 symbols
      Output are created by set of 8 symbols ordered as follow:
            
      input[...] :           out0[...]=        out1[...]=
      00000000h      X0         00000000h      X0        00000000h      X'0
      00000001h      A0         00000001h      X1        00000001h      X'1
      00000002h      A'0        00000002h      X2        00000002h      X'2
      00000003h      X1         00000003h      X3        00000003h      X'3
      00000004h      A1         00000004h      A0        00000004h      A'0
      00000005h      A'1        00000005h      A1        00000005h      A'1
      00000006h      X2         00000006h      A2        00000006h      A'2
      00000007h      A2         00000007h      A3        00000007h      A'3
      00000008h      A'2                               
      00000009h      X3
      0000000Ah      A3
      0000000Bh      A'3
            
      */
      case 3:
            
        k=0;
       
        for (i=0;i<frameLen*rate;i+=12)
        {
          x1ap0a0x0  = _mem4((void *)input); input+=3;
          x2ap1a1x1  = _mem4((void *)input); input+=3;
          x3ap2a2x2  = _mem4((void *)input); input+=3;
          yap3a3x3   = _mem4((void *)input); input+=3;
                          
          a1x1a0x0   = _pack2(x2ap1a1x1,x1ap0a0x0);
          a3x3a2x2   = _pack2(yap3a3x3,x3ap2a2x2);
          x2ap1x1ap0 = _packh2(x2ap1a1x1,x1ap0a0x0);
          yap3x3ap2  = _packh2(yap3a3x3,x3ap2a2x2);
                          
          x3x2x1x0   = _packl4(a3x3a2x2,a1x1a0x0);
          a3a2a1a0   = _packh4(a3x3a2x2,a1x1a0x0);
             
          ap3ap2ap1ap0 = _packl4(yap3x3ap2,x2ap1x1ap0);
             
          a3a2a1a0x3x2x1x0 = _itod(a3a2a1a0,x3x2x1x0);

          // X'0 
          xp3xp2xp1xp0=inputForInterleave[interleaver[k]*rate];
          // X'1 
          xp3xp2xp1xp0|=inputForInterleave[interleaver[k+1]*rate]<<8;
          // X'2 
          xp3xp2xp1xp0|=inputForInterleave[interleaver[k+2]*rate]<<16;
          // X'3 
          xp3xp2xp1xp0|=inputForInterleave[interleaver[k+3]*rate]<<24;
          k+=4;
            
          ap3ap2ap1ap0xp3xp2xp1xp0 = _itod(ap3ap2ap1ap0,xp3xp2xp1xp0);
            
          *out0++ = a3a2a1a0x3x2x1x0;         
          *out1++ = ap3ap2ap1ap0xp3xp2xp1xp0;
       
        }
        break;

      /*
      rate 1/4:
      input are taken by set of 32 symbols   
      Output are created by set of 10 symbols ordered as follow:
            
      input[...] :            out0[...]=        out1[...]=
      00000000h      X0          00000000h      X0         00000000h      X'0
      00000001h      A0          00000001h      X1         00000001h      X'1
      00000002h      B0          00000002h      X2         00000002h      X'2
      00000003h      B'0         00000003h      X3         00000003h      X'3
      00000004h      X1          00000004h      A0         00000004h      B'0
      00000005h      A1          00000005h      A1         00000005h      B'1
      00000006h      A'1         00000006h      A2         00000006h      B'2
      00000007h      B'1         00000007h      A3         00000007h      B'3
      00000008h      X2          00000008h      B0         00000008h      A'1
      00000009h      A2          00000009h      B2         00000009h      A'3
      0000000Ah      B2                                              
      0000000Bh      B'2                                             
      0000000Ch      X3
      0000000Dh      A3
      0000000Eh      A'3
      0000000Fh      B'3
                  
      */        
      case 4:

        k=0;
             
      
        for (i=0;i<frameLen*rate;i+=16)
        {
      
          bp1ap1a1x1bp0b0a0x0 = _memd8((void *)input); input+=8;
          bp3ap3a3x3bp2b2a2x2 = _memd8((void *)input); input+=8;
                         
          bp1ap1a1x1 = _hi(bp1ap1a1x1bp0b0a0x0);
          bp0b0a0x0  = _lo(bp1ap1a1x1bp0b0a0x0);
                         
          bp3ap3a3x3 = _hi(bp3ap3a3x3bp2b2a2x2); 
          bp2b2a2x2  = _lo(bp3ap3a3x3bp2b2a2x2);
                         
          a1x1a0x0 = _pack2(bp1ap1a1x1,bp0b0a0x0);
          a3x3a2x2 = _pack2(bp3ap3a3x3,bp2b2a2x2);
          a3a2a1a0 = _packh4(a3x3a2x2,a1x1a0x0);
          x3x2x1x0 = _packl4(a3x3a2x2,a1x1a0x0);
                  
          a3a2a1a0x3x2x1x0 = _itod(a3a2a1a0,x3x2x1x0);
                  
          bp1ap1bp0b0  = _packh2(bp1ap1a1x1,bp0b0a0x0);
          bp3ap3bp2b2  = _packh2(bp3ap3a3x3,bp2b2a2x2);
          bp3bp2bp1bp0 = _packh4(bp3ap3bp2b2,bp1ap1bp0b0);
                  
          // X'0 
          xp3xp2xp1xp0=inputForInterleave[interleaver[k]*rate];
          // X'1 
          xp3xp2xp1xp0|=inputForInterleave[interleaver[k+1]*rate]<<8;
          // X'2 
          xp3xp2xp1xp0|=inputForInterleave[interleaver[k+2]*rate]<<16;
          // X'3 
          xp3xp2xp1xp0|=inputForInterleave[interleaver[k+3]*rate]<<24;
          // xp3xp2xp1xp0 contains systematics X'3 X'2 X'1 X'0 
          k+=4;
             
          bp3bp2bp1bp0xp3xp2xp1xp0 = _itod(bp3bp2bp1bp0,xp3xp2xp1xp0);
             
          //_memd8((void *)out0)=a3a2a1a0x3x2x1x0; out0+=10;
          //_memd8((void *)out1)=bp3bp2bp1bp0xp3xp2xp1xp0; out0+=10;
          _memd8((void *)out0rate4)=a3a2a1a0x3x2x1x0; 
          out0rate4+=8;
          _memd8((void *)out1rate4)=bp3bp2bp1bp0xp3xp2xp1xp0; 
          out1rate4+=8;
                         
                         
          bp2b2bp0b0 = _pack2(bp3ap3bp2b2,bp1ap1bp0b0);
          bp3ap3bp1ap1 = _packh2(bp3ap3bp2b2,bp1ap1bp0b0);
          ap3ap1b2b0 = _packl4(bp3ap3bp1ap1,bp2b2bp0b0);
             
             
          *(Uint16 *)out0rate4=(Uint16)ap3ap1b2b0;             
          out0rate4+=2;
          *(Uint16 *)out1rate4=(Uint16)(ap3ap1b2b0>>16);       
          out1rate4+=2;
             
             
        }
        break;
  
  
//      default:
//        return(-1);
      }

//      return(0);

} /* end TCP_demuxInput() */


/******************************************************************************\
 * TCP_interleaveExt() function definition for extrinsics in SP mode
 * Optimized for LITTLE ENDIAN data
 * interleaver table will be read in double-words - dummy indexes must be put
 * at the end of the interleaver table to make sure extra data must not
 * overwrite valid data
 * extrinsics will be read in bytes
 * apriori will be written in words 
 * will interleave ceil(frameLen/4) data
 * apriori buffer size in bytes must therefore be a multiple of 4
 *
 * Frame Size   Code Size   Incl. Total   Max Cycles   Min Cycles   Ave Cycles
 *   6138          436           3           7296         7214         7260
\******************************************************************************/
void TCP_interleaveExt(TCP_ExtrinsicData *restrict aprioriMap2, 
                              const TCP_ExtrinsicData *restrict extrinsicsMap1, 
                              const Uint16 *restrict interleaverTable, 
                              Uint32  numExt)
{
Uint32 i;  
const double *interleaver=(const double*)interleaverTable;
Uint32 *out=(Uint32 *)aprioriMap2;
Uint32 counter = TCP_ceil(numExt,2);
Uint32 temp,temp1;
      
    for (i=0;i<counter;i++)
    {
      temp   =extrinsicsMap1[_lo(interleaver[i])&0xffff];
      temp  |=_mpyu(extrinsicsMap1[_lo(interleaver[i])>>16],256);
      temp1  =extrinsicsMap1[_hi(interleaver[i])&0xffff];
      temp1 |=(extrinsicsMap1[_hi(interleaver[i])>>16]<<8);
      out[i] =_pack2(temp1,temp);
    } /* end for i */
      
} /* end TCP_interleaveExt() */
                         

/******************************************************************************\
 * TCP_deinterleaveExt() function definition for extrinsics in SP mode
 * Optimized for LITTLE ENDIAN data
 * tested for little endian mode - need modification for big endian
 * interleaver table will in double-words
 * extrinsics will be read in words
 * apriori will be written in bytes 
 * will deinterleave ceil(frameLen/4) data
 * apriori buffer size in bytes must therefore be a multiple of 4
 *
 * Frame Size   Code Size   Incl. Total   Max Cycles   Min Cycles   Ave Cycles
 *    6138         384           3           8628         8495         8557
\******************************************************************************/
void TCP_deinterleaveExt(TCP_ExtrinsicData *restrict aprioriMap1, 
                                const TCP_ExtrinsicData *restrict extrinsicsMap2, 
                                const Uint16 *restrict interleaverTable, 
                                 Uint32  numExt)
{
Uint32 i;  
const double *interleaver=(const double*)interleaverTable;
const Uint32 *in=(const Uint32 *)extrinsicsMap2;
Uint32 counter = TCP_ceil(numExt,2);
Uint32 temp,temp1,temp2;
Uint32 a,b,c,d;
      
    temp=in[0];
      
    for (i=0;i<counter;i++)
    {
            
      temp=in[i];
            
      temp1 = _lo(interleaver[i]);
      aprioriMap1[temp1&0xffff] = temp;
      a = _rotl(temp,24); ; 
      b = (temp1>>16)&0xFFFF; 
      aprioriMap1[b] = a;
            
      temp2 = _hi(interleaver[i]);
      aprioriMap1[temp2&0xffff] = temp>>16;
      c = _rotl(temp,8); ; 
      d =(temp2>>16)&0xFFFF; 
      aprioriMap1[d] = c;

    } /* end for i */
      
} /* end TCP_deinterleaveExt() */


/******************************************************************************\
 * TCP_calculateHd() function definition for HardDecisions in SP mode
 * Optimized for LITTLE ENDIAN data
 * tested for little endian mode - need modification for big endian/
 * extrinsics1 will be read in words
 * extrinsics2 will be read in words
 * systematics are read in bytes
 * hard decisions will be written in words
 * 
 * Frame Size   Code Size   Incl. Total   Max Cycles   Min Cycles   Ave Cycles
 *    6138         1256          3           25039        24373        24627
\******************************************************************************/
void TCP_calculateHd(const TCP_ExtrinsicData *restrict extrinsicsMap1, 
                     const TCP_ExtrinsicData *restrict apriori, 
                     const TCP_UserData *restrict channel_data, 
                     Uint32 *restrict hardDecisions,
                     Uint16 numExt,
                     Uint8  rate)
{
Uint32 i;
const Int32 *ext32MAP1=(const Int32*)extrinsicsMap1;
const Int32 *ext32MAP2=(const Int32*)apriori;
Uint32 nbWords;
Uint32 wordCounter=0;
Uint32 shift=0;
Int32 temp1,temp2,a,b,c,d;
Uint32 j=0;


    nbWords=TCP_ceil(numExt,2);
    hardDecisions[0]=0;

    for (i = 0; i < nbWords; i++) 
    { 

      temp1=ext32MAP1[i];
      temp2=ext32MAP2[i];
 
      a = ((0-_ext(channel_data[(j)*rate],24,24)-_ext(temp1,25,24)-_ext(temp2,25,24)));
          hardDecisions[wordCounter] |= ((a>>9)&0x1)<<(shift++);

      b = ((0-_ext(channel_data[(j+1)*rate],24,24)-_ext(temp1,17,24)-_ext(temp2,17,24)));
          hardDecisions[wordCounter] |= ((b>>9)&0x1)<<(shift++);

      c = ((0-_ext(channel_data[(j+2)*rate],24,24)-_ext(temp1,9,24)-_ext(temp2,9,24)));
          hardDecisions[wordCounter] |= ((c>>9)&0x1)<<(shift++);

      d = ((0-_ext(channel_data[(j+3)*rate],24,24)-_ext(temp1,1,24)-_ext(temp2,1,24)));
          hardDecisions[wordCounter] |= ((d>>9)&0x1)<<(shift++);

      j+=4;

      if ((shift & 0x1f) == 0)
      {
        hardDecisions[++wordCounter] = 0;
        shift = 0;                  
      } /* end if shift & 0x1f */

    } /* end for i */

} /* end TCP_calculateHd() */


 #endif /* OPT_LE */
#endif /* else if !NO_OPT */
 
/*******************************************************************************************\
*  TCP_init() Input parameters structure
*             set the register values from parameter structure init.
*             calls tailInitxxx functions for ic6-ic11 values
* 
\*******************************************************************************************/
/* void TCP_init(TCP_Init *Init) {

  Uint32 gie = IRQ_globalDisable();
  TCP_UserData  *restrict xabData =(Init->xabData);
  TCP_Params configParms; 
  TCP_BaseParams configBase={0,0,0,0,0,0,0,0}; 


    configParms.standard    = Init->standard;
    configParms.rate        = Init->rate;
    configParms.intFlag     = Init->intFlag;
    configParms.outParmFlag = Init->outParmFlag;
    configParms.frameLen    = Init->frameLen;
    configParms.prologSize  = Init->prologSize;
    configParms.maxIter     = Init->maxIter;
    configParms.snr         = Init->snr;

    configBase.standard = Init->standard;
    configBase.rate        = Init->rate;
    configBase.intFlag     = Init->intFlag;
    configBase.outParmFlag = Init->outParmFlag;
    configBase.frameLen    = Init->frameLen;
    configBase.prologSize  = Init->prologSize;
    configBase.maxIter     = Init->maxIter;
    configBase.snr         = Init->snr;


    TCP_genParams(&configBase, &configParms);

  
  if (configParms.mode) {  (configParms.mode) = (configParms.mode << 2) + (configParms.map); }

  
  TCP_RSET(IC0,TCP_IC0_RMK(Init->frameLen,Init->outParmFlag,Init->intFlag,Init->rate,configParms.mode));
  TCP_RSET(IC1,TCP_IC1_RMK(configParms.relLenLast,configParms.relLen,configParms.subFrameLen));
  TCP_RSET(IC2,TCP_IC2_RMK(Init->snr,Init->maxIter,configParms.numSubBlockLast,configParms.numSubBlock,Init->prologSize));
  TCP_RSET(IC3,TCP_IC3_RMK(configParms.numSysPar,configParms.numInter));
  TCP_RSET(IC4,TCP_IC4_RMK(configParms.numExt,configParms.numApriori));
  TCP_RSET(IC5,TCP_IC5_RMK(configParms.numHd));

  
  if (Init->standard == TCP_STANDARD_3GPP) {
          TCP_tailInit3GPP(configParms.mode, configParms.map, xabData);
 }  else  {
          TCP_tailInitIs2000(configParms.mode, configParms.map, Init->rate,xabData);
 } 

  IRQ_globalRestore(gie);

}*/

/****** functions set the ic6-ic11 registers based on parameter structure *****/

 void TCP_tailInit3GPP(TCP_Mode mode, TCP_Map map,TCP_UserData *restrict xabData) {
  register Uint32 tail1, tail2, tail3, tail4, tail5, tail6;
  Int32 gie;

  gie = IRQ_globalDisable();

  if ((mode == TCP_MODE_SP) && (map == TCP_MAP_MAP2)){
    /* tail1 = 0, x_t_2, x_t_1, x_t_0 */
    /* tail2 = 0, a_t_2, a_t_1, a_t_0 */
    /* tail3 = 0,   0  ,   0  ,   0   */
    /* tail4 = 0,   0  ,   0  ,   0   */
    /* tail5 = 0,   0  ,   0  ,   0   */
    /* tail6 = 0,   0  ,   0  ,   0   */
    tail1 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
    tail2 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
    tail3 = 0;
    tail4 = 0;
    tail5 = 0;
    tail6 = 0;
  } /* end if SPMAP2 */
  else if (mode == TCP_MODE_SP){
    /* tail1 = 0, xt_2, xt_1, xt_0 */
    /* tail2 = 0, at_2, at_1, at_0 */
    /* tail3 = 0,   0  ,   0  ,   0   */
    /* tail4 = 0,   0  ,   0  ,   0   */
    /* tail5 = 0,   0  ,   0  ,   0   */
    /* tail6 = 0,   0  ,   0  ,   0   */
    tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
    tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
    tail3 = 0;
    tail4 = 0;
    tail5 = 0;
    tail6 = 0;
  } /* end if SPMAP1 */
  else { /* if (mode == TCP_MODE_SA) */
    /* tail1 = 0,  xt_2,  xt_1,  xt_0 */
    /* tail2 = 0,  at_2,  at_1,  at_0 */
    /* tail3 = 0,   0  ,   0  ,   0   */
    /* tail4 = 0, x_t_2, x_t_1, x_t_0 */
    /* tail5 = 0, a_t_2, a_t_1, a_t_0 */
    /* tail6 = 0,   0  ,   0  ,   0   */
    tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
    tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
    tail3 = 0;
    tail4 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
    tail5 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
    tail6 = 0;
  } /* end if SA */

  TCP_RSET(IC6,tail1);
  TCP_RSET(IC7,tail2);
  TCP_RSET(IC8,tail3);
  TCP_RSET(IC9,tail4);
  TCP_RSET(IC10,tail5);
  TCP_RSET(IC11,tail6);

  IRQ_globalRestore(gie);
}
 /* end TCP_tailInit3GPP */
/*----------------------------------------------------------------------------*/

void TCP_tailInitIs2000(TCP_Mode mode,TCP_Map map,TCP_Rate rate,TCP_UserData *restrict xabData) {

  Int32 gie;
  Uint32 tail1, tail2, tail3, tail4, tail5, tail6;

  gie = IRQ_globalDisable();

  if ((mode == TCP_MODE_SP) && (map == TCP_MAP_MAP2)) {
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0, x_t_2, x_t_1, x_t_0 */
        /* tail2 = 0, a_t_2, a_t_1, a_t_0 */
        tail1 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
        tail2 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        tail1 = TCP_makeTailArgs(        0                 , (xabData[15]), \
                                (xabData[12]), (xabData[9]));
        tail2 = TCP_makeTailArgs(0, xabData[17], xabData[14], xabData[11]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       b_t_2     ,       b_t_1     ,       b_t_0      */
        /* tail3 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        tail1 = TCP_makeTailArgs(        0                 , (xabData[20]), \
                                (xabData[16]), (xabData[12]));
        tail2 = TCP_makeTailArgs(0, xabData[23], xabData[19], xabData[15]);
        tail3 = TCP_makeTailArgs(0, xabData[22], xabData[18], xabData[14]);
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    } /* end switch rate */
  } /* end if mode == TCP_MODE_SPMAP2 */
  /*--------------------------------------------------------------------------*/
  else if (mode == TCP_MODE_SP) { /*  && (map == TCP_MAP1) */
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0, xt_2, xt_1, xt_0 */
        /* tail2 = 0, at_2, at_1, at_0 */
        tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
        tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        tail1 = TCP_makeTailArgs(        0               , (xabData[6]), \
                                (xabData[3]), (xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[8], xabData[5], xabData[2]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, (xt_2 + _xt_2), (xt_1 + _xt_1), (xt_0 + _xt_0) */
        /* tail2 = 0,      at_2     ,      at_1     ,      at_0      */
        /* tail3 = 0,      bt_2     ,      bt_1     ,      bt_0      */
        tail1 = TCP_makeTailArgs(        0               , (xabData[8]), \
                                (xabData[4]), (xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[10], xabData[6], xabData[2]);
        tail3 = TCP_makeTailArgs(0, xabData[11], xabData[7], xabData[3]);
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    } /* end switch (rate) */
  } /* end if mode == TCP_MODE_SPMAP1 */
  /*--------------------------------------------------------------------------*/
  else { /* (mode == TCP_MODE_SA) */
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0,  xt_2,  xt_1,  xt_0 */
        /* tail2 = 0,  at_2,  at_1,  at_0 */
        /* tail3 = 0,   0  ,   0  ,   0   */
        /* tail4 = 0, x_t_2, x_t_1, x_t_0 */
        /* tail5 = 0, a_t_2, a_t_1, a_t_0 */
        /* tail6 = 0,   0  ,   0  ,   0   */
        tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
        tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
        tail3 = 0;
        tail4 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
        tail5 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, ( xt_2 +  _xt_2), ( xt_1 +  _xt_1), ( xt_0 +  _xt_0) */
        /* tail2 = 0,        at_2     ,        at_1     ,        at_0      */
        /* tail3 = 0,         0       ,         0       ,         0        */
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        /* tail3 = 0,         0       ,         0       ,         0        */
        tail1 = TCP_makeTailArgs(        0               , (xabData[6]), \
                                (xabData[3]), (xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[8], xabData[5], xabData[2]);
        tail3 = 0;
        tail4 = TCP_makeTailArgs(        0                 , (xabData[15]), \
                                (xabData[12]), (xabData[9]));
        tail5 = TCP_makeTailArgs(0, xabData[17], xabData[14], xabData[11]);
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, ( xt_2 +  _xt_2), ( xt_1 +  _xt_1), ( xt_0 +  _xt_0) */
        /* tail2 = 0,       at_2      ,       at_1      ,       at_0       */
        /* tail3 = 0,       bt_2      ,       bt_1      ,       bt_0       */
        /* tail4 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail5 = 0,      a_t_2      ,      a_t_1      ,      a_t_0       */
        /* tail6 = 0,      b_t_2      ,      b_t_1      ,      b_t_0       */
        tail1 = TCP_makeTailArgs(        0               , (xabData[8]), \
                                (xabData[4]), (xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[10], xabData[6], xabData[2]);
        tail3 = TCP_makeTailArgs(0, xabData[11], xabData[7], xabData[3]);
        tail4 = TCP_makeTailArgs(        0                 , (xabData[20]), \
                                (xabData[16]), (xabData[12]));
        tail5 = TCP_makeTailArgs(0, xabData[22], xabData[18], xabData[14]);
        tail6 = TCP_makeTailArgs(0, xabData[23], xabData[19], xabData[15]);
        break;
    } /* end switch (rate) */
  } /* end if mode == TCP_MODE_SA */
  /*--------------------------------------------------------------------------*/
  TCP_RSET(IC6,tail1);
  TCP_RSET(IC7,tail2);
  TCP_RSET(IC8,tail3);
  TCP_RSET(IC9,tail4);
  TCP_RSET(IC10,tail5);
  TCP_RSET(IC11,tail6);  


  IRQ_globalRestore(gie);
} 
/* end of TCP_tailInitIs2000() */

 
 
 
#endif /*TCP_SUPPORT*/

/******************************************************************************\
* End of csl_tcp.c
\******************************************************************************/

/*----------------------------------------------------------------------------*/
#if 0
void TCP_tailConfigIs2000(TCP_Mode mode,
        TCP_Map map,
        TCP_Rate rate,
        const TCP_UserData *restrict xabData,
        TCP_ConfigIc *restrict configIc) {

  Int32 gie;
  Uint32 tail1, tail2, tail3, tail4, tail5, tail6;

  gie = IRQ_globalDisable();

  if ((mode == TCP_MODE_SP) && (map == TCP_MAP_MAP2)) {
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0, x_t_2, x_t_1, x_t_0 */
        /* tail2 = 0, a_t_2, a_t_1, a_t_0 */
        tail1 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
        tail2 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        tail1 = TCP_makeTailArgs(        0                 , (xabData[16] + xabData[15]), \
                                (xabData[13] + xabData[12]), (xabData[10] + xabData[9]));
        tail2 = TCP_makeTailArgs(0, xabData[17], xabData[14], xabData[11]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        /* tail3 = 0,       b_t_2     ,       b_t_1     ,       b_t_0      */
        tail1 = TCP_makeTailArgs(        0                 , (xabData[21] + xabData[20]), \
                                (xabData[17] + xabData[16]), (xabData[13] + xabData[12]));
        tail2 = TCP_makeTailArgs(0, xabData[22], xabData[18], xabData[14]);
        tail3 = TCP_makeTailArgs(0, xabData[23], xabData[19], xabData[15]);
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    } /* end switch rate */
  } /* end if mode == TCP_MODE_SPMAP2 */
  /*--------------------------------------------------------------------------*/
  else if (mode == TCP_MODE_SP) { /*  && (map == TCP_MAP1) */
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0, xt_2, xt_1, xt_0 */
        /* tail2 = 0, at_2, at_1, at_0 */
        tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
        tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        tail1 = TCP_makeTailArgs(        0               , (xabData[7] + xabData[6]), \
                                (xabData[4] + xabData[3]), (xabData[1] + xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[8], xabData[5], xabData[2]);
        tail3 = 0;
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, (xt_2 + _xt_2), (xt_1 + _xt_1), (xt_0 + _xt_0) */
        /* tail2 = 0,      at_2     ,      at_1     ,      at_0      */
        /* tail3 = 0,      bt_2     ,      bt_1     ,      bt_0      */
        tail1 = TCP_makeTailArgs(        0               , (xabData[9] + xabData[8]), \
                                (xabData[5] + xabData[4]), (xabData[1] + xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[10], xabData[6], xabData[2]);
        tail3 = TCP_makeTailArgs(0, xabData[11], xabData[7], xabData[3]);
        tail4 = 0;
        tail5 = 0;
        tail6 = 0;
        break;
    } /* end switch (rate) */
  } /* end if mode == TCP_MODE_SPMAP1 */
  /*--------------------------------------------------------------------------*/
  else { /* (mode == TCP_MODE_SA) */
    switch (rate) {
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_2:
        /* tail1 = 0,  xt_2,  xt_1,  xt_0 */
        /* tail2 = 0,  at_2,  at_1,  at_0 */
        /* tail3 = 0,   0  ,   0  ,   0   */
        /* tail4 = 0, x_t_2, x_t_1, x_t_0 */
        /* tail5 = 0, a_t_2, a_t_1, a_t_0 */
        /* tail6 = 0,   0  ,   0  ,   0   */
        tail1 = TCP_makeTailArgs(0, xabData[4], xabData[2], xabData[0]);
        tail2 = TCP_makeTailArgs(0, xabData[5], xabData[3], xabData[1]);
        tail3 = 0;
        tail4 = TCP_makeTailArgs(0, xabData[10], xabData[8], xabData[6]);
        tail5 = TCP_makeTailArgs(0, xabData[11], xabData[9], xabData[7]);
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_3:
        /* tail1 = 0, ( xt_2 +  _xt_2), ( xt_1 +  _xt_1), ( xt_0 +  _xt_0) */
        /* tail2 = 0,        at_2     ,        at_1     ,        at_0      */
        /* tail3 = 0,         0       ,         0       ,         0        */
        /* tail1 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail2 = 0,       a_t_2     ,       a_t_1     ,       a_t_0      */
        /* tail3 = 0,         0       ,         0       ,         0        */
        tail1 = TCP_makeTailArgs(        0               , (xabData[7] + xabData[6]), \
                                (xabData[4] + xabData[3]), (xabData[1] + xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[8], xabData[5], xabData[2]);
        tail3 = 0;
        tail4 = TCP_makeTailArgs(        0                 , (xabData[16] + xabData[15]), \
                                (xabData[13] + xabData[12]), (xabData[10] + xabData[9]));
        tail5 = TCP_makeTailArgs(0, xabData[17], xabData[14], xabData[11]);
        tail6 = 0;
        break;
    /*------------------------------------------------------------------------*/
      case TCP_RATE_1_4:
        /* tail1 = 0, ( xt_2 +  _xt_2), ( xt_1 +  _xt_1), ( xt_0 +  _xt_0) */
        /* tail2 = 0,       at_2      ,       at_1      ,       at_0       */
        /* tail3 = 0,       bt_2      ,       bt_1      ,       bt_0       */
        /* tail4 = 0, (x_t_2 + _x_t_2), (x_t_1 + _x_t_1), (x_t_0 + _x_t_0) */
        /* tail5 = 0,      a_t_2      ,      a_t_1      ,      a_t_0       */
        /* tail6 = 0,      b_t_2      ,      b_t_1      ,      b_t_0       */
        tail1 = TCP_makeTailArgs(        0               , (xabData[9] + xabData[8]), \
                                (xabData[5] + xabData[4]), (xabData[1] + xabData[0]));
        tail2 = TCP_makeTailArgs(0, xabData[10], xabData[6], xabData[2]);
        tail3 = TCP_makeTailArgs(0, xabData[11], xabData[7], xabData[3]);
        tail4 = TCP_makeTailArgs(        0                 , (xabData[21] + xabData[20]), \
                                (xabData[17] + xabData[16]), (xabData[13] + xabData[12]));
        tail5 = TCP_makeTailArgs(0, xabData[22], xabData[18], xabData[14]);
        tail6 = TCP_makeTailArgs(0, xabData[23], xabData[19], xabData[15]);
        break;
    } /* end switch (rate) */
  } /* end if mode == TCP_MODE_SA */
  /*--------------------------------------------------------------------------*/
  
  configIc->ic6  = tail1;
  configIc->ic7  = tail2;
  configIc->ic8  = tail3;
  configIc->ic9  = tail4;
  configIc->ic10 = tail5;
  configIc->ic11 = tail6;

  IRQ_globalRestore(gie);
} /* end TCP_tailConfigIs2000 */
#endif



csl_timer.c/    1090821497  0     0     0       5297      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_timer.c
* DATE CREATED.. 06/20/1999 
* LAST MODIFIED. 07/24/2004 - Re-introduced BIOS dependency due to compatibility issues
*                Removed bios related items
*                02/12/2002 _TIMER_setBiosHandle() , TIMER_getBiosHandle()
*                12/18/2000
\******************************************************************************/
#define _TIMER_MOD_

#include <csl_timer.h>
#include <csl.h>


#if (TIMER_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/
#define DEVICE_TABLE_ENTRY(devNum) { \
  /* allocated */ FALSE, \
  /* eventId   */ (Uint32)IRQ_EVT_TINT##devNum,  \
  /* baseAddr  */ (volatile Uint32 *)_TIMER_BASE_DEV##devNum## \
}


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/

/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/
TIMER_Obj _TIMER_deviceTable[TIMER_DEVICE_CNT] = {
  DEVICE_TABLE_ENTRY(0),
  DEVICE_TABLE_ENTRY(1)
  #if (TIMER_DEVICE_CNT > 2)
    ,DEVICE_TABLE_ENTRY(2)
  #endif
};

TIMER_Handle _TIMER_hDev0 = (TIMER_Handle)(&_TIMER_deviceTable[0]);
TIMER_Handle _TIMER_hDev1 = (TIMER_Handle)(&_TIMER_deviceTable[1]);
TIMER_Handle _TIMER_hBios = INV;

/******************************************************************************\
* global function definitions
\******************************************************************************/
/*----------------------------------------------------------------------------*/
TIMER_Handle TIMER_getBiosHandle() {
      return _TIMER_hBios;
}

/*----------------------------------------------------------------------------*/
void TIMER_reset(TIMER_Handle hTimer) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hTimer == INV) {
    TIMER_reset(&_TIMER_deviceTable[0]);
    TIMER_reset(&_TIMER_deviceTable[1]);
    #if (TIMER_DEVICE_CNT > 2)
      TIMER_reset(&_TIMER_deviceTable[2]);
    #endif
  } else {
    TIMER_RSETH(hTimer,CTL,TIMER_CTL_DEFAULT);
    TIMER_RSETH(hTimer,PRD,TIMER_PRD_DEFAULT);
    TIMER_RSETH(hTimer,CNT,TIMER_CNT_DEFAULT);
    IRQ_reset(hTimer->eventId);
  }
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
void TIMER_resetAll() {

  TIMER_reset(INV); 
}
/*----------------------------------------------------------------------------*/
TIMER_Handle TIMER_open(int devNum, Uint32 flags) {

  TIMER_Handle hTimer = INV;
  Uint32 dev,gie;

  gie = IRQ_globalDisable();

  if (devNum==-1) {
    for (dev=0; dev<TIMER_DEVICE_CNT; dev++) {
      if (!_TIMER_deviceTable[dev].allocated) {
        hTimer = (TIMER_Handle)&(_TIMER_deviceTable[dev]);
        break;
      }
    }
  } else if (!_TIMER_deviceTable[devNum].allocated) {
    hTimer = (TIMER_Handle)&(_TIMER_deviceTable[devNum]);
  }

  if (hTimer != INV) {
    hTimer->allocated = TRUE;
    if (flags & TIMER_OPEN_RESET) {
      TIMER_reset(hTimer);
    }
  }

  IRQ_globalRestore(gie);

  return hTimer;
}

/*----------------------------------------------------------------------------*/
void TIMER_close(TIMER_Handle hTimer) {
  
  Uint32 gie;

  gie = IRQ_globalDisable();
  hTimer->allocated = FALSE;
  TIMER_reset(hTimer);
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/


#endif /* TIMER_SUPPORT */
/******************************************************************************\
* End of csl_timer.c
\******************************************************************************/


csl_utop.c/     1030611980  0     0     0       3130      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_utop.c
* DATE CREATED.. 07/19/2000 
* LAST MODIFIED. 10/09/2000 
\******************************************************************************/
#define _UTOP_MOD_
#include "csl_utop.h"


#if (UTOP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/
/*----------------------------------------------------------------------------*/
void UTOP_reset() {

  Uint32 gie;

  gie = IRQ_globalDisable();

  UTOP_RSET(UCR,   UTOP_UCR_DEFAULT);
  UTOP_RSET(UIER,  UTOP_UIER_DEFAULT);
  UTOP_RSET(UIPR,  0xFFFFFFFF);
  UTOP_RSET(CDR,   UTOP_CDR_DEFAULT);
  UTOP_RSET(EIER,  UTOP_EIER_DEFAULT);
  UTOP_RSET(EIPR,  0xFFFFFFFF);

  IRQ_disable(IRQ_EVT_UINT);
  IRQ_clear(IRQ_EVT_UINT);

  IRQ_globalRestore(gie);

  return;
}

/*----------------------------------------------------------------------------*/


#endif /* UTOP_SUPPORT */
/******************************************************************************\
* End of csl_utop.c
\******************************************************************************/

csl_vcp.c/      1030611981  0     0     0       12996     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vcp.c
* DATE CREATED.. 04/09/2001 
* LAST MODIFIED. 04/09/2001
\******************************************************************************/
#define _VCP_MOD_
#include "csl_vcp.h"

#if (VCP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/
void VCP_genParams(VCP_BaseParams *restrict baseParms, 
                   VCP_Params *restrict configParms){

VCP_Rate rate     = baseParms->rate;
Uint8  constLen   = baseParms->constLen;
Uint16 frameLen   = baseParms->frameLen;
Uint16 yamTh      = baseParms->yamTh;
Uint8  stateNum   = baseParms->stateNum;
Uint8  decision   = baseParms->decision;
Uint8  readFlag   = baseParms->readFlag;

Uint8        poly0    = 0;
Uint8        poly1    = 0;
Uint8        poly2    = 0;
Uint8        poly3    = 0;
Uint16       relLen   = 0;
Uint16       convDist = 0;
Uint16       maxSm    = 0x400; /* was 0xFA -changed to 0x400 on 01/08/2002 */
Uint16       minSm    = 0;
Uint8        bmBuffLen;
Uint8        decBuffLen;
Uint16       numBmFrames;
Uint16       numDecFrames;
Uint8        traceBack;

Uint16  polynomes[4];
Uint16  fMax     = 0;
Uint16  rcMax    = 0;
Uint16  multiple = 0;
Uint16  nsw      = 0;
Uint16  mask     = 0;
Uint16  length   = 0;
Uint8   i;

    if (rate == VCP_RATE_1_2){
      if (constLen == 9){
        polynomes[0] =   0561;  /*   1 + D^2 + D^3 + D^4 + D^8              */
        polynomes[1] =   0753;  /*   1 + D   + D^2 + D^3 + D^5 + D^7 + D^8  */
      } /* end if constLen == 9 */
      else if (constLen == 8){
        polynomes[0] =   0712;       /*  (712 = 111001010)   */
        polynomes[1] =   0476;       /*  (476 = 100111110)   */
      } /* end if constLen == 8 */
      else if (constLen == 7){
        polynomes[0] =   0554;       /*  (554 = 101101100)   */
        polynomes[1] =   0744;       /*  (744 = 111100100)   */
      } /* end if constLen == 7 */
      else if (constLen == 6){
        polynomes[0] =   0650;       /*  ( 65 = 110101000)   */
        polynomes[1] =   0570;       /*  ( 57 = 101111000)   */
      } /* end if constLen == 6 */
      else { /* (constLen == 5) */
        polynomes[0] =   0460;       /*  ( 46 = 100110000)   */
        polynomes[1] =   0720;       /*  ( 72 = 111010000)   */
      } /* end if constLen == 5 */
    } /* end if rate 1/2 */
    else { /* if rate 1/3 or 1/4 */  
      if (constLen == 9){
        polynomes[0] =   0557;       /*  (557 = 101101111)  */
        polynomes[1] =   0663;       /*  (663 = 110110011)  */
        polynomes[2] =   0711;       /*  (711 = 111001001)  */
        polynomes[3] =   0557;       /*  (557 = 101101111)  */
      } /* end if constLen == 9 */
      else if (constLen == 8){
        polynomes[0] =   0452;       /*  (452 = 100101010)   */
        polynomes[1] =   0662;       /*  (662 = 110110010)   */
        polynomes[2] =   0756;       /*  (756 = 111101110)   */
        polynomes[3] =   0452;       /*  (452 = 100101010)   */
      } /* end if constLen == 8 */
      else if (constLen == 7){
        polynomes[0] =   0544;       /*  (554 = 101101100)   */
        polynomes[1] =   0624;       /*  (624 = 110010100)   */
        polynomes[2] =   0764;       /*  (764 = 111110100)   */
        polynomes[3] =   0544;       /*  (554 = 101101100)   */
      } /* end if constLen == 7 */
      else if (constLen == 6){
        polynomes[0] =   0470;       /*  (47  = 100111000)   */
        polynomes[1] =   0530;       /*  (53  = 101011000)   */
        polynomes[2] =   0750;       /*  (75  = 111101000)   */
        polynomes[3] =   0470;       /*  (47  = 100111000)   */
      } /* end if constLen == 6 */
      else { /* (constLen == 5) */
        polynomes[0] =   0520;       /*  (52  = 101010000)   */
        polynomes[1] =   0660;       /*  (66  = 110110000)   */
        polynomes[2] =   0760;       /*  (76  = 111110000)   */
        polynomes[3] =   0520;       /*  (52  = 101010000)   */
      } /* end if constLen == 5 */
    } /* end if rate 1/3 or 1/4 */

    /* zero out any unneeded polynomials, based on the data rate */
    for (i = VCP_RATE_1_4; i > rate; i--){
      polynomes[i-1] = 0;
    }
    /* the polynome sent to the coprocessor has always the most
       significant bit masked */
    mask = 0x00FF;
    
    /* Polynomes coefficients */   
    poly0 = polynomes[0]&mask;
    poly1 = polynomes[1]&mask;
    poly2 = polynomes[2]&mask;
    poly3 = polynomes[3]&mask;

    /* Identify Fmax for a given constraint length and decision type */
    if (decision == VCP_DECISION_HARD){
      if (constLen == 9){
        fMax =  120;
        rcMax = 124;
        multiple = 4;
      } /* end if constLen == 9 */
      if (constLen == 8){
        fMax =  217;
        rcMax = 217;
        multiple = 7;
      } /* end if constLen == 8 */
      if (constLen == 7){
        fMax =  378;
        rcMax = 372;
        multiple = 6;
      } /* end if constLen == 7 */
      if (constLen == 6){
        fMax =  635;
        rcMax = 605;
        multiple = 5;
      } /* end if constLen == 6 */
      if (constLen == 5){
        fMax = 2044;
        rcMax = 1020;
        multiple = 4;
      } /* end if constLen == 5 */
    } /* end if hard decision */
    else { /* if soft decision */
      if (constLen == 9){
        fMax     =  24;
        relLen   =   4;
        convDist =  24;
      } /* end if constLen == 9 */
      if (constLen == 8){
        fMax     =  49;
        relLen   =  28;
        convDist =  21;
      } /* end if constLen == 8 */
      if (constLen == 7){
        fMax     =  90;
        relLen   =  60;
        convDist =  18;
      } /* end if constLen == 7 */
      if (constLen == 6){
        fMax     = 155;
        relLen   =  60;
        convDist =  15;
      } /* end if constLen == 6 */
      if (constLen == 5){
        fMax     = 508;
        relLen   =  60;
        convDist =  12;
      } /* end if constLen == 5 */
    } /* end if soft decision */
      
    if (frameLen > fMax) traceBack = VCP_TRACEBACK_MIXED;
    else traceBack = VCP_TRACEBACK_TAILED;
    
    if ((decision == VCP_DECISION_HARD) && (traceBack != VCP_TRACEBACK_TAILED)){
      convDist = 3 * (constLen - 1);
      nsw = VCP_normalCeil(frameLen, rcMax - convDist);
      relLen = multiple * VCP_normalCeil(frameLen, nsw * multiple);
    } /* end if mixed or convergent traceback modes */

    /* Setting number of symbol per XEVT and REVT depending on Rate
       (just multiple of 4/64)*/
  
    /* n. of symbols for XEVT always expressed as multiple of 4. Low 4 bits.*/
    bmBuffLen = 64 >> rate;             /* 16 for 1/2; 8 for 1/3; 4 for 1/4 */
    decBuffLen = 16;
    numDecFrames = 1;                   /* Default # frames                 */

    length = frameLen + constLen - 1;         /* calculate the frame length */
    numBmFrames = VCP_normalCeil(length, 4 * bmBuffLen);/* number of sub frames  */
    bmBuffLen = VCP_normalCeil(length, 4 * numBmFrames);/* optimal SYMX          */

    if (decision == VCP_DECISION_HARD){
      if (64 * decBuffLen < frameLen){
        numDecFrames = VCP_normalCeil(frameLen, 64 * decBuffLen);
        decBuffLen = VCP_normalCeil(frameLen, 64 * numDecFrames);
      } /* end if 64 * decBuffLen < frameLen */
      else { /* if frameLen < 64 * decBuffLen */
        numDecFrames = 1;
        decBuffLen = VCP_ceil(frameLen, 6);
      } /* end else if frameLen < 64 * decBuffLen */
    } /* end if Hard decisions  */
    else if (traceBack == VCP_TRACEBACK_TAILED) { /* Soft Dec and Tailed TB */
      if (decBuffLen < frameLen){
        numDecFrames = VCP_normalCeil(frameLen, 4 * decBuffLen);
        decBuffLen = VCP_normalCeil(frameLen, 4 * numDecFrames);
      } /* end if decBuffLen < frameLen */
      else { /* if frameLen < 64 * decBuffLen */
        numDecFrames = 1;
        decBuffLen = VCP_ceil(frameLen, 2);
      } /* end else if frameLen < 64 * decBuffLen */
    } /* end if Soft decisions and tailed traceback mode */
    else { /* Soft Dec and either convergent or mixed traceback */
      numDecFrames = VCP_normalCeil(frameLen, 4 * decBuffLen);
      decBuffLen = VCP_normalCeil(frameLen, 4 * numDecFrames);
    } /* end else if Soft decisions and convergent or mixed traceback */

    configParms->rate         = rate;
    configParms->constLen     = constLen;
    configParms->poly0        = poly0;
    configParms->poly1        = poly1;
    configParms->poly2        = poly2;
    configParms->poly3        = poly3;
    configParms->yamTh        = yamTh;
    configParms->frameLen     = frameLen;
    configParms->relLen       = relLen;
    configParms->convDist     = convDist;
    configParms->maxSm        = maxSm;
    configParms->minSm        = minSm;
    configParms->stateNum     = stateNum;
    configParms->bmBuffLen    = bmBuffLen;
    configParms->decBuffLen   = decBuffLen;
    configParms->traceBack    = traceBack;
    configParms->readFlag     = readFlag;
    configParms->decision     = decision;
    configParms->numBmFrames  = numBmFrames;
    configParms->numDecFrames = numDecFrames;

} /* end VCP_genParams() */


void VCP_genIc(VCP_Params *restrict configParms,
               VCP_ConfigIc *restrict configIc){

  Uint32 gie;
  Uint32 poly0      = configParms->poly0;
  Uint32 poly1      = configParms->poly1;
  Uint32 poly2      = configParms->poly2;
  Uint32 poly3      = configParms->poly3;
  Uint32 yamTh      = configParms->yamTh;
  Uint32 frameLen   = configParms->frameLen;
  Uint32 relLen     = configParms->relLen;
  Uint32 convDist   = configParms->convDist;
  Uint32 maxSm      = configParms->maxSm;
  Uint32 minSm      = configParms->minSm;
  Uint32 stateNum   = configParms->stateNum;
  Uint32 bmBuffLen  = configParms->bmBuffLen;
  Uint32 decBuffLen = configParms->decBuffLen;
  Uint32 traceBack  = configParms->traceBack;
  Uint32 readFlag   = configParms->readFlag;
  Uint32 decision   = configParms->decision;
  Uint32 ic0, ic1, ic2, ic3, ic4, ic5;

  gie = IRQ_globalDisable();

  ic0 = VCP_IC0_RMK(poly3,poly2,poly1,poly0);
  if (yamTh) ic1 = VCP_IC1_RMK(VCP_IC1_YAMEN_ENABLE, yamTh,VCP_IC1_ZERO_ZEROS);
  else ic1 = 0;
  ic2 = VCP_IC2_RMK(relLen,frameLen);
  ic3 = VCP_IC3_RMK(convDist);
  ic4 = VCP_IC4_RMK(minSm,maxSm);
  ic5 = VCP_IC5_RMK(decision,readFlag,traceBack,decBuffLen-1,bmBuffLen-1,stateNum);

  configIc->ic0 = ic0;
  configIc->ic1 = ic1;
  configIc->ic2 = ic2;
  configIc->ic3 = ic3;
  configIc->ic4 = ic4;
  configIc->ic5 = ic5;      
  

  IRQ_globalRestore(gie);
} /* end VCP_genIc */






/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


#endif /* VCP_SUPPORT */
/******************************************************************************\
* End of csl_vcp2.c
\******************************************************************************/


csl_vic.c/      1050408837  0     0     0       2636      `
/******************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vic.c
* DATE CREATED.. 02/21/2002 
* LAST MODIFIED.
\******************************************************************************/
#define _VIC_MOD_

#include <csl_vic.h>


#if (VIC_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/

#endif /* VIC_SUPPORT */
/******************************************************************************\
* End of csl_vic.c
\******************************************************************************/

csl_vp.c/       1091195464  0     0     0       11689     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vp.c
* DATE CREATED.. 03/1/2002 
* LAST MODIFIED. 
* 
\******************************************************************************/
#define _VP_MOD_
#include <csl_vp.h>

#if (VP_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/

/******************************************************************************\
* static macro declarations
\******************************************************************************/

/*This should match the Vp_Obj structure in csl_vp.h*/
#if (CHIP_DM642)
 #define DEVICE_ENTRY(devNum) { \
  FALSE, \
  IRQ_EVT_VINT##devNum##, \
  (volatile Uint32*)_VP_BASE_PORT##devNum##, \
  _VP_YSRCA##devNum##_ADDR, \
  _VP_CBSRCA##devNum##_ADDR, \
  _VP_CRSRCA##devNum##_ADDR, \
  _VP_YDSTA##devNum##_ADDR, \
  _VP_CBDST##devNum##_ADDR, \
  _VP_CRDST##devNum##_ADDR, \
  _VP_YSRCB##devNum##_ADDR, \
  _VP_CBSRCB##devNum##_ADDR, \
  _VP_CRSRCB##devNum##_ADDR, \
  _VP_YDSTB##devNum##_ADDR \
 }
#else
 #define DEVICE_ENTRY(devNum) { \
  FALSE, \
  IRQ_EVT_VINT##devNum##, \
  (volatile Uint32*)_VP_BASE_PORT##devNum##, \
  _VP_YSRCA##devNum##_ADDR, \
  _VP_CBSRCA##devNum##_ADDR, \
  _VP_CRSRCA##devNum##_ADDR, \
  _VP_YDSTA##devNum##_ADDR, \
  _VP_CBDST##devNum##_ADDR, \
  _VP_CRDST##devNum##_ADDR, \
 }

#endif

/******************************************************************************\
* static typedef declarations
\******************************************************************************/

/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static VP_Obj _VP_deviceTable[_VP_PORT_CNT] = {
  DEVICE_ENTRY(0)
  #if (_VP_PORT_CNT==2)
  ,DEVICE_ENTRY(1)
  #else
    #if (_VP_PORT_CNT==3)
    ,DEVICE_ENTRY(1)
    ,DEVICE_ENTRY(2)
    #endif
  #endif
};

/******************************************************************************\
* static function definitions
\******************************************************************************/

/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/

/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
void VP_reset(VP_Handle hVp) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hVp == INV) {
    VP_reset((VP_Handle)(&(_VP_deviceTable[0])));
    #if (_VP_PORT_CNT==2)
	  VP_reset((VP_Handle)(&(_VP_deviceTable[1])));
    #else
    #if (_VP_PORT_CNT==3)
      VP_reset((VP_Handle)(&(_VP_deviceTable[1])));
      VP_reset((VP_Handle)(&(_VP_deviceTable[2])));
    #endif
    #endif
  } else {

#if 1 

  /* Enable video port in PCR register if it is not */
  if(!VP_FGETH(hVp, PCR, PEREN))
  {
  	VP_FSETSH(hVp, PCR, PEREN, ENABLE);
  }

  VP_FSETSH(hVp,VPCTL,VPRST,RESET);

  /* Wait for reset to complete */
  while(VP_FGETH(hVp,VPCTL,VPRST));

#else
    VP_RSETH(hVp,PFUNC,VP_PFUNC_DEFAULT);
    VP_RSETH(hVp,PDIR,VP_PDIR_DEFAULT);
    VP_RSETH(hVp,PDOUT,VP_PDOUT_DEFAULT);
    VP_RSETH(hVp,PDSET,VP_PDSET_DEFAULT);
    VP_RSETH(hVp,PDCLR,VP_PDCLR_DEFAULT);
    VP_RSETH(hVp,PIEN,VP_PIEN_DEFAULT);
    VP_RSETH(hVp,PIPOL,VP_PIPOL_DEFAULT);
    VP_RSETH(hVp,PICLR,VP_PICLR_DEFAULT);
    VP_RSETH(hVp,VPCTL,VP_VPCTL_DEFAULT&0xFFFFBFFF);/* Reserved the VPHLT Default Value */
    VP_RSETH(hVp,VPIE,VP_VPIE_DEFAULT);
    VP_RSETH(hVp,VPIS,VP_VPIS_DEFAULT);
    VP_RSETH(hVp,VCACTL,VP_VCACTL_DEFAULT);
    VP_RSETH(hVp,VCASTRT1,VP_VCASTRT1_DEFAULT);
    VP_RSETH(hVp,VCASTOP1,VP_VCASTOP1_DEFAULT);
    VP_RSETH(hVp,VCASTRT2,VP_VCASTRT2_DEFAULT);
    VP_RSETH(hVp,VCASTOP2,VP_VCASTOP2_DEFAULT);
    VP_RSETH(hVp,VCAVINT,VP_VCAVINT_DEFAULT);
    VP_RSETH(hVp,VCATHRLD,VP_VCATHRLD_DEFAULT);
    VP_RSETH(hVp,VCAEVTCT,VP_VCAEVTCT_DEFAULT);
    VP_RSETH(hVp,VCBCTL,VP_VCBCTL_DEFAULT);
    VP_RSETH(hVp,VCBSTRT1,VP_VCBSTRT1_DEFAULT);
    VP_RSETH(hVp,VCBSTOP1,VP_VCBSTOP1_DEFAULT);
    VP_RSETH(hVp,VCBSTRT2,VP_VCBSTRT2_DEFAULT);
    VP_RSETH(hVp,VCBSTOP2,VP_VCBSTOP2_DEFAULT);
    VP_RSETH(hVp,VCBVINT,VP_VCBVINT_DEFAULT);
    VP_RSETH(hVp,VCBTHRLD,VP_VCBTHRLD_DEFAULT);
    VP_RSETH(hVp,VCBEVTCT,VP_VCBEVTCT_DEFAULT);
    VP_RSETH(hVp,TSICTL,VP_TSICTL_DEFAULT);
    VP_RSETH(hVp,TSICLKINITL,VP_TSICLKINITL_DEFAULT);
    VP_RSETH(hVp,TSICLKINITM,VP_TSICLKINITM_DEFAULT);
    VP_RSETH(hVp,TSISTCMPL,VP_TSISTCMPL_DEFAULT);
    VP_RSETH(hVp,TSISTCMPM,VP_TSISTCMPM_DEFAULT);
    VP_RSETH(hVp,TSISTMSKL,VP_TSISTMSKL_DEFAULT);
    VP_RSETH(hVp,TSISTMSKM,VP_TSISTMSKM_DEFAULT);
    VP_RSETH(hVp,TSITICKS,VP_TSITICKS_DEFAULT);
    VP_RSETH(hVp,VDCTL,VP_VDCTL_DEFAULT);
    VP_RSETH(hVp,VDFRMSZ,VP_VDFRMSZ_DEFAULT);
    VP_RSETH(hVp,VDHBLNK,VP_VDHBLNK_DEFAULT);
    VP_RSETH(hVp,VDVBLKS1,VP_VDVBLKS1_DEFAULT);
    VP_RSETH(hVp,VDVBLKE1,VP_VDVBLKE1_DEFAULT);
    VP_RSETH(hVp,VDVBLKS2,VP_VDVBLKS2_DEFAULT);
    VP_RSETH(hVp,VDVBLKE2,VP_VDVBLKE2_DEFAULT);
    VP_RSETH(hVp,VDIMGOFF1,VP_VDIMGOFF1_DEFAULT);
    VP_RSETH(hVp,VDIMGSZ1,VP_VDIMGSZ1_DEFAULT);
    VP_RSETH(hVp,VDIMGOFF2,VP_VDIMGOFF2_DEFAULT);
    VP_RSETH(hVp,VDIMGSZ2,VP_VDIMGSZ2_DEFAULT);
    VP_RSETH(hVp,VDFLDT1,VP_VDFLDT1_DEFAULT);
    VP_RSETH(hVp,VDFLDT2,VP_VDFLDT2_DEFAULT);
    VP_RSETH(hVp,VDTHRLD,VP_VDTHRLD_DEFAULT);
    VP_RSETH(hVp,VDHSYNC,VP_VDHSYNC_DEFAULT);
    VP_RSETH(hVp,VDVSYNS1,VP_VDVSYNS1_DEFAULT);
    VP_RSETH(hVp,VDVSYNE1,VP_VDVSYNE1_DEFAULT);
    VP_RSETH(hVp,VDVSYNS2,VP_VDVSYNS2_DEFAULT);
    VP_RSETH(hVp,VDVSYNE2,VP_VDVSYNE2_DEFAULT);
    VP_RSETH(hVp,VDRELOAD,VP_VDRELOAD_DEFAULT);
    VP_RSETH(hVp,VDDISPEVT,VP_VDDISPEVT_DEFAULT);
    VP_RSETH(hVp,VDCLIP,VP_VDCLIP_DEFAULT);
    VP_RSETH(hVp,VDVINT,VP_VDVINT_DEFAULT);
    VP_RSETH(hVp,VDVINT,VP_VDFBIT_DEFAULT);
    VP_RSETH(hVp,VDVINT,VP_VDVBIT1_DEFAULT);
    VP_RSETH(hVp,VDVINT,VP_VDVBIT2_DEFAULT);
#endif
	
	IRQ_reset(hVp->eventId);
  }                    
  IRQ_globalRestore(gie);
  return;              
}                      
/*----------------------------------------------------------------------------*/
void VP_resetAll() {

  VP_reset(INV);
}
/*----------------------------------------------------------------------------*/
void VP_resetCaptureChA(VP_Handle hVp) {

  Uint32 gie;

  gie = IRQ_globalDisable();

  VP_FSETSH(hVp,VCACTL,RSTCH,RESET);

  /* Wait for reset to complete */
  while(VP_FGETH(hVp, VCACTL, RSTCH));
  /* Clean up channel A related bit field in VPIE and VPIS */
  VP_FSETSH(hVp,VPIE,VIE,DISABLE);

  VP_FSETSH(hVp,VPIE,LFDA,DISABLE);
  VP_FSETSH(hVp,VPIE,SFDA,DISABLE);
  VP_FSETSH(hVp,VPIE,VINTA2,DISABLE);
  VP_FSETSH(hVp,VPIE,VINTA1,DISABLE);
  VP_FSETSH(hVp,VPIE,SERRA,DISABLE);
  VP_FSETSH(hVp,VPIE,CCMPA,DISABLE);
  VP_FSETSH(hVp,VPIE,COVRA,DISABLE);

  VP_FSETSH(hVp,VPIS,LFDA,CLEAR);
  VP_FSETSH(hVp,VPIS,SFDA,CLEAR);
  VP_FSETSH(hVp,VPIS,VINTA2,CLEAR);
  VP_FSETSH(hVp,VPIS,VINTA1,CLEAR);
  VP_FSETSH(hVp,VPIS,SERRA,CLEAR);
  VP_FSETSH(hVp,VPIS,CCMPA,CLEAR);
  VP_FSETSH(hVp,VPIS,COVRA,CLEAR);

  VP_FSETSH(hVp,VPIE,VIE,ENABLE);

  IRQ_reset(hVp->eventId);

  IRQ_globalRestore(gie);
  return;              
}
/*----------------------------------------------------------------------------*/
#if (CHIP_DM642)
 void VP_resetCaptureChB(VP_Handle hVp) {

  Uint32 gie;

  gie = IRQ_globalDisable();

  VP_FSETSH(hVp,VCBCTL,RSTCH,RESET);

  /* Wait for reset to complete */
  while(VP_FGETH(hVp, VCBCTL, RSTCH));

  /* Clean up channel B related bit field in VPIE and VPIS */
  VP_FSETSH(hVp,VPIE,VIE,DISABLE);

  VP_FSETSH(hVp,VPIE,LFDB,DISABLE);
  VP_FSETSH(hVp,VPIE,SFDB,DISABLE);
  VP_FSETSH(hVp,VPIE,VINTB2,DISABLE);
  VP_FSETSH(hVp,VPIE,VINTB1,DISABLE);
  VP_FSETSH(hVp,VPIE,SERRB,DISABLE);
  VP_FSETSH(hVp,VPIE,CCMPB,DISABLE);
  VP_FSETSH(hVp,VPIE,COVRB,DISABLE);

  VP_FSETSH(hVp,VPIS,LFDB,CLEAR);
  VP_FSETSH(hVp,VPIS,SFDB,CLEAR);
  VP_FSETSH(hVp,VPIS,VINTB2,CLEAR);
  VP_FSETSH(hVp,VPIS,VINTB1,CLEAR);
  VP_FSETSH(hVp,VPIS,SERRB,CLEAR);
  VP_FSETSH(hVp,VPIS,CCMPB,CLEAR);
  VP_FSETSH(hVp,VPIS,COVRB,CLEAR);

  VP_FSETSH(hVp,VPIE,VIE,ENABLE);

  IRQ_reset(hVp->eventId);

  IRQ_globalRestore(gie);
  return;              
 }
#endif
/*----------------------------------------------------------------------------*/
void VP_resetDisplay(VP_Handle hVp) {

  Uint32 gie;

  gie = IRQ_globalDisable();

  VP_FSETSH(hVp,VDCTL,RSTCH,RESET);

  /* Wait for reset to complete */
  while(VP_FGETH(hVp, VDCTL, RSTCH));

  /* Clean up display related bit field in VPIE and VPIS */
  VP_FSETSH(hVp,VPIE,VIE,DISABLE);

  VP_FSETSH(hVp,VPIE,DCMP,DISABLE);
  VP_FSETSH(hVp,VPIE,DUND,DISABLE);
  VP_FSETSH(hVp,VPIE,DCNA,DISABLE);

  VP_FSETSH(hVp,VPIS,DCMP,CLEAR);
  VP_FSETSH(hVp,VPIS,DUND,CLEAR);
  VP_FSETSH(hVp,VPIS,DCNA,CLEAR);

  VP_FSETSH(hVp,VPIE,VIE,ENABLE);

  IRQ_reset(hVp->eventId);


  IRQ_globalRestore(gie);
  return;              
}
/*----------------------------------------------------------------------------*/
VP_Handle VP_open(int devNum, Uint32 flags) {
                       
  Uint32 gie;          
                       
  VP_Handle hVp = INV;
                       
  gie = IRQ_globalDisable();
  if (!_VP_deviceTable[devNum].allocated) {
    hVp = &(_VP_deviceTable[devNum]);
    _VP_deviceTable[devNum].allocated = TRUE;
                       
    if (hVp != INV) {
      if (flags & VP_OPEN_RESET) {
        VP_reset(hVp);
      }                
    }                  
  }
  IRQ_globalRestore(gie);

  return hVp;
}
/*----------------------------------------------------------------------------*/
void VP_close(VP_Handle hVp) {

  Uint32 gie;

  gie = IRQ_globalDisable();
  if (hVp != INV) {
    VP_reset(hVp);
    hVp->allocated = FALSE;
  }
  IRQ_globalRestore(gie);
  return;
}
/*----------------------------------------------------------------------------*/
Uint32 VP_getPins(VP_Handle hVp) {

  return VP_RGETH(hVp,PDIN);
}
/*----------------------------------------------------------------------------*/
void VP_setPins(VP_Handle hVp, Uint32 val) {

  VP_RSETH(hVp,PDSET,val);
  return;
}
/*----------------------------------------------------------------------------*/
void VP_clearPins(VP_Handle hVp, Uint32 val) {

  VP_RSETH(hVp,PDCLR,val);
  return;
}
/*----------------------------------------------------------------------------*/

#endif /* VP_SUPPORT */
/******************************************************************************\
* End of csl_vp.c
\******************************************************************************/



csl_xbus.c/     1030611985  0     0     0       2647      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_xbus.c
* DATE CREATED.. 06/12/2000 
* LAST MODIFIED. 10/03/2000 
\******************************************************************************/
#define _XBUS_MOD_
#include "csl_xbus.h"


#if (XBUS_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/

#endif /* XBUS_SUPPORT */
/******************************************************************************\
* End of csl_xbus.c
\******************************************************************************/


csl.h/          1092218716  0     0     0       5805      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl.h
* DATE CREATED.. 06/13/2000 
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                07/24/2004 - Re-introducing BIOS components from CSL due to compatibility issues.
*                06/26/2003  Added CHIP_6411
*                06/17/2003  Added CHIP_6712C
*                05/28/2003  Added CHIP_6711C
*                03/26/2003 -  6412,DM642 check libraries 
*                10/10/2001 -  6712-6713-6414-6416-6415  check libraries
*                11/19/2003 - Removed BIOS components from CSL - _CSL_Config
*
\******************************************************************************/
#ifndef _CSL_H_
#define _CSL_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_timer.h>


/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far 
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _CSL_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* if this structure changes, be sure to also change it in csl_irq_.asm */
typedef union {
  struct {
    Uint32 biosPresent;
    _IRQ_Dispatch *dispatchTable;
    Uint32 timerUsed;
    Uint32 timerNum;
  } args;
  struct {
    TIMER_Handle hTimer;
    Uint32 *event2IntTbl;
    Uint32 *int2EventTbl;
  } ret;
} _CSL_Config;
/******************************************************************************\
* global variable declarations
\******************************************************************************/

/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void _CSL_init(_CSL_Config *config);

CSLAPI void CSL6201_LIB_();
CSLAPI void CSL6202_LIB_();
CSLAPI void CSL6203_LIB_();
CSLAPI void CSL6204_LIB_();
CSLAPI void CSL6205_LIB_();
CSLAPI void CSL6211_LIB_();
CSLAPI void CSL6701_LIB_();
CSLAPI void CSL6711_LIB_();
CSLAPI void CSL6712_LIB_();
CSLAPI void CSL6713_LIB_();
CSLAPI void CSLDA610_LIB_();
CSLAPI void CSLDM642_LIB_();
CSLAPI void CSLDM640_LIB_();
CSLAPI void CSLDM641_LIB_();
CSLAPI void CSL6412_LIB_();
CSLAPI void CSL6414_LIB_();
CSLAPI void CSL6415_LIB_();
CSLAPI void CSL6416_LIB_();
CSLAPI void CSL6711C_LIB_();
CSLAPI void CSL6712C_LIB_();
CSLAPI void CSL6411_LIB_();
/* next two options are DRI300 versions */
CSLAPI void CSL6410_LIB_();
CSLAPI void CSL6413_LIB_();
CSLAPI void CSL6418_LIB_();

/******************************************************************************\
* inline function declarations
\******************************************************************************/


/******************************************************************************\
* special inline function
\******************************************************************************/

/* This function checks to make sure that the correct library is being */
/* linked in compared to the CHIP_XXXX definition.                     */

static inline void CSL_init() {

  #if (CHIP_6201)
    CSL6201_LIB_();
  #elif (CHIP_6202)
    CSL6202_LIB_();
  #elif (CHIP_6203)
    CSL6203_LIB_();
  #elif (CHIP_6204)
    CSL6204_LIB_();
  #elif (CHIP_6205)
    CSL6205_LIB_();
  #elif (CHIP_6211)
    CSL6211_LIB_();
   #elif (CHIP_6701)
    CSL6701_LIB_();
  #elif (CHIP_6711)
    CSL6711_LIB_();
  #elif (CHIP_6712)
    CSL6712_LIB_();
  #elif (CHIP_6713)
    CSL6713_LIB_();
  #elif (CHIP_DA610)
    CSLDA610_LIB_();
  #elif (CHIP_DM642)
    CSLDM642_LIB_();
  #elif (CHIP_DM640)
    CSLDM640_LIB_();
  #elif (CHIP_DM641)
    CSLDM641_LIB_();
  #elif (CHIP_6412)
    CSL6412_LIB_();
  #elif (CHIP_6414)
    CSL6414_LIB_();
  #elif (CHIP_6415)
    CSL6415_LIB_();
 #elif (CHIP_6416)
    CSL6416_LIB_();
 #elif (CHIP_6711C)
    CSL6711C_LIB_();    
 #elif (CHIP_6712C)
    CSL6712C_LIB_();
 #elif (CHIP_6411)
    CSL6411_LIB_();
/* next three are DRI300 versions */
 #elif (CHIP_6410)
    CSL6410_LIB_();
 #elif (CHIP_6413)
    CSL6413_LIB_();
 #elif (CHIP_6418)
    CSL6418_LIB_();
 #endif

  _CSL_init((_CSL_Config*)INV);
}

/*----------------------------------------------------------------------------*/


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* _CSL_H_ */
/******************************************************************************\
* End of csl.h
\******************************************************************************/


csl_cache.h/    1092218717  0     0     0       14829     `
/******************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_cache.h
* DATE CREATED.. 06/11/1999
* LAST MODIFIED. 10/01/2001 - Addition of 192K L2 SRAM for 6713
*                04/16/2004 - Modified CACHE_ROUND_TO_LINESIZE implementation
\******************************************************************************/
#ifndef _CSL_CACHE_H_
#define _CSL_CACHE_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_cachehal.h>


#if (CACHE_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _CACHE_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/
#if (!C64_SUPPORT)
  #define CACHE_CE00   CACHE_ADDR(MAR0)
  #define CACHE_CE01   CACHE_ADDR(MAR1)
  #define CACHE_CE02   CACHE_ADDR(MAR2)
  #define CACHE_CE03   CACHE_ADDR(MAR3)
  #define CACHE_CE10   CACHE_ADDR(MAR4)
  #define CACHE_CE11   CACHE_ADDR(MAR5)
  #define CACHE_CE12   CACHE_ADDR(MAR6)
  #define CACHE_CE13   CACHE_ADDR(MAR7)
  #define CACHE_CE20   CACHE_ADDR(MAR8)
  #define CACHE_CE21   CACHE_ADDR(MAR9)
  #define CACHE_CE22   CACHE_ADDR(MAR10)
  #define CACHE_CE23   CACHE_ADDR(MAR11)
  #define CACHE_CE30   CACHE_ADDR(MAR12)
  #define CACHE_CE31   CACHE_ADDR(MAR13)
  #define CACHE_CE32   CACHE_ADDR(MAR14)
  #define CACHE_CE33   CACHE_ADDR(MAR15)
#else

  #if (CHIP_6414 | CHIP_6415 | CHIP_6416)
    
     #define CACHE_EMIFB_CE00   CACHE_ADDR(MAR96)
     #define CACHE_EMIFB_CE01   CACHE_ADDR(MAR97)
     #define CACHE_EMIFB_CE02   CACHE_ADDR(MAR98)
     #define CACHE_EMIFB_CE03   CACHE_ADDR(MAR99)
     #define CACHE_EMIFB_CE10   CACHE_ADDR(MAR100)
     #define CACHE_EMIFB_CE11   CACHE_ADDR(MAR101)
     #define CACHE_EMIFB_CE12   CACHE_ADDR(MAR102)
     #define CACHE_EMIFB_CE13   CACHE_ADDR(MAR103)
     #define CACHE_EMIFB_CE20   CACHE_ADDR(MAR104)
     #define CACHE_EMIFB_CE21   CACHE_ADDR(MAR105)
     #define CACHE_EMIFB_CE22   CACHE_ADDR(MAR106)
     #define CACHE_EMIFB_CE23   CACHE_ADDR(MAR107)
     #define CACHE_EMIFB_CE30   CACHE_ADDR(MAR108)
     #define CACHE_EMIFB_CE31   CACHE_ADDR(MAR109)
     #define CACHE_EMIFB_CE32   CACHE_ADDR(MAR110)
     #define CACHE_EMIFB_CE33   CACHE_ADDR(MAR111)

  #endif

  #define CACHE_EMIFA_CE00    CACHE_ADDR(MAR128)
  #define CACHE_EMIFA_CE01    CACHE_ADDR(MAR129)
  #define CACHE_EMIFA_CE02    CACHE_ADDR(MAR130)
  #define CACHE_EMIFA_CE03    CACHE_ADDR(MAR131)
  #define CACHE_EMIFA_CE04    CACHE_ADDR(MAR132)
  #define CACHE_EMIFA_CE05    CACHE_ADDR(MAR133)
  #define CACHE_EMIFA_CE06    CACHE_ADDR(MAR134)
  #define CACHE_EMIFA_CE07    CACHE_ADDR(MAR135)
  #define CACHE_EMIFA_CE08    CACHE_ADDR(MAR136)
  #define CACHE_EMIFA_CE09    CACHE_ADDR(MAR137)
  #define CACHE_EMIFA_CE010   CACHE_ADDR(MAR138)
  #define CACHE_EMIFA_CE011   CACHE_ADDR(MAR139)
  #define CACHE_EMIFA_CE012   CACHE_ADDR(MAR140)
  #define CACHE_EMIFA_CE013   CACHE_ADDR(MAR141)
  #define CACHE_EMIFA_CE014   CACHE_ADDR(MAR142)
  #define CACHE_EMIFA_CE015   CACHE_ADDR(MAR143)

  #define CACHE_EMIFA_CE10    CACHE_ADDR(MAR144)
  #define CACHE_EMIFA_CE11    CACHE_ADDR(MAR145)
  #define CACHE_EMIFA_CE12    CACHE_ADDR(MAR146)
  #define CACHE_EMIFA_CE13    CACHE_ADDR(MAR147)
  #define CACHE_EMIFA_CE14    CACHE_ADDR(MAR148)
  #define CACHE_EMIFA_CE15    CACHE_ADDR(MAR149)
  #define CACHE_EMIFA_CE16    CACHE_ADDR(MAR150)
  #define CACHE_EMIFA_CE17    CACHE_ADDR(MAR151)
  #define CACHE_EMIFA_CE18    CACHE_ADDR(MAR152)
  #define CACHE_EMIFA_CE19    CACHE_ADDR(MAR153)
  #define CACHE_EMIFA_CE110   CACHE_ADDR(MAR154)
  #define CACHE_EMIFA_CE111   CACHE_ADDR(MAR155)
  #define CACHE_EMIFA_CE112   CACHE_ADDR(MAR156)
  #define CACHE_EMIFA_CE113   CACHE_ADDR(MAR157)
  #define CACHE_EMIFA_CE114   CACHE_ADDR(MAR158)
  #define CACHE_EMIFA_CE115   CACHE_ADDR(MAR159)

  #define CACHE_EMIFA_CE20    CACHE_ADDR(MAR160)
  #define CACHE_EMIFA_CE21    CACHE_ADDR(MAR161)
  #define CACHE_EMIFA_CE22    CACHE_ADDR(MAR162)
  #define CACHE_EMIFA_CE23    CACHE_ADDR(MAR163)
  #define CACHE_EMIFA_CE24    CACHE_ADDR(MAR164)
  #define CACHE_EMIFA_CE25    CACHE_ADDR(MAR165)
  #define CACHE_EMIFA_CE26    CACHE_ADDR(MAR166)
  #define CACHE_EMIFA_CE27    CACHE_ADDR(MAR167)
  #define CACHE_EMIFA_CE28    CACHE_ADDR(MAR168)
  #define CACHE_EMIFA_CE29    CACHE_ADDR(MAR169)
  #define CACHE_EMIFA_CE210   CACHE_ADDR(MAR170)
  #define CACHE_EMIFA_CE211   CACHE_ADDR(MAR171)
  #define CACHE_EMIFA_CE212   CACHE_ADDR(MAR172)
  #define CACHE_EMIFA_CE213   CACHE_ADDR(MAR173)
  #define CACHE_EMIFA_CE214   CACHE_ADDR(MAR174)
  #define CACHE_EMIFA_CE215   CACHE_ADDR(MAR175)

  #define CACHE_EMIFA_CE30    CACHE_ADDR(MAR176)
  #define CACHE_EMIFA_CE31    CACHE_ADDR(MAR177)
  #define CACHE_EMIFA_CE32    CACHE_ADDR(MAR178)
  #define CACHE_EMIFA_CE33    CACHE_ADDR(MAR179)
  #define CACHE_EMIFA_CE34    CACHE_ADDR(MAR180)
  #define CACHE_EMIFA_CE35    CACHE_ADDR(MAR181)
  #define CACHE_EMIFA_CE36    CACHE_ADDR(MAR182)
  #define CACHE_EMIFA_CE37    CACHE_ADDR(MAR183)
  #define CACHE_EMIFA_CE38    CACHE_ADDR(MAR184)
  #define CACHE_EMIFA_CE39    CACHE_ADDR(MAR185)
  #define CACHE_EMIFA_CE310   CACHE_ADDR(MAR186)
  #define CACHE_EMIFA_CE311   CACHE_ADDR(MAR187)
  #define CACHE_EMIFA_CE312   CACHE_ADDR(MAR188)
  #define CACHE_EMIFA_CE313   CACHE_ADDR(MAR189)
  #define CACHE_EMIFA_CE314   CACHE_ADDR(MAR190)
  #define CACHE_EMIFA_CE315   CACHE_ADDR(MAR191)

#endif


#if (C64_SUPPORT)
    #define CACHE_L2_LINESIZE    128
    #define CACHE_L1D_LINESIZE    64
    #define CACHE_L1P_LINESIZE    32
#else
    #define CACHE_L2_LINESIZE    128
    #define CACHE_L1D_LINESIZE    32
    #define CACHE_L1P_LINESIZE    64
#endif /* C64_SUPPORT */

#define CACHE_ROUND_TO_LINESIZE(CACHE,ELCNT,ELSIZE)          \
        ((CACHE_##CACHE##_LINESIZE *                           \
         (( (((ELCNT)*(ELSIZE)) -1)/CACHE_##CACHE##_LINESIZE ) + 1))/ \
           (ELSIZE))

/******************************************************************************\
* global typedef declarations
\******************************************************************************/
#if(!C64_SUPPORT && !CHIP_6713 && !CHIP_DA610)
typedef enum {
  CACHE_64KSRAM  = 0,
  CACHE_0KCACHE  = 0,
  CACHE_48KSRAM  = 1,
  CACHE_16KCACHE = 1,
  CACHE_32KSRAM  = 2,
  CACHE_32KCACHE = 2,
  CACHE_16KSRAM  = 3,
  CACHE_48KCACHE = 3,
  CACHE_0KSRAM   = 7,
  CACHE_64KCACHE = 7
} CACHE_L2Mode;
#endif

#if (CHIP_6414 | CHIP_6415 | CHIP_6416)
typedef enum {
  CACHE_1024KSRAM = 0,
  CACHE_0KCACHE   = 0,
  CACHE_992KSRAM  = 1,
  CACHE_32KCACHE  = 1,
  CACHE_960KSRAM  = 2,
  CACHE_64KCACHE  = 2,
  CACHE_896KSRAM  = 3,
  CACHE_128KCACHE = 3,
  CACHE_768KSRAM  = 7,
  CACHE_256KCACHE = 7   /* 4-way cache 128Kbytes max */
} CACHE_L2Mode;
  #endif

#if (CHIP_6713 || CHIP_DA610)
 typedef enum {
  CACHE_256KSRAM = 0,
  CACHE_0KCACHE  = 0,
  CACHE_240KSRAM = 1,
  CACHE_16KCACHE = 1,
  CACHE_224KSRAM = 2,
  CACHE_32KCACHE = 2,
  CACHE_208KSRAM = 3,
  CACHE_48KCACHE = 3,
  CACHE_192KSRAM = 7,
  CACHE_64KCACHE = 7
} CACHE_L2Mode;
 #endif

#if (CHIP_DM642 | CHIP_6412 | CHIP_6411)
  typedef enum {
  CACHE_256KSRAM  = 0,
  CACHE_0KCACHE   = 0,
  CACHE_224KSRAM  = 1,
  CACHE_32KCACHE  = 1,
  CACHE_192KSRAM  = 2,
  CACHE_64KCACHE  = 2,
  CACHE_128KSRAM  = 3,
  CACHE_128KCACHE = 3,
  CACHE_0KSRAM    = 7,
  CACHE_256KCACHE = 7
} CACHE_L2Mode;
#endif

/* Cache sizes for the DRI300 variants
 - 6418 : 512 K 
 - 6413 : 256 K
 - 6410 : 128 K
*/

#if (CHIP_6418)
  typedef enum {
  CACHE_512KSRAM  = 0,
  CACHE_0KCACHE   = 0,
  CACHE_480KSRAM  = 1,
  CACHE_32KCACHE  = 1,
  CACHE_448KSRAM  = 2,
  CACHE_64KCACHE  = 2,
  CACHE_384KSRAM  = 3,
  CACHE_128KCACHE = 3,
  CACHE_256KSRAM  = 7,
  CACHE_256KCACHE = 7
} CACHE_L2Mode; 
#endif

#if (CHIP_6413)
  typedef enum {
  CACHE_256KSRAM  = 0,
  CACHE_0KCACHE   = 0,
  CACHE_224KSRAM  = 1,
  CACHE_32KCACHE  = 1,
  CACHE_192KSRAM  = 2,
  CACHE_64KCACHE  = 2,
  CACHE_128KSRAM  = 3,
  CACHE_128KCACHE = 3,
  CACHE_256KCACHE = 7
} CACHE_L2Mode; 
#endif

#if (CHIP_6410 | CHIP_DM641 | CHIP_DM640)
  typedef enum {
  CACHE_128KSRAM  = 0,
  CACHE_0KCACHE   = 0,
  CACHE_96KSRAM   = 1,
  CACHE_32KCACHE  = 1,
  CACHE_64KSRAM   = 2,
  CACHE_64KCACHE  = 2,
  CACHE_128KCACHE = 3 /* All other modes are invalid */
} CACHE_L2Mode; 
#endif

typedef enum {
  CACHE_L2,
  CACHE_L2ALL,
  CACHE_L1P,
  CACHE_L1PALL,
  CACHE_L1D,
  CACHE_L1DALL
} CACHE_Region;

typedef enum {
  CACHE_PCC_MAPPED = 0,
  CACHE_PCC_ENABLE = 2,
  CACHE_PCC_FREEZE = 3,
  CACHE_PCC_BYPASS = 4
} CACHE_Pcc;

/* Define macros for L2 priority Level */
#define CACHE_L2PRIURG           0
#define CACHE_L2PRIHIGH          1
#define CACHE_L2PRIMED           2
#define CACHE_L2PRILOW           3

/* Define macros for L2 Queues  */
#define CACHE_L2Q0              0
#define CACHE_L2Q1              1
#define CACHE_L2Q2              2
#define CACHE_L2Q3              3

/* Define CACHE wait flag */
typedef enum {
  CACHE_NOWAIT = 0,
  CACHE_WAIT   = 1
} CACHE_Wait;

#define CACHE_WAIT_L2WB         0x00000001
#define CACHE_WAIT_L2INV        0x00000002
#define CACHE_WAIT_L2WBINV      0x00000004
#define CACHE_WAIT_L2WBALL      0x00000008
#define CACHE_WAIT_L2WBINVALL   0x00000010
#define CACHE_WAIT_L1DINV       0x00000020
#define CACHE_WAIT_L1DWBINV     0x00000040
#define CACHE_WAIT_L1PINV       0x00000080

/*  Renaming Function  */

#define CACHE_resetEMIFA  CACHE_resetEmifa

#if (CHIP_6414 | CHIP_6415 | CHIP_6416)
  #define CACHE_resetEMIFB  CACHE_resetEmifb
#endif

/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void CACHE_reset();
CSLAPI void CACHE_resetEmifa();

#if (CHIP_6414 | CHIP_6415 | CHIP_6416)
  CSLAPI void CACHE_resetEmifb();
#endif

CSLAPI CACHE_L2Mode CACHE_setL2Mode(CACHE_L2Mode newMode);
CSLAPI CACHE_L2Mode CACHE_getL2Mode();
CSLAPI CACHE_Pcc CACHE_setPccMode(CACHE_Pcc newMode);
CSLAPI void CACHE_flush(CACHE_Region region,void *addr,Uint32 wordCnt);
CSLAPI void CACHE_clean(CACHE_Region region,void *addr,Uint32 wordCnt);
CSLAPI void CACHE_invalidate(CACHE_Region region,void *addr,Uint32 wordCnt);
CSLAPI Uint32 CACHE_getL2SramSize();

/* New API base on SPRU609 and SPRU610 */
CSLAPI void CACHE_wbL2(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait);
CSLAPI void CACHE_wbInvL2(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait);
CSLAPI void CACHE_wbAllL2(CACHE_Wait wait);
CSLAPI void CACHE_wbInvAllL2(CACHE_Wait wait);
//CSLAPI void CACHE_invAllL1d();
CSLAPI void CACHE_wbInvL1d(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait);
CSLAPI void CACHE_invL1p(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait);
CSLAPI void CACHE_invAllL1p();
CSLAPI void CACHE_wait();

#if (C64_SUPPORT)
CSLAPI void CACHE_invL2(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait);
CSLAPI void CACHE_invL1d(void *blockPtr,Uint32 byteCnt,CACHE_Wait wait);
#endif

/* new APIs with  user-determined blocksize option */
CSLAPI void CACHE_wbInvL2_blocks(void *blockPtr,Uint32 byteCnt, Uint32 blockSize);
CSLAPI void CACHE_wbL2_blocks(void *blockPtr,Uint32 byteCnt, Uint32 blockSize);


/*#if (C64_SUPPORT)
CSLAPI void CACHE_freezeL1P();
CSLAPI void CACHE_freezeL1D();
#endif */

/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL void CACHE_enableCaching(Uint32 block);
#if  (CHIP_6414 | CHIP_6415 | CHIP_6416| CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412 | CHIP_6411 | CHIP_6410 | CHIP_6413 | CHIP_6418)
IDECL void CACHE_setPriL2Req(Uint32 priority);
IDECL void CACHE_setL2Queue(Uint32 queueNum,Uint32 length);
IDECL void CACHE_resetL2Queue(Uint32 queueNum);
#endif

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void CACHE_enableCaching(Uint32 block) {

  #if (L2CACHE_SUPPORT)
    CACHE_FSETA(block,MAR,CE,1);
    while (!CACHE_FGETA(block,MAR,CE))
                   ;
  #else
    UNREFERENCED_PARAMETER(block);
  #endif
}

/*----------------------------------------------------------------------------*/
#if (CHIP_6414 | CHIP_6415 | CHIP_6416| CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412 | CHIP_6411 | CHIP_6410 | CHIP_6413 | CHIP_6418)
IDEF void CACHE_setPriL2Req(Uint32 priority) {
   CACHE_FSET(CCFG,P,priority);
 }
/*----------------------------------------------------------------------------*/
IDEF void CACHE_setL2Queue(Uint32 queueNum,Uint32 length) {
  if (queueNum ==  0 ){
     CACHE_FSET(L2ALLOC0,Q0CNT,length);
  } else {
     if (queueNum ==  1 ){
        CACHE_FSET(L2ALLOC1,Q1CNT,length);
     } else {
        if (queueNum ==  2 ){
           CACHE_FSET(L2ALLOC2,Q2CNT,length);
        } else {
           if (queueNum ==  3 ){
              CACHE_FSET(L2ALLOC3,Q3CNT,length);
           }
        }
     }
  }
}
/*----------------------------------------------------------------------------*/
IDEF void CACHE_resetL2Queue(Uint32 queueNum) {
  if (queueNum ==  0 ) {
    CACHE_FSET(L2ALLOC0,Q0CNT,6);
  } else {
     if (queueNum ==  1 ) { 
        CACHE_FSET(L2ALLOC1,Q1CNT,2);
     } else {
        if (queueNum ==  2 ) {
           CACHE_FSET(L2ALLOC2,Q2CNT,2);
        } else {
           if (queueNum ==  3 ) {
              CACHE_FSET(L2ALLOC3,Q3CNT,2);
           }
        }
     }
  }
}
#endif
/*----------------------------------------------------------------------------*/

#endif /* USEDEFS */

#endif /* CACHE_SUPPORT */
#endif /* _CSL_CACHE_H_ */
/******************************************************************************\
* End of csl_cache.h
\******************************************************************************/

csl_cachehal.h/ 1091195456  0     0     0       75781     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_cachehal.h
* DATE CREATED.. 06/12/1999 
* LAST MODIFIED. 04/13/2001
*------------------------------------------------------------------------------
* REGISTERS
*
* CCFG     - cache configuration register
* L2FBAR   - L2 flush base address register
* L2FWC    - L2 flush word count register
* L2CBAR   - L2 clean base register
* L2CWC    - L2 clean word count register
* L1PFBAR  - L1P flush base address register
* L1PFWC   - L1P flush word count register
* L1DFBAR  - L1D flush base address register
* L1DFWC   - L1D flush word count register
* L2FLUSH  - L2 flush register
* L2CLEAN  - L2 clean register
*
*
*
*
*
* New Register Names based on SPRU609 for C621x/C671x
* and
* New Register Names based on SPRU610 for C64x
*
*
* L2WBAR   - L2 writeback base address register
* L2WWC    - L2 writeback word count register
* L2WIBAR  - L2 writeback-invalidate base address register
* L2WIWC   - L2 writeback-invalidate word count register
* L2IBAR   - L2 invalidate base address register(2)
* L2IWC    - L2 invalidate word count register(2)
* L1PIBAR  - L1P invalidate base address register
* L1PIWC   - L1P invalidate word count register
* L1DWIBAR - L1D writeback-invalidate base address register
* L1DWIWC  - L1D writeback-invalidate word count register
* L1DIBAR  - L1D invalidate base address register(2)
* L1DIWC   - L1D invalidate word count register(2)
* L2WB     - L2 writeback all register
* L2WBINV  - L2 writeback-invalidate all register
*
* MAR0     - memory attribute register 0
* MAR1     - memory attribute register 1
* ...      - ...
* MARn     - memory attribute register n (1)
* L2ALLOC0 - L2 Allocation register 0    (2)
* L2ALLOC1 - L2 Allocation register 1    (2)
* L2ALLOC2 - L2 Allocation register 2    (2)
* L2ALLOC3 - L2 Allocation register 3    (2)
*
* (1) n is different between C6x1x and C64x
* (2) C64x devices only
*
\******************************************************************************/
#ifndef _CSL_CACHEHAL_H_
#define _CSL_CACHEHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (CACHE_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#define _CACHE_BASE_GLOBAL  0x01840000u
#define CACHE_L2_SUPPORT L2CACHE_SUPPORT 


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define CACHE_FMK(REG,FIELD,x)\
    _PER_FMK(CACHE,##REG,##FIELD,x)

  #define CACHE_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(CACHE,##REG,##FIELD,##SYM)
 
 
  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define CACHE_ADDR(REG)\
    _CACHE_##REG##_ADDR

  #define CACHE_RGET(REG)\
    _PER_RGET(_CACHE_##REG##_ADDR,CACHE,##REG)

  #define CACHE_RSET(REG,x)\
    _PER_RSET(_CACHE_##REG##_ADDR,CACHE,##REG,x)

  #define CACHE_FGET(REG,FIELD)\
    _CACHE_##REG##_FGET(##FIELD)

  #define CACHE_FSET(REG,FIELD,x)\
    _CACHE_##REG##_FSET(##FIELD,x)

  #define CACHE_FSETS(REG,FIELD,SYM)\
    _CACHE_##REG##_FSETS(##FIELD,##SYM)
 
 
  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define CACHE_RGETA(addr,REG)\
    _PER_RGET(addr,CACHE,##REG)

  #define CACHE_RSETA(addr,REG,x)\
    _PER_RSET(addr,CACHE,##REG,x)

  #define CACHE_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,CACHE,##REG,##FIELD)

  #define CACHE_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,CACHE,##REG,##FIELD,x)

  #define CACHE_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,CACHE,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C C F G          |
* |___________________|
*
* CCFG - cache configuration register
*
* FIELDS (msb -> lsb)
* (rw) P (1)
* (w)  IP
* (w)  ID
* (rw) L2MODE
*
* (1) only supported for C64x devices
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_CCFG_ADDR             0x01840000u

#if (C64_SUPPORT)
  #define _CACHE_CCFG_P_MASK           0xE0000000u
  #define _CACHE_CCFG_P_SHIFT          0x0000001Du
  #define  CACHE_CCFG_P_DEFAULT        0x00000000u
  #define  CACHE_CCFG_P_OF(x)          _VALUEOF(x)
  #define  CACHE_CCFG_P_URGENT         0x00000000u
  #define  CACHE_CCFG_P_HIGH           0x00000001u
  #define  CACHE_CCFG_P_MEDIUM         0x00000002u
  #define  CACHE_CCFG_P_LOW            0x00000003u
#endif

  #define _CACHE_CCFG_IP_MASK          0x00000200u
  #define _CACHE_CCFG_IP_SHIFT         0x00000009u
  #define  CACHE_CCFG_IP_DEFAULT       0x00000000u
  #define  CACHE_CCFG_IP_OF(x)         _VALUEOF(x)
  #define  CACHE_CCFG_IP_NORMAL        0x00000000u
  #define  CACHE_CCFG_IP_INVALIDATE    0x00000001u

  #define _CACHE_CCFG_ID_MASK          0x00000100u
  #define _CACHE_CCFG_ID_SHIFT         0x00000008u
  #define  CACHE_CCFG_ID_DEFAULT       0x00000000u
  #define  CACHE_CCFG_ID_OF(x)         _VALUEOF(x)
  #define  CACHE_CCFG_ID_NORMAL        0x00000000u
  #define  CACHE_CCFG_ID_INVALIDATE    0x00000001u

#if (!C64_SUPPORT)
  #define _CACHE_CCFG_L2MODE_MASK      0x00000007u
  #define _CACHE_CCFG_L2MODE_SHIFT     0x00000000u
  #define  CACHE_CCFG_L2MODE_DEFAULT   0x00000000u
  #define  CACHE_CCFG_L2MODE_OF(x)     _VALUEOF(x)
  #define  CACHE_CCFG_L2MODE_0KC       0x00000000u
  #define  CACHE_CCFG_L2MODE_16KC      0x00000001u
  #define  CACHE_CCFG_L2MODE_32KC      0x00000002u
  #define  CACHE_CCFG_L2MODE_48KC      0x00000003u
  #define  CACHE_CCFG_L2MODE_64KC      0x00000007u
#else 
  #define _CACHE_CCFG_L2MODE_MASK      0x00000007u
  #define _CACHE_CCFG_L2MODE_SHIFT     0x00000000u
  #define  CACHE_CCFG_L2MODE_DEFAULT   0x00000000u
  #define  CACHE_CCFG_L2MODE_OF(x)     _VALUEOF(x)
  #define  CACHE_CCFG_L2MODE_0KC       0x00000000u
  #define  CACHE_CCFG_L2MODE_32KC      0x00000001u
  #define  CACHE_CCFG_L2MODE_64KC      0x00000002u
  #define  CACHE_CCFG_L2MODE_128KC     0x00000003u

  #if (!(CHIP_6410 | CHIP_DM641 | CHIP_DM640))
      #define  CACHE_CCFG_L2MODE_256KC     0x00000007u /* This is an invalid mode for C6410,DM641,DM640 */
  #endif

#endif

  #define  CACHE_CCFG_OF(x)            _VALUEOF(x)

#if (!C64_SUPPORT)
  #define CACHE_CCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,CCFG,IP) \
    |_PER_FDEFAULT(CACHE,CCFG,ID) \
    |_PER_FDEFAULT(CACHE,CCFG,L2MODE) \
  )

  #define CACHE_CCFG_RMK(ip,id,l2mode) (Uint32)( \
     _PER_FMK(CACHE,CCFG,IP,ip) \
    |_PER_FMK(CACHE,CCFG,ID,id) \
    |_PER_FMK(CACHE,CCFG,L2MODE,l2mode) \
  )
#else 
  #define CACHE_CCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,CCFG,P) \
    |_PER_FDEFAULT(CACHE,CCFG,IP) \
    |_PER_FDEFAULT(CACHE,CCFG,ID) \
    |_PER_FDEFAULT(CACHE,CCFG,L2MODE) \
  )

  #define CACHE_CCFG_RMK(p,ip,id,l2mode) (Uint32)( \
     _PER_FMK(CACHE,CCFG,P,p) \
    |_PER_FMK(CACHE,CCFG,IP,ip) \
    |_PER_FMK(CACHE,CCFG,ID,id) \
    |_PER_FMK(CACHE,CCFG,L2MODE,l2mode) \
  )
#endif

  #define _CACHE_CCFG_FGET(FIELD)\
    _PER_FGET(_CACHE_CCFG_ADDR,CACHE,CCFG,##FIELD)

  #define _CACHE_CCFG_FSET(FIELD,field)\
    _PER_FSET(_CACHE_CCFG_ADDR,CACHE,CCFG,##FIELD,field)

  #define _CACHE_CCFG_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_CCFG_ADDR,CACHE,CCFG,##FIELD,##SYM)

#endif /* L2CACHE_SUPPORT */


/******************************************************************************\
* _____________________
* |                   |
* |  L 2 F B A R      |
* |___________________|
*
* L2FBAR - L2 flush base address register
*
* Fields:
* (rw) L2FBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2FBAR_ADDR           0x01844000u

  #define _CACHE_L2FBAR_L2FBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L2FBAR_L2FBAR_SHIFT   0x00000000u
  #define  CACHE_L2FBAR_L2FBAR_DEFAULT 0x00000000u
  #define  CACHE_L2FBAR_L2FBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L2FBAR_OF(x)          _VALUEOF(x)

  #define CACHE_L2FBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2FBAR,L2FBAR) \
  )

  #define CACHE_L2FBAR_RMK(l2fbar) (Uint32)( \
     _PER_FMK(CACHE,L2FBAR,L2FBAR,l2fbar) \
  )

  #define _CACHE_L2FBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L2FBAR_ADDR,CACHE,L2FBAR,##FIELD)

  #define _CACHE_L2FBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2FBAR_ADDR,CACHE,L2FBAR,##FIELD,field)

  #define _CACHE_L2FBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2FBAR_ADDR,CACHE,L2FBAR,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 2 F W C        |
* |___________________|
*
* L2FWC - L2 flush word count register
*
* Fields:
* (rw) L2FWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2FWC_ADDR           0x01844004u

  #define _CACHE_L2FWC_L2FWC_MASK     0x0000FFFFu
  #define _CACHE_L2FWC_L2FWC_SHIFT    0x00000000u
  #define  CACHE_L2FWC_L2FWC_DEFAULT  0x00000000u
  #define  CACHE_L2FWC_L2FWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L2FWC_OF(x)          _VALUEOF(x)

  #define CACHE_L2FWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2FWC,L2FWC) \
  )

  #define CACHE_L2FWC_RMK(l2fwc) (Uint32)( \
     _PER_FMK(CACHE,L2FWC,L2FWC,l2fwc) \
  )

  #define _CACHE_L2FWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L2FWC_ADDR,CACHE,L2FWC,##FIELD)

  #define _CACHE_L2FWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2FWC_ADDR,CACHE,L2FWC,##FIELD,field)

  #define _CACHE_L2FWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2FWC_ADDR,CACHE,L2FWC,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 2 C B A R      |
* |___________________|
*
* L2CBAR - L2 clean base address register
*
* Fields:
* (rw) L2CBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2CBAR_ADDR           0x01844010u

  #define _CACHE_L2CBAR_L2CBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L2CBAR_L2CBAR_SHIFT   0x00000000u
  #define  CACHE_L2CBAR_L2CBAR_DEFAULT 0x00000000u
  #define  CACHE_L2CBAR_L2CBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L2CBAR_OF(x)          _VALUEOF(x)

  #define CACHE_L2CBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2CBAR,L2CBAR) \
  )

  #define CACHE_L2CBAR_RMK(l2cbar) (Uint32)( \
     _PER_FMK(CACHE,L2CBAR,L2CBAR,l2cbar) \
  )

  #define _CACHE_L2CBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L2CBAR_ADDR,CACHE,L2CBAR,##FIELD)

  #define _CACHE_L2CBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2CBAR_ADDR,CACHE,L2CBAR,##FIELD,field)

  #define _CACHE_L2CBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2CBAR_ADDR,CACHE,L2CBAR,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 2 C W C        |
* |___________________|
*
* L2CWC - L2 clean word count register
*
* Fields:
* (rw) L2CWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2CWC_ADDR           0x01844014u

  #define _CACHE_L2CWC_L2CWC_MASK     0x0000FFFFu
  #define _CACHE_L2CWC_L2CWC_SHIFT    0x00000000u
  #define  CACHE_L2CWC_L2CWC_DEFAULT  0x00000000u
  #define  CACHE_L2CWC_L2CWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L2CWC_OF(x)          _VALUEOF(x)

  #define CACHE_L2CWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2CWC,L2CWC) \
  )

  #define CACHE_L2CWC_RMK(l2cwc) (Uint32)( \
     _PER_FMK(CACHE,L2CWC,L2CWC,l2cwc) \
  )

  #define _CACHE_L2CWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L2CWC_ADDR,CACHE,L2CWC,##FIELD)

  #define _CACHE_L2CWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2CWC_ADDR,CACHE,L2CWC,##FIELD,field)

  #define _CACHE_L2CWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2CWC_ADDR,CACHE,L2CWC,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 1 P F B A R    |
* |___________________|
*
* L1PFBAR - L1P flush base address register
*
* Fields:
* (rw) L1PFBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
   #define _CACHE_L1PFBAR_ADDR            0x01844020u

  #define _CACHE_L1PFBAR_L1PFBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L1PFBAR_L1PFBAR_SHIFT   0x00000000u
  #define  CACHE_L1PFBAR_L1PFBAR_DEFAULT 0x00000000u
  #define  CACHE_L1PFBAR_L1PFBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L1PFBAR_OF(x)           _VALUEOF(x)

  #define CACHE_L1PFBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1PFBAR,L1PFBAR) \
  )

  #define _CACHE_L1PFBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L1PFBAR_ADDR,CACHE,L1PFBAR,##FIELD)

  #define _CACHE_L1PFBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1PFBAR_ADDR,CACHE,L1PFBAR,##FIELD,field)

  #define _CACHE_L1PFBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1PFBAR_ADDR,CACHE,L1PFBAR,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 1 P F W C      |
* |___________________|
*
* L1PFWC - L1P flush word count register
*
* Fields:
* (rw) L1PFWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L1PFWC_ADDR            0x01844024u

  #define _CACHE_L1PFWC_L1PFWC_MASK     0x0000FFFFu
  #define _CACHE_L1PFWC_L1PFWC_SHIFT    0x00000000u
  #define  CACHE_L1PFWC_L1PFWC_DEFAULT  0x00000000u
  #define  CACHE_L1PFWC_L1PFWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L1PFWC_OF(x)           _VALUEOF(x)

  #define CACHE_L1PFWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1PFWC,L1PFWC) \
  )

  #define CACHE_L1PFWC_RMK(l1pfwc) (Uint32)( \
     _PER_FMK(CACHE,L1PFWC,L1PFWC,l1pfwc) \
  )

  #define _CACHE_L1PFWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L1PFWC_ADDR,CACHE,L1PFWC,##FIELD)

  #define _CACHE_L1PFWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1PFWC_ADDR,CACHE,L1PFWC,##FIELD,field)

  #define _CACHE_L1PFWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1PFWC_ADDR,CACHE,L1PFWC,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 1 D F B A R    |
* |___________________|
*
* L1DFBAR - L1D flush base address register
*
* Fields:
* (rw) L1DFBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L1DFBAR_ADDR            0x01844030u

  #define _CACHE_L1DFBAR_L1DFBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L1DFBAR_L1DFBAR_SHIFT   0x00000000u
  #define  CACHE_L1DFBAR_L1DFBAR_DEFAULT 0x00000000u
  #define  CACHE_L1DFBAR_L1DFBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L1DFBAR_OF(x)           _VALUEOF(x)

  #define CACHE_L1DFBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1DFBAR,L1DFBAR) \
  )

  #define CACHE_L1DFBAR_RMK(l1dfbar) (Uint32)( \
     _PER_FMK(CACHE,L1DFBAR,L1DFBAR,l1dfbar) \
  )

  #define _CACHE_L1DFBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L1DFBAR_ADDR,CACHE,L1DFBAR,##FIELD)

  #define _CACHE_L1DFBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1DFBAR_ADDR,CACHE,L1DFBAR,##FIELD,field)

  #define _CACHE_L1DFBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1DFBAR_ADDR,CACHE,L1DFBAR,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 1 D F W C      |
* |___________________|
*
* L1DFWC - L1D flush word count register
*
* Fields:
* (rw) L1DFWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L1DFWC_ADDR            0x01844034u

  #define _CACHE_L1DFWC_L1DFWC_MASK     0x0000FFFFu
  #define _CACHE_L1DFWC_L1DFWC_SHIFT    0x00000000u
  #define  CACHE_L1DFWC_L1DFWC_DEFAULT  0x00000000u
  #define  CACHE_L1DFWC_L1DFWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L1DFWC_OF(x)           _VALUEOF(x)

  #define CACHE_L1DFWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1DFWC,L1DFWC) \
  )

  #define CACHE_L1DFWC_RMK(l1dfwc) (Uint32)( \
     _PER_FMK(CACHE,L1DFWC,L1DFWC,l1dfwc) \
  )

  #define _CACHE_L1DFWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L1DFWC_ADDR,CACHE,L1DFWC,##FIELD)

  #define _CACHE_L1DFWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1DFWC_ADDR,CACHE,L1DFWC,##FIELD,field)

  #define _CACHE_L1DFWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1DFWC_ADDR,CACHE,L1DFWC,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 2 F L U S H    |
* |___________________|
*
* L2FLUSH - L2 flush register
*
* Fields:
* (rw) F
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2FLUSH_ADDR      0x01845000u

  #define _CACHE_L2FLUSH_F_MASK    0x00000001u
  #define _CACHE_L2FLUSH_F_SHIFT   0x00000000u
  #define  CACHE_L2FLUSH_F_DEFAULT 0x00000000u
  #define  CACHE_L2FLUSH_F_OF(x)   _VALUEOF(x)
  #define  CACHE_L2FLUSH_F_NORMAL  0x00000000u
  #define  CACHE_L2FLUSH_F_FLUSH   0x00000001u

  #define  CACHE_L2FLUSH_OF(x)     _VALUEOF(x)

  #define CACHE_L2FLUSH_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2FLUSH,F) \
  )

  #define CACHE_L2FLUSH_RMK(f) (Uint32)( \
     _PER_FMK(CACHE,L2FLUSH,F,f) \
  )

  #define _CACHE_L2FLUSH_FGET(FIELD)\
    _PER_FGET(_CACHE_L2FLUSH_ADDR,CACHE,L2FLUSH,##FIELD)

  #define _CACHE_L2FLUSH_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2FLUSH_ADDR,CACHE,L2FLUSH,##FIELD,field)

  #define _CACHE_L2FLUSH_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2FLUSH_ADDR,CACHE,L2FLUSH,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 2 C L E A N    |
* |___________________|
*
* L2CLEAN - L2 clean register
*
* Fields:
* (rw) C
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2CLEAN_ADDR       0x01845004u

  #define _CACHE_L2CLEAN_C_MASK     0x00000001u
  #define _CACHE_L2CLEAN_C_SHIFT    0x00000000u
  #define  CACHE_L2CLEAN_C_DEFAULT  0x00000000u
  #define  CACHE_L2CLEAN_C_OF(x)    _VALUEOF(x)
  #define  CACHE_L2CLEAN_C_NORMAL   0x00000000u
  #define  CACHE_L2CLEAN_C_CLEAN    0x00000001u

  #define  CACHE_L2CLEAN_OF(x)      _VALUEOF(x)

  #define CACHE_L2CLEAN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2CLEAN,C) \
  )

  #define CACHE_L2CLEAN_RMK(c) (Uint32)( \
     _PER_FMK(CACHE,L2CLEAN,C,c) \
  )

  #define _CACHE_L2CLEAN_FGET(FIELD)\
    _PER_FGET(_CACHE_L2CLEAN_ADDR,CACHE,L2CLEAN,##FIELD)

  #define _CACHE_L2CLEAN_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2CLEAN_ADDR,CACHE,L2CLEAN,##FIELD,field)

  #define _CACHE_L2CLEAN_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2CLEAN_ADDR,CACHE,L2CLEAN,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 2 A L L O C 0  |
* |___________________|
*
* L2ALLOC0 - L2 allocation register 0 (1)
*
* Fields:
* (rw) Q0CNT (2) (3)
*
* (1) only supported for C6400
* (2) default value is different from L2ALLOC1, L2ALLOC2, L2ALLOC3
* (3) Rename bit filed based on spru610
*
\******************************************************************************/
#if (L2CACHE_SUPPORT && C64_SUPPORT)
  #define _CACHE_L2ALLOC0_ADDR               0x01842000u

  #define _CACHE_L2ALLOC0_Q0CNT_MASK       0x00000007u
  #define _CACHE_L2ALLOC0_Q0CNT_SHIFT      0x00000000u
  #define  CACHE_L2ALLOC0_Q0CNT_DEFAULT    0x00000006u
  #define  CACHE_L2ALLOC0_Q0CNT_OF(x)      _VALUEOF(x)

  #define _CACHE_L2ALLOC0_L2ALLOC_MASK       _CACHE_L2ALLOC0_Q0CNT_MASK   
  #define _CACHE_L2ALLOC0_L2ALLOC_SHIFT      _CACHE_L2ALLOC0_Q0CNT_SHIFT  
  #define  CACHE_L2ALLOC0_L2ALLOC_DEFAULT     CACHE_L2ALLOC0_Q0CNT_DEFAULT
  #define  CACHE_L2ALLOC0_L2ALLOC_OF(x)       CACHE_L2ALLOC0_Q0CNT_OF(x)  

  #define  CACHE_L2ALLOC0_OF(x)            _VALUEOF(x)

  #define CACHE_L2ALLOC0_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2ALLOC0,Q0CNT) \
  )

  #define CACHE_L2ALLOC0_RMK(q0cnt)(Uint32)( \
     _PER_FMK(CACHE,L2ALLOC0,Q0CNT,q0cnt) \
  )

  #define _CACHE_L2ALLOC0_FGET(FIELD)\
    _PER_FGET(_CACHE_L2ALLOC0_ADDR,CACHE,L2ALLOC0,##FIELD)

  #define _CACHE_L2ALLOC0_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2ALLOC0_ADDR,CACHE,L2ALLOC0,##FIELD,field)

  #define _CACHE_L2ALLOC0_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2ALLOC0_ADDR,CACHE,L2ALLOC0,##FIELD,##SYM)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 2 A L L O C 1  |
* |___________________|
*
* L2ALLOC1 - L2 allocation register 1 (1)
*
* Fields:
* (rw) Q1CNT (2)
*
* (1) only supported for C6400
* (2) Rename bit filed based on spru610
*
\******************************************************************************/
#if (L2CACHE_SUPPORT && C64_SUPPORT)
  #define _CACHE_L2ALLOC1_ADDR             0x01842004u

  #define _CACHE_L2ALLOC1_Q1CNT_MASK       0x00000007u
  #define _CACHE_L2ALLOC1_Q1CNT_SHIFT      0x00000000u
  #define  CACHE_L2ALLOC1_Q1CNT_DEFAULT    0x00000002u
  #define  CACHE_L2ALLOC1_Q1CNT_OF(x)      _VALUEOF(x)

  #define _CACHE_L2ALLOC1_L2ALLOC_MASK     _CACHE_L2ALLOC1_Q1CNT_MASK   
  #define _CACHE_L2ALLOC1_L2ALLOC_SHIFT    _CACHE_L2ALLOC1_Q1CNT_SHIFT  
  #define  CACHE_L2ALLOC1_L2ALLOC_DEFAULT   CACHE_L2ALLOC1_Q1CNT_DEFAULT
  #define  CACHE_L2ALLOC1_L2ALLOC_OF(x)     CACHE_L2ALLOC1_Q1CNT_OF(x)  

  #define  CACHE_L2ALLOC1_OF(x)            _VALUEOF(x)

  #define CACHE_L2ALLOC1_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2ALLOC1,Q1CNT) \
  )

  #define CACHE_L2ALLOC1_RMK(q1cnt) (Uint32)( \
     _PER_FMK(CACHE,L2ALLOC1,Q1CNT,q1cnt) \
  )

  #define _CACHE_L2ALLOC1_FGET(FIELD)\
    _PER_FGET(_CACHE_L2ALLOC1_ADDR,CACHE,L2ALLOC1,##FIELD)

  #define _CACHE_L2ALLOC1_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2ALLOC1_ADDR,CACHE,L2ALLOC1,##FIELD,field)

  #define _CACHE_L2ALLOC1_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2ALLOC1_ADDR,CACHE,L2ALLOC1,##FIELD,##SYM)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 2 A L L O C 2  |
* |___________________|
*
* L2ALLOC2 - L2 allocation register 2 (1)
*
* Fields:
* (rw) Q2CNT (2)
*
* (1) only supported for C6400
* (2) Rename bit filed based on spru610
*
\******************************************************************************/
#if (L2CACHE_SUPPORT && C64_SUPPORT)
  #define _CACHE_L2ALLOC2_ADDR               0x01842008u

  #define _CACHE_L2ALLOC2_Q2CNT_MASK       0x00000007u
  #define _CACHE_L2ALLOC2_Q2CNT_SHIFT      0x00000000u
  #define  CACHE_L2ALLOC2_Q2CNT_DEFAULT    0x00000002u
  #define  CACHE_L2ALLOC2_Q2CNT_OF(x)      _VALUEOF(x)

  #define _CACHE_L2ALLOC2_L2ALLOC_MASK       _CACHE_L2ALLOC2_Q2CNT_MASK   
  #define _CACHE_L2ALLOC2_L2ALLOC_SHIFT      _CACHE_L2ALLOC2_Q2CNT_SHIFT  
  #define  CACHE_L2ALLOC2_L2ALLOC_DEFAULT     CACHE_L2ALLOC2_Q2CNT_DEFAULT
  #define  CACHE_L2ALLOC2_L2ALLOC_OF(x)       CACHE_L2ALLOC2_Q2CNT_OF(x)  

  #define  CACHE_L2ALLOC2_OF(x)            _VALUEOF(x)

  #define CACHE_L2ALLOC2_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2ALLOC2,Q2CNT) \
  )

  #define CACHE_L2ALLOC2_RMK(q2cnt) (Uint32)( \
     _PER_FMK(CACHE,L2ALLOC2,Q2CNT,q2cnt) \
  )

  #define _CACHE_L2ALLOC2_FGET(FIELD)\
    _PER_FGET(_CACHE_L2ALLOC2_ADDR,CACHE,L2ALLOC2,##FIELD)

  #define _CACHE_L2ALLOC2_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2ALLOC2_ADDR,CACHE,L2ALLOC2,##FIELD,field)

  #define _CACHE_L2ALLOC2_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2ALLOC2_ADDR,CACHE,L2ALLOC2,##FIELD,##SYM)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 2 A L L O C 3  |
* |___________________|
*
* L2ALLOC3 - L2 allocation register 3 (1)
*
* Fields:
* (rw) Q2CNT (2)
*
* (1) only supported for C6400
* (2) Rename bit filed based on spru610
*
\******************************************************************************/
#if (L2CACHE_SUPPORT && C64_SUPPORT)
  #define _CACHE_L2ALLOC3_ADDR               0x0184200Cu

  #define _CACHE_L2ALLOC3_Q3CNT_MASK       0x00000007u
  #define _CACHE_L2ALLOC3_Q3CNT_SHIFT      0x00000000u
  #define  CACHE_L2ALLOC3_Q3CNT_DEFAULT    0x00000002u
  #define  CACHE_L2ALLOC3_Q3CNT_OF(x)      _VALUEOF(x)

  #define _CACHE_L2ALLOC3_L2ALLOC_MASK       _CACHE_L2ALLOC3_Q3CNT_MASK    
  #define _CACHE_L2ALLOC3_L2ALLOC_SHIFT      _CACHE_L2ALLOC3_Q3CNT_SHIFT   
  #define  CACHE_L2ALLOC3_L2ALLOC_DEFAULT     CACHE_L2ALLOC3_Q3CNT_DEFAULT 
  #define  CACHE_L2ALLOC3_L2ALLOC_OF(x)       CACHE_L2ALLOC3_Q3CNT_OF(x)   

  #define  CACHE_L2ALLOC3_OF(x)            _VALUEOF(x)

  #define CACHE_L2ALLOC3_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2ALLOC3,Q3CNT) \
  )

  #define CACHE_L2ALLOC3_RMK(q3cnt) (Uint32)( \
     _PER_FMK(CACHE,L2ALLOC3,Q3CNT,q3cnt) \
  )

  #define _CACHE_L2ALLOC3_FGET(FIELD)\
    _PER_FGET(_CACHE_L2ALLOC3_ADDR,CACHE,L2ALLOC3,##FIELD)

  #define _CACHE_L2ALLOC3_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2ALLOC3_ADDR,CACHE,L2ALLOC3,##FIELD,field)

  #define _CACHE_L2ALLOC3_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2ALLOC3_ADDR,CACHE,L2ALLOC3,##FIELD,##SYM)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  M A R            |
* |___________________|
*
* MAR0   - memory attribute register 0 (1)
* MAR1   - memory attribute register 1 (1)
* MAR2   - memory attribute register 2 (1)
* ...    - ...
* MARn   - memory attribute register n (2)
*
* Fields:
* (rw) NR (3)
* (rw) NW (3)
* (rw) PE (3)
* (rw) CE (4)
*
* (1) register values are read only for C6400 
* (2) n = 15 for C6211/C6711, n = 255 for C6400
* (3) only supported for C6400
* (4) only supported for C6211/C6711
* (5) MARn range for C6211/C6711 are from MAR0 ~ MAR15,
*     MARn range for C6400 are:
*     MAR0   ~ MAR2   : register values read only
*     MAR48  ~ MAR51  : McBSP0 
*     MAR52  ~ MAR55  : McBSP1 
*     MAR56  ~ MAR59  : McBSP2 
*     MAR60  ~ MAR63  : UTOPIAII 
*     MAR64  ~ MAR79  : HPI/PCI 
*     MAR96  ~ MAR111 : EMIFB (1)
*     MAR128 ~ MAR191 : EMIFA 
*
* (1) only in C6414, C6415, C6416 variants
\******************************************************************************/
#if (L2CACHE_SUPPORT && !C64_SUPPORT)
  #define _CACHE_MAR0_ADDR             _CACHE_MAR128_ADDR 
  #define _CACHE_MAR1_ADDR             _CACHE_MAR129_ADDR 
  #define _CACHE_MAR2_ADDR             _CACHE_MAR130_ADDR 
  #define _CACHE_MAR3_ADDR             _CACHE_MAR131_ADDR 
  #define _CACHE_MAR4_ADDR             _CACHE_MAR144_ADDR 
  #define _CACHE_MAR5_ADDR             _CACHE_MAR145_ADDR 
  #define _CACHE_MAR6_ADDR             _CACHE_MAR146_ADDR 
  #define _CACHE_MAR7_ADDR             _CACHE_MAR147_ADDR 
  #define _CACHE_MAR8_ADDR             _CACHE_MAR160_ADDR 
  #define _CACHE_MAR9_ADDR             _CACHE_MAR161_ADDR 
  #define _CACHE_MAR10_ADDR            _CACHE_MAR162_ADDR
  #define _CACHE_MAR11_ADDR            _CACHE_MAR163_ADDR
  #define _CACHE_MAR12_ADDR            _CACHE_MAR176_ADDR
  #define _CACHE_MAR13_ADDR            _CACHE_MAR177_ADDR
  #define _CACHE_MAR14_ADDR            _CACHE_MAR178_ADDR
  #define _CACHE_MAR15_ADDR            _CACHE_MAR179_ADDR

  #define _CACHE_MAR128_ADDR            0x01848200u
  #define _CACHE_MAR129_ADDR            0x01848204u
  #define _CACHE_MAR130_ADDR            0x01848208u
  #define _CACHE_MAR131_ADDR            0x0184820Cu
  #define _CACHE_MAR144_ADDR            0x01848240u
  #define _CACHE_MAR145_ADDR            0x01848244u
  #define _CACHE_MAR146_ADDR            0x01848248u
  #define _CACHE_MAR147_ADDR            0x0184824Cu
  #define _CACHE_MAR160_ADDR            0x01848280u
  #define _CACHE_MAR161_ADDR            0x01848284u
  #define _CACHE_MAR162_ADDR            0x01848288u
  #define _CACHE_MAR163_ADDR            0x0184828Cu
  #define _CACHE_MAR176_ADDR            0x018482C0u
  #define _CACHE_MAR177_ADDR            0x018482C4u
  #define _CACHE_MAR178_ADDR            0x018482C8u
  #define _CACHE_MAR179_ADDR            0x018482CCu

  #define _CACHE_MAR_CE_MASK           0x00000001u
  #define _CACHE_MAR_CE_SHIFT          0x00000000u
  #define  CACHE_MAR_CE_DEFAULT        0x00000000u
  #define  CACHE_MAR_CE_OF(x)          _VALUEOF(x)
  #define  CACHE_MAR_CE_DISABLE        0x00000000u
  #define  CACHE_MAR_CE_ENABLE         0x00000001u

  #define  CACHE_MAR_OF(x)             _VALUEOF(x)

  #define CACHE_MAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,MAR,CE) \
  )

  #define CACHE_MAR_RMK(ce) (Uint32)( \
     _PER_FMK(CACHE,MAR,CE,ce) \
  )

  #define _CACHE_MAR_FGET(N,FIELD)\
    _PER_FGET(_CACHE_MAR##N##_ADDR,CACHE,MAR,##FIELD)

  #define _CACHE_MAR_FSET(N,FIELD,field)\
    _PER_FSET(_CACHE_MAR##N##_ADDR,CACHE,MAR,##FIELD,field)

  #define _CACHE_MAR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_CACHE_MAR##N##_ADDR,CACHE,MAR,##FIELD,##SYM)

  #define _CACHE_MAR0_FGET(FIELD)  _CACHE_MAR_FGET(128,##FIELD)
  #define _CACHE_MAR1_FGET(FIELD)  _CACHE_MAR_FGET(129,##FIELD)
  #define _CACHE_MAR2_FGET(FIELD)  _CACHE_MAR_FGET(130,##FIELD)
  #define _CACHE_MAR3_FGET(FIELD)  _CACHE_MAR_FGET(131,##FIELD)
  #define _CACHE_MAR4_FGET(FIELD)  _CACHE_MAR_FGET(144,##FIELD)
  #define _CACHE_MAR5_FGET(FIELD)  _CACHE_MAR_FGET(145,##FIELD)
  #define _CACHE_MAR6_FGET(FIELD)  _CACHE_MAR_FGET(146,##FIELD)
  #define _CACHE_MAR7_FGET(FIELD)  _CACHE_MAR_FGET(147,##FIELD)
  #define _CACHE_MAR8_FGET(FIELD)  _CACHE_MAR_FGET(160,##FIELD)
  #define _CACHE_MAR9_FGET(FIELD)  _CACHE_MAR_FGET(161,##FIELD)
  #define _CACHE_MAR10_FGET(FIELD) _CACHE_MAR_FGET(162,##FIELD)
  #define _CACHE_MAR11_FGET(FIELD) _CACHE_MAR_FGET(163,##FIELD)
  #define _CACHE_MAR12_FGET(FIELD) _CACHE_MAR_FGET(176,##FIELD)
  #define _CACHE_MAR13_FGET(FIELD) _CACHE_MAR_FGET(177,##FIELD)
  #define _CACHE_MAR14_FGET(FIELD) _CACHE_MAR_FGET(178,##FIELD)
  #define _CACHE_MAR15_FGET(FIELD) _CACHE_MAR_FGET(179,##FIELD)

  #define _CACHE_MAR0_FSET(FIELD,f)  _CACHE_MAR_FSET(128,##FIELD,f)
  #define _CACHE_MAR1_FSET(FIELD,f)  _CACHE_MAR_FSET(129,##FIELD,f)
  #define _CACHE_MAR2_FSET(FIELD,f)  _CACHE_MAR_FSET(130,##FIELD,f)
  #define _CACHE_MAR3_FSET(FIELD,f)  _CACHE_MAR_FSET(131,##FIELD,f)
  #define _CACHE_MAR4_FSET(FIELD,f)  _CACHE_MAR_FSET(144,##FIELD,f)
  #define _CACHE_MAR5_FSET(FIELD,f)  _CACHE_MAR_FSET(145,##FIELD,f)
  #define _CACHE_MAR6_FSET(FIELD,f)  _CACHE_MAR_FSET(146,##FIELD,f)
  #define _CACHE_MAR7_FSET(FIELD,f)  _CACHE_MAR_FSET(147,##FIELD,f)
  #define _CACHE_MAR8_FSET(FIELD,f)  _CACHE_MAR_FSET(160,##FIELD,f)
  #define _CACHE_MAR9_FSET(FIELD,f)  _CACHE_MAR_FSET(161,##FIELD,f)
  #define _CACHE_MAR10_FSET(FIELD,f) _CACHE_MAR_FSET(162,##FIELD,f)
  #define _CACHE_MAR11_FSET(FIELD,f) _CACHE_MAR_FSET(163,##FIELD,f)
  #define _CACHE_MAR12_FSET(FIELD,f) _CACHE_MAR_FSET(176,##FIELD,f)
  #define _CACHE_MAR13_FSET(FIELD,f) _CACHE_MAR_FSET(177,##FIELD,f)
  #define _CACHE_MAR14_FSET(FIELD,f) _CACHE_MAR_FSET(178,##FIELD,f)
  #define _CACHE_MAR15_FSET(FIELD,f) _CACHE_MAR_FSET(179,##FIELD,f)

  #define _CACHE_MAR0_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(128,##FIELD,##SYM)
  #define _CACHE_MAR1_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(129,##FIELD,##SYM)
  #define _CACHE_MAR2_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(130,##FIELD,##SYM)
  #define _CACHE_MAR3_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(131,##FIELD,##SYM)
  #define _CACHE_MAR4_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(144,##FIELD,##SYM)
  #define _CACHE_MAR5_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(145,##FIELD,##SYM)
  #define _CACHE_MAR6_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(146,##FIELD,##SYM)
  #define _CACHE_MAR7_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(147,##FIELD,##SYM)
  #define _CACHE_MAR8_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(160,##FIELD,##SYM)
  #define _CACHE_MAR9_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(161,##FIELD,##SYM)
  #define _CACHE_MAR10_FSETS(FIELD,SYM) _CACHE_MAR_FSETS(162,##FIELD,##SYM)
  #define _CACHE_MAR11_FSETS(FIELD,SYM) _CACHE_MAR_FSETS(163,##FIELD,##SYM)
  #define _CACHE_MAR12_FSETS(FIELD,SYM) _CACHE_MAR_FSETS(176,##FIELD,##SYM)
  #define _CACHE_MAR13_FSETS(FIELD,SYM) _CACHE_MAR_FSETS(177,##FIELD,##SYM)
  #define _CACHE_MAR14_FSETS(FIELD,SYM) _CACHE_MAR_FSETS(178,##FIELD,##SYM)
  #define _CACHE_MAR15_FSETS(FIELD,SYM) _CACHE_MAR_FSETS(179,##FIELD,##SYM)

  #define _CACHE_MAR128_FGET(FIELD)  _CACHE_MAR_FGET(128,##FIELD)
  #define _CACHE_MAR129_FGET(FIELD)  _CACHE_MAR_FGET(129,##FIELD)
  #define _CACHE_MAR130_FGET(FIELD)  _CACHE_MAR_FGET(130,##FIELD)
  #define _CACHE_MAR131_FGET(FIELD)  _CACHE_MAR_FGET(131,##FIELD)
  #define _CACHE_MAR144_FGET(FIELD)  _CACHE_MAR_FGET(144,##FIELD)
  #define _CACHE_MAR145_FGET(FIELD)  _CACHE_MAR_FGET(145,##FIELD)
  #define _CACHE_MAR146_FGET(FIELD)  _CACHE_MAR_FGET(146,##FIELD)
  #define _CACHE_MAR147_FGET(FIELD)  _CACHE_MAR_FGET(147,##FIELD)
  #define _CACHE_MAR160_FGET(FIELD)  _CACHE_MAR_FGET(160,##FIELD)
  #define _CACHE_MAR161_FGET(FIELD)  _CACHE_MAR_FGET(161,##FIELD)
  #define _CACHE_MAR162_FGET(FIELD)  _CACHE_MAR_FGET(162,##FIELD)
  #define _CACHE_MAR163_FGET(FIELD)  _CACHE_MAR_FGET(163,##FIELD)
  #define _CACHE_MAR176_FGET(FIELD)  _CACHE_MAR_FGET(176,##FIELD)
  #define _CACHE_MAR177_FGET(FIELD)  _CACHE_MAR_FGET(177,##FIELD)
  #define _CACHE_MAR178_FGET(FIELD)  _CACHE_MAR_FGET(178,##FIELD)
  #define _CACHE_MAR179_FGET(FIELD)  _CACHE_MAR_FGET(179,##FIELD)

  #define _CACHE_MAR128_FSET(FIELD,f)  _CACHE_MAR_FSET(128,##FIELD,f)
  #define _CACHE_MAR129_FSET(FIELD,f)  _CACHE_MAR_FSET(129,##FIELD,f)
  #define _CACHE_MAR130_FSET(FIELD,f)  _CACHE_MAR_FSET(130,##FIELD,f)
  #define _CACHE_MAR131_FSET(FIELD,f)  _CACHE_MAR_FSET(131,##FIELD,f)
  #define _CACHE_MAR144_FSET(FIELD,f)  _CACHE_MAR_FSET(144,##FIELD,f)
  #define _CACHE_MAR145_FSET(FIELD,f)  _CACHE_MAR_FSET(145,##FIELD,f)
  #define _CACHE_MAR146_FSET(FIELD,f)  _CACHE_MAR_FSET(146,##FIELD,f)
  #define _CACHE_MAR147_FSET(FIELD,f)  _CACHE_MAR_FSET(147,##FIELD,f)
  #define _CACHE_MAR160_FSET(FIELD,f)  _CACHE_MAR_FSET(160,##FIELD,f)
  #define _CACHE_MAR161_FSET(FIELD,f)  _CACHE_MAR_FSET(161,##FIELD,f)
  #define _CACHE_MAR162_FSET(FIELD,f)  _CACHE_MAR_FSET(162,##FIELD,f)
  #define _CACHE_MAR163_FSET(FIELD,f)  _CACHE_MAR_FSET(163,##FIELD,f)
  #define _CACHE_MAR176_FSET(FIELD,f)  _CACHE_MAR_FSET(176,##FIELD,f)
  #define _CACHE_MAR177_FSET(FIELD,f)  _CACHE_MAR_FSET(177,##FIELD,f)
  #define _CACHE_MAR178_FSET(FIELD,f)  _CACHE_MAR_FSET(178,##FIELD,f)
  #define _CACHE_MAR179_FSET(FIELD,f)  _CACHE_MAR_FSET(179,##FIELD,f)

  #define _CACHE_MAR128_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(128,##FIELD,##SYM)
  #define _CACHE_MAR129_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(129,##FIELD,##SYM)
  #define _CACHE_MAR130_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(130,##FIELD,##SYM)
  #define _CACHE_MAR131_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(131,##FIELD,##SYM)
  #define _CACHE_MAR144_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(144,##FIELD,##SYM)
  #define _CACHE_MAR145_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(145,##FIELD,##SYM)
  #define _CACHE_MAR146_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(146,##FIELD,##SYM)
  #define _CACHE_MAR147_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(147,##FIELD,##SYM)
  #define _CACHE_MAR160_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(160,##FIELD,##SYM)
  #define _CACHE_MAR161_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(161,##FIELD,##SYM)
  #define _CACHE_MAR162_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(162,##FIELD,##SYM)
  #define _CACHE_MAR163_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(163,##FIELD,##SYM)
  #define _CACHE_MAR176_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(176,##FIELD,##SYM)
  #define _CACHE_MAR177_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(177,##FIELD,##SYM)
  #define _CACHE_MAR178_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(178,##FIELD,##SYM)
  #define _CACHE_MAR179_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(179,##FIELD,##SYM)

#else 

  /* MAR96 to MAR111 are associated with EMIFB memory space. This is supported only in  
   * the C6414, C6415 and C6416 chips                                                  */
    
  #if (CHIP_6414 | CHIP_6415 | CHIP_6416)
    #define _CACHE_MAR96_ADDR            0x01848180u
    #define _CACHE_MAR97_ADDR            0x01848184u
    #define _CACHE_MAR98_ADDR            0x01848188u
    #define _CACHE_MAR99_ADDR            0x0184818Cu
    #define _CACHE_MAR100_ADDR           0x01848190u
    #define _CACHE_MAR101_ADDR           0x01848194u
    #define _CACHE_MAR102_ADDR           0x01848198u
    #define _CACHE_MAR103_ADDR           0x0184819Cu
    #define _CACHE_MAR104_ADDR           0x018481A0u
    #define _CACHE_MAR105_ADDR           0x018481A4u
    #define _CACHE_MAR106_ADDR           0x018481A8u
    #define _CACHE_MAR107_ADDR           0x018481ACu
    #define _CACHE_MAR108_ADDR           0x018481B0u
    #define _CACHE_MAR109_ADDR           0x018481B4u
    #define _CACHE_MAR110_ADDR           0x018481B8u
    #define _CACHE_MAR111_ADDR           0x018481BCu
  #endif

  #define _CACHE_MAR128_ADDR           0x01848200u
  #define _CACHE_MAR129_ADDR           0x01848204u
  #define _CACHE_MAR130_ADDR           0x01848208u
  #define _CACHE_MAR131_ADDR           0x0184820Cu
  #define _CACHE_MAR132_ADDR           0x01848210u
  #define _CACHE_MAR133_ADDR           0x01848214u
  #define _CACHE_MAR134_ADDR           0x01848218u
  #define _CACHE_MAR135_ADDR           0x0184821Cu
  #define _CACHE_MAR136_ADDR           0x01848220u
  #define _CACHE_MAR137_ADDR           0x01848224u
  #define _CACHE_MAR138_ADDR           0x01848228u
  #define _CACHE_MAR139_ADDR           0x0184822Cu
  #define _CACHE_MAR140_ADDR           0x01848230u
  #define _CACHE_MAR141_ADDR           0x01848234u
  #define _CACHE_MAR142_ADDR           0x01848238u
  #define _CACHE_MAR143_ADDR           0x0184823Cu
  #define _CACHE_MAR144_ADDR           0x01848240u
  #define _CACHE_MAR145_ADDR           0x01848244u
  #define _CACHE_MAR146_ADDR           0x01848248u
  #define _CACHE_MAR147_ADDR           0x0184824Cu
  #define _CACHE_MAR148_ADDR           0x01848250u
  #define _CACHE_MAR149_ADDR           0x01848254u
  #define _CACHE_MAR150_ADDR           0x01848258u
  #define _CACHE_MAR151_ADDR           0x0184825Cu
  #define _CACHE_MAR152_ADDR           0x01848260u
  #define _CACHE_MAR153_ADDR           0x01848264u
  #define _CACHE_MAR154_ADDR           0x01848268u
  #define _CACHE_MAR155_ADDR           0x0184826Cu
  #define _CACHE_MAR156_ADDR           0x01848270u
  #define _CACHE_MAR157_ADDR           0x01848274u
  #define _CACHE_MAR158_ADDR           0x01848278u
  #define _CACHE_MAR159_ADDR           0x0184827Cu
  #define _CACHE_MAR160_ADDR           0x01848280u
  #define _CACHE_MAR161_ADDR           0x01848284u
  #define _CACHE_MAR162_ADDR           0x01848288u
  #define _CACHE_MAR163_ADDR           0x0184828Cu
  #define _CACHE_MAR164_ADDR           0x01848290u
  #define _CACHE_MAR165_ADDR           0x01848294u
  #define _CACHE_MAR166_ADDR           0x01848298u
  #define _CACHE_MAR167_ADDR           0x0184829Cu
  #define _CACHE_MAR168_ADDR           0x018482A0u
  #define _CACHE_MAR169_ADDR           0x018482A4u
  #define _CACHE_MAR170_ADDR           0x018482A8u
  #define _CACHE_MAR171_ADDR           0x018482ACu
  #define _CACHE_MAR172_ADDR           0x018482B0u
  #define _CACHE_MAR173_ADDR           0x018482B4u
  #define _CACHE_MAR174_ADDR           0x018482B8u
  #define _CACHE_MAR175_ADDR           0x018482BCu
  #define _CACHE_MAR176_ADDR           0x018482C0u
  #define _CACHE_MAR177_ADDR           0x018482C4u
  #define _CACHE_MAR178_ADDR           0x018482C8u
  #define _CACHE_MAR179_ADDR           0x018482CCu
  #define _CACHE_MAR180_ADDR           0x018482D0u
  #define _CACHE_MAR181_ADDR           0x018482D4u
  #define _CACHE_MAR182_ADDR           0x018482D8u
  #define _CACHE_MAR183_ADDR           0x018482DCu
  #define _CACHE_MAR184_ADDR           0x018482E0u
  #define _CACHE_MAR185_ADDR           0x018482E4u
  #define _CACHE_MAR186_ADDR           0x018482E8u
  #define _CACHE_MAR187_ADDR           0x018482ECu
  #define _CACHE_MAR188_ADDR           0x018482F0u
  #define _CACHE_MAR189_ADDR           0x018482F4u
  #define _CACHE_MAR190_ADDR           0x018482F8u
  #define _CACHE_MAR191_ADDR           0x018482FCu

  #define _CACHE_MAR_CE_MASK           0x00000001u
  #define _CACHE_MAR_CE_SHIFT          0x00000000u
  #define  CACHE_MAR_CE_DEFAULT        0x00000000u
  #define  CACHE_MAR_CE_OF(x)          _VALUEOF(x)
  #define  CACHE_MAR_CE_DISABLE        0x00000000u
  #define  CACHE_MAR_CE_ENABLE         0x00000001u

  #define  CACHE_MAR_OF(x)             _VALUEOF(x)

  #define CACHE_MAR_DEFAULT (Uint32)( \
    _PER_FDEFAULT(CACHE,MAR,CE) \
  )

  #define CACHE_MAR_RMK(ce) (Uint32)( \
    _PER_FMK(CACHE,MAR,CE,ce) \
  )

  #define _CACHE_MAR_FGET(N,FIELD)\
    _PER_FGET(_CACHE_MAR##N##_ADDR,CACHE,MAR,##FIELD)

  #define _CACHE_MAR_FSET(N,FIELD,field)\
    _PER_FSET(_CACHE_MAR##N##_ADDR,CACHE,MAR,##FIELD,field)

  #define _CACHE_MAR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_CACHE_MAR##N##_ADDR,CACHE,MAR,##FIELD,##SYM)

  #if (CHIP_6414 | CHIP_6415 | CHIP_6416)
    #define _CACHE_MAR96_FGET(FIELD)   _CACHE_MAR_FGET(96,##FIELD)
    #define _CACHE_MAR97_FGET(FIELD)   _CACHE_MAR_FGET(97,##FIELD)
    #define _CACHE_MAR98_FGET(FIELD)   _CACHE_MAR_FGET(98,##FIELD)
    #define _CACHE_MAR99_FGET(FIELD)   _CACHE_MAR_FGET(99,##FIELD)
    #define _CACHE_MAR100_FGET(FIELD)  _CACHE_MAR_FGET(100,##FIELD)
    #define _CACHE_MAR101_FGET(FIELD)  _CACHE_MAR_FGET(101,##FIELD)
    #define _CACHE_MAR102_FGET(FIELD)  _CACHE_MAR_FGET(102,##FIELD)
    #define _CACHE_MAR103_FGET(FIELD)  _CACHE_MAR_FGET(103,##FIELD)
    #define _CACHE_MAR104_FGET(FIELD)  _CACHE_MAR_FGET(104,##FIELD)
    #define _CACHE_MAR105_FGET(FIELD)  _CACHE_MAR_FGET(105,##FIELD)
    #define _CACHE_MAR106_FGET(FIELD)  _CACHE_MAR_FGET(106,##FIELD)
    #define _CACHE_MAR107_FGET(FIELD)  _CACHE_MAR_FGET(107,##FIELD)
    #define _CACHE_MAR108_FGET(FIELD)  _CACHE_MAR_FGET(108,##FIELD)
    #define _CACHE_MAR109_FGET(FIELD)  _CACHE_MAR_FGET(109,##FIELD)
    #define _CACHE_MAR110_FGET(FIELD)  _CACHE_MAR_FGET(110,##FIELD)
    #define _CACHE_MAR111_FGET(FIELD)  _CACHE_MAR_FGET(111,##FIELD)
  #endif

  #define _CACHE_MAR128_FGET(FIELD)  _CACHE_MAR_FGET(128,##FIELD)
  #define _CACHE_MAR129_FGET(FIELD)  _CACHE_MAR_FGET(129,##FIELD)
  #define _CACHE_MAR130_FGET(FIELD)  _CACHE_MAR_FGET(130,##FIELD)
  #define _CACHE_MAR131_FGET(FIELD)  _CACHE_MAR_FGET(131,##FIELD)
  #define _CACHE_MAR132_FGET(FIELD)  _CACHE_MAR_FGET(132,##FIELD)
  #define _CACHE_MAR133_FGET(FIELD)  _CACHE_MAR_FGET(133,##FIELD)
  #define _CACHE_MAR134_FGET(FIELD)  _CACHE_MAR_FGET(134,##FIELD)
  #define _CACHE_MAR135_FGET(FIELD)  _CACHE_MAR_FGET(135,##FIELD)
  #define _CACHE_MAR136_FGET(FIELD)  _CACHE_MAR_FGET(136,##FIELD)
  #define _CACHE_MAR137_FGET(FIELD)  _CACHE_MAR_FGET(137,##FIELD)
  #define _CACHE_MAR138_FGET(FIELD)  _CACHE_MAR_FGET(138,##FIELD)
  #define _CACHE_MAR139_FGET(FIELD)  _CACHE_MAR_FGET(139,##FIELD)
  #define _CACHE_MAR140_FGET(FIELD)  _CACHE_MAR_FGET(140,##FIELD)
  #define _CACHE_MAR141_FGET(FIELD)  _CACHE_MAR_FGET(141,##FIELD)
  #define _CACHE_MAR142_FGET(FIELD)  _CACHE_MAR_FGET(142,##FIELD)
  #define _CACHE_MAR143_FGET(FIELD)  _CACHE_MAR_FGET(143,##FIELD)
  #define _CACHE_MAR144_FGET(FIELD)  _CACHE_MAR_FGET(144,##FIELD)
  #define _CACHE_MAR145_FGET(FIELD)  _CACHE_MAR_FGET(145,##FIELD)
  #define _CACHE_MAR146_FGET(FIELD)  _CACHE_MAR_FGET(146,##FIELD)
  #define _CACHE_MAR147_FGET(FIELD)  _CACHE_MAR_FGET(147,##FIELD)
  #define _CACHE_MAR148_FGET(FIELD)  _CACHE_MAR_FGET(148,##FIELD)
  #define _CACHE_MAR149_FGET(FIELD)  _CACHE_MAR_FGET(149,##FIELD)
  #define _CACHE_MAR150_FGET(FIELD)  _CACHE_MAR_FGET(150,##FIELD)
  #define _CACHE_MAR151_FGET(FIELD)  _CACHE_MAR_FGET(151,##FIELD)
  #define _CACHE_MAR152_FGET(FIELD)  _CACHE_MAR_FGET(152,##FIELD)
  #define _CACHE_MAR153_FGET(FIELD)  _CACHE_MAR_FGET(153,##FIELD)
  #define _CACHE_MAR154_FGET(FIELD)  _CACHE_MAR_FGET(154,##FIELD)
  #define _CACHE_MAR155_FGET(FIELD)  _CACHE_MAR_FGET(155,##FIELD)
  #define _CACHE_MAR156_FGET(FIELD)  _CACHE_MAR_FGET(156,##FIELD)
  #define _CACHE_MAR157_FGET(FIELD)  _CACHE_MAR_FGET(157,##FIELD)
  #define _CACHE_MAR158_FGET(FIELD)  _CACHE_MAR_FGET(158,##FIELD)
  #define _CACHE_MAR159_FGET(FIELD)  _CACHE_MAR_FGET(159,##FIELD)
  #define _CACHE_MAR160_FGET(FIELD)  _CACHE_MAR_FGET(160,##FIELD)
  #define _CACHE_MAR161_FGET(FIELD)  _CACHE_MAR_FGET(161,##FIELD)
  #define _CACHE_MAR162_FGET(FIELD)  _CACHE_MAR_FGET(162,##FIELD)
  #define _CACHE_MAR163_FGET(FIELD)  _CACHE_MAR_FGET(163,##FIELD)
  #define _CACHE_MAR164_FGET(FIELD)  _CACHE_MAR_FGET(164,##FIELD)
  #define _CACHE_MAR165_FGET(FIELD)  _CACHE_MAR_FGET(165,##FIELD)
  #define _CACHE_MAR166_FGET(FIELD)  _CACHE_MAR_FGET(166,##FIELD)
  #define _CACHE_MAR167_FGET(FIELD)  _CACHE_MAR_FGET(167,##FIELD)
  #define _CACHE_MAR168_FGET(FIELD)  _CACHE_MAR_FGET(168,##FIELD)
  #define _CACHE_MAR169_FGET(FIELD)  _CACHE_MAR_FGET(169,##FIELD)
  #define _CACHE_MAR170_FGET(FIELD)  _CACHE_MAR_FGET(170,##FIELD)
  #define _CACHE_MAR171_FGET(FIELD)  _CACHE_MAR_FGET(171,##FIELD)
  #define _CACHE_MAR172_FGET(FIELD)  _CACHE_MAR_FGET(172,##FIELD)
  #define _CACHE_MAR173_FGET(FIELD)  _CACHE_MAR_FGET(173,##FIELD)
  #define _CACHE_MAR174_FGET(FIELD)  _CACHE_MAR_FGET(174,##FIELD)
  #define _CACHE_MAR175_FGET(FIELD)  _CACHE_MAR_FGET(175,##FIELD)
  #define _CACHE_MAR176_FGET(FIELD)  _CACHE_MAR_FGET(176,##FIELD)
  #define _CACHE_MAR177_FGET(FIELD)  _CACHE_MAR_FGET(177,##FIELD)
  #define _CACHE_MAR178_FGET(FIELD)  _CACHE_MAR_FGET(178,##FIELD)
  #define _CACHE_MAR179_FGET(FIELD)  _CACHE_MAR_FGET(179,##FIELD)
  #define _CACHE_MAR180_FGET(FIELD)  _CACHE_MAR_FGET(180,##FIELD)
  #define _CACHE_MAR181_FGET(FIELD)  _CACHE_MAR_FGET(181,##FIELD)
  #define _CACHE_MAR182_FGET(FIELD)  _CACHE_MAR_FGET(182,##FIELD)
  #define _CACHE_MAR183_FGET(FIELD)  _CACHE_MAR_FGET(183,##FIELD)
  #define _CACHE_MAR184_FGET(FIELD)  _CACHE_MAR_FGET(184,##FIELD)
  #define _CACHE_MAR185_FGET(FIELD)  _CACHE_MAR_FGET(185,##FIELD)
  #define _CACHE_MAR186_FGET(FIELD)  _CACHE_MAR_FGET(186,##FIELD)
  #define _CACHE_MAR187_FGET(FIELD)  _CACHE_MAR_FGET(187,##FIELD)
  #define _CACHE_MAR188_FGET(FIELD)  _CACHE_MAR_FGET(188,##FIELD)
  #define _CACHE_MAR189_FGET(FIELD)  _CACHE_MAR_FGET(189,##FIELD)
  #define _CACHE_MAR190_FGET(FIELD)  _CACHE_MAR_FGET(190,##FIELD)
  #define _CACHE_MAR191_FGET(FIELD)  _CACHE_MAR_FGET(191,##FIELD)

  #if (CHIP_6414 | CHIP_6415 | CHIP_6416)
    #define _CACHE_MAR96_FSET(FIELD,f)   _CACHE_MAR_FSET(96,##FIELD,f)
    #define _CACHE_MAR97_FSET(FIELD,f)   _CACHE_MAR_FSET(97,##FIELD,f)
    #define _CACHE_MAR98_FSET(FIELD,f)   _CACHE_MAR_FSET(98,##FIELD,f)
    #define _CACHE_MAR99_FSET(FIELD,f)   _CACHE_MAR_FSET(99,##FIELD,f)
    #define _CACHE_MAR100_FSET(FIELD,f)  _CACHE_MAR_FSET(100,##FIELD,f)
    #define _CACHE_MAR101_FSET(FIELD,f)  _CACHE_MAR_FSET(101,##FIELD,f)
    #define _CACHE_MAR102_FSET(FIELD,f)  _CACHE_MAR_FSET(102,##FIELD,f)
    #define _CACHE_MAR103_FSET(FIELD,f)  _CACHE_MAR_FSET(103,##FIELD,f)
    #define _CACHE_MAR104_FSET(FIELD,f)  _CACHE_MAR_FSET(104,##FIELD,f)
    #define _CACHE_MAR105_FSET(FIELD,f)  _CACHE_MAR_FSET(105,##FIELD,f)
    #define _CACHE_MAR106_FSET(FIELD,f)  _CACHE_MAR_FSET(106,##FIELD,f)
    #define _CACHE_MAR107_FSET(FIELD,f)  _CACHE_MAR_FSET(107,##FIELD,f)
    #define _CACHE_MAR108_FSET(FIELD,f)  _CACHE_MAR_FSET(108,##FIELD,f)
    #define _CACHE_MAR109_FSET(FIELD,f)  _CACHE_MAR_FSET(109,##FIELD,f)
    #define _CACHE_MAR110_FSET(FIELD,f)  _CACHE_MAR_FSET(110,##FIELD,f)
    #define _CACHE_MAR111_FSET(FIELD,f)  _CACHE_MAR_FSET(111,##FIELD,f)
  #endif

  #define _CACHE_MAR128_FSET(FIELD,f)  _CACHE_MAR_FSET(128,##FIELD,f)
  #define _CACHE_MAR129_FSET(FIELD,f)  _CACHE_MAR_FSET(129,##FIELD,f)
  #define _CACHE_MAR130_FSET(FIELD,f)  _CACHE_MAR_FSET(130,##FIELD,f)
  #define _CACHE_MAR131_FSET(FIELD,f)  _CACHE_MAR_FSET(131,##FIELD,f)
  #define _CACHE_MAR132_FSET(FIELD,f)  _CACHE_MAR_FSET(132,##FIELD,f)
  #define _CACHE_MAR133_FSET(FIELD,f)  _CACHE_MAR_FSET(133,##FIELD,f)
  #define _CACHE_MAR134_FSET(FIELD,f)  _CACHE_MAR_FSET(134,##FIELD,f)
  #define _CACHE_MAR135_FSET(FIELD,f)  _CACHE_MAR_FSET(135,##FIELD,f)
  #define _CACHE_MAR136_FSET(FIELD,f)  _CACHE_MAR_FSET(136,##FIELD,f)
  #define _CACHE_MAR137_FSET(FIELD,f)  _CACHE_MAR_FSET(137,##FIELD,f)
  #define _CACHE_MAR138_FSET(FIELD,f)  _CACHE_MAR_FSET(138,##FIELD,f)
  #define _CACHE_MAR139_FSET(FIELD,f)  _CACHE_MAR_FSET(139,##FIELD,f)
  #define _CACHE_MAR140_FSET(FIELD,f)  _CACHE_MAR_FSET(140,##FIELD,f)
  #define _CACHE_MAR141_FSET(FIELD,f)  _CACHE_MAR_FSET(141,##FIELD,f)
  #define _CACHE_MAR142_FSET(FIELD,f)  _CACHE_MAR_FSET(142,##FIELD,f)
  #define _CACHE_MAR143_FSET(FIELD,f)  _CACHE_MAR_FSET(143,##FIELD,f)
  #define _CACHE_MAR144_FSET(FIELD,f)  _CACHE_MAR_FSET(144,##FIELD,f)
  #define _CACHE_MAR145_FSET(FIELD,f)  _CACHE_MAR_FSET(145,##FIELD,f)
  #define _CACHE_MAR146_FSET(FIELD,f)  _CACHE_MAR_FSET(146,##FIELD,f)
  #define _CACHE_MAR147_FSET(FIELD,f)  _CACHE_MAR_FSET(147,##FIELD,f)
  #define _CACHE_MAR148_FSET(FIELD,f)  _CACHE_MAR_FSET(148,##FIELD,f)
  #define _CACHE_MAR149_FSET(FIELD,f)  _CACHE_MAR_FSET(149,##FIELD,f)
  #define _CACHE_MAR150_FSET(FIELD,f)  _CACHE_MAR_FSET(150,##FIELD,f)
  #define _CACHE_MAR151_FSET(FIELD,f)  _CACHE_MAR_FSET(151,##FIELD,f)
  #define _CACHE_MAR152_FSET(FIELD,f)  _CACHE_MAR_FSET(152,##FIELD,f)
  #define _CACHE_MAR153_FSET(FIELD,f)  _CACHE_MAR_FSET(153,##FIELD,f)
  #define _CACHE_MAR154_FSET(FIELD,f)  _CACHE_MAR_FSET(154,##FIELD,f)
  #define _CACHE_MAR155_FSET(FIELD,f)  _CACHE_MAR_FSET(155,##FIELD,f)
  #define _CACHE_MAR156_FSET(FIELD,f)  _CACHE_MAR_FSET(156,##FIELD,f)
  #define _CACHE_MAR157_FSET(FIELD,f)  _CACHE_MAR_FSET(157,##FIELD,f)
  #define _CACHE_MAR158_FSET(FIELD,f)  _CACHE_MAR_FSET(158,##FIELD,f)
  #define _CACHE_MAR159_FSET(FIELD,f)  _CACHE_MAR_FSET(159,##FIELD,f)
  #define _CACHE_MAR160_FSET(FIELD,f)  _CACHE_MAR_FSET(160,##FIELD,f)
  #define _CACHE_MAR161_FSET(FIELD,f)  _CACHE_MAR_FSET(161,##FIELD,f)
  #define _CACHE_MAR162_FSET(FIELD,f)  _CACHE_MAR_FSET(162,##FIELD,f)
  #define _CACHE_MAR163_FSET(FIELD,f)  _CACHE_MAR_FSET(163,##FIELD,f)
  #define _CACHE_MAR164_FSET(FIELD,f)  _CACHE_MAR_FSET(164,##FIELD,f)
  #define _CACHE_MAR165_FSET(FIELD,f)  _CACHE_MAR_FSET(165,##FIELD,f)
  #define _CACHE_MAR166_FSET(FIELD,f)  _CACHE_MAR_FSET(166,##FIELD,f)
  #define _CACHE_MAR167_FSET(FIELD,f)  _CACHE_MAR_FSET(167,##FIELD,f)
  #define _CACHE_MAR168_FSET(FIELD,f)  _CACHE_MAR_FSET(168,##FIELD,f)
  #define _CACHE_MAR169_FSET(FIELD,f)  _CACHE_MAR_FSET(169,##FIELD,f)
  #define _CACHE_MAR170_FSET(FIELD,f)  _CACHE_MAR_FSET(170,##FIELD,f)
  #define _CACHE_MAR171_FSET(FIELD,f)  _CACHE_MAR_FSET(171,##FIELD,f)
  #define _CACHE_MAR172_FSET(FIELD,f)  _CACHE_MAR_FSET(172,##FIELD,f)
  #define _CACHE_MAR173_FSET(FIELD,f)  _CACHE_MAR_FSET(173,##FIELD,f)
  #define _CACHE_MAR174_FSET(FIELD,f)  _CACHE_MAR_FSET(174,##FIELD,f)
  #define _CACHE_MAR175_FSET(FIELD,f)  _CACHE_MAR_FSET(175,##FIELD,f)
  #define _CACHE_MAR176_FSET(FIELD,f)  _CACHE_MAR_FSET(176,##FIELD,f)
  #define _CACHE_MAR177_FSET(FIELD,f)  _CACHE_MAR_FSET(177,##FIELD,f)
  #define _CACHE_MAR178_FSET(FIELD,f)  _CACHE_MAR_FSET(178,##FIELD,f)
  #define _CACHE_MAR179_FSET(FIELD,f)  _CACHE_MAR_FSET(179,##FIELD,f)
  #define _CACHE_MAR180_FSET(FIELD,f)  _CACHE_MAR_FSET(180,##FIELD,f)
  #define _CACHE_MAR181_FSET(FIELD,f)  _CACHE_MAR_FSET(181,##FIELD,f)
  #define _CACHE_MAR182_FSET(FIELD,f)  _CACHE_MAR_FSET(182,##FIELD,f)
  #define _CACHE_MAR183_FSET(FIELD,f)  _CACHE_MAR_FSET(183,##FIELD,f)
  #define _CACHE_MAR184_FSET(FIELD,f)  _CACHE_MAR_FSET(184,##FIELD,f)
  #define _CACHE_MAR185_FSET(FIELD,f)  _CACHE_MAR_FSET(185,##FIELD,f)
  #define _CACHE_MAR186_FSET(FIELD,f)  _CACHE_MAR_FSET(186,##FIELD,f)
  #define _CACHE_MAR187_FSET(FIELD,f)  _CACHE_MAR_FSET(187,##FIELD,f)
  #define _CACHE_MAR188_FSET(FIELD,f)  _CACHE_MAR_FSET(188,##FIELD,f)
  #define _CACHE_MAR189_FSET(FIELD,f)  _CACHE_MAR_FSET(189,##FIELD,f)
  #define _CACHE_MAR190_FSET(FIELD,f)  _CACHE_MAR_FSET(190,##FIELD,f)
  #define _CACHE_MAR191_FSET(FIELD,f)  _CACHE_MAR_FSET(191,##FIELD,f)

  #if (CHIP_6414 | CHIP_6415 | CHIP_6416)
    #define _CACHE_MAR96_FSETS(FIELD,SYM)   _CACHE_MAR_FSETS(96,##FIELD,##SYM)
    #define _CACHE_MAR97_FSETS(FIELD,SYM)   _CACHE_MAR_FSETS(97,##FIELD,##SYM)
    #define _CACHE_MAR98_FSETS(FIELD,SYM)   _CACHE_MAR_FSETS(98,##FIELD,##SYM)
    #define _CACHE_MAR99_FSETS(FIELD,SYM)   _CACHE_MAR_FSETS(99,##FIELD,##SYM)
    #define _CACHE_MAR100_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(100,##FIELD,##SYM)
    #define _CACHE_MAR101_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(101,##FIELD,##SYM)
    #define _CACHE_MAR102_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(102,##FIELD,##SYM)
    #define _CACHE_MAR103_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(103,##FIELD,##SYM)
    #define _CACHE_MAR104_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(104,##FIELD,##SYM)
    #define _CACHE_MAR105_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(105,##FIELD,##SYM)
    #define _CACHE_MAR106_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(106,##FIELD,##SYM)
    #define _CACHE_MAR107_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(107,##FIELD,##SYM)
    #define _CACHE_MAR108_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(108,##FIELD,##SYM)
    #define _CACHE_MAR109_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(109,##FIELD,##SYM)
    #define _CACHE_MAR110_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(110,##FIELD,##SYM)
    #define _CACHE_MAR111_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(111,##FIELD,##SYM)
  #endif

  #define _CACHE_MAR128_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(128,##FIELD,##SYM)
  #define _CACHE_MAR129_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(129,##FIELD,##SYM)
  #define _CACHE_MAR130_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(130,##FIELD,##SYM)
  #define _CACHE_MAR131_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(131,##FIELD,##SYM)
  #define _CACHE_MAR132_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(132,##FIELD,##SYM)
  #define _CACHE_MAR133_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(133,##FIELD,##SYM)
  #define _CACHE_MAR134_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(134,##FIELD,##SYM)
  #define _CACHE_MAR135_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(135,##FIELD,##SYM)
  #define _CACHE_MAR136_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(136,##FIELD,##SYM)
  #define _CACHE_MAR137_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(137,##FIELD,##SYM)
  #define _CACHE_MAR138_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(138,##FIELD,##SYM)
  #define _CACHE_MAR139_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(139,##FIELD,##SYM)
  #define _CACHE_MAR140_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(140,##FIELD,##SYM)
  #define _CACHE_MAR141_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(141,##FIELD,##SYM)
  #define _CACHE_MAR142_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(142,##FIELD,##SYM)
  #define _CACHE_MAR143_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(143,##FIELD,##SYM)
  #define _CACHE_MAR144_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(144,##FIELD,##SYM)
  #define _CACHE_MAR145_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(145,##FIELD,##SYM)
  #define _CACHE_MAR146_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(146,##FIELD,##SYM)
  #define _CACHE_MAR147_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(147,##FIELD,##SYM)
  #define _CACHE_MAR148_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(148,##FIELD,##SYM)
  #define _CACHE_MAR149_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(149,##FIELD,##SYM)
  #define _CACHE_MAR150_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(150,##FIELD,##SYM)
  #define _CACHE_MAR151_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(151,##FIELD,##SYM)
  #define _CACHE_MAR152_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(152,##FIELD,##SYM)
  #define _CACHE_MAR153_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(153,##FIELD,##SYM)
  #define _CACHE_MAR154_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(154,##FIELD,##SYM)
  #define _CACHE_MAR155_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(155,##FIELD,##SYM)
  #define _CACHE_MAR156_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(156,##FIELD,##SYM)
  #define _CACHE_MAR157_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(157,##FIELD,##SYM)
  #define _CACHE_MAR158_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(158,##FIELD,##SYM)
  #define _CACHE_MAR159_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(159,##FIELD,##SYM)
  #define _CACHE_MAR160_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(160,##FIELD,##SYM)
  #define _CACHE_MAR161_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(161,##FIELD,##SYM)
  #define _CACHE_MAR162_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(162,##FIELD,##SYM)
  #define _CACHE_MAR163_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(163,##FIELD,##SYM)
  #define _CACHE_MAR164_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(164,##FIELD,##SYM)
  #define _CACHE_MAR165_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(165,##FIELD,##SYM)
  #define _CACHE_MAR166_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(166,##FIELD,##SYM)
  #define _CACHE_MAR167_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(167,##FIELD,##SYM)
  #define _CACHE_MAR168_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(168,##FIELD,##SYM)
  #define _CACHE_MAR169_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(169,##FIELD,##SYM)
  #define _CACHE_MAR170_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(170,##FIELD,##SYM)
  #define _CACHE_MAR171_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(171,##FIELD,##SYM)
  #define _CACHE_MAR172_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(172,##FIELD,##SYM)
  #define _CACHE_MAR173_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(173,##FIELD,##SYM)
  #define _CACHE_MAR174_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(174,##FIELD,##SYM)
  #define _CACHE_MAR175_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(175,##FIELD,##SYM)
  #define _CACHE_MAR176_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(176,##FIELD,##SYM)
  #define _CACHE_MAR177_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(177,##FIELD,##SYM)
  #define _CACHE_MAR178_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(178,##FIELD,##SYM)
  #define _CACHE_MAR179_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(179,##FIELD,##SYM)
  #define _CACHE_MAR180_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(180,##FIELD,##SYM)
  #define _CACHE_MAR181_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(181,##FIELD,##SYM)
  #define _CACHE_MAR182_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(182,##FIELD,##SYM)
  #define _CACHE_MAR183_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(183,##FIELD,##SYM)
  #define _CACHE_MAR184_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(184,##FIELD,##SYM)
  #define _CACHE_MAR185_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(185,##FIELD,##SYM)
  #define _CACHE_MAR186_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(186,##FIELD,##SYM)
  #define _CACHE_MAR187_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(187,##FIELD,##SYM)
  #define _CACHE_MAR188_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(188,##FIELD,##SYM)
  #define _CACHE_MAR189_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(189,##FIELD,##SYM)
  #define _CACHE_MAR190_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(190,##FIELD,##SYM)
  #define _CACHE_MAR191_FSETS(FIELD,SYM)  _CACHE_MAR_FSETS(191,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 2 W B A R      |
* |___________________|
*
* L2WBAR   - L2 writeback base address register
*
* Fields:
* (rw) L2WBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2WBAR_ADDR           0x01844000u

  #define _CACHE_L2WBAR_L2WBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L2WBAR_L2WBAR_SHIFT   0x00000000u
  #define  CACHE_L2WBAR_L2WBAR_DEFAULT 0x00000000u
  #define  CACHE_L2WBAR_L2WBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L2WBAR_OF(x)          _VALUEOF(x)

  #define CACHE_L2WBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2WBAR,L2WBAR) \
  )

  #define CACHE_L2WBAR_RMK(l2wbar) (Uint32)( \
     _PER_FMK(CACHE,L2WBAR,L2WBAR,l2wbar) \
  )

  #define _CACHE_L2WBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L2WBAR_ADDR,CACHE,L2WBAR,##FIELD)

  #define _CACHE_L2WBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2WBAR_ADDR,CACHE,L2WBAR,##FIELD,field)

  #define _CACHE_L2WBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2WBAR_ADDR,CACHE,L2WBAR,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  L 2 W W C        |
* |___________________|
*
* L2WWC    - L2 writeback word count register
*
* Fields:
* (rw) L2WWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2WWC_ADDR           0x01844004u

  #define _CACHE_L2WWC_L2WWC_MASK     0x0000FFFFu
  #define _CACHE_L2WWC_L2WWC_SHIFT    0x00000000u
  #define  CACHE_L2WWC_L2WWC_DEFAULT  0x00000000u
  #define  CACHE_L2WWC_L2WWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L2WWC_OF(x)          _VALUEOF(x)

  #define CACHE_L2WWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2WWC,L2WWC) \
  )

  #define CACHE_L2WWC_RMK(l2wwc) (Uint32)( \
     _PER_FMK(CACHE,L2WWC,L2WWC,l2wwc) \
  )

  #define _CACHE_L2WWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L2WWC_ADDR,CACHE,L2WWC,##FIELD)

  #define _CACHE_L2WWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2WWC_ADDR,CACHE,L2WWC,##FIELD,field)

  #define _CACHE_L2WWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2WWC_ADDR,CACHE,L2WWC,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 2 W I B A R    |
* |___________________|
*
* L2WIBAR  - L2 writeback-invalidate base address register
*
* Fields:
* (rw) L2WIBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2WIBAR_ADDR           0x01844010u

  #define _CACHE_L2WIBAR_L2WIBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L2WIBAR_L2WIBAR_SHIFT   0x00000000u
  #define  CACHE_L2WIBAR_L2WIBAR_DEFAULT 0x00000000u
  #define  CACHE_L2WIBAR_L2WIBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L2WIBAR_OF(x)          _VALUEOF(x)

  #define CACHE_L2WIBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2WIBAR,L2WIBAR) \
  )

  #define CACHE_L2WIBAR_RMK(l2wibar) (Uint32)( \
     _PER_FMK(CACHE,L2WIBAR,L2WIBAR,l2wibar) \
  )

  #define _CACHE_L2WIBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L2WIBAR_ADDR,CACHE,L2WIBAR,##FIELD)

  #define _CACHE_L2WIBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2WIBAR_ADDR,CACHE,L2WIBAR,##FIELD,field)

  #define _CACHE_L2WIBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2WIBAR_ADDR,CACHE,L2WIBAR,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 2 W I W C      |
* |___________________|
*
* L2WIWC   - L2 writeback-invalidate word count register
*
* Fields:
* (rw) L2WIWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2WIWC_ADDR           0x01844014u

  #define _CACHE_L2WIWC_L2WIWC_MASK     0x0000FFFFu
  #define _CACHE_L2WIWC_L2WIWC_SHIFT    0x00000000u
  #define  CACHE_L2WIWC_L2WIWC_DEFAULT  0x00000000u
  #define  CACHE_L2WIWC_L2WIWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L2WIWC_OF(x)          _VALUEOF(x)

  #define CACHE_L2WIWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2WIWC,L2WIWC) \
  )

  #define CACHE_L2WIWC_RMK(l2wiwc) (Uint32)( \
     _PER_FMK(CACHE,L2WIWC,L2WIWC,l2wiwc) \
  )

  #define _CACHE_L2WIWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L2WIWC_ADDR,CACHE,L2WIWC,##FIELD)

  #define _CACHE_L2WIWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2WIWC_ADDR,CACHE,L2WIWC,##FIELD,field)

  #define _CACHE_L2WIWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2WIWC_ADDR,CACHE,L2WIWC,##FIELD,##SYM)
#endif

/******************************************************************************\
* ___________________
* |                 |
* |  L 2 I B A R    |
* |_________________|
*
* L2IBAR  - L2 invalidate base address register
*
* Fields:
* (rw) L2IBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT && C64_SUPPORT)
  #define _CACHE_L2IBAR_ADDR           0x01844018u

  #define _CACHE_L2IBAR_L2IBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L2IBAR_L2IBAR_SHIFT   0x00000000u
  #define  CACHE_L2IBAR_L2IBAR_DEFAULT 0x00000000u
  #define  CACHE_L2IBAR_L2IBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L2IBAR_OF(x)          _VALUEOF(x)

  #define CACHE_L2IBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2IBAR,L2IBAR) \
  )

  #define CACHE_L2IBAR_RMK(l2ibar) (Uint32)( \
     _PER_FMK(CACHE,L2IBAR,L2IBAR,l2ibar) \
  )

  #define _CACHE_L2IBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L2IBAR_ADDR,CACHE,L2IBAR,##FIELD)

  #define _CACHE_L2IBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2IBAR_ADDR,CACHE,L2IBAR,##FIELD,field)

  #define _CACHE_L2IBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2IBAR_ADDR,CACHE,L2IBAR,##FIELD,##SYM)
#endif

/******************************************************************************\
* ___________________
* |                 |
* |  L 2 I W C      |
* |_________________|
*
* L2IWC   - L2 invalidate word count register
*
* Fields:
* (rw) L2IWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT && C64_SUPPORT)
  #define _CACHE_L2IWC_ADDR           0x0184401Cu

  #define _CACHE_L2IWC_L2IWC_MASK     0x0000FFFFu
  #define _CACHE_L2IWC_L2IWC_SHIFT    0x00000000u
  #define  CACHE_L2IWC_L2IWC_DEFAULT  0x00000000u
  #define  CACHE_L2IWC_L2IWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L2IWC_OF(x)          _VALUEOF(x)

  #define CACHE_L2IWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2IWC,L2IWC) \
  )

  #define CACHE_L2IWC_RMK(l2iwc) (Uint32)( \
     _PER_FMK(CACHE,L2IWC,L2IWC,l2iwc) \
  )

  #define _CACHE_L2IWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L2IWC_ADDR,CACHE,L2IWC,##FIELD)

  #define _CACHE_L2IWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2IWC_ADDR,CACHE,L2IWC,##FIELD,field)

  #define _CACHE_L2IWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2IWC_ADDR,CACHE,L2IWC,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 1 P I B A R    |
* |___________________|
*
* L1PIBAR  - L1P invalidate base address register
*
* Fields:
* (rw) L1PIBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L1PIBAR_ADDR            0x01844020u

  #define _CACHE_L1PIBAR_L1PIBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L1PIBAR_L1PIBAR_SHIFT   0x00000000u
  #define  CACHE_L1PIBAR_L1PIBAR_DEFAULT 0x00000000u
  #define  CACHE_L1PIBAR_L1PIBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L1PIBAR_OF(x)           _VALUEOF(x)

  #define CACHE_L1PIBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1PIBAR,L1PIBAR) \
  )

  #define CACHE_L1PIBAR_RMK(l1pibar) (Uint32)( \
     _PER_FMK(CACHE,L1PIBAR,L1PIBAR,l1pibar) \
  )

  #define _CACHE_L1PIBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L1PIBAR_ADDR,CACHE,L1PIBAR,##FIELD)

  #define _CACHE_L1PIBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1PIBAR_ADDR,CACHE,L1PIBAR,##FIELD,field)

  #define _CACHE_L1PIBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1PIBAR_ADDR,CACHE,L1PIBAR,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 1 P I W C      |
* |___________________|
*
* L1PIWC   - L1P invalidate word count register
*
* Fields:
* (rw) L1PFWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L1PIWC_ADDR            0x01844024u

  #define _CACHE_L1PIWC_L1PIWC_MASK     0x0000FFFFu
  #define _CACHE_L1PIWC_L1PIWC_SHIFT    0x00000000u
  #define  CACHE_L1PIWC_L1PIWC_DEFAULT  0x00000000u
  #define  CACHE_L1PIWC_L1PIWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L1PIWC_OF(x)           _VALUEOF(x)

  #define CACHE_L1PIWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1PIWC,L1PIWC) \
  )

  #define CACHE_L1PIWC_RMK(l1piwc) (Uint32)( \
     _PER_FMK(CACHE,L1PIWC,L1PIWC,l1piwc) \
  )

  #define _CACHE_L1PIWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L1PIWC_ADDR,CACHE,L1PIWC,##FIELD)

  #define _CACHE_L1PIWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1PIWC_ADDR,CACHE,L1PIWC,##FIELD,field)

  #define _CACHE_L1PIWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1PIWC_ADDR,CACHE,L1PIWC,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 1 D W I B A R  |
* |___________________|
*
* L1DWIBAR - L1D writeback-invalidate base address register
*
* Fields:
* (rw) L1DWIBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L1DWIBAR_ADDR            0x01844030u

  #define _CACHE_L1DWIBAR_L1DWIBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L1DWIBAR_L1DWIBAR_SHIFT   0x00000000u
  #define  CACHE_L1DWIBAR_L1DWIBAR_DEFAULT 0x00000000u
  #define  CACHE_L1DWIBAR_L1DWIBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L1DWIBAR_OF(x)           _VALUEOF(x)

  #define CACHE_L1DWIBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1DWIBAR,L1DWIBAR) \
  )

  #define CACHE_L1DWIBAR_RMK(l1dwibar) (Uint32)( \
     _PER_FMK(CACHE,L1DWIBAR,L1DWIBAR,l1dwibar) \
  )

  #define _CACHE_L1DWIBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L1DWIBAR_ADDR,CACHE,L1DWIBAR,##FIELD)

  #define _CACHE_L1DWIBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1DWIBAR_ADDR,CACHE,L1DWIBAR,##FIELD,field)

  #define _CACHE_L1DWIBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1DWIBAR_ADDR,CACHE,L1DWIBAR,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 1 D W I W C    |
* |___________________|
*
* L1DWIWC  - L1D writeback-invalidate word count register
*
* Fields:
* (rw) L1DWIWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L1DWIWC_ADDR            0x01844034u

  #define _CACHE_L1DWIWC_L1DWIWC_MASK     0x0000FFFFu
  #define _CACHE_L1DWIWC_L1DWIWC_SHIFT    0x00000000u
  #define  CACHE_L1DWIWC_L1DWIWC_DEFAULT  0x00000000u
  #define  CACHE_L1DWIWC_L1DWIWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L1DWIWC_OF(x)           _VALUEOF(x)

  #define CACHE_L1DWIWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1DWIWC,L1DWIWC) \
  )

  #define CACHE_L1DWIWC_RMK(l1dwiwc) (Uint32)( \
     _PER_FMK(CACHE,L1DWIWC,L1DWIWC,l1dwiwc) \
  )

  #define _CACHE_L1DWIWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L1DWIWC_ADDR,CACHE,L1DWIWC,##FIELD)

  #define _CACHE_L1DWIWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1DWIWC_ADDR,CACHE,L1DWIWC,##FIELD,field)

  #define _CACHE_L1DWIWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1DWIWC_ADDR,CACHE,L1DWIWC,##FIELD,##SYM)
#endif

/******************************************************************************\
* ___________________
* |                 |
* |  L 1 D I B A R  |
* |_________________|
*
* L1DIBAR - L1D invalidate base address register
*
* Fields:
* (rw) L1DIBAR
*
\******************************************************************************/
#if (L2CACHE_SUPPORT && C64_SUPPORT)
  #define _CACHE_L1DIBAR_ADDR            0x01844048u

  #define _CACHE_L1DIBAR_L1DIBAR_MASK    0xFFFFFFFFu
  #define _CACHE_L1DIBAR_L1DIBAR_SHIFT   0x00000000u
  #define  CACHE_L1DIBAR_L1DIBAR_DEFAULT 0x00000000u
  #define  CACHE_L1DIBAR_L1DIBAR_OF(x)   _VALUEOF(x)

  #define  CACHE_L1DIBAR_OF(x)           _VALUEOF(x)

  #define CACHE_L1DIBAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1DIBAR,L1DIBAR) \
  )

  #define CACHE_L1DIBAR_RMK(l1dibar) (Uint32)( \
     _PER_FMK(CACHE,L1DIBAR,L1DIBAR,l1dibar) \
  )

  #define _CACHE_L1DIBAR_FGET(FIELD)\
    _PER_FGET(_CACHE_L1DIBAR_ADDR,CACHE,L1DIBAR,##FIELD)

  #define _CACHE_L1DIBAR_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1DIBAR_ADDR,CACHE,L1DIBAR,##FIELD,field)

  #define _CACHE_L1DIBAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1DIBAR_ADDR,CACHE,L1DIBAR,##FIELD,##SYM)
#endif

/******************************************************************************\
* ___________________
* |                 |
* |  L 1 D I W C    |
* |_________________|
*
* L1DIWC  - L1D invalidate word count register
*
* Fields:
* (rw) L1DIWC
*
\******************************************************************************/
#if (L2CACHE_SUPPORT && C64_SUPPORT)
  #define _CACHE_L1DIWC_ADDR            0x0184404Cu

  #define _CACHE_L1DIWC_L1DIWC_MASK     0x0000FFFFu
  #define _CACHE_L1DIWC_L1DIWC_SHIFT    0x00000000u
  #define  CACHE_L1DIWC_L1DIWC_DEFAULT  0x00000000u
  #define  CACHE_L1DIWC_L1DIWC_OF(x)    _VALUEOF(x)

  #define  CACHE_L1DIWC_OF(x)           _VALUEOF(x)

  #define CACHE_L1DIWC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L1DIWC,L1DIWC) \
  )

  #define CACHE_L1DIWC_RMK(l1diwc) (Uint32)( \
     _PER_FMK(CACHE,L1DIWC,L1DIWC,l1diwc) \
  )

  #define _CACHE_L1DIWC_FGET(FIELD)\
    _PER_FGET(_CACHE_L1DIWC_ADDR,CACHE,L1DIWC,##FIELD)

  #define _CACHE_L1DIWC_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L1DIWC_ADDR,CACHE,L1DIWC,##FIELD,field)

  #define _CACHE_L1DIWC_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L1DIWC_ADDR,CACHE,L1DIWC,##FIELD,##SYM)
#endif

/******************************************************************************\
* _______________
* |             |
* |  L 2 W B    |
* |_____________|
*
* L2WB     - L2 writeback all register
*
* Fields:
* (rw) L2WB
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2WB_ADDR      0x01845000u

  #define _CACHE_L2WB_C_MASK    0x00000001u
  #define _CACHE_L2WB_C_SHIFT   0x00000000u
  #define  CACHE_L2WB_C_DEFAULT 0x00000000u
  #define  CACHE_L2WB_C_OF(x)   _VALUEOF(x)
  #define  CACHE_L2WB_C_NORMAL  0x00000000u
  #define  CACHE_L2WB_C_FLUSH   0x00000001u

  #define  CACHE_L2WB_OF(x)     _VALUEOF(x)

  #define CACHE_L2WB_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2WB,C) \
  )

  #define CACHE_L2WB_RMK(c) (Uint32)( \
     _PER_FMK(CACHE,L2WB,C,c) \
  )

  #define _CACHE_L2WB_FGET(FIELD)\
    _PER_FGET(_CACHE_L2WB_ADDR,CACHE,L2WB,##FIELD)

  #define _CACHE_L2WB_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2WB_ADDR,CACHE,L2WB,##FIELD,field)

  #define _CACHE_L2WB_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2WB_ADDR,CACHE,L2WB,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  L 2 W B I N V    |
* |___________________|
*
* L2WBINV  - L2 writeback-invalidate all register
*
* Fields:
* (rw) C
*
\******************************************************************************/
#if (L2CACHE_SUPPORT)
  #define _CACHE_L2WBINV_ADDR       0x01845004u

  #define _CACHE_L2WBINV_C_MASK     0x00000001u
  #define _CACHE_L2WBINV_C_SHIFT    0x00000000u
  #define  CACHE_L2WBINV_C_DEFAULT  0x00000000u
  #define  CACHE_L2WBINV_C_OF(x)    _VALUEOF(x)
  #define  CACHE_L2WBINV_C_NORMAL   0x00000000u
  #define  CACHE_L2WBINV_C_CLEAN    0x00000001u

  #define  CACHE_L2WBINV_OF(x)      _VALUEOF(x)

  #define CACHE_L2WBINV_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CACHE,L2WBINV,C) \
  )

  #define CACHE_L2WBINV_RMK(c) (Uint32)( \
     _PER_FMK(CACHE,L2WBINV,C,c) \
  )

  #define _CACHE_L2WBINV_FGET(FIELD)\
    _PER_FGET(_CACHE_L2WBINV_ADDR,CACHE,L2WBINV,##FIELD)

  #define _CACHE_L2WBINV_FSET(FIELD,field)\
    _PER_FSET(_CACHE_L2WBINV_ADDR,CACHE,L2WBINV,##FIELD,field)

  #define _CACHE_L2WBINV_FSETS(FIELD,SYM)\
    _PER_FSETS(_CACHE_L2WBINV_ADDR,CACHE,L2WBINV,##FIELD,##SYM)
#endif

/*----------------------------------------------------------------------------*/

#endif /* CACHE_SUPPORT */
#endif /* _CSL_CACHEHAL_H_ */
/******************************************************************************\
* End of csl_cachehal.h
\******************************************************************************/


csl_chip.h/     1092218717  0     0     0       8328      `
/******************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_chip.h
* DATE CREATED.. 08/19/1999 
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                06/17/2003   - Added support for 6712C
*                06/09/2003   - Added support for 6711C
*                12/03/2001   - CHIP_configArgs
*                11/08/2001   - CHIP_getSiliconRevId()
*                             - CHIP_config() / CHIP_getConfig  DM642
\******************************************************************************/
#ifndef _CSL_CHIP_H_
#define _CSL_CHIP_H_

#include <csl_stdinc.h>

#include <csl_chiphal.h>
#include <csl_emifhal.h>


/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _CHIP_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/
#define CHIP_ENDIAN_BIG    0
#define CHIP_ENDIAN_LITTLE 1

#define CHIP_MAP_0         0
#define CHIP_MAP_1         1

/* Selected devices masks*/
#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
#define CHIP_EKSRC_SYSCLK3  0x00000000u
#define CHIP_EKSRC_ECLKIN   0x00000010u
#endif

#if (CHIP_6713 || CHIP_DA610)
#define CHIP_TOUT1          0x00000000u
#define CHIP_AXR04_AXR111   0x00000008u

#define CHIP_TOUT0          0x00000000u
#define CHIP_AXR02_AXR113   0x00000004u

#define CHIP_MCASP0         0x00000002u
#define CHIP_MCBSP0         0x00000000u

#define CHIP_I2C1           0x00000001u
#define CHIP_MCBSP1         0x00000000u
/* Full mask value */
#define _CHIP_DEVCFG_MASK  0x0000001Fu
#endif

#if CHIP_DM642
#define CHIP_VP2            0x00000040u
#define CHIP_VP1            0x00000020u
#define CHIP_VP0            0x00000010u
#define CHIP_I2C            0x00000008u
#define CHIP_MCBSP1         0x00000004u
#define CHIP_MCBSP0         0x00000002u
#define CHIP_MCASP0         0x00000001u

#define _CHIP_DEVCFG_MASK   0x0000007Fu
#endif

#if CHIP_DM641
#define CHIP_VP1            0x00000020u
#define CHIP_VP0            0x00000010u
#define CHIP_I2C            0x00000008u
#define CHIP_MCBSP1         0x00000004u
#define CHIP_MCBSP0         0x00000002u
#define CHIP_MCASP0         0x00000001u

#define _CHIP_DEVCFG_MASK   0x0000003Fu
#endif

#if CHIP_DM640
#define CHIP_VP0            0x00000010u
#define CHIP_I2C            0x00000008u
#define CHIP_MCBSP1         0x00000004u
#define CHIP_MCBSP0         0x00000002u
#define CHIP_MCASP0         0x00000001u

#define _CHIP_DEVCFG_MASK   0x0000001Fu
#endif

#if CHIP_6412
#define CHIP_I2C            0x00000008u
#define CHIP_MCBSP1         0x00000004u
#define CHIP_MCBSP0         0x00000002u
#define _CHIP_DEVCFG_MASK   0x0000000Eu
#endif

#if (CHIP_6410 || CHIP_6413 || CHIP_6418)
#define CHIP_ATL            0x80000000u
#define CHIP_ADIV           0x60000000u
#define CHIP_ATLMEN         0x10000000u
#define CHIP_AFCMUX         0x00000600u
#define CHIP_MCASP1         0x00000100u
#define CHIP_I2C1           0x00000080u
#define CHIP_I2C0           0x00000008u
#define CHIP_MCBSP1         0x00000004u
#define CHIP_MCBSP0         0x00000002u
#define CHIP_MCASP0         0x00000001u

#define _CHIP_DEVCFG_MASK   0xF000078Fu
#endif

/******************************************************************************\
* global typedef declarations
\******************************************************************************/

typedef struct{
   Uint32 devcfg;
} CHIP_Config; 

/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 CHIP_getCpuId();
IDECL Uint32 CHIP_getRevId();
IDECL Uint32 CHIP_getSiliconRevId();
IDECL int    CHIP_getEndian();
IDECL int    CHIP_getMapMode();

#if (CHIP_6713 || CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_DA610 || CHIP_6412 || CHIP_6711C || CHIP_6712C || CHIP_6410 || CHIP_6413 || CHIP_6418) 
IDECL void   CHIP_config(CHIP_Config *config);
IDECL void   CHIP_configArgs(Uint32 devcfg);
IDECL void   CHIP_getConfig(CHIP_Config *config); 
#endif

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 CHIP_getCpuId() {
  return CHIP_FGET(CSR,CPUID);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 CHIP_getRevId() {
  return CHIP_FGET(CSR,REVID);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 CHIP_getSiliconRevId() {
  return (( 0x000F0000 & REG32(0x01B00200))>>16);
}
/*----------------------------------------------------------------------------*/
IDEF int CHIP_getEndian() {
  return CHIP_FGET(CSR,EN);
}
/*----------------------------------------------------------------------------*/
IDEF int CHIP_getMapMode() {
  int mapmode = 0;
  #if (!C11_SUPPORT && !C64_SUPPORT)
    mapmode = EMIF_FGET(GBLCTL,MAP);
  #endif
  return mapmode;
}
/*----------------------------------------------------------------------------*/
#if (CHIP_6713 || CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_DA610 || CHIP_6412 || CHIP_6711C || CHIP_6712C || CHIP_6410 || CHIP_6413 || CHIP_6418)
IDEF void   CHIP_config(CHIP_Config *config) {
  Uint32 gie = CHIP_FGET(CSR,GIE);
  volatile Uint32 *base = (volatile Uint32 *)(_CHIP_DEVCFG_ADDR);
  register int x0;

  CHIP_FSET(CSR,GIE,0);

#if(CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_6412 || CHIP_6410 || CHIP_6413 || CHIP_6418)
  CHIP_FSETS(PCFGLOCK,LOCK,UNLOCK);
#endif

  x0 = config->devcfg;
  base[_CHIP_DEVCFG_OFFSET] = x0;

  CHIP_FSET(CSR,GIE,gie);
}      
#endif
/*----------------------------------------------------------------------------*/
#if (CHIP_6713 || CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_DA610 || CHIP_6412 || CHIP_6711C || CHIP_6712C || CHIP_6410 || CHIP_6413 || CHIP_6418)
IDEF void   CHIP_getConfig(CHIP_Config *config) {
   Uint32 gie = CHIP_FGET(CSR,GIE);
   volatile Uint32 *base = (volatile Uint32 *)(_CHIP_DEVCFG_ADDR);
   register int x0;

   CHIP_FSET(CSR,GIE,0);

   x0 = base[_CHIP_DEVCFG_OFFSET]; 
   config->devcfg=x0;

   CHIP_FSET(CSR,GIE,gie);
}      
#endif
/*----------------------------------------------------------------------------*/
#if (CHIP_6713 || CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_DA610 || CHIP_6412 || CHIP_6711C || CHIP_6712C || CHIP_6410 || CHIP_6413 || CHIP_6418)
IDEF void   CHIP_configArgs(Uint32 devcfg) {
   Uint32 gie = CHIP_FGET(CSR,GIE);
   volatile Uint32 *base = (volatile Uint32 *)(_CHIP_DEVCFG_ADDR);

  CHIP_FSET(CSR,GIE,0);

#if(CHIP_DM642 || CHIP_6412)
  CHIP_FSETS(PCFGLOCK,LOCK,UNLOCK);
#endif

  base[_CHIP_DEVCFG_OFFSET]= devcfg; 

  CHIP_FSET(CSR,GIE,gie);
}      
#endif

/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* _CSL_CHIP_H_ */
/******************************************************************************\
* End of csl_chip.h
\******************************************************************************/

csl_chiphal.h/  1092218718  0     0     0       86144     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_chiphal.h
* DATE CREATED.. 14 Aug 2000
* LAST MODIFIED. 14 Jan 2004 Adding support for DRI300 versions (6410, 6413)
*                05 Aug 2003 Removing external control cregisters EM,ER,IN,OUT and DIER.
*                26 Jun 2003 Added support for 6411
*                17 Jun 2003 Added support for 6712C
*                28 May 2003 Added support for 6711C
*                05 Nov 2001 DM642 , 6411 remove 6400
*                03 Oct 2001 - CHIP_6713 - MCASP_SUPPORT - IIC_SUPPORT
*                           - DEVCFG register
*                           - redefinition of CHIP_RSET() / CHIP_RGET()
*                           - new CHIP_CRSET() / CHIP_CRGET() => modification of csl_irq.h
*                04 Apr 2004-  Removing external control cregisters EM,ER,IN,OUT and DIER.
*------------------------------------------------------------------------------
* REGISTERS
*
* CSR    - control/status register
* IFR    - interrupt flag register
* ISR    - interrupt set register
* ICR    - interrupt clear register
* IER    - interrupt enable register
* ISTP   - interrupt service table pointer register
* IRP    - interrupt return pointer
* NRP    - non-maskable interrupt return pointer
* AMR    - addressing mode reister
* FADCR  - floating point adder configuration register  (2)
* FAUCR  - floating point auxiliary control register  (2)
* FMCR   - floating point multiplier configuration register  (2)
* GFPGFR - Galois field polynomial generator function register  (3)
* DEVCFG - Device Configuration register  (4)
* DEVSTAT - Device Status Register (5)
* JTAGID - JTAG ID register (5)
*
* (1) only supported on 67xx
* (2) only supported on floating point devices
* (3) only supported on 6411/14/15/16 devices
* (4) only supported on 6713/DA610/DM642/6412/6711C/6712C devices
* (5) only supported on DM642/6412/6410/6413 devices
*
\******************************************************************************/
#ifndef _CSL_CHIPHAL_H_
#define _CSL_CHIPHAL_H_

#include <csl_stdinc.h>


/******************************************************************************\
* CHIP identification section
\******************************************************************************/
#ifdef CHIP_BASELINE
  #undef CHIP_BASELINE
  #define CHIP_BASELINE 1
#else
  #define CHIP_BASELINE 0
#endif

#if (CHIP_BASELINE)
  #define CHIP_6201 1
#endif

#ifdef CHIP_6201
  #undef CHIP_6201
  #define CHIP_6201 1
#else
  #define CHIP_6201 0
#endif

#ifdef CHIP_6202
  #undef CHIP_6202
  #define CHIP_6202 1
#else
  #define CHIP_6202 0
#endif

#ifdef CHIP_6203
  #undef CHIP_6203
  #define CHIP_6203 1
#else
  #define CHIP_6203 0
#endif

#ifdef CHIP_6204
  #undef CHIP_6204
  #define CHIP_6204 1
#else
  #define CHIP_6204 0
#endif

#ifdef CHIP_6205
  #undef CHIP_6205
  #define CHIP_6205 1
#else
  #define CHIP_6205 0
#endif

#ifdef CHIP_6211
  #undef CHIP_6211
  #define CHIP_6211 1
#else
  #define CHIP_6211 0
#endif

#ifdef CHIP_6701
  #undef CHIP_6701
  #define CHIP_6701 1
#else
  #define CHIP_6701 0
#endif

#ifdef CHIP_6711
  #undef CHIP_6711
  #define CHIP_6711 1
#else
  #define CHIP_6711 0
#endif

#ifdef CHIP_6712
  #undef CHIP_6712
  #define CHIP_6712 1
#else
  #define CHIP_6712 0
#endif


#ifdef CHIP_6713
  #undef CHIP_6713
  #define CHIP_6713 1
#else
  #define CHIP_6713 0
#endif

#ifdef CHIP_DA610
  #undef CHIP_DA610
  #define CHIP_DA610 1
#else
  #define CHIP_DA610 0
#endif

#ifdef CHIP_DM642
  #undef CHIP_DM642
  #define CHIP_DM642 1
#else
  #define CHIP_DM642 0
#endif

#ifdef CHIP_DM641
  #undef CHIP_DM641
  #define CHIP_DM641 1
#else
  #define CHIP_DM641 0
#endif

#ifdef CHIP_DM640
  #undef CHIP_DM640
  #define CHIP_DM640 1
#else
  #define CHIP_DM640 0
#endif

#ifdef CHIP_6412
  #undef CHIP_6412
  #define CHIP_6412 1
#else
  #define CHIP_6412 0
#endif

#ifdef CHIP_6414
  #undef CHIP_6414
  #define CHIP_6414 1
#else
  #define CHIP_6414 0
#endif

#ifdef CHIP_6415
  #undef CHIP_6415
  #define CHIP_6415 1
#else
  #define CHIP_6415 0
#endif

#ifdef CHIP_6416
  #undef CHIP_6416
  #define CHIP_6416 1
#else
  #define CHIP_6416 0
#endif

#ifdef CHIP_6711C
  #undef CHIP_6711C
  #define CHIP_6711C 1
#else
  #define CHIP_6711C 0
#endif

#ifdef CHIP_6712C
  #undef CHIP_6712C
  #define CHIP_6712C 1
#else
  #define CHIP_6712C 0
#endif

#ifdef CHIP_6411
  #undef CHIP_6411
  #define CHIP_6411 1
#else
  #define CHIP_6411 0
#endif

/* next two are DRI300 versions */
#ifdef CHIP_6410
  #undef CHIP_6410
  #define CHIP_6410 1
#else
  #define CHIP_6410 0
#endif

#ifdef CHIP_6413
  #undef CHIP_6413
  #define CHIP_6413 1
#else
  #define CHIP_6413 0
#endif

#ifdef CHIP_6418
  #undef CHIP_6418
  #define CHIP_6418 1
#else
  #define CHIP_6418 0
#endif

#define CHIP_OROFALL (\
  CHIP_6201 | \
  CHIP_6202 | \
  CHIP_6203 | \
  CHIP_6204 | \
  CHIP_6205 | \
  CHIP_6211 | \
  CHIP_6701 | \
  CHIP_6711 | \
  CHIP_6712 | \
  CHIP_6713 | \
  CHIP_DA610 | \
  CHIP_DM642 | \
  CHIP_DM641 | \
  CHIP_DM640 | \
  CHIP_6412 | \
  CHIP_6414 | \
  CHIP_6415 | \
  CHIP_6416 |  \
  CHIP_6711C | \
  CHIP_6712C | \
  CHIP_6411 |\
  CHIP_6410 |\
  CHIP_6413 |\
  CHIP_6418 \
)

#if (CHIP_OROFALL==0)
  #error NO CHIP DEFINED (use -dCHIP_XXXX where XXXX is chip number, i.e. 6201)
#endif

#define CHIP_NONE 0

#define CHIP_SUPPORT(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,c21,c22,c23,c24) ( \
  ( c0*CHIP_6201)  | \
  ( c1*CHIP_6202)  | \
  ( c2*CHIP_6203)  | \
  ( c3*CHIP_6204)  | \
  ( c4*CHIP_6205)  | \
  ( c5*CHIP_6211)  | \
  ( c6*CHIP_6701)  | \
  ( c7*CHIP_6711)  | \
  ( c8*CHIP_6712)  | \
  ( c9*CHIP_6713)  | \
  ( c10*CHIP_DA610)| \
  ( c11*CHIP_DM642)| \
  ( c12*CHIP_DM641)| \
  ( c13*CHIP_DM640)| \
  ( c14*CHIP_6412) | \
  ( c15*CHIP_6414) | \
  ( c16*CHIP_6415) | \
  ( c17*CHIP_6416) | \
  ( c18*CHIP_6711C) | \
  ( c19*CHIP_6712C) | \
  ( c20*CHIP_6411) | \
  ( c21*CHIP_6410) | \
  ( c22*CHIP_6413) | \
  ( c23*CHIP_6418) | \
  ( c24*CHIP_NONE)   \
 )

/*---------------------------------------------------------------------------------------*/
/*                                     6 6 6 6 6 6 6 6 6 6 D D D D 6 6 6 6 6 6 6 6 6 6 N */
/*                                     2 2 2 2 2 2 7 7 7 7 A M M M 4 4 4 4 7 7 4 4 4 4 O */
/*                                     0 0 0 0 0 1 0 1 1 1 6 6 6 6 1 1 1 1 1 1 1 1 1 1 N */
/*                                     1 2 3 4 5 1 1 1 2 3 1 4 4 4 2 4 5 6 1 2 1 0 3 8 E */
/*                                                         0 2 1 0         C C           */
/*---------------------------------------------------------------------------------------*/
#define CACHE_SUPPORT     CHIP_SUPPORT(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define DMA_SUPPORT       CHIP_SUPPORT(1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
#define EDMA_SUPPORT      CHIP_SUPPORT(0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define EMIF_SUPPORT      CHIP_SUPPORT(1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0)
#define EMIFA_SUPPORT     CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,0)
#define EMIFB_SUPPORT     CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0)
#define GPIO_SUPPORT      CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define HPI_SUPPORT       CHIP_SUPPORT(1,0,0,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0)
#define I2C_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0)
#define IRQ_SUPPORT       CHIP_SUPPORT(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define MCASP_SUPPORT     CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0)
#define MCBSP_SUPPORT     CHIP_SUPPORT(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define PLL_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,0,0)
#define TIMER_SUPPORT     CHIP_SUPPORT(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define XBUS_SUPPORT      CHIP_SUPPORT(0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
#define PCI_SUPPORT       CHIP_SUPPORT(0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0,1,0,0,0,0)
/*---------------------------------------------------------------------------------------*/
/*                                     6 6 6 6 6 6 6 6 6 6 D D D D 6 6 6 6 6 6 6 6 6 6 N */
/*                                     2 2 2 2 2 2 7 7 7 7 A M M M 4 4 4 4 7 7 4 4 4 4 O */
/*                                     0 0 0 0 0 1 0 1 1 1 6 6 6 6 1 1 1 1 1 1 1 1 1 1 N */
/*                                     1 2 3 4 5 1 1 1 2 3 1 4 4 4 2 4 5 6 1 2 1 0 3 8 E */
/*                                                         0 2 1 0         C C           */
/*---------------------------------------------------------------------------------------*/
#define VP_SUPPORT        CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define VIC_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0)
#define DAT_SUPPORT       CHIP_SUPPORT(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define PWR_SUPPORT       CHIP_SUPPORT(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define UTOP_SUPPORT      CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0)
#define TCP_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0)
#define VCP_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0)
#define EMAC_SUPPORT      CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define MDIO_SUPPORT      CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0)
#define EMU_SUPPORT	  CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0)
                                                                                       
#define L2CACHE_SUPPORT   CHIP_SUPPORT(0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define TC_SUPPORT        CHIP_SUPPORT(0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0)
#define FPU_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0)
#define C01_SUPPORT       CHIP_SUPPORT(1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
#define C11_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0)
#define C64_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,0)
#define ATL_SUPPORT       CHIP_SUPPORT(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0)

#define CACHE_L2_SUPPORT  L2CACHE_SUPPORT
/*----------------------------------------------------------------------*/


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define CHIP_FMK(REG,FIELD,x)\
    _PER_FMK(CHIP,##REG,##FIELD,x)

  #define CHIP_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(CHIP,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define CHIP_CRGET(REG)\
    _PER_CRGET(CHIP,##REG)

  #define CHIP_CRSET(REG,x)\
    _PER_CRSET(CHIP,##REG,x)

  #define CHIP_RGET(REG)\
   _PER_RGET(_CHIP_##REG##_ADDR,CHIP,##REG)

  #define CHIP_RSET(REG,x)\
     _PER_RSET(_CHIP_##REG##_ADDR,CHIP,##REG,x)


  #define CHIP_FGET(REG,FIELD)\
    _CHIP_##REG##_FGET(##FIELD)

  #define CHIP_FSET(REG,FIELD,x)\
    _CHIP_##REG##_FSET(##FIELD,x)

  #define CHIP_FSETS(REG,FIELD,SYM)\
    _CHIP_##REG##_FSETS(##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C S R            |
* |___________________|
*
* CSR - control/status register
*
* FIELDS (msb -> lsb)
* (r)  CPUID
* (r)  REVID
* (rw) PWRD
* (rc) SAT
* (r)  EN
* (rw) PCC
* (rw) DCC
* (rw) PGIE
* (rw) GIE
*
\******************************************************************************/
  extern far cregister volatile unsigned int CSR;

  #define _CHIP_CSR_CPUID_MASK         0xFF000000u
  #define _CHIP_CSR_CPUID_SHIFT        0x00000018u
  #define  CHIP_CSR_CPUID_DEFAULT      0x00000000u
  #define  CHIP_CSR_CPUID_OF(x)        _VALUEOF(x)
  #define  CHIP_CSR_CPUID_C62X         0x00000000u
  #define  CHIP_CSR_CPUID_C67X         0x00000002u
  #define  CHIP_CSR_CPUID_C64X         0x00000004u

  #define _CHIP_CSR_REVID_MASK         0x00FF0000u
  #define _CHIP_CSR_REVID_SHIFT        0x00000010u
  #define  CHIP_CSR_REVID_DEFAULT      0x00000000u
  #define  CHIP_CSR_REVID_OF(x)        _VALUEOF(x)
  #define  CHIP_CSR_REVID_620120       0x00000001u
  #define  CHIP_CSR_REVID_620121       0x00000001u
  #define  CHIP_CSR_REVID_620130       0x00000002u
  #define  CHIP_CSR_REVID_670100       0x00000201u
  #define  CHIP_CSR_REVID_670110       0x00000202u
  #define  CHIP_CSR_REVID_621110       0x00000002u
  #define  CHIP_CSR_REVID_640010       0x00000801u
  #define  CHIP_CSR_REVID_6202         0x00000002u
  #define  CHIP_CSR_REVID_6202B        0x00000003u
  #define  CHIP_CSR_REVID_6711         0x00000002u
  #define  CHIP_CSR_REVID_6711C        0x00000003u
  #define  CHIP_CSR_REVID_6712         0x00000002u
  #define  CHIP_CSR_REVID_6712C        0x00000003u

  #define _CHIP_CSR_PWRD_MASK          0x0000FC00u
  #define _CHIP_CSR_PWRD_SHIFT         0x0000000Au
  #define  CHIP_CSR_PWRD_DEFAULT       0x00000000u
  #define  CHIP_CSR_PWRD_OF(x)         _VALUEOF(x)
  #define  CHIP_CSR_PWRD_NONE          0x00000000u
  #define  CHIP_CSR_PWRD_PD1A          0x00000009u
  #define  CHIP_CSR_PWRD_PD1B          0x00000011u
  #define  CHIP_CSR_PWRD_PD2           0x0000001Au
  #define  CHIP_CSR_PWRD_PD3           0x0000001Cu

  #define _CHIP_CSR_SAT_MASK           0x00000200u
  #define _CHIP_CSR_SAT_SHIFT          0x00000009u
  #define  CHIP_CSR_SAT_DEFAULT        0x00000000u
  #define  CHIP_CSR_SAT_OF(x)          _VALUEOF(x)
  #define  CHIP_CSR_SAT_0              0x00000000u
  #define  CHIP_CSR_SAT_1              0x00000001u

  #define _CHIP_CSR_EN_MASK            0x00000100u
  #define _CHIP_CSR_EN_SHIFT           0x00000008u
  #define  CHIP_CSR_EN_DEFAULT         0x00000000u
  #define  CHIP_CSR_EN_OF(x)           _VALUEOF(x)
  #define  CHIP_CSR_EN_BIG             0x00000000u
  #define  CHIP_CSR_EN_LITTLE          0x00000001u

  #define _CHIP_CSR_PCC_MASK           0x000000E0u
  #define _CHIP_CSR_PCC_SHIFT          0x00000005u
  #define  CHIP_CSR_PCC_DEFAULT        0x00000000u
  #define  CHIP_CSR_PCC_OF(x)          _VALUEOF(x)
  #define  CHIP_CSR_PCC_MAPPED         0x00000000u
  #define  CHIP_CSR_PCC_ENABLE         0x00000002u
  #define  CHIP_CSR_PCC_FREEZE         0x00000003u
  #define  CHIP_CSR_PCC_BYPASS         0x00000004u

  #define _CHIP_CSR_DCC_MASK           0x0000001Cu
  #define _CHIP_CSR_DCC_SHIFT          0x00000002u
  #define  CHIP_CSR_DCC_DEFAULT        0x00000000u
  #define  CHIP_CSR_DCC_OF(x)          _VALUEOF(x)
  #define  CHIP_CSR_DCC_MAPPED         0x00000000u
  #define  CHIP_CSR_DCC_ENABLE         0x00000002u
  #define  CHIP_CSR_DCC_FREEZE         0x00000003u
  #define  CHIP_CSR_DCC_BYPASS         0x00000004u

  #define _CHIP_CSR_PGIE_MASK          0x00000002u
  #define _CHIP_CSR_PGIE_SHIFT         0x00000001u
  #define  CHIP_CSR_PGIE_DEFAULT       0x00000000u
  #define  CHIP_CSR_PGIE_OF(x)         _VALUEOF(x)
  #define  CHIP_CSR_PGIE_0             0x00000000u
  #define  CHIP_CSR_PGIE_1             0x00000001u

  #define _CHIP_CSR_GIE_MASK           0x00000001u
  #define _CHIP_CSR_GIE_SHIFT          0x00000000u
  #define  CHIP_CSR_GIE_DEFAULT        0x00000000u
  #define  CHIP_CSR_GIE_OF(x)          _VALUEOF(x)
  #define  CHIP_CSR_GIE_0              0x00000000u
  #define  CHIP_CSR_GIE_1              0x00000001u

  #define  CHIP_CSR_OF(x)              _VALUEOF(x)

  #define CHIP_CSR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,CSR,CPUID) \
    |_PER_FDEFAULT(CHIP,CSR,REVID) \
    |_PER_FDEFAULT(CHIP,CSR,PWRD) \
    |_PER_FDEFAULT(CHIP,CSR,SAT) \
    |_PER_FDEFAULT(CHIP,CSR,EN) \
    |_PER_FDEFAULT(CHIP,CSR,PCC) \
    |_PER_FDEFAULT(CHIP,CSR,DCC) \
    |_PER_FDEFAULT(CHIP,CSR,PGIE) \
    |_PER_FDEFAULT(CHIP,CSR,GIE) \
  )

  #define CHIP_CSR_RMK(pwrd,pcc,dcc,pgie,gie) (Uint32)( \
     _PER_FMK(CHIP,CSR,PWRD,pwrd) \
    |_PER_FMK(CHIP,CSR,PCC,pcc) \
    |_PER_FMK(CHIP,CSR,DCC,dcc) \
    |_PER_FMK(CHIP,CSR,PGIE,pgie) \
    |_PER_FMK(CHIP,CSR,GIE,gie) \
  )

  #define _CHIP_CSR_FGET(FIELD)\
    _PER_CFGET(CHIP,CSR,##FIELD)

  #define _CHIP_CSR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,CSR,##FIELD,field)

  #define _CHIP_CSR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,CSR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  I F R            |
* |___________________|
*
* IFR - interruppt flag register
*
* FIELDS (msb -> lsb)
* (rw) IF
*
\******************************************************************************/
  extern far cregister volatile unsigned int IFR;

  #define _CHIP_IFR_IF_MASK          0x0000FFFFu
  #define _CHIP_IFR_IF_SHIFT         0x00000000u
  #define  CHIP_IFR_IF_DEFAULT       0x00000000u
  #define  CHIP_IFR_IF_OF(x)         _VALUEOF(x)

  #define  CHIP_IFR_OF(x)            _VALUEOF(x)

  #define CHIP_IFR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,IFR,IF)\
  )

  #define CHIP_IFR_RMK(if) (Uint32)( \
     _PER_FMK(CHIP,IFR,IF,if)\
  )

  #define _CHIP_IFR_FGET(FIELD)\
    _PER_CFGET(CHIP,IFR,##FIELD)

  #define _CHIP_IFR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,IFR,##FIELD,field)

  #define _CHIP_IFR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,IFR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  I S R            |
* |___________________|
*
* ISR - interruppt set register
*
* FIELDS (msb -> lsb)
* (w) IS
*
\******************************************************************************/
  extern far cregister volatile unsigned int ISR;

  #define _CHIP_ISR_IS_MASK          0x0000FFFFu
  #define _CHIP_ISR_IS_SHIFT         0x00000000u
  #define  CHIP_ISR_IS_DEFAULT       0x00000000u
  #define  CHIP_ISR_IS_OF(x)         _VALUEOF(x)

  #define  CHIP_ISR_OF(x)            _VALUEOF(x)

  #define CHIP_ISR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,ISR,IS)\
  )

  #define CHIP_ISR_RMK(is) (Uint32)( \
     _PER_FMK(CHIP,ISR,IS,is)\
  )

  #define _CHIP_ISR_FGET(FIELD)\
    _PER_CFGET(CHIP,ISR,##FIELD)

  #define _CHIP_ISR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,ISR,##FIELD,field)

  #define _CHIP_ISR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,ISR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  I C R            |
* |___________________|
*
* ICR - interruppt clear register
*
* FIELDS (msb -> lsb)
* (w) IC
*
\******************************************************************************/
  extern far cregister volatile unsigned int ICR;

  #define _CHIP_ICR_IC_MASK          0x0000FFFFu
  #define _CHIP_ICR_IC_SHIFT         0x00000000u
  #define  CHIP_ICR_IC_DEFAULT       0x00000000u
  #define  CHIP_ICR_IC_OF(x)         _VALUEOF(x)

  #define  CHIP_ICR_OF(x)            _VALUEOF(x)

  #define CHIP_ICR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,ICR,IC)\
  )

  #define CHIP_ICR_RMK(ic) (Uint32)( \
     _PER_FMK(CHIP,ICR,IC,ic)\
  )

  #define _CHIP_ICR_FGET(FIELD)\
    _PER_CFGET(CHIP,ICR,##FIELD)

  #define _CHIP_ICR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,ICR,##FIELD,field)

  #define _CHIP_ICR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,ICR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  I E R            |
* |___________________|
*
* IER - interruppt enable register
*
* FIELDS (msb -> lsb)
* (rw) IE
*
\******************************************************************************/
  extern far cregister volatile unsigned int IER;

  #define _CHIP_IER_IE_MASK          0x0000FFFFu
  #define _CHIP_IER_IE_SHIFT         0x00000000u
  #define  CHIP_IER_IE_DEFAULT       0x00000000u
  #define  CHIP_IER_IE_OF(x)         _VALUEOF(x)

  #define  CHIP_IER_OF(x)            _VALUEOF(x)

  #define CHIP_IER_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,IER,IE)\
  )

  #define CHIP_IER_RMK(ie) (Uint32)( \
     _PER_FMK(CHIP,IER,IE,ie)\
  )

  #define _CHIP_IER_FGET(FIELD)\
    _PER_CFGET(CHIP,IER,##FIELD)

  #define _CHIP_IER_FSET(FIELD,field)\
    _PER_CFSET(CHIP,IER,##FIELD,field)

  #define _CHIP_IER_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,IER,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  I S T P          |
* |___________________|
*
* ISTP - interrupt service table pointer
*
* FIELDS (msb -> lsb)
* (r)   HPEINT
* (rw)  ISTB
*
\******************************************************************************/
  extern far cregister volatile unsigned int ISTP;

  #define _CHIP_ISTP_ISTB_MASK         0xFFFFFC00u
  #define _CHIP_ISTP_ISTB_SHIFT        0x0000000Au
  #define  CHIP_ISTP_ISTB_DEFAULT      0x00000000u
  #define  CHIP_ISTP_ISTB_OF(x)        _VALUEOF(x)

  #define _CHIP_ISTP_HPEINT_MASK       0x000003E0u
  #define _CHIP_ISTP_HPEINT_SHIFT      0x00000005u
  #define  CHIP_ISTP_HPEINT_DEFAULT    0x00000000u
  #define  CHIP_ISTP_HPEINT_OF(x)      _VALUEOF(x)

  #define  CHIP_ISTP_OF(x)             _VALUEOF(x)

  #define CHIP_ISTP_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,ISTP,ISTB)\
    |_PER_FDEFAULT(CHIP,ISTP,HPEINT)\
  )

  #define CHIP_ISTP_RMK(istb) (Uint32)( \
     _PER_FMK(CHIP,ISTP,ISTB,istb)\
  )

  #define _CHIP_ISTP_FGET(FIELD)\
    _PER_CFGET(CHIP,ISTP,##FIELD)

  #define _CHIP_ISTP_FSET(FIELD,field)\
    _PER_CFSET(CHIP,ISTP,##FIELD,field)

  #define _CHIP_ISTP_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,ISTP,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  I R P            |
* |___________________|
*
* IRP - interrupt return pointer
*
* FIELDS (msb -> lsb)
* (rw) IRP
*
\******************************************************************************/
  extern far cregister volatile unsigned int IRP;

  #define _CHIP_IRP_IRP_MASK           0xFFFFFFFFu
  #define _CHIP_IRP_IRP_SHIFT          0x00000000u
  #define  CHIP_IRP_IRP_DEFAULT        0x00000000u
  #define  CHIP_IRP_IRP_OF(x)          _VALUEOF(x)

  #define  CHIP_IRP_OF(x)              _VALUEOF(x)

  #define CHIP_IRP_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,IRP,IRP)\
  )

  #define CHIP_IRP_RMK(irp) (Uint32)( \
     _PER_FMK(CHIP,IRP,IRP,irp)\
  )

  #define _CHIP_IRP_FGET(FIELD)\
    _PER_CFGET(CHIP,IRP,##FIELD)

  #define _CHIP_IRP_FSET(FIELD,field)\
    _PER_CFSET(CHIP,IRP,##FIELD,field)

  #define _CHIP_IRP_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,IRP,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  N R P            |
* |___________________|
*
* NRP - non-maskable interrupt return pointer
*
* FIELDS (msb -> lsb)
* (rw) NRP
*
\******************************************************************************/
  extern far cregister volatile unsigned int NRP;

  #define _CHIP_NRP_NRP_MASK           0xFFFFFFFFu
  #define _CHIP_NRP_NRP_SHIFT          0x00000000u
  #define  CHIP_NRP_NRP_DEFAULT        0x00000000u
  #define  CHIP_NRP_NRP_OF(x)          _VALUEOF(x)

  #define  CHIP_NRP_OF(x)              _VALUEOF(x)

  #define CHIP_NRP_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,NRP,NRP)\
  )

  #define CHIP_NRP_RMK(nrp) (Uint32)( \
     _PER_FMK(CHIP,NRP,NRP,nrp)\
  )

  #define _CHIP_NRP_FGET(FIELD)\
    _PER_CFGET(CHIP,NRP,##FIELD)

  #define _CHIP_NRP_FSET(FIELD,field)\
    _PER_CFSET(CHIP,NRP,##FIELD,field)

  #define _CHIP_NRP_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,NRP,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  A M R            |
* |___________________|
*
* AMR - addressing mode register
*
* FIELDS (msb -> lsb)
* (rw) BK1
* (rw) BK0
* (rw) B7MODE
* (rw) B6MODE
* (rw) B5MODE
* (rw) B4MODE
* (rw) A7MODE
* (rw) A6MODE
* (rw) A5MODE
* (rw) A4MODE
*
\******************************************************************************/
  extern far cregister volatile unsigned int AMR;

  #define _CHIP_AMR_BK1_MASK           0x02E00000u
  #define _CHIP_AMR_BK1_SHIFT          0x00000015u
  #define  CHIP_AMR_BK1_DEFAULT        0x00000000u
  #define  CHIP_AMR_BK1_OF(x)          _VALUEOF(x)
  #define  CHIP_AMR_BK1_2              0x00000000u
  #define  CHIP_AMR_BK1_4              0x00000001u
  #define  CHIP_AMR_BK1_8              0x00000002u
  #define  CHIP_AMR_BK1_16             0x00000003u
  #define  CHIP_AMR_BK1_32             0x00000004u
  #define  CHIP_AMR_BK1_64             0x00000005u
  #define  CHIP_AMR_BK1_128            0x00000006u
  #define  CHIP_AMR_BK1_256            0x00000007u
  #define  CHIP_AMR_BK1_512            0x00000008u
  #define  CHIP_AMR_BK1_1K             0x00000009u
  #define  CHIP_AMR_BK1_2K             0x0000000Au
  #define  CHIP_AMR_BK1_4K             0x0000000Bu
  #define  CHIP_AMR_BK1_8K             0x0000000Cu
  #define  CHIP_AMR_BK1_16K            0x0000000Du
  #define  CHIP_AMR_BK1_32K            0x0000000Eu
  #define  CHIP_AMR_BK1_64K            0x0000000Fu
  #define  CHIP_AMR_BK1_128K           0x00000010u
  #define  CHIP_AMR_BK1_256K           0x00000011u
  #define  CHIP_AMR_BK1_512K           0x00000012u
  #define  CHIP_AMR_BK1_1M             0x00000013u
  #define  CHIP_AMR_BK1_2M             0x00000014u
  #define  CHIP_AMR_BK1_4M             0x00000015u
  #define  CHIP_AMR_BK1_8M             0x00000016u
  #define  CHIP_AMR_BK1_16M            0x00000017u
  #define  CHIP_AMR_BK1_32M            0x00000018u
  #define  CHIP_AMR_BK1_64M            0x00000019u
  #define  CHIP_AMR_BK1_128M           0x0000001Au
  #define  CHIP_AMR_BK1_256M           0x0000001Bu
  #define  CHIP_AMR_BK1_512M           0x0000001Cu
  #define  CHIP_AMR_BK1_1G             0x0000001Du
  #define  CHIP_AMR_BK1_2G             0x0000001Eu
  #define  CHIP_AMR_BK1_4G             0x0000001Fu

  #define _CHIP_AMR_BK0_MASK           0x001F0000u
  #define _CHIP_AMR_BK0_SHIFT          0x00000010u
  #define  CHIP_AMR_BK0_DEFAULT        0x00000000u
  #define  CHIP_AMR_BK0_OF(x)          _VALUEOF(x)
  #define  CHIP_AMR_BK0_2              0x00000000u
  #define  CHIP_AMR_BK0_4              0x00000001u
  #define  CHIP_AMR_BK0_8              0x00000002u
  #define  CHIP_AMR_BK0_16             0x00000003u
  #define  CHIP_AMR_BK0_32             0x00000004u
  #define  CHIP_AMR_BK0_64             0x00000005u
  #define  CHIP_AMR_BK0_128            0x00000006u
  #define  CHIP_AMR_BK0_256            0x00000007u
  #define  CHIP_AMR_BK0_512            0x00000008u
  #define  CHIP_AMR_BK0_1K             0x00000009u
  #define  CHIP_AMR_BK0_2K             0x0000000Au
  #define  CHIP_AMR_BK0_4K             0x0000000Bu
  #define  CHIP_AMR_BK0_8K             0x0000000Cu
  #define  CHIP_AMR_BK0_16K            0x0000000Du
  #define  CHIP_AMR_BK0_32K            0x0000000Eu
  #define  CHIP_AMR_BK0_64K            0x0000000Fu
  #define  CHIP_AMR_BK0_128K           0x00000010u
  #define  CHIP_AMR_BK0_256K           0x00000011u
  #define  CHIP_AMR_BK0_512K           0x00000012u
  #define  CHIP_AMR_BK0_1M             0x00000013u
  #define  CHIP_AMR_BK0_2M             0x00000014u
  #define  CHIP_AMR_BK0_4M             0x00000015u
  #define  CHIP_AMR_BK0_8M             0x00000016u
  #define  CHIP_AMR_BK0_16M            0x00000017u
  #define  CHIP_AMR_BK0_32M            0x00000018u
  #define  CHIP_AMR_BK0_64M            0x00000019u
  #define  CHIP_AMR_BK0_128M           0x0000001Au
  #define  CHIP_AMR_BK0_256M           0x0000001Bu
  #define  CHIP_AMR_BK0_512M           0x0000001Cu
  #define  CHIP_AMR_BK0_1G             0x0000001Du
  #define  CHIP_AMR_BK0_2G             0x0000001Eu
  #define  CHIP_AMR_BK0_4G             0x0000001Fu


  #define _CHIP_AMR_B7MODE_MASK        0x0000C000u
  #define _CHIP_AMR_B7MODE_SHIFT       0x0000000Eu
  #define  CHIP_AMR_B7MODE_DEFAULT     0x00000000u
  #define  CHIP_AMR_B7MODE_OF(x)       _VALUEOF(x)
  #define  CHIP_AMR_B7MODE_LINEAR      0x00000000u
  #define  CHIP_AMR_B7MODE_CIRCULAR0   0x00000001u
  #define  CHIP_AMR_B7MODE_CIRCULAR1   0x00000002u

  #define _CHIP_AMR_B6MODE_MASK        0x00003000u
  #define _CHIP_AMR_B6MODE_SHIFT       0x0000000Cu
  #define  CHIP_AMR_B6MODE_DEFAULT     0x00000000u
  #define  CHIP_AMR_B6MODE_OF(x)       _VALUEOF(x)
  #define  CHIP_AMR_B6MODE_LINEAR      0x00000000u
  #define  CHIP_AMR_B6MODE_CIRCULAR0   0x00000001u
  #define  CHIP_AMR_B6MODE_CIRCULAR1   0x00000002u

  #define _CHIP_AMR_B5MODE_MASK        0x00000C00u
  #define _CHIP_AMR_B5MODE_SHIFT       0x0000000Au
  #define  CHIP_AMR_B5MODE_DEFAULT     0x00000000u
  #define  CHIP_AMR_B5MODE_OF(x)       _VALUEOF(x)
  #define  CHIP_AMR_B5MODE_LINEAR      0x00000000u
  #define  CHIP_AMR_B5MODE_CIRCULAR0   0x00000001u
  #define  CHIP_AMR_B5MODE_CIRCULAR1   0x00000002u

  #define _CHIP_AMR_B4MODE_MASK        0x00000300u
  #define _CHIP_AMR_B4MODE_SHIFT       0x00000008u
  #define  CHIP_AMR_B4MODE_DEFAULT     0x00000000u
  #define  CHIP_AMR_B4MODE_OF(x)       _VALUEOF(x)
  #define  CHIP_AMR_B4MODE_LINEAR      0x00000000u
  #define  CHIP_AMR_B4MODE_CIRCULAR0   0x00000001u
  #define  CHIP_AMR_B4MODE_CIRCULAR1   0x00000002u

  #define _CHIP_AMR_A7MODE_MASK        0x000000C0u
  #define _CHIP_AMR_A7MODE_SHIFT       0x00000006u
  #define  CHIP_AMR_A7MODE_DEFAULT     0x00000000u
  #define  CHIP_AMR_A7MODE_OF(x)       _VALUEOF(x)
  #define  CHIP_AMR_A7MODE_LINEAR      0x00000000u
  #define  CHIP_AMR_A7MODE_CIRCULAR0   0x00000001u
  #define  CHIP_AMR_A7MODE_CIRCULAR1   0x00000002u

  #define _CHIP_AMR_A6MODE_MASK        0x00000030u
  #define _CHIP_AMR_A6MODE_SHIFT       0x00000004u
  #define  CHIP_AMR_A6MODE_DEFAULT     0x00000000u
  #define  CHIP_AMR_A6MODE_OF(x)       _VALUEOF(x)
  #define  CHIP_AMR_A6MODE_LINEAR      0x00000000u
  #define  CHIP_AMR_A6MODE_CIRCULAR0   0x00000001u
  #define  CHIP_AMR_A6MODE_CIRCULAR1   0x00000002u

  #define _CHIP_AMR_A5MODE_MASK        0x0000000Cu
  #define _CHIP_AMR_A5MODE_SHIFT       0x00000002u
  #define  CHIP_AMR_A5MODE_DEFAULT     0x00000000u
  #define  CHIP_AMR_A5MODE_OF(x)       _VALUEOF(x)
  #define  CHIP_AMR_A5MODE_LINEAR      0x00000000u
  #define  CHIP_AMR_A5MODE_CIRCULAR0   0x00000001u
  #define  CHIP_AMR_A5MODE_CIRCULAR1   0x00000002u

  #define _CHIP_AMR_A4MODE_MASK        0x00000003u
  #define _CHIP_AMR_A4MODE_SHIFT       0x00000000u
  #define  CHIP_AMR_A4MODE_DEFAULT     0x00000000u
  #define  CHIP_AMR_A4MODE_OF(x)       _VALUEOF(x)
  #define  CHIP_AMR_A4MODE_LINEAR      0x00000000u
  #define  CHIP_AMR_A4MODE_CIRCULAR0   0x00000001u
  #define  CHIP_AMR_A4MODE_CIRCULAR1   0x00000002u

  #define  CHIP_AMR_OF(x)              _VALUEOF(x)

  #define CHIP_AMR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,AMR,BK1)\
    |_PER_FDEFAULT(CHIP,AMR,BK0)\
    |_PER_FDEFAULT(CHIP,AMR,B7MODE)\
    |_PER_FDEFAULT(CHIP,AMR,B6MODE)\
    |_PER_FDEFAULT(CHIP,AMR,B5MODE)\
    |_PER_FDEFAULT(CHIP,AMR,B4MODE)\
    |_PER_FDEFAULT(CHIP,AMR,A7MODE)\
    |_PER_FDEFAULT(CHIP,AMR,A6MODE)\
    |_PER_FDEFAULT(CHIP,AMR,A5MODE)\
    |_PER_FDEFAULT(CHIP,AMR,A4MODE)\
  )

  #define CHIP_AMR_RMK(bk1,bk0,b7mode,b6mode,b5mode,b4mode,a7,ode,\
    a6mode,a5mode,a4mode) (Uint32)( \
     _PER_FMK(CHIP,AMR,BK1,bk1)\
    |_PER_FMK(CHIP,AMR,BK0,bk0)\
    |_PER_FMK(CHIP,AMR,B7MODE,b7mode)\
    |_PER_FMK(CHIP,AMR,B6MODE,b6mode)\
    |_PER_FMK(CHIP,AMR,B5MODE,b5mode)\
    |_PER_FMK(CHIP,AMR,B4MODE,b4mode)\
    |_PER_FMK(CHIP,AMR,A7MODE,a7mode)\
    |_PER_FMK(CHIP,AMR,A6MODE,a6mode)\
    |_PER_FMK(CHIP,AMR,A5MODE,a5mode)\
    |_PER_FMK(CHIP,AMR,A4MODE,a4mode)\
  )

  #define _CHIP_AMR_FGET(FIELD)\
    _PER_CFGET(CHIP,AMR,##FIELD)

  #define _CHIP_AMR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,AMR,##FIELD,field)

  #define _CHIP_AMR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,AMR,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  F A D C R        |
* |___________________|
*
* FADCR - floating-point adder config register (1)
*
* FIELDS (msb -> lsb)
* (rw) L2RMODE
* (rw) L2UNDER
* (rw) L2INEX
* (rw) L2OVER
* (rw) L2INFO
* (rw) L2INVAL
* (rw) L2DEN2
* (rw) L2DEN1
* (rw) L2NAN2
* (rw) L2NAN1
* (rw) L1RMODE
* (rw) L1UNDER
* (rw) L1INEX
* (rw) L1OVER
* (rw) L1INFO
* (rw) L1INVAL
* (rw) L1DEN2
* (rw) L1DEN1
* (rw) L1NAN2
* (rw) L1NAN1
*
* (1) only supported on devices with floating point unit
*
\******************************************************************************/
#if (FPU_SUPPORT)
  extern far cregister volatile unsigned int FADCR;

  #define _CHIP_FADCR_L2RMODE_MASK    0x06000000u
  #define _CHIP_FADCR_L2RMODE_SHIFT   0x00000019u
  #define  CHIP_FADCR_L2RMODE_DEFAULT 0x00000000u
  #define  CHIP_FADCR_L2RMODE_OF(x)   _VALUEOF(x)

  #define _CHIP_FADCR_L2UNDER_MASK    0x01000000u
  #define _CHIP_FADCR_L2UNDER_SHIFT   0x00000018u
  #define  CHIP_FADCR_L2UNDER_DEFAULT 0x00000000u
  #define  CHIP_FADCR_L2UNDER_OF(x)   _VALUEOF(x)

  #define _CHIP_FADCR_L2INEX_MASK     0x00800000u
  #define _CHIP_FADCR_L2INEX_SHIFT    0x00000017u
  #define  CHIP_FADCR_L2INEX_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L2INEX_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L2OVER_MASK     0x00400000u
  #define _CHIP_FADCR_L2OVER_SHIFT    0x00000016u
  #define  CHIP_FADCR_L2OVER_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L2OVER_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L2INFO_MASK     0x00200000u
  #define _CHIP_FADCR_L2INFO_SHIFT    0x00000015u
  #define  CHIP_FADCR_L2INFO_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L2INFO_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L2INVAL_MASK    0x00100000u
  #define _CHIP_FADCR_L2INVAL_SHIFT   0x00000014u
  #define  CHIP_FADCR_L2INVAL_DEFAULT 0x00000000u
  #define  CHIP_FADCR_L2INVAL_OF(x)   _VALUEOF(x)

  #define _CHIP_FADCR_L2DEN2_MASK     0x00080000u
  #define _CHIP_FADCR_L2DEN2_SHIFT    0x00000013u
  #define  CHIP_FADCR_L2DEN2_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L2DEN2_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L2DEN1_MASK     0x00040000u
  #define _CHIP_FADCR_L2DEN1_SHIFT    0x00000012u
  #define  CHIP_FADCR_L2DEN1_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L2DEN1_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L2NAN2_MASK     0x00020000u
  #define _CHIP_FADCR_L2NAN2_SHIFT    0x00000011u
  #define  CHIP_FADCR_L2NAN2_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L2NAN2_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L2NAN1_MASK     0x00010000u
  #define _CHIP_FADCR_L2NAN1_SHIFT    0x00000010u
  #define  CHIP_FADCR_L2NAN1_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L2NAN1_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L1RMODE_MASK    0x00000600u
  #define _CHIP_FADCR_L1RMODE_SHIFT   0x00000009u
  #define  CHIP_FADCR_L1RMODE_DEFAULT 0x00000000u
  #define  CHIP_FADCR_L1RMODE_OF(x)   _VALUEOF(x)

  #define _CHIP_FADCR_L1UNDER_MASK    0x00000100u
  #define _CHIP_FADCR_L1UNDER_SHIFT   0x00000008u
  #define  CHIP_FADCR_L1UNDER_DEFAULT 0x00000000u
  #define  CHIP_FADCR_L1UNDER_OF(x)   _VALUEOF(x)

  #define _CHIP_FADCR_L1INEX_MASK     0x00000080u
  #define _CHIP_FADCR_L1INEX_SHIFT    0x00000007u
  #define  CHIP_FADCR_L1INEX_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L1INEX_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L1OVER_MASK     0x00000040u
  #define _CHIP_FADCR_L1OVER_SHIFT    0x00000006u
  #define  CHIP_FADCR_L1OVER_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L1OVER_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L1INFO_MASK     0x00000020u
  #define _CHIP_FADCR_L1INFO_SHIFT    0x00000005u
  #define  CHIP_FADCR_L1INFO_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L1INFO_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L1INVAL_MASK    0x00000010u
  #define _CHIP_FADCR_L1INVAL_SHIFT   0x00000004u
  #define  CHIP_FADCR_L1INVAL_DEFAULT 0x00000000u
  #define  CHIP_FADCR_L1INVAL_OF(x)   _VALUEOF(x)

  #define _CHIP_FADCR_L1DEN2_MASK     0x00000008u
  #define _CHIP_FADCR_L1DEN2_SHIFT    0x00000003u
  #define  CHIP_FADCR_L1DEN2_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L1DEN2_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L1DEN1_MASK     0x00000004u
  #define _CHIP_FADCR_L1DEN1_SHIFT    0x00000002u
  #define  CHIP_FADCR_L1DEN1_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L1DEN1_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L1NAN2_MASK     0x00000002u
  #define _CHIP_FADCR_L1NAN2_SHIFT    0x00000001u
  #define  CHIP_FADCR_L1NAN2_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L1NAN2_OF(x)    _VALUEOF(x)

  #define _CHIP_FADCR_L1NAN1_MASK     0x00000001u
  #define _CHIP_FADCR_L1NAN1_SHIFT    0x00000000u
  #define  CHIP_FADCR_L1NAN1_DEFAULT  0x00000000u
  #define  CHIP_FADCR_L1NAN1_OF(x)    _VALUEOF(x)

  #define  CHIP_FADCR_OF(x)           _VALUEOF(x)

  #define CHIP_FADCR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,FADCR,L2RMODE)\
    |_PER_FDEFAULT(CHIP,FADCR,L2UNDER)\
    |_PER_FDEFAULT(CHIP,FADCR,L2INEX)\
    |_PER_FDEFAULT(CHIP,FADCR,L2OVER)\
    |_PER_FDEFAULT(CHIP,FADCR,L2INFO)\
    |_PER_FDEFAULT(CHIP,FADCR,L2INVAL)\
    |_PER_FDEFAULT(CHIP,FADCR,L2DEN2)\
    |_PER_FDEFAULT(CHIP,FADCR,L2DEN1)\
    |_PER_FDEFAULT(CHIP,FADCR,L2NAN2)\
    |_PER_FDEFAULT(CHIP,FADCR,L2NAN1)\
    |_PER_FDEFAULT(CHIP,FADCR,L1RMODE)\
    |_PER_FDEFAULT(CHIP,FADCR,L1UNDER)\
    |_PER_FDEFAULT(CHIP,FADCR,L1INEX)\
    |_PER_FDEFAULT(CHIP,FADCR,L1OVER)\
    |_PER_FDEFAULT(CHIP,FADCR,L1INFO)\
    |_PER_FDEFAULT(CHIP,FADCR,L1INVAL)\
    |_PER_FDEFAULT(CHIP,FADCR,L1DEN2)\
    |_PER_FDEFAULT(CHIP,FADCR,L1DEN1)\
    |_PER_FDEFAULT(CHIP,FADCR,L1NAN2)\
    |_PER_FDEFAULT(CHIP,FADCR,L1NAN1)\
  )

  #define CHIP_FADCR_MK(l2rmode,l2under,l2index,l2over,l2info,l2inval,\
    l2den2,l2den1,l2nan2,l2nan1,l1rmode,l1under,l1inex,l1over,l1info,\
    l1inval,l1den2,l1den1,l1nan2,l1nan1) (Uint32)( \
     _PER_FMK(CHIP,FADCR,L2RMODE,l2rmode)\
    |_PER_FMK(CHIP,FADCR,L2UNDER,l2under)\
    |_PER_FMK(CHIP,FADCR,L2INEX,l2inex)\
    |_PER_FMK(CHIP,FADCR,L2OVER,l2over)\
    |_PER_FMK(CHIP,FADCR,L2INFO,l2info)\
    |_PER_FMK(CHIP,FADCR,L2INVAL,l2inval)\
    |_PER_FMK(CHIP,FADCR,L2DEN2,l2den2)\
    |_PER_FMK(CHIP,FADCR,L2DEN1,l2den1)\
    |_PER_FMK(CHIP,FADCR,L2NAN2,l2nan2)\
    |_PER_FMK(CHIP,FADCR,L2NAN1,l2nan1)\
    |_PER_FMK(CHIP,FADCR,L1RMODE,l1rmode)\
    |_PER_FMK(CHIP,FADCR,L1UNDER,l1under)\
    |_PER_FMK(CHIP,FADCR,L1INEX,l1inex)\
    |_PER_FMK(CHIP,FADCR,L1OVER,l1over)\
    |_PER_FMK(CHIP,FADCR,L1INFO,l1info)\
    |_PER_FMK(CHIP,FADCR,L1INVAL,l1inval)\
    |_PER_FMK(CHIP,FADCR,L1DEN2,l1den2)\
    |_PER_FMK(CHIP,FADCR,L1DEN1,l1den1)\
    |_PER_FMK(CHIP,FADCR,L1NAN2,l1nan2)\
    |_PER_FMK(CHIP,FADCR,L1NAN1,l1nan1)\
  )

  #define _CHIP_FADCR_FGET(FIELD)\
    _PER_CFGET(CHIP,FADCR,##FIELD)

  #define _CHIP_FADCR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,FADCR,##FIELD,field)

  #define _CHIP_FADCR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,FADCR,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  F A U C R        |
* |___________________|
*
* FAUCR - floating-point auxiliary config register (1)
*
* FIELDS (msb -> lsb)
* (rw) S2DIV0
* (rw) S2UNORD
* (rw) S2UND
* (rw) S2INEX
* (rw) S2OVER
* (rw) S2INFO
* (rw) S2INVAL
* (rw) S2DEN2
* (rw) S2DEN1
* (rw) S2NAN2
* (rw) S2NAN1
* (rw) S1DIV0
* (rw) S1UNORD
* (rw) S1UND
* (rw) S1INEX
* (rw) S1OVER
* (rw) S1INFO
* (rw) S1INVAL
* (rw) S1DEN2
* (rw) S1DEN1
* (rw) S1NAN2
* (rw) S1NAN1
*
* (1) only supported on devices with floating point unit
*
\******************************************************************************/
#if (FPU_SUPPORT)
  extern far cregister volatile unsigned int FAUCR;

  #define _CHIP_FAUCR_S2DIV0_MASK     0x04000000u
  #define _CHIP_FAUCR_S2DIV0_SHIFT    0x0000001Au
  #define  CHIP_FAUCR_S2DIV0_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S2DIV0_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S2UNORD_MASK    0x02000000u
  #define _CHIP_FAUCR_S2UNORD_SHIFT   0x00000019u
  #define  CHIP_FAUCR_S2UNORD_DEFAULT 0x00000000u
  #define  CHIP_FAUCR_S2UNORD_OF(x)   _VALUEOF(x)

  #define _CHIP_FAUCR_S2UND_MASK      0x01000000u
  #define _CHIP_FAUCR_S2UND_SHIFT     0x00000018u
  #define  CHIP_FAUCR_S2UND_DEFAULT   0x00000000u
  #define  CHIP_FAUCR_S2UND_OF(x)     _VALUEOF(x)

  #define _CHIP_FAUCR_S2INEX_MASK     0x00800000u
  #define _CHIP_FAUCR_S2INEX_SHIFT    0x00000017u
  #define  CHIP_FAUCR_S2INEX_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S2INEX_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S2OVER_MASK     0x00400000u
  #define _CHIP_FAUCR_S2OVER_SHIFT    0x00000016u
  #define  CHIP_FAUCR_S2OVER_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S2OVER_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S2INFO_MASK     0x00200000u
  #define _CHIP_FAUCR_S2INFO_SHIFT    0x00000015u
  #define  CHIP_FAUCR_S2INFO_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S2INFO_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S2INVAL_MASK    0x00100000u
  #define _CHIP_FAUCR_S2INVAL_SHIFT   0x00000014u
  #define  CHIP_FAUCR_S2INVAL_DEFAULT 0x00000000u
  #define  CHIP_FAUCR_S2INVAL_OF(x)   _VALUEOF(x)

  #define _CHIP_FAUCR_S2DEN2_MASK     0x00080000u
  #define _CHIP_FAUCR_S2DEN2_SHIFT    0x00000013u
  #define  CHIP_FAUCR_S2DEN2_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S2DEN2_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S2DEN1_MASK     0x00040000u
  #define _CHIP_FAUCR_S2DEN1_SHIFT    0x00000012u
  #define  CHIP_FAUCR_S2DEN1_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S2DEN1_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S2NAN2_MASK     0x00020000u
  #define _CHIP_FAUCR_S2NAN2_SHIFT    0x00000011u
  #define  CHIP_FAUCR_S2NAN2_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S2NAN2_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S2NAN1_MASK     0x00010000u
  #define _CHIP_FAUCR_S2NAN1_SHIFT    0x00000010u
  #define  CHIP_FAUCR_S2NAN1_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S2NAN1_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S1DIV0_MASK     0x00000400u
  #define _CHIP_FAUCR_S1DIV0_SHIFT    0x0000000Au
  #define  CHIP_FAUCR_S1DIV0_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S1DIV0_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S1UNORD_MASK    0x00000200u
  #define _CHIP_FAUCR_S1UNORD_SHIFT   0x00000009u
  #define  CHIP_FAUCR_S1UNORD_DEFAULT 0x00000000u
  #define  CHIP_FAUCR_S1UNORD_OF(x)   _VALUEOF(x)

  #define _CHIP_FAUCR_S1UND_MASK      0x00000100u
  #define _CHIP_FAUCR_S1UND_SHIFT     0x00000008u
  #define  CHIP_FAUCR_S1UND_DEFAULT   0x00000000u
  #define  CHIP_FAUCR_S1UND_OF(x)     _VALUEOF(x)

  #define _CHIP_FAUCR_S1INEX_MASK     0x00000080u
  #define _CHIP_FAUCR_S1INEX_SHIFT    0x00000007u
  #define  CHIP_FAUCR_S1INEX_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S1INEX_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S1OVER_MASK     0x00000040u
  #define _CHIP_FAUCR_S1OVER_SHIFT    0x00000006u
  #define  CHIP_FAUCR_S1OVER_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S1OVER_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S1INFO_MASK     0x00000020u
  #define _CHIP_FAUCR_S1INFO_SHIFT    0x00000005u
  #define  CHIP_FAUCR_S1INFO_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S1INFO_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S1INVAL_MASK    0x00000010u
  #define _CHIP_FAUCR_S1INVAL_SHIFT   0x00000004u
  #define  CHIP_FAUCR_S1INVAL_DEFAULT 0x00000000u
  #define  CHIP_FAUCR_S1INVAL_OF(x)   _VALUEOF(x)

  #define _CHIP_FAUCR_S1DEN2_MASK     0x00000008u
  #define _CHIP_FAUCR_S1DEN2_SHIFT    0x00000003u
  #define  CHIP_FAUCR_S1DEN2_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S1DEN2_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S1DEN1_MASK     0x00000004u
  #define _CHIP_FAUCR_S1DEN1_SHIFT    0x00000002u
  #define  CHIP_FAUCR_S1DEN1_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S1DEN1_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S1NAN2_MASK     0x00000002u
  #define _CHIP_FAUCR_S1NAN2_SHIFT    0x00000001u
  #define  CHIP_FAUCR_S1NAN2_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S1NAN2_OF(x)    _VALUEOF(x)

  #define _CHIP_FAUCR_S1NAN1_MASK     0x00000001u
  #define _CHIP_FAUCR_S1NAN1_SHIFT    0x00000000u
  #define  CHIP_FAUCR_S1NAN1_DEFAULT  0x00000000u
  #define  CHIP_FAUCR_S1NAN1_OF(x)    _VALUEOF(x)

  #define  CHIP_FAUCR_OF(x)           _VALUEOF(x)

  #define CHIP_FAUCR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,FAUCR,S2DIV0)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2UNORD)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2UND)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2INEX)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2OVER)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2INFO)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2INVAL)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2DEN2)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2DEN1)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2NAN2)\
    |_PER_FDEFAULT(CHIP,FAUCR,S2NAN1)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1DIV0)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1UNORD)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1UND)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1INEX)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1OVER)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1INFO)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1INVAL)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1DEN2)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1DEN1)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1NAN2)\
    |_PER_FDEFAULT(CHIP,FAUCR,S1NAN1)\
  )

  #define CHIP_FAUCR_MK(s2div0,s2unord,s2und,s2inex,s2over,s2info,s2inval,\
    s2den2,s2den1,s2nan2,s2nan1,s1div0,s1unord,s1und,s1inex,s1over,s1info,\
    s1inval,s1den2,s1den1,s1nan2,s1nan1) (Uint32)( \
     _PER_FMK(CHIP,FAUCR,S2DIV0,s2div)\
    |_PER_FMK(CHIP,FAUCR,S2UNORD,s2unord)\
    |_PER_FMK(CHIP,FAUCR,S2UND,s2und)\
    |_PER_FMK(CHIP,FAUCR,S2INEX,s2inex)\
    |_PER_FMK(CHIP,FAUCR,S2OVER,s2over)\
    |_PER_FMK(CHIP,FAUCR,S2INFO,s2info)\
    |_PER_FMK(CHIP,FAUCR,S2INVAL,s2inval)\
    |_PER_FMK(CHIP,FAUCR,S2DEN2,s2den2)\
    |_PER_FMK(CHIP,FAUCR,S2DEN1,s2den1)\
    |_PER_FMK(CHIP,FAUCR,S2NAN2,s2nan2)\
    |_PER_FMK(CHIP,FAUCR,S2NAN1,s2nan1)\
    |_PER_FMK(CHIP,FAUCR,S1DIV0,s1div0)\
    |_PER_FMK(CHIP,FAUCR,S1UNORD,s1unord)\
    |_PER_FMK(CHIP,FAUCR,S1UND,s1und)\
    |_PER_FMK(CHIP,FAUCR,S1INEX,s1inex)\
    |_PER_FMK(CHIP,FAUCR,S1OVER,s1over)\
    |_PER_FMK(CHIP,FAUCR,S1INFO,s1info)\
    |_PER_FMK(CHIP,FAUCR,S1INVAL,s1inval)\
    |_PER_FMK(CHIP,FAUCR,S1DEN2,s1den2)\
    |_PER_FMK(CHIP,FAUCR,S1DEN1,s1den1)\
    |_PER_FMK(CHIP,FAUCR,S1NAN2,s1nan2)\
    |_PER_FMK(CHIP,FAUCR,S1NAN1,s1nan1)\
  )

  #define _CHIP_FAUCR_FGET(FIELD)\
    _PER_CFGET(CHIP,FAUCR,##FIELD)

  #define _CHIP_FAUCR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,FAUCR,##FIELD,field)

  #define _CHIP_FAUCR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,FAUCR,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  F M C R          |
* |___________________|
*
* FMCR - floating-point multiplier config register (1)
*
* FIELDS (msb -> lsb)
* (rw) M2RMODE
* (rw) M2UNDER
* (rw) M2INEX
* (rw) M2OVER
* (rw) M2INFO
* (rw) M2INVAL
* (rw) M2DEN2
* (rw) M2DEN1
* (rw) M2NAN2
* (rw) M2NAN1
* (rw) M1RMODE
* (rw) M1UNDER
* (rw) M1INEX
* (rw) M1OVER
* (rw) M1INFO
* (rw) M1INVAL
* (rw) M1DEN2
* (rw) M1DEN1
* (rw) M1NAN2
* (rw) M1NAN1
*
* (1) only supported on devices with floating point unit
*
\******************************************************************************/
#if (FPU_SUPPORT)
  extern far cregister volatile unsigned int FMCR;

  #define _CHIP_FMCR_M2RMODE_MASK     0x06000000u
  #define _CHIP_FMCR_M2RMODE_SHIFT    0x00000019u
  #define  CHIP_FMCR_M2RMODE_DEFAULT  0x00000000u
  #define  CHIP_FMCR_M2RMODE_OF(x)    _VALUEOF(x)

  #define _CHIP_FMCR_M2UNDER_MASK     0x01000000u
  #define _CHIP_FMCR_M2UNDER_SHIFT    0x00000018u
  #define  CHIP_FMCR_M2UNDER_DEFAULT  0x00000000u
  #define  CHIP_FMCR_M2UNDER_OF(x)    _VALUEOF(x)

  #define _CHIP_FMCR_M2INEX_MASK      0x00800000u
  #define _CHIP_FMCR_M2INEX_SHIFT     0x00000017u
  #define  CHIP_FMCR_M2INEX_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M2INEX_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M2OVER_MASK      0x00400000u
  #define _CHIP_FMCR_M2OVER_SHIFT     0x00000016u
  #define  CHIP_FMCR_M2OVER_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M2OVER_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M2INFO_MASK      0x00200000u
  #define _CHIP_FMCR_M2INFO_SHIFT     0x00000015u
  #define  CHIP_FMCR_M2INFO_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M2INFO_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M2INVAL_MASK     0x00100000u
  #define _CHIP_FMCR_M2INVAL_SHIFT    0x00000014u
  #define  CHIP_FMCR_M2INVAL_DEFAULT  0x00000000u
  #define  CHIP_FMCR_M2INVAL_OF(x)    _VALUEOF(x)

  #define _CHIP_FMCR_M2DEN2_MASK      0x00080000u
  #define _CHIP_FMCR_M2DEN2_SHIFT     0x00000013u
  #define  CHIP_FMCR_M2DEN2_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M2DEN2_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M2DEN1_MASK      0x00040000u
  #define _CHIP_FMCR_M2DEN1_SHIFT     0x00000012u
  #define  CHIP_FMCR_M2DEN1_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M2DEN1_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M2NAN2_MASK      0x00020000u
  #define _CHIP_FMCR_M2NAN2_SHIFT     0x00000011u
  #define  CHIP_FMCR_M2NAN2_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M2NAN2_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M2NAN1_MASK      0x00010000u
  #define _CHIP_FMCR_M2NAN1_SHIFT     0x00000010u
  #define  CHIP_FMCR_M2NAN1_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M2NAN1_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M1RMODE_MASK     0x00000600u
  #define _CHIP_FMCR_M1RMODE_SHIFT    0x00000009u
  #define  CHIP_FMCR_M1RMODE_DEFAULT  0x00000000u
  #define  CHIP_FMCR_M1RMODE_OF(x)    _VALUEOF(x)

  #define _CHIP_FMCR_M1UNDER_MASK     0x00000100u
  #define _CHIP_FMCR_M1UNDER_SHIFT    0x00000008u
  #define  CHIP_FMCR_M1UNDER_DEFAULT  0x00000000u
  #define  CHIP_FMCR_M1UNDER_OF(x)    _VALUEOF(x)

  #define _CHIP_FMCR_M1INEX_MASK      0x00000080u
  #define _CHIP_FMCR_M1INEX_SHIFT     0x00000007u
  #define  CHIP_FMCR_M1INEX_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M1INEX_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M1OVER_MASK      0x00000040u
  #define _CHIP_FMCR_M1OVER_SHIFT     0x00000006u
  #define  CHIP_FMCR_M1OVER_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M1OVER_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M1INFO_MASK      0x00000020u
  #define _CHIP_FMCR_M1INFO_SHIFT     0x00000005u
  #define  CHIP_FMCR_M1INFO_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M1INFO_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M1INVAL_MASK     0x00000010u
  #define _CHIP_FMCR_M1INVAL_SHIFT    0x00000004u
  #define  CHIP_FMCR_M1INVAL_DEFAULT  0x00000000u
  #define  CHIP_FMCR_M1INVAL_OF(x)    _VALUEOF(x)

  #define _CHIP_FMCR_M1DEN2_MASK      0x00000008u
  #define _CHIP_FMCR_M1DEN2_SHIFT     0x00000003u
  #define  CHIP_FMCR_M1DEN2_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M1DEN2_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M1DEN1_MASK      0x00000004u
  #define _CHIP_FMCR_M1DEN1_SHIFT     0x00000002u
  #define  CHIP_FMCR_M1DEN1_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M1DEN1_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M1NAN2_MASK      0x00000002u
  #define _CHIP_FMCR_M1NAN2_SHIFT     0x00000001u
  #define  CHIP_FMCR_M1NAN2_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M1NAN2_OF(x)     _VALUEOF(x)

  #define _CHIP_FMCR_M1NAN1_MASK      0x00000001u
  #define _CHIP_FMCR_M1NAN1_SHIFT     0x00000000u
  #define  CHIP_FMCR_M1NAN1_DEFAULT   0x00000000u
  #define  CHIP_FMCR_M1NAN1_OF(x)     _VALUEOF(x)

  #define  CHIP_FMCR_OF(x)            _VALUEOF(x)

  #define CHIP_FMCR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,FMCR,M2RMODE)\
    |_PER_FDEFAULT(CHIP,FMCR,M2UNDER)\
    |_PER_FDEFAULT(CHIP,FMCR,M2INEX)\
    |_PER_FDEFAULT(CHIP,FMCR,M2OVER)\
    |_PER_FDEFAULT(CHIP,FMCR,M2INFO)\
    |_PER_FDEFAULT(CHIP,FMCR,M2INVAL)\
    |_PER_FDEFAULT(CHIP,FMCR,M2DEN2)\
    |_PER_FDEFAULT(CHIP,FMCR,M2DEN1)\
    |_PER_FDEFAULT(CHIP,FMCR,M2NAN2)\
    |_PER_FDEFAULT(CHIP,FMCR,M2NAN1)\
    |_PER_FDEFAULT(CHIP,FMCR,M1RMODE)\
    |_PER_FDEFAULT(CHIP,FMCR,M1UNDER)\
    |_PER_FDEFAULT(CHIP,FMCR,M1INEX)\
    |_PER_FDEFAULT(CHIP,FMCR,M1OVER)\
    |_PER_FDEFAULT(CHIP,FMCR,M1INFO)\
    |_PER_FDEFAULT(CHIP,FMCR,M1INVAL)\
    |_PER_FDEFAULT(CHIP,FMCR,M1DEN2)\
    |_PER_FDEFAULT(CHIP,FMCR,M1DEN1)\
    |_PER_FDEFAULT(CHIP,FMCR,M1NAN2)\
    |_PER_FDEFAULT(CHIP,FMCR,M1NAN1)\
  )

  #define CHIP_FMCR_MK(m2rmode,m2under,m2index,m2over,m2info,m2inval,\
    m2den2,m2den1,m2nan2,m2nan1,m1rmode,m1under,m1inex,m1over,m1info,\
    m1inval,m1den2,m1den1,m1nan2,m1nan1) (Uint32)( \
     _PER_FMK(CHIP,FMCR,M2RMODE,m2rmode)\
    |_PER_FMK(CHIP,FMCR,M2UNDER,m2under)\
    |_PER_FMK(CHIP,FMCR,M2INEX,m2inex)\
    |_PER_FMK(CHIP,FMCR,M2OVER,m2over)\
    |_PER_FMK(CHIP,FMCR,M2INFO,m2info)\
    |_PER_FMK(CHIP,FMCR,M2INVAL,m2inval)\
    |_PER_FMK(CHIP,FMCR,M2DEN2,m2den2)\
    |_PER_FMK(CHIP,FMCR,M2DEN1,m2den1)\
    |_PER_FMK(CHIP,FMCR,M2NAN2,m2nan2)\
    |_PER_FMK(CHIP,FMCR,M2NAN1,m2nan1)\
    |_PER_FMK(CHIP,FMCR,M1RMODE,m1rmode)\
    |_PER_FMK(CHIP,FMCR,M1UNDER,m1under)\
    |_PER_FMK(CHIP,FMCR,M1INEX,m1inex)\
    |_PER_FMK(CHIP,FMCR,M1OVER,m1over)\
    |_PER_FMK(CHIP,FMCR,M1INFO,m1info)\
    |_PER_FMK(CHIP,FMCR,M1INVAL,m1inval)\
    |_PER_FMK(CHIP,FMCR,M1DEN2,m1den2)\
    |_PER_FMK(CHIP,FMCR,M1DEN1,m1den1)\
    |_PER_FMK(CHIP,FMCR,M1NAN2,m1nan2)\
    |_PER_FMK(CHIP,FMCR,M1NAN1,m1nan1)\
  )

  #define _CHIP_FMCR_FGET(FIELD)\
    _PER_CFGET(CHIP,FMCR,##FIELD)

  #define _CHIP_FMCR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,FMCR,##FIELD,field)

  #define _CHIP_FMCR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,FMCR,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  G F P G F R      |
* |___________________|
*
* GFPGFR - Galois field polynomial generator function register (1)
*
* FIELDS (msb -> lsb)
* (rw) SIZE
* (rw) POLY
* (1) only supported on C64x family of devices
*
\******************************************************************************/
#if (C64_SUPPORT)
  extern cregister volatile unsigned int GFPGFR;

  #define _CHIP_GFPGFR_POLY_MASK          0x000000FFu
  #define _CHIP_GFPGFR_POLY_SHIFT         0x00000000u
  #define  CHIP_GFPGFR_POLY_DEFAULT       0x0000001Du
  #define  CHIP_GFPGFR_POLY_OF(x)         _VALUEOF(x)

  #define _CHIP_GFPGFR_SIZE_MASK          0x07000000u
  #define _CHIP_GFPGFR_SIZE_SHIFT         0x00000018u
  #define  CHIP_GFPGFR_SIZE_DEFAULT       0x00000007u
  #define  CHIP_GFPGFR_SIZE_OF(x)         _VALUEOF(x)

  #define  CHIP_GFPGFR_OF(x)              _VALUEOF(x)

  #define CHIP_GFPGFR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,GFPGFR,SIZE) \
    |_PER_FDEFAULT(CHIP,GFPGFR,POLY) \
  )

  #define CHIP_GFPGFR_RMK(size,poly) (Uint32)( \
     _PER_FMK(CHIP,GFPGFR,SIZE,size) \
    |_PER_FMK(CHIP,GFPGFR,POLY,poly) \
  )

  #define _CHIP_GFPGFR_FGET(FIELD)\
    _PER_CFGET(CHIP,GFPGFR,##FIELD)

  #define _CHIP_GFPGFR_FSET(FIELD,field)\
    _PER_CFSET(CHIP,GFPGFR,##FIELD,field)

  #define _CHIP_GFPGFR_FSETS(FIELD,SYM)\
    _PER_CFSETS(CHIP,GFPGFR,##FIELD,##SYM)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  D E V C F G      |
* |___________________|
*
* DEVCFG - Device Configuration register (1)
*
* FIELDS (msb -> lsb)  CHIP_6713/CHIP_DA610
* (rw) EKSRC
* (rw) TOUT1SEL
* (rw) TOUT0SEL
* (rw) MCBSP0DIS
* (rw) MCBSP1DIS
* (rw) GPIO1EN (only for CHIP_DA610)
*
* FIELDS (msb -> lsb)  CHIP_DM642
* (rw) VP2EN
* (rw) VP1EN
* (rw) VP0EN
* (rw) I2C0EN
* (rw) MCBSP1EN
* (rw) MCBSP0EN
* (rw) MCASP0EN
*
* FIELDS (msb -> lsb)  CHIP_6412
* (rw) I2C0EN
* (rw) MCBSP1EN
* (rw) MCBSP0EN
*
* FIELDS (msb -> lsb)  CHIP_6711C/CHIP_6712C
* (rw) EKSRC
*
* FIELDS (msb -> lsb)  CHIP_6410/CHIP_6413/CHIP_6418
* (rw) ATLEN  
* (rw) ADIV
* (rw) ATLMEN
* (rw) AFCMUX  
* (rw) MCASP1EN
* (rw) I2C1EN
* (rw) I2C0EN
* (rw) MCBSP1EN
* (rw) MCBSP0EN
* (rw) MCASP0EN
*
\******************************************************************************/

#if (CHIP_DA610)

  #define   _CHIP_DEVCFG_ADDR              0x019C0200u
  #define   _CHIP_DEVCFG_OFFSET             0

  #define _CHIP_DEVCFG_GPIO1EN_MASK        0x00010000u
  #define _CHIP_DEVCFG_GPIO1EN_SHIFT       0x0000000Fu
  #define  CHIP_DEVCFG_GPIO1EN_DEFAULT     0x00000000u
  #define  CHIP_DEVCFG_GPIO1EN_OF(x)       _VALUEOF(x)
  #define  CHIP_DEVCFG_GPIO1EN_0           0x00000000u
  #define  CHIP_DEVCFG_GPIO1EN_1           0x00000001u

  #define _CHIP_DEVCFG_EKSRC_MASK          0x00000010u
  #define _CHIP_DEVCFG_EKSRC_SHIFT         0x00000004u
  #define  CHIP_DEVCFG_EKSRC_DEFAULT       0x00000000u
  #define  CHIP_DEVCFG_EKSRC_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVCFG_EKSRC_SYSCLK3       0x00000000u
  #define  CHIP_DEVCFG_EKSRC_ECLKIN        0x00000001u

  #define _CHIP_DEVCFG_TOUT1SEL_MASK       0x00000008u
  #define _CHIP_DEVCFG_TOUT1SEL_SHIFT      0x00000003u
  #define  CHIP_DEVCFG_TOUT1SEL_DEFAULT    0x00000000u
  #define  CHIP_DEVCFG_TOUT1SEL_OF(x)       _VALUEOF(x)
  #define  CHIP_DEVCFG_TOUT1SEL_TOUT1PIN   0x00000000u
  #define  CHIP_DEVCFG_TOUT1SEL_MCASPPIN   0x00000001u

  #define _CHIP_DEVCFG_TOUT0SEL_MASK       0x00000004u
  #define _CHIP_DEVCFG_TOUT0SEL_SHIFT      0x00000002u
  #define  CHIP_DEVCFG_TOUT0SEL_DEFAULT    0x00000000u
  #define  CHIP_DEVCFG_TOUT0SEL_OF(x)       _VALUEOF(x)
  #define  CHIP_DEVCFG_TOUT0SEL_TOUT0PIN   0x00000000u
  #define  CHIP_DEVCFG_TOUT0SEL_MCASPPIN   0x00000001u

  #define _CHIP_DEVCFG_MCBSP0DIS_MASK       0x00000002u
  #define _CHIP_DEVCFG_MCBSP0DIS_SHIFT      0x00000001u
  #define  CHIP_DEVCFG_MCBSP0DIS_DEFAULT    0x00000000u
  #define  CHIP_DEVCFG_MCBSP0DIS_OF(x)       _VALUEOF(x)
  #define  CHIP_DEVCFG_MCBSP0DIS_0          0x00000000u
  #define  CHIP_DEVCFG_MCBSP0DIS_1          0x00000001u

  #define _CHIP_DEVCFG_MCBSP1DIS_MASK         0x00000001u
  #define _CHIP_DEVCFG_MCBSP1DIS_SHIFT        0x00000000u
  #define  CHIP_DEVCFG_MCBSP1DIS_DEFAULT      0x00000000u
  #define  CHIP_DEVCFG_MCBSP1DIS_OF(x)        _VALUEOF(x)
  #define  CHIP_DEVCFG_MCBSP1DIS_0            0x00000000u
  #define  CHIP_DEVCFG_MCBSP1DIS_1            0x00000001u


  #define  CHIP_DEVCFG_OF(x)              _VALUEOF(x)

  #define CHIP_DEVCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,DEVCFG,EKSRC) \
    |_PER_FDEFAULT(CHIP,DEVCFG,TOUT1SEL) \
    |_PER_FDEFAULT(CHIP,DEVCFG,TOUT0SEL) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP0DIS) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP1DIS) \
    |_PER_FDEFAULT(CHIP,DEVCFG,GPIO1EN) \
 )

  #define CHIP_DEVCFG_RMK(eksrc,tout1sel,tout0sel,mcbsp0dis,mcbsp1dis,\
                          gpio1en ) (Uint32)( \
      _PER_FMK(CHIP,DEVCFG,EKSRC,eksrc) \
    |_PER_FMK(CHIP,DEVCFG,TOUT1SEL,tout1sel) \
    |_PER_FMK(CHIP,DEVCFG,TOUT0SEL,tout0sel) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP0DIS,mcbsp0dis) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP1DIS,mcbsp1dis) \
    |_PER_FMK(CHIP,DEVCFG,GPIO1EN,gpio1en) \
)
#elif (CHIP_6713)
  #define   _CHIP_DEVCFG_ADDR              0x019C0200u
  #define   _CHIP_DEVCFG_OFFSET             0

  #define _CHIP_DEVCFG_EKSRC_MASK          0x00000010u
  #define _CHIP_DEVCFG_EKSRC_SHIFT         0x00000004u
  #define  CHIP_DEVCFG_EKSRC_DEFAULT       0x00000000u
  #define  CHIP_DEVCFG_EKSRC_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVCFG_EKSRC_SYSCLK3       0x00000000u
  #define  CHIP_DEVCFG_EKSRC_ECLKIN        0x00000001u

  #define _CHIP_DEVCFG_TOUT1SEL_MASK       0x00000008u
  #define _CHIP_DEVCFG_TOUT1SEL_SHIFT      0x00000003u
  #define  CHIP_DEVCFG_TOUT1SEL_DEFAULT    0x00000000u
  #define  CHIP_DEVCFG_TOUT1SEL_OF(x)       _VALUEOF(x)
  #define  CHIP_DEVCFG_TOUT1SEL_TOUT1PIN   0x00000000u
  #define  CHIP_DEVCFG_TOUT1SEL_MCASPPIN   0x00000001u

  #define _CHIP_DEVCFG_TOUT0SEL_MASK       0x00000004u
  #define _CHIP_DEVCFG_TOUT0SEL_SHIFT      0x00000002u
  #define  CHIP_DEVCFG_TOUT0SEL_DEFAULT    0x00000000u
  #define  CHIP_DEVCFG_TOUT0SEL_OF(x)       _VALUEOF(x)
  #define  CHIP_DEVCFG_TOUT0SEL_TOUT0PIN   0x00000000u
  #define  CHIP_DEVCFG_TOUT0SEL_MCASPPIN   0x00000001u

  #define _CHIP_DEVCFG_MCBSP0DIS_MASK      0x00000002u
  #define _CHIP_DEVCFG_MCBSP0DIS_SHIFT     0x00000001u
  #define  CHIP_DEVCFG_MCBSP0DIS_DEFAULT   0x00000000u
  #define  CHIP_DEVCFG_MCBSP0DIS_OF(x)     _VALUEOF(x)
  #define  CHIP_DEVCFG_MCBSP0DIS_0         0x00000000u
  #define  CHIP_DEVCFG_MCBSP0DIS_1         0x00000001u

  #define _CHIP_DEVCFG_MCBSP1DIS_MASK      0x00000001u
  #define _CHIP_DEVCFG_MCBSP1DIS_SHIFT     0x00000000u
  #define  CHIP_DEVCFG_MCBSP1DIS_DEFAULT   0x00000000u
  #define  CHIP_DEVCFG_MCBSP1DIS_OF(x)     _VALUEOF(x)
  #define  CHIP_DEVCFG_MCBSP1DIS_0         0x00000000u
  #define  CHIP_DEVCFG_MCBSP1DIS_1         0x00000001u


  #define  CHIP_DEVCFG_OF(x)              _VALUEOF(x)

  #define CHIP_DEVCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,DEVCFG,EKSRC) \
    |_PER_FDEFAULT(CHIP,DEVCFG,TOUT1SEL) \
    |_PER_FDEFAULT(CHIP,DEVCFG,TOUT0SEL) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP0DIS) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP1DIS) \
 )

  #define CHIP_DEVCFG_RMK(eksrc,tout1sel,tout0sel,mcbsp0dis,mcbsp1dis\
                          ) (Uint32)( \
      _PER_FMK(CHIP,DEVCFG,EKSRC,eksrc) \
    |_PER_FMK(CHIP,DEVCFG,TOUT1SEL,tout1sel) \
    |_PER_FMK(CHIP,DEVCFG,TOUT0SEL,tout0sel) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP0DIS,mcbsp0dis) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP1DIS,mcbsp1dis) \
)

#endif

#if (CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_6412)

  #define   _CHIP_DEVCFG_ADDR                0x01B3F000u
  #define   _CHIP_DEVCFG_OFFSET              0

#if (CHIP_DM642)
  #define _CHIP_DEVCFG_VP2EN_MASK            0x00000040u
  #define _CHIP_DEVCFG_VP2EN_SHIFT           0x00000006u
  #define  CHIP_DEVCFG_VP2EN_DEFAULT         0x00000000u
  #define  CHIP_DEVCFG_VP2EN_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVCFG_VP2EN_DISABLE         0x00000000u
  #define  CHIP_DEVCFG_VP2EN_ENABLE          0x00000001u
#endif

#if (CHIP_DM642 | CHIP_DM641)                          
  #define _CHIP_DEVCFG_VP1EN_MASK            0x00000020u
  #define _CHIP_DEVCFG_VP1EN_SHIFT           0x00000005u
  #define  CHIP_DEVCFG_VP1EN_DEFAULT         0x00000000u
  #define  CHIP_DEVCFG_VP1EN_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVCFG_VP1EN_DISABLE         0x00000000u
  #define  CHIP_DEVCFG_VP1EN_ENABLE          0x00000001u
#endif

#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640)                          
  #define _CHIP_DEVCFG_VP0EN_MASK            0x00000010u
  #define _CHIP_DEVCFG_VP0EN_SHIFT           0x00000004u
  #define  CHIP_DEVCFG_VP0EN_DEFAULT         0x00000000u
  #define  CHIP_DEVCFG_VP0EN_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVCFG_VP0EN_DISABLE         0x00000000u
  #define  CHIP_DEVCFG_VP0EN_ENABLE          0x00000001u
#endif

  #define _CHIP_DEVCFG_I2C0EN_MASK           0x00000008u
  #define _CHIP_DEVCFG_I2C0EN_SHIFT          0x00000003u
  #define  CHIP_DEVCFG_I2C0EN_DEFAULT        0x00000000u
  #define  CHIP_DEVCFG_I2C0EN_OF(x)          _VALUEOF(x)
  #define  CHIP_DEVCFG_I2C0EN_DISABLE        0x00000000u
  #define  CHIP_DEVCFG_I2C0EN_ENABLE         0x00000001u

  #define _CHIP_DEVCFG_MCBSP1EN_MASK         0x00000004u
  #define _CHIP_DEVCFG_MCBSP1EN_SHIFT        0x00000002u
  #define  CHIP_DEVCFG_MCBSP1EN_DEFAULT      0x00000001u
  #define  CHIP_DEVCFG_MCBSP1EN_OF(x)        _VALUEOF(x)
  #define  CHIP_DEVCFG_MCBSP1EN_DISABLE      0x00000000u
  #define  CHIP_DEVCFG_MCBSP1EN_ENABLE       0x00000001u

  #define _CHIP_DEVCFG_MCBSP0EN_MASK         0x00000002u
  #define _CHIP_DEVCFG_MCBSP0EN_SHIFT        0x00000001u
  #define  CHIP_DEVCFG_MCBSP0EN_DEFAULT      0x00000001u
  #define  CHIP_DEVCFG_MCBSP0EN_OF(x)        _VALUEOF(x)
  #define  CHIP_DEVCFG_MCBSP0EN_DISABLE      0x00000000u
  #define  CHIP_DEVCFG_MCBSP0EN_ENABLE       0x00000001u

#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640)
  #define _CHIP_DEVCFG_MCASP0EN_MASK         0x00000001u
  #define _CHIP_DEVCFG_MCASP0EN_SHIFT        0x00000000u
  #define  CHIP_DEVCFG_MCASP0EN_DEFAULT      0x00000000u
  #define  CHIP_DEVCFG_MCASP0EN_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVCFG_MCASP0EN_DISABLE      0x00000000u
  #define  CHIP_DEVCFG_MCASP0EN_ENABLE       0x00000001u
#endif


  #define  CHIP_DEVCFG_OF(x)              _VALUEOF(x)

#if (CHIP_DM642)
  #define CHIP_DEVCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,DEVCFG,VP2EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,VP1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,VP0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,I2C0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCASP0EN) \
   )


 #define CHIP_DEVCFG_RMK(vp2en,vp1en,vp0en,i2c0en,mcbsp1en,mcbsp0en,mcasp0en) (Uint32)( \
     _PER_FMK(CHIP,DEVCFG,VP2EN,vp2en) \
    |_PER_FMK(CHIP,DEVCFG,VP1EN,vp1en) \
    |_PER_FMK(CHIP,DEVCFG,VP0EN,vp0en) \
    |_PER_FMK(CHIP,DEVCFG,I2C0EN,i2c0en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP1EN,mcbsp1en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP0EN,mcbsp0en) \
    |_PER_FMK(CHIP,DEVCFG,MCASP0EN,mcasp0en) \
  )
#endif

#if (CHIP_DM641)
  #define CHIP_DEVCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,DEVCFG,VP1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,VP0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,I2C0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCASP0EN) \
   )


 #define CHIP_DEVCFG_RMK(vp1en,vp0en,i2c0en,mcbsp1en,mcbsp0en,mcasp0en) (Uint32)( \
     _PER_FMK(CHIP,DEVCFG,VP1EN,vp1en) \
    |_PER_FMK(CHIP,DEVCFG,VP0EN,vp0en) \
    |_PER_FMK(CHIP,DEVCFG,I2C0EN,i2c0en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP1EN,mcbsp1en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP0EN,mcbsp0en) \
    |_PER_FMK(CHIP,DEVCFG,MCASP0EN,mcasp0en) \
  )
#endif

#if (CHIP_DM640)
  #define CHIP_DEVCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,DEVCFG,VP0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,I2C0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCASP0EN) \
   )


 #define CHIP_DEVCFG_RMK(vp0en,i2c0en,mcbsp1en,mcbsp0en,mcasp0en) (Uint32)( \
     _PER_FMK(CHIP,DEVCFG,VP0EN,vp0en) \
    |_PER_FMK(CHIP,DEVCFG,I2C0EN,i2c0en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP1EN,mcbsp1en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP0EN,mcbsp0en) \
    |_PER_FMK(CHIP,DEVCFG,MCASP0EN,mcasp0en) \
  )
#endif

#if (CHIP_6412)
  #define CHIP_DEVCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,DEVCFG,I2C0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP0EN) \
   )


 #define CHIP_DEVCFG_RMK(i2c0en,mcbsp1en,mcbsp0en) (Uint32)( \
    |_PER_FMK(CHIP,DEVCFG,I2C0EN,i2c0en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP1EN,mcbsp1en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP0EN,mcbsp0en) \
  )
#endif

#endif /* CHIP_DM642 || CHIP_6412  */

#if (CHIP_6410 || CHIP_6413 || CHIP_6418)

  #define   _CHIP_DEVCFG_ADDR                0x01B3F000u
  #define   _CHIP_DEVCFG_OFFSET              0

  #define _CHIP_DEVCFG_ATLEN_MASK            0x80000000u
  #define _CHIP_DEVCFG_ATLEN_SHIFT           0x0000001Eu
  #define  CHIP_DEVCFG_ATLEN_DEFAULT         0x00000000u
  #define  CHIP_DEVCFG_ATLEN_OF(x)            _VALUEOF(x)
  #define  CHIP_DEVCFG_ATLEN_DISABLE         0x00000000u
  #define  CHIP_DEVCFG_ATLEN_ENABLE          0x00000001u

  #define _CHIP_DEVCFG_ADIV_MASK             0x60000000u
  #define _CHIP_DEVCFG_ADIV_SHIFT            0x0000001Du
  #define  CHIP_DEVCFG_ADIV_DEFAULT          0x00000000u
  #define  CHIP_DEVCFG_ADIV_OF(x)             _VALUEOF(x)
  #define  CHIP_DEVCFG_ADIV_BY4              0x00000000u
  #define  CHIP_DEVCFG_ADIV_BY3HALF          0x00000001u
  #define  CHIP_DEVCFG_ADIV_BY9              0x00000002u
  #define  CHIP_DEVCFG_ADIV_EATCLK           0x00000003u

  #define _CHIP_DEVCFG_ATLMEN_MASK           0x10000000u
  #define _CHIP_DEVCFG_ATLMEN_SHIFT          0x0000001Cu
  #define  CHIP_DEVCFG_ATLMEN_DEFAULT        0x00000000u
  #define  CHIP_DEVCFG_ATLMEN_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVCFG_ATLMEN_DISABLE        0x00000000u
  #define  CHIP_DEVCFG_ATLMEN_ENABLE         0x00000001u

  #define _CHIP_DEVCFG_AFCMUX_MASK           0x00000600u
  #define _CHIP_DEVCFG_AFCMUX_SHIFT          0x00000009u
  #define  CHIP_DEVCFG_AFCMUX_DEFAULT        0x00000000u
  #define  CHIP_DEVCFG_AFCMUX_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVCFG_AFCMUX_PIN0           0x00000000u
  #define  CHIP_DEVCFG_AFCMUX_PIN1           0x00000001u
  #define  CHIP_DEVCFG_AFCMUX_PIN2           0x00000002u
  #define  CHIP_DEVCFG_AFCMUX_PIN3           0x00000003u

  #define _CHIP_DEVCFG_MCASP1EN_MASK         0x00000100u
  #define _CHIP_DEVCFG_MCASP1EN_SHIFT        0x00000008u
  #define  CHIP_DEVCFG_MCASP1EN_DEFAULT      0x00000000u
  #define  CHIP_DEVCFG_MCASP1EN_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVCFG_MCASP1EN_DISABLE      0x00000000u
  #define  CHIP_DEVCFG_MCASP1EN_ENABLE       0x00000001u

  #define _CHIP_DEVCFG_I2C1EN_MASK           0x00000080u
  #define _CHIP_DEVCFG_I2C1EN_SHIFT          0x00000007u
  #define  CHIP_DEVCFG_I2C1EN_DEFAULT        0x00000000u
  #define  CHIP_DEVCFG_I2C1EN_OF(x)          _VALUEOF(x)
  #define  CHIP_DEVCFG_I2C1EN_DISABLE        0x00000000u
  #define  CHIP_DEVCFG_I2C1EN_ENABLE         0x00000001u

  #define _CHIP_DEVCFG_I2C0EN_MASK           0x00000008u
  #define _CHIP_DEVCFG_I2C0EN_SHIFT          0x00000003u
  #define  CHIP_DEVCFG_I2C0EN_DEFAULT        0x00000000u
  #define  CHIP_DEVCFG_I2C0EN_OF(x)          _VALUEOF(x)
  #define  CHIP_DEVCFG_I2C0EN_DISABLE        0x00000000u
  #define  CHIP_DEVCFG_I2C0EN_ENABLE         0x00000001u

  #define _CHIP_DEVCFG_MCBSP1EN_MASK         0x00000004u
  #define _CHIP_DEVCFG_MCBSP1EN_SHIFT        0x00000002u
  #define  CHIP_DEVCFG_MCBSP1EN_DEFAULT      0x00000001u
  #define  CHIP_DEVCFG_MCBSP1EN_OF(x)        _VALUEOF(x)
  #define  CHIP_DEVCFG_MCBSP1EN_DISABLE      0x00000000u
  #define  CHIP_DEVCFG_MCBSP1EN_ENABLE       0x00000001u
 
  #define _CHIP_DEVCFG_MCBSP0EN_MASK         0x00000002u
  #define _CHIP_DEVCFG_MCBSP0EN_SHIFT        0x00000001u
  #define  CHIP_DEVCFG_MCBSP0EN_DEFAULT      0x00000001u
  #define  CHIP_DEVCFG_MCBSP0EN_OF(x)        _VALUEOF(x)
  #define  CHIP_DEVCFG_MCBSP0EN_DISABLE      0x00000000u
  #define  CHIP_DEVCFG_MCBSP0EN_ENABLE       0x00000001u

  #define _CHIP_DEVCFG_MCASP0EN_MASK         0x00000001u
  #define _CHIP_DEVCFG_MCASP0EN_SHIFT        0x00000000u
  #define  CHIP_DEVCFG_MCASP0EN_DEFAULT      0x00000000u
  #define  CHIP_DEVCFG_MCASP0EN_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVCFG_MCASP0EN_DISABLE      0x00000000u
  #define  CHIP_DEVCFG_MCASP0EN_ENABLE       0x00000001u

  #define  CHIP_DEVCFG_OF(x)              _VALUEOF(x)

  #define CHIP_DEVCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,DEVCFG,ATLEN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,ADIV) \
    |_PER_FDEFAULT(CHIP,DEVCFG,ATLMEN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,AFCMUX) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCASP1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,I2C1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,I2C0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP1EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCBSP0EN) \
    |_PER_FDEFAULT(CHIP,DEVCFG,MCASP0EN) \
   )  
  

 #define CHIP_DEVCFG_RMK(atlen,adiv,atlmen,afcmux,mcasp1en,i2c1en,i2c0en,mcbsp1en,mcbsp0en,mcasp0en) (Uint32)( \
     _PER_FMK(CHIP,DEVCFG,ATLEN,atlen) \
    |_PER_FMK(CHIP,DEVCFG,ADIV,adiv) \
    |_PER_FMK(CHIP,DEVCFG,ATLMEN,atlmen) \
    |_PER_FMK(CHIP,DEVCFG,AFCMUX,afcmux) \
    |_PER_FMK(CHIP,DEVCFG,MCASP1EN,mcasp1en) \
    |_PER_FMK(CHIP,DEVCFG,I2C1EN,i2c1en) \
    |_PER_FMK(CHIP,DEVCFG,I2C0EN,i2c0en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP1EN,mcbsp1en) \
    |_PER_FMK(CHIP,DEVCFG,MCBSP0EN,mcbsp0en) \
    |_PER_FMK(CHIP,DEVCFG,MCASP0EN,mcasp0en) \
  )  

#endif /* CHIP_6410 || CHIP_6413 || CHIP_6418 */

#if (CHIP_6711C || CHIP_6712C)
  #define   _CHIP_DEVCFG_ADDR              0x019C0200u
  #define   _CHIP_DEVCFG_OFFSET            0

  #define _CHIP_DEVCFG_EKSRC_MASK          0x00000010u
  #define _CHIP_DEVCFG_EKSRC_SHIFT         0x00000004u
  #define  CHIP_DEVCFG_EKSRC_DEFAULT       0x00000000u
  #define  CHIP_DEVCFG_EKSRC_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVCFG_EKSRC_SYSCLK3       0x00000000u
  #define  CHIP_DEVCFG_EKSRC_ECLKIN        0x00000001u

  #define  CHIP_DEVCFG_OF(x)              _VALUEOF(x)

  #define CHIP_DEVCFG_DEFAULT (Uint32)( \
     _PER_FDEFAULT(CHIP,DEVCFG,EKSRC) \
 )

  #define CHIP_DEVCFG_RMK(eksrc) (Uint32)( \
      _PER_FMK(CHIP,DEVCFG,EKSRC,eksrc) \
)

#endif /* CHIP_6711C || CHIP_6712C */


  #define _CHIP_DEVCFG_FGET(FIELD)\
    _PER_FGET(_CHIP_DEVCFG_ADDR,CHIP,DEVCFG,##FIELD)

  #define _CHIP_DEVCFG_FSET(FIELD,field)\
    _PER_FSET(_CHIP_DEVCFG_ADDR,CHIP,DEVCFG,##FIELD,field)

  #define _CHIP_DEVCFG_FSETS(FIELD,SYM)\
    _PER_FSETS(_CHIP_DEVCFG_ADDR,CHIP,DEVCFG,##FIELD,##SYM)

/*----------------------------------------------------------------------------*/
/******************************************************************************\
* _____________________
* |                   |
* |  D E V S T A T    |
* |___________________|
*
* DEVSTAT - Device Status Register (1)
*
* FIELDS (msb -> lsb)
* DM642
* (r) MACEN
* (r) HPIWIDTH
* (r) PCIEEAI
* (r) PCIEN
* (r) CLKMODE
* (r) LENDIAN
* (r) BOOTMODE
* (r) AECLKINSEL
*
* DRI300
* (r) PLLM
* (r) OSCEXTRES
* (r) CLKINSEL
* (r) CLKMODE3
* (r) HPIWIDTH
* (r) HPIENZ
* (r) CLKMODE2
* (r) CLKMODE1
* (r) CLKMODE0
* (r) LENDIAN
* (r) BOOTMODE
* (r) AECLKINSEL
*
* 
\******************************************************************************/
#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412)

  #define   _CHIP_DEVSTAT_ADDR                0x01B3F004u
  #define   _CHIP_DEVSTAT_OFFSET              0

  #define _CHIP_DEVSTAT_MACEN_MASK            0x00000800u
  #define _CHIP_DEVSTAT_MACEN_SHIFT           0x0000000Bu
  #define  CHIP_DEVSTAT_MACEN_DEFAULT         0x00000000u
  #define  CHIP_DEVSTAT_MACEN_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVSTAT_MACEN_DISABLE         0x00000000u
  #define  CHIP_DEVSTAT_MACEN_ENABLE          0x00000001u

 #if !(CHIP_DM640)
  #define _CHIP_DEVSTAT_HPIWIDTH_MASK            0x00000400u
  #define _CHIP_DEVSTAT_HPIWIDTH_SHIFT           0x0000000Au
  #define  CHIP_DEVSTAT_HPIWIDTH_DEFAULT         0x00000000u
  #define  CHIP_DEVSTAT_HPIWIDTH_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVSTAT_HPIWIDTH_16              0x00000000u
  #define  CHIP_DEVSTAT_HPIWIDTH_32              0x00000001u
 #endif

 #if !(CHIP_DM641 | CHIP_DM640)
  #define _CHIP_DEVSTAT_PCIEEAI_MASK            0x00000200u
  #define _CHIP_DEVSTAT_PCIEEAI_SHIFT           0x00000009u
  #define  CHIP_DEVSTAT_PCIEEAI_DEFAULT         0x00000000u
  #define  CHIP_DEVSTAT_PCIEEAI_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVSTAT_PCIEEAI_NONE            0x00000000u
  #define  CHIP_DEVSTAT_PCIEEAI_INIT            0x00000001u

  #define _CHIP_DEVSTAT_PCIEN_MASK           0x00000100u
  #define _CHIP_DEVSTAT_PCIEN_SHIFT          0x00000008u
  #define  CHIP_DEVSTAT_PCIEN_DEFAULT        0x00000000u
  #define  CHIP_DEVSTAT_PCIEN_OF(x)          _VALUEOF(x)
  #define  CHIP_DEVSTAT_PCIEN_DISABLE        0x00000000u
  #define  CHIP_DEVSTAT_PCIEN_ENABLE         0x00000001u
 #endif

  #define _CHIP_DEVSTAT_CLKMODE_MASK         0x00000060u
  #define _CHIP_DEVSTAT_CLKMODE_SHIFT        0x00000005u
  #define  CHIP_DEVSTAT_CLKMODE_DEFAULT      0x00000001u
  #define  CHIP_DEVSTAT_CLKMODE_OF(x)        _VALUEOF(x)
  #define  CHIP_DEVSTAT_CLKMODE_X1           0x00000000u
  #define  CHIP_DEVSTAT_CLKMODE_X6           0x00000001u
  #define  CHIP_DEVSTAT_CLKMODE_X12          0x00000002u
  #define  CHIP_DEVSTAT_CLKMODE_X20          0x00000003u

  #define _CHIP_DEVSTAT_LENDIAN_MASK         0x00000010u
  #define _CHIP_DEVSTAT_LENDIAN_SHIFT        0x00000004u
  #define  CHIP_DEVSTAT_LENDIAN_DEFAULT      0x00000001u
  #define  CHIP_DEVSTAT_LENDIAN_OF(x)        _VALUEOF(x)
  #define  CHIP_DEVSTAT_LENDIAN_BIG          0x00000000u
  #define  CHIP_DEVSTAT_LENDIAN_LITTLE       0x00000001u

  #define _CHIP_DEVSTAT_BOOTMODE_MASK         0x0000000Cu
  #define _CHIP_DEVSTAT_BOOTMODE_SHIFT        0x00000002u
  #define  CHIP_DEVSTAT_BOOTMODE_DEFAULT      0x00000000u
  #define  CHIP_DEVSTAT_BOOTMODE_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVSTAT_BOOTMODE_NONE         0x00000000u
  #define  CHIP_DEVSTAT_BOOTMODE_HPIPCI       0x00000001u
  #define  CHIP_DEVSTAT_BOOTMODE_EMIFA        0x00000003u

  #define _CHIP_DEVSTAT_AECLKINSEL_MASK         0x00000003u
  #define _CHIP_DEVSTAT_AECLKINSEL_SHIFT        0x00000000u
  #define  CHIP_DEVSTAT_AECLKINSEL_DEFAULT      0x00000000u
  #define  CHIP_DEVSTAT_AECLKINSEL_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVSTAT_AECLKINSEL_ECLKIN       0x00000000u
  #define  CHIP_DEVSTAT_AECLKINSEL_CLKOUT4      0x00000001u
  #define  CHIP_DEVSTAT_AECLKINSEL_CLKOUT6      0x00000002u
  #define  CHIP_DEVSTAT_OF(x)              _VALUEOF(x)

  #define  CHIP_DEVSTAT_OF(x)              _VALUEOF(x)

  /* Read only Register */

  #define _CHIP_DEVSTAT_FGET(FIELD)\
    _PER_FGET(_CHIP_DEVSTAT_ADDR,CHIP,DEVSTAT,##FIELD)


#endif /* CHIP_DM642 | CHIP_6412  */

#if (CHIP_6410 || CHIP_6413 || CHIP_6418)

  #define   _CHIP_DEVSTAT_ADDR                 0x01B3F004u
  #define   _CHIP_DEVSTAT_OFFSET               0

  #define _CHIP_DEVSTAT_PLLM_MASK              0x00F10000u
  #define _CHIP_DEVSTAT_PLLM_SHIFT             0x00000013u
  #define  CHIP_DEVSTAT_PLLM_DEFAULT           0x00000000u
  #define  CHIP_DEVSTAT_PLLM_OF(x)             _VALUEOF(x)
  #define  CHIP_DEVSTAT_PLLM_BYPASS            0x00000000u
  #define  CHIP_DEVSTAT_PLLM_5                 0x00000001u
  #define  CHIP_DEVSTAT_PLLM_6                 0x00000002u
  #define  CHIP_DEVSTAT_PLLM_7                 0x00000003u
  #define  CHIP_DEVSTAT_PLLM_8                 0x00000004u
  #define  CHIP_DEVSTAT_PLLM_9                 0x00000005u
  #define  CHIP_DEVSTAT_PLLM_10                0x00000006u
  #define  CHIP_DEVSTAT_PLLM_11                0x00000007u
  #define  CHIP_DEVSTAT_PLLM_12                0x00000008u
  #define  CHIP_DEVSTAT_PLLM_16                0x00000009u
  #define  CHIP_DEVSTAT_PLLM_18                0x0000000Au
  #define  CHIP_DEVSTAT_PLLM_19                0x0000000Bu
  #define  CHIP_DEVSTAT_PLLM_20                0x0000000Cu
  #define  CHIP_DEVSTAT_PLLM_21                0x0000000Du
  #define  CHIP_DEVSTAT_PLLM_22                0x0000000Eu
  #define  CHIP_DEVSTAT_PLLM_24                0x0000000Fu
 
  #define _CHIP_DEVSTAT_OSCEXTRES_MASK         0x00020000u
  #define _CHIP_DEVSTAT_OSCEXTRES_SHIFT        0x00000011u
  #define  CHIP_DEVSTAT_OSCEXTRES_DEFAUL       0x00000001u
  #define  CHIP_DEVSTAT_OSCEXTRES_OF(x)        _VALUEOF(x)
  #define  CHIP_DEVSTAT_OSCEXTRES_DISABL       0x00000000u
  #define  CHIP_DEVSTAT_OSCEXTRES_ENABLE       0x00000001u
 
  #define _CHIP_DEVSTAT_CLKINSEL_MASK          0x00010000u
  #define _CHIP_DEVSTAT_CLKINSEL_SHIFT         0x00000010u
  #define  CHIP_DEVSTAT_CLKINSEL_DEFAULT       0x00000000u
  #define  CHIP_DEVSTAT_CLKINSEL_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVSTAT_CLKINSEL_DISABLE       0x00000000u
  #define  CHIP_DEVSTAT_CLKINSEL_ENABLE        0x00000001u
 
  #define _CHIP_DEVSTAT_HPIWIDTH_MASK          0x00000400u
  #define _CHIP_DEVSTAT_HPIWIDTH_SHIFT         0x0000000Au
  #define  CHIP_DEVSTAT_HPIWIDTH_DEFAUL        0x00000000u
  #define  CHIP_DEVSTAT_HPIWIDTH_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVSTAT_HPIWIDTH_16            0x00000000u
  #define  CHIP_DEVSTAT_HPIWIDTH_32            0x00000001u
 
  #define _CHIP_DEVSTAT_HPIENZ_MASK            0x00000100u
  #define _CHIP_DEVSTAT_HPIENZ_SHIFT           0x00000008u
  #define  CHIP_DEVSTAT_HPIENZ_DEFAULT         0x00000000u
  #define  CHIP_DEVSTAT_HPIENZ_OF(x)           _VALUEOF(x)
  #define  CHIP_DEVSTAT_HPIENZ_ENABLE          0x00000000u
  #define  CHIP_DEVSTAT_HPIENZ_DISABLE         0x00000001u
 
  #define _CHIP_DEVSTAT_CLKMODE_MASK          0x000010E0u
  #define _CHIP_DEVSTAT_CLKMODE_SHIFT         0x00000005u
  #define  CHIP_DEVSTAT_CLKMODE_DEFAULT       0x00000001u
  #define  CHIP_DEVSTAT_CLKMODE_OF(x)         _VALUEOF(x)
  #define  CHIP_DEVSTAT_CLKMODE_0             0x00000000u
  #define  CHIP_DEVSTAT_CLKMODE_1             0x00000001u
  #define  CHIP_DEVSTAT_CLKMODE_2             0x00000002u
  #define  CHIP_DEVSTAT_CLKMODE_3             0x00000003u
  #define  CHIP_DEVSTAT_CLKMODE_4             0x00000004u
  #define  CHIP_DEVSTAT_CLKMODE_5             0x00000005u
  #define  CHIP_DEVSTAT_CLKMODE_6             0x00000006u
  #define  CHIP_DEVSTAT_CLKMODE_7             0x00000007u
  #define  CHIP_DEVSTAT_CLKMODE_8             0x00000080u
  #define  CHIP_DEVSTAT_CLKMODE_9             0x00000081u
  #define  CHIP_DEVSTAT_CLKMODE_10            0x00000082u
  #define  CHIP_DEVSTAT_CLKMODE_11            0x00000083u
  #define  CHIP_DEVSTAT_CLKMODE_12            0x00000084u
  #define  CHIP_DEVSTAT_CLKMODE_13            0x00000085u
  #define  CHIP_DEVSTAT_CLKMODE_14            0x00000086u
  #define  CHIP_DEVSTAT_CLKMODE_15            0x00000087u
 
  #define _CHIP_DEVSTAT_LENDIAN_MASK           0x00000010u
  #define _CHIP_DEVSTAT_LENDIAN_SHIFT          0x00000004u
  #define  CHIP_DEVSTAT_LENDIAN_DEFAULT        0x00000001u
  #define  CHIP_DEVSTAT_LENDIAN_OF(x)          _VALUEOF(x)
  #define  CHIP_DEVSTAT_LENDIAN_BIG            0x00000000u 
  #define  CHIP_DEVSTAT_LENDIAN_LITTLE         0x00000001u
 
  #define _CHIP_DEVSTAT_BOOTMODE_MASK          0x0000000Cu
  #define _CHIP_DEVSTAT_BOOTMODE_SHIFT         0x00000002u
  #define  CHIP_DEVSTAT_BOOTMODE_DEFAULT       0x00000000u
  #define  CHIP_DEVSTAT_BOOTMODE_OF(x)          _VALUEOF(x)
  #define  CHIP_DEVSTAT_BOOTMODE_NONE          0x00000000u
  #define  CHIP_DEVSTAT_BOOTMODE_HPI           0x00000001u
  #define  CHIP_DEVSTAT_BOOTMODE_EMIFA         0x00000003u

  #define _CHIP_DEVSTAT_AECLKINSEL_MASK        0x00000003u
  #define _CHIP_DEVSTAT_AECLKINSEL_SHIFT       0x00000000u
  #define  CHIP_DEVSTAT_AECLKINSEL_DEFAULT     0x00000000u
  #define  CHIP_DEVSTAT_AECLKINSEL_OF(x)       _VALUEOF(x)
  #define  CHIP_DEVSTAT_AECLKINSEL_ECLKIN      0x00000000u
  #define  CHIP_DEVSTAT_AECLKINSEL_CLKOUT4     0x00000001u
  #define  CHIP_DEVSTAT_AECLKINSEL_CLKOUT6     0x00000002u

  #define  CHIP_DEVSTAT_OF(x)              _VALUEOF(x)

  /* Read only Register */

  #define _CHIP_DEVSTAT_FGET(FIELD)\
    _PER_FGET(_CHIP_DEVSTAT_ADDR,CHIP,DEVSTAT,##FIELD)


#endif /* CHIP_6410 || CHIP_6413 || CHIP_6418 */

/******************************************************************************\
* _____________________
* |                   |
* |  J T A G I D      |
* |___________________|
*
* JTAGID - JTAG ID register (1)
*
* FIELDS (msb -> lsb)
* (r) VARIANT
* (r) PART
* (r) MANNUFACTURE
* (r) LSB
*
* (1) Only for DM642
*
\******************************************************************************/


#if (CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_6412 )

  #define   _CHIP_JTAGID_ADDR                0x01B3F008u
  #define   _CHIP_JTAGID_OFFSET              0

  #define _CHIP_JTAGID_VARIANT_MASK          0xF0000000u
  #define _CHIP_JTAGID_VARIANT_SHIFT         0x0000001Cu
  #define  CHIP_JTAGID_VARIANT_DEFAULT       0x00000000u
  #define  CHIP_JTAGID_VARIANT_OF(x)         _VALUEOF(x)

  #define _CHIP_JTAGID_PART_MASK             0x0FFFF000u
  #define _CHIP_JTAGID_PART_SHIFT            0x0000000Cu
  #define  CHIP_JTAGID_PART_DEFAULT          0x00000079u
  #define  CHIP_JTAGID_PART_OF(x)            _VALUEOF(x)

  #define _CHIP_JTAGID_MANUFACTURE_MASK      0x00000FFEu
  #define _CHIP_JTAGID_MANUFACTURE_SHIFT     0x00000001u
  #define  CHIP_JTAGID_MANUFACTURE_DEFAULT   0x00000017u
  #define  CHIP_JTAGID_MANUFACTURE_OF(x)     _VALUEOF(x)

  #define _CHIP_JTAGID_LSB_MASK              0x00000001u
  #define _CHIP_JTAGID_LSB_SHIFT             0x00000000u
  #define  CHIP_JTAGID_LSB_DEFAULT           0x00000001u
  #define  CHIP_JTAGID_LSB_OF(x)             _VALUEOF(x)

  #define  CHIP_JTAGID_OF(x)              _VALUEOF(x)

  #define _CHIP_JTAGID_FGET(FIELD)\
    _PER_FGET(_CHIP_JTAGID_ADDR,CHIP,JTAGID,##FIELD)

#endif /* CHIP_DM642 || CHIP_6412  */

/******************************************************************************\
* _____________________
* |                   |
* |  P C F G L O C K  |
* |___________________|
*
* PCFGLOCK - Peripheral Configuration Lock register (1)
*
* FIELDS (msb -> lsb)
* (r) LOCKSTAT
* (w) LOCK
*
* (1) Only for DM642
*
\******************************************************************************/

#if (CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_6412 || CHIP_6410 || CHIP_6413 || CHIP_6418)

  #define   _CHIP_PCFGLOCK_ADDR                 0x01B3F018u
  #define   _CHIP_PCFGLOCK_OFFSET               0

  #define _CHIP_PCFGLOCK_LOCKSTAT_MASK          0x00000001u
  #define _CHIP_PCFGLOCK_LOCKSTAT_SHIFT         0x00000000u
  #define  CHIP_PCFGLOCK_LOCKSTAT_DEFAULT       0x00000001u
  #define  CHIP_PCFGLOCK_LOCKSTAT_OF(x)         _VALUEOF(x)
  #define  CHIP_PCFGLOCK_LOCKSTAT_UNLOCK        0x00000000u
  #define  CHIP_PCFGLOCK_LOCKSTAT_LOCK          0x00000001u

  #define _CHIP_PCFGLOCK_LOCK_MASK              0xFFFFFFFFu
  #define _CHIP_PCFGLOCK_LOCK_SHIFT             0x00000000u
  #define  CHIP_PCFGLOCK_LOCK_DEFAULT           0x00000000u
  #define  CHIP_PCFGLOCK_LOCK_OF(x)             _VALUEOF(x)
  #define  CHIP_PCFGLOCK_LOCK_UNLOCK            0x10C0010Cu
  #define  CHIP_PCFGLOCK_LOCK_DISABLE           0x10C0010Cu

  #define  CHIP_PCFGLOCK_OF(x)                  _VALUEOF(x)

  #define _CHIP_PCFGLOCK_FGET(FIELD)\
    _PER_FGET(_CHIP_PCFGLOCK_ADDR,CHIP,PCFGLOCK,##FIELD)

  #define _CHIP_PCFGLOCK_FSET(FIELD,field)\
    _PER_FSET(_CHIP_PCFGLOCK_ADDR,CHIP,PCFGLOCK,##FIELD,field)

  #define _CHIP_PCFGLOCK_FSETS(FIELD,SYM)\
    _PER_FSETS(_CHIP_PCFGLOCK_ADDR,CHIP,PCFGLOCK,##FIELD,##SYM)


#endif /* CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_6412 || CHIP_6410 || CHIP_6413 || CHIP_6418*/

/*----------------------------------------------------------------------------*/
#endif /* _CSL_CHIPHAL_H_ */
/******************************************************************************\
* End of csl_chiphal.h
\******************************************************************************/

csl_dat.h/      1030611954  0     0     0       4815      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_dat.h
* DATE CREATED.. 11/11/1999 
* LAST MODIFIED. 10/03/2000
\******************************************************************************/
#ifndef _CSL_DAT_H_
#define _CSL_DAT_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_dma.h>
#include <csl_edma.h>


#if (DAT_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _DAT_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/
#if (DMA_SUPPORT)
  #define DAT_CHAANY    DMA_CHAANY
  #define DAT_CHA0      DMA_CHA0
  #define DAT_CHA1      DMA_CHA1
  #define DAT_CHA2      DMA_CHA2
  #define DAT_CHA3      DMA_CHA3
  #define DAT_PRI_LOW   DMA_PRICTL_PRI_CPU
  #define DAT_PRI_HIGH  DMA_PRICTL_PRI_DMA

  #define DAT_1D2D      0x000000D0
  #define DAT_2D1D      0x00000070
  #define DAT_2D2D      0x000000F0

#elif (EDMA_SUPPORT)
  #define DAT_CHAANY    0
  #define DAT_CHA0      0
  #define DAT_CHA1      0
  #define DAT_CHA2      0
  #define DAT_CHA3      0
  #define DAT_PRI_LOW   EDMA_OPT_PRI_LOW
  #define DAT_PRI_HIGH  EDMA_OPT_PRI_HIGH

  #define DAT_1D2D      0x01A00001
  #define DAT_2D1D      0x05200001
  #define DAT_2D2D      0x05A00001
#endif

/* open flags */
#define DAT_OPEN_2D    1

/* special magic transfer IDs */
#define DAT_XFRID_WAITALL   0xFFFFFFFF
#define DAT_XFRID_WAITNONE  0xFFFF0010


/******************************************************************************\
* global typedef declarations
\******************************************************************************/
#if (DMA_SUPPORT)
  typedef struct {
    Uint32 useMask;
    Uint32 baseAddr;
    Uint32 gblcntAddr;
    Uint32 gblidxAddr;
    Uint32 initPrictl;
  } _DAT_StateStruct;
#endif

#if (EDMA_SUPPORT)
  typedef struct {
    Uint32 useMask;
    Uint32 baseAddr;
    Uint32 initOpt;
  } _DAT_StateStruct;
#endif


/******************************************************************************\
* global variable declarations
\******************************************************************************/
extern far _DAT_StateStruct _DAT_stateStruct;


/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI int DAT_open(int chaNum, int priority, Uint32 flags);
CSLAPI void DAT_close();

CSLAPI Uint32 DAT_copy(void *src , void *dst , Uint16 byteCnt);
CSLAPI Uint32 DAT_fill(void *dst , Uint16 byteCnt, Uint32 *value);
CSLAPI void   DAT_wait(Uint32 id);
CSLAPI int    DAT_busy(Uint32 id);

CSLAPI Uint32 DAT_copy2d(Uint32 type, void *src, void *dst, Uint16 lineLen, Uint16 lineCnt, Uint16 linePitch);


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL void DAT_setPriority(int priority);


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void DAT_setPriority(int priority) {
  #if (DMA_SUPPORT)
    DMA_FSETA(&(_DAT_stateStruct.initPrictl), PRICTL, PRI, priority);
  #endif

  #if (EDMA_SUPPORT)
    EDMA_FSETA(&(_DAT_stateStruct.initOpt), OPT, PRI, priority);
  #endif 
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* DAT_SUPPORT */
#endif /* _CSL_DAT_H_ */
/******************************************************************************\
* End of csl_dat.h
\******************************************************************************/


csl_dma.h/      1030611956  0     0     0       14243     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_dma.h
* DATE CREATED.. 06/11/1999 
* LAST MODIFIED. 09/20/2000
*
\******************************************************************************/
#ifndef _CSL_DMA_H_
#define _CSL_DMA_H_

#include <csl_chip.h>
#include <csl_dmahal.h>
#include <csl_irq.h>


#if (DMA_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far 
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _DMA_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/
#define DMA_CHA_CNT        4

/* DMA_open() flags */
#define DMA_OPEN_RESET     0x00000001u

/* channel identifiers for DMA_open() */
#define DMA_CHAANY  (-1)
#define DMA_CHA0    (0)
#define DMA_CHA1    (1)
#define DMA_CHA2    (2)
#define DMA_CHA3    (3)

/* DMA status state */
#define DMA_STATUS_STOPPED      DMA_PRICTL_STATUS_STOPPED
#define DMA_STATUS_RUNNING      DMA_PRICTL_STATUS_RUNNING
#define DMA_STATUS_PAUSED       DMA_PRICTL_STATUS_PAUSED
#define DMA_STATUS_AUTORUNNING  DMA_PRICTL_STATUS_AUTORUNNING

/* predefined global register IDs */
#define DMA_GBL_ADDRRLDB    0x00000001u
#define DMA_GBL_ADDRRLDC    0x00000002u
#define DMA_GBL_ADDRRLDD    0x00000003u
#define DMA_GBL_INDEXA      0x00000004u
#define DMA_GBL_INDEXB      0x00000005u
#define DMA_GBL_CNTRLDA     0x00000008u
#define DMA_GBL_CNTRLDB     0x00000009u
#define DMA_GBL_SPLITA      0x0000000Du
#define DMA_GBL_SPLITB      0x0000000Eu
#define DMA_GBL_SPLITC      0x0000000Fu

#define DMA_GBLADDRA        0x00000001u
#define DMA_GBLADDRB        0x00000002u
#define DMA_GBLADDRC        0x00000004u
#define DMA_GBLADDRD        0x00000008u
#define DMA_GBLIDXA         0x00000010u
#define DMA_GBLIDXB         0x00000020u
#define DMA_GBLCNTA         0x00000040u
#define DMA_GBLCNTB         0x00000080u

#define _DMA_GBLREG_CNT     16
#define _DMA_GBLREG_MASK    (_DMA_GBLREG_CNT-1)

/****************************************************************/
/* The two following macros are used to get/clear the condition */
/* flags of the DMA SECCTL register in a safe manner.           */
/*                                                              */
/* The X argument MUST be one of the following:                 */
/*   DMA_SECCTL_SXCOND                                          */
/*   DMA_SECCTL_FRAMECOND                                       */
/*   DMA_SECCTL_LASTCOND                                        */
/*   DMA_SECCTL_BLOCKCOND                                       */
/*   DMA_SECCTL_RDROPCOND                                       */
/*   DMA_SECCTL_WDROPCOND                                       */
/****************************************************************/

#define DMA_GET_CONDITION(hDma,X) \
  ((DMA_RGETH(hDma,SECCTL)&_##X##_MASK)>>_##X##_SHIFT)

#define DMA_CLEAR_CONDITION(hDma,X) \
  _PER_RAOI(DMA_ADDRH(hDma,SECCTL),DMA,SECCTL,\
    (0xFFFF0AAA&~_##X##_MASK),\
    (0x00000555&~_##X##_MASK),\
    0x00000000\
  )


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* private object, not to be used by application code */
typedef struct {
  Uint32           allocated;
  Uint32           eventId;
  Uint32 volatile *baseAddr;
} DMA_Obj,*DMA_Handle;

/* channel configuration structure */
typedef struct {
  Uint32 prictl;
  Uint32 secctl;
  Uint32 src;
  Uint32 dst;
  Uint32 xfrcnt;
} DMA_Config;

typedef enum {
  DMA_GBL_ADDRRLD = 0x00,
  DMA_GBL_INDEX   = 0x04,
  DMA_GBL_CNTRLD  = 0x08,
  DMA_GBL_SPLIT   = 0x0C
} DMA_Gbl;

typedef struct {
  Uint32 addrA;
  Uint32 addrB;
  Uint32 addrC;
  Uint32 addrD;
  Uint32 idxA;
  Uint32 idxB;
  Uint32 cntA;
  Uint32 cntB;
} DMA_GlobalConfig;


/******************************************************************************\
* global variable declarations
\******************************************************************************/
extern far Uint32 _DMA_gblRegTbl[_DMA_GBLREG_CNT];

/* Predefined channel handles, these are only here for legacy    */
/* purposes and should not be used.                              */
extern far DMA_Handle _DMA_hCha0;
extern far DMA_Handle _DMA_hCha1;
extern far DMA_Handle _DMA_hCha2;
extern far DMA_Handle _DMA_hCha3;


/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void DMA_reset(DMA_Handle hDma);

CSLAPI DMA_Handle DMA_open(int chaNum, Uint32 flags);
CSLAPI void DMA_close(DMA_Handle hDma);

CSLAPI Uint32 DMA_allocGlobalReg(DMA_Gbl regType, Uint32 initVal);
CSLAPI void   DMA_freeGlobalReg(Uint32 regId);  

CSLAPI Uint32 DMA_globalAlloc(Uint32 regs);
CSLAPI void   DMA_globalFree(Uint32 regs);


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 DMA_getEventId(DMA_Handle hDma);
IDECL Uint32 DMA_getStatus(DMA_Handle hDma);
IDECL void DMA_restoreStatus(DMA_Handle hDma,Uint32 status); 

IDECL void   DMA_start(DMA_Handle hDma);
IDECL void   DMA_stop(DMA_Handle hDma);
IDECL void   DMA_pause(DMA_Handle hDma);
IDECL void   DMA_autoStart(DMA_Handle hDma);
IDECL void   DMA_wait(DMA_Handle hDma);

IDECL void   DMA_setAuxCtl(Uint32 auxCtl);

IDECL Uint32 DMA_getGlobalRegAddr(Uint32 regId);
IDECL Uint32 DMA_getGlobalReg(Uint32 regId);
IDECL void   DMA_setGlobalReg(Uint32 regId, Uint32 val);

IDECL void DMA_config(DMA_Handle hDma, DMA_Config *config);
IDECL void DMA_configArgs(DMA_Handle hDma, Uint32 prictl, Uint32 secctl, 
  Uint32 src, Uint32 dst, Uint32 xfrcnt);
IDECL void DMA_getConfig(DMA_Handle hDma, DMA_Config *config);
  
IDECL void   DMA_globalConfig(Uint32 regs, DMA_GlobalConfig *cfg); 
IDECL void   DMA_globalConfigArgs(Uint32 regs, Uint32 addrA, Uint32 addrB,
  Uint32 addrC,Uint32 addrD,Uint32 idxA,Uint32 idxB,Uint32 cntA,Uint32 cntB);
IDECL void   DMA_globalGetConfig(Uint32 regs, DMA_GlobalConfig *cfg); 


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 DMA_getEventId(DMA_Handle hDma) {
  return (Uint32)(hDma->eventId);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 DMA_getStatus(DMA_Handle hDma) {
  return (Uint32)DMA_FGETH(hDma,PRICTL,STATUS);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_restoreStatus(DMA_Handle hDma,Uint32 status) {
   DMA_FSETH(hDma,PRICTL,START,status);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_start(DMA_Handle hDma) {
  DMA_FSETSH(hDma,PRICTL,START,NORMAL);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_stop(DMA_Handle hDma) {
  DMA_FSETSH(hDma,PRICTL,START,STOP);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_pause(DMA_Handle hDma) {
  DMA_FSETSH(hDma,PRICTL,START,PAUSE);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_autoStart(DMA_Handle hDma) {
  DMA_FSETSH(hDma,PRICTL,START,AUTOINIT);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_wait(DMA_Handle hDma) {
  while (DMA_getStatus(hDma) & DMA_STATUS_RUNNING);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_setAuxCtl(Uint32 auxCtl) {
  DMA_RSET(AUXCTL,auxCtl);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 DMA_getGlobalRegAddr(Uint32 regId) {
  return _DMA_gblRegTbl[regId&_DMA_GBLREG_MASK];
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 DMA_getGlobalReg(Uint32 regId) {
  return DMA_RGETA(_DMA_gblRegTbl[regId&_DMA_GBLREG_MASK],REG);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_setGlobalReg(Uint32 regId, Uint32 val) {
  DMA_RSETA(_DMA_gblRegTbl[regId&_DMA_GBLREG_MASK],REG,val);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_config(DMA_Handle hDma, DMA_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hDma->baseAddr);
  register int prictl,secctl,src,dst,xfrcnt;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  prictl = config->prictl;
  secctl = config->secctl;
  src    = config->src;
  dst    = config->dst;
  xfrcnt = config->xfrcnt;

  base[_DMA_PRICTL_OFFSET] = 0x00000000;
  base[_DMA_SECCTL_OFFSET] = secctl;
  base[_DMA_SRC_OFFSET]    = src;
  base[_DMA_DST_OFFSET]    = dst;
  base[_DMA_XFRCNT_OFFSET] = xfrcnt;
  base[_DMA_PRICTL_OFFSET] = prictl;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_configArgs(DMA_Handle hDma, Uint32 prictl, Uint32 secctl, 
  Uint32 src, Uint32 dst, Uint32 xfrcnt) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hDma->baseAddr);

  gie = IRQ_globalDisable();
  base[_DMA_PRICTL_OFFSET] = 0x00000000;
  base[_DMA_SECCTL_OFFSET] = secctl;
  base[_DMA_SRC_OFFSET]    = src;
  base[_DMA_DST_OFFSET]    = dst;
  base[_DMA_XFRCNT_OFFSET] = xfrcnt;
  base[_DMA_PRICTL_OFFSET] = prictl;
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_getConfig(DMA_Handle hDma, DMA_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hDma->baseAddr);
  volatile DMA_Config*cfg = (volatile DMA_Config*)config;
  register int prictl,secctl,src,dst,xfrcnt;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  prictl = base[_DMA_PRICTL_OFFSET];
  secctl = base[_DMA_SECCTL_OFFSET];
  src    = base[_DMA_SRC_OFFSET];
  dst    = base[_DMA_DST_OFFSET];
  xfrcnt = base[_DMA_XFRCNT_OFFSET];

  cfg->prictl = prictl;
  cfg->secctl = secctl;
  cfg->src    = src;
  cfg->dst    = dst;
  cfg->xfrcnt = xfrcnt;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_globalConfig(Uint32 regs, DMA_GlobalConfig *cfg) {

  Uint32 gie;
  gie = IRQ_globalDisable();
  if (regs & DMA_GBLADDRA) DMA_RSET(GBLADDRA,cfg->addrA);
  if (regs & DMA_GBLADDRB) DMA_RSET(GBLADDRB,cfg->addrB);
  if (regs & DMA_GBLADDRC) DMA_RSET(GBLADDRC,cfg->addrC);
  if (regs & DMA_GBLADDRD) DMA_RSET(GBLADDRD,cfg->addrD);
  if (regs & DMA_GBLIDXA)  DMA_RSET(GBLIDXA,cfg->idxA);
  if (regs & DMA_GBLIDXB)  DMA_RSET(GBLIDXB,cfg->idxB);
  if (regs & DMA_GBLCNTA)  DMA_RSET(GBLCNTA,cfg->cntA);
  if (regs & DMA_GBLCNTB)  DMA_RSET(GBLCNTB,cfg->cntB);
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
IDEF void DMA_globalConfigArgs(Uint32 regs, Uint32 addrA, Uint32 addrB,
  Uint32 addrC,Uint32 addrD,Uint32 idxA,Uint32 idxB,Uint32 cntA,Uint32 cntB) {

  Uint32 gie;
  gie = IRQ_globalDisable();
  if (regs & DMA_GBLADDRA) DMA_RSET(GBLADDRA,addrA);
  if (regs & DMA_GBLADDRB) DMA_RSET(GBLADDRB,addrB);
  if (regs & DMA_GBLADDRC) DMA_RSET(GBLADDRC,addrC);
  if (regs & DMA_GBLADDRD) DMA_RSET(GBLADDRD,addrD);
  if (regs & DMA_GBLIDXA)  DMA_RSET(GBLIDXA,idxA);
  if (regs & DMA_GBLIDXB)  DMA_RSET(GBLIDXB,idxB);
  if (regs & DMA_GBLCNTA)  DMA_RSET(GBLCNTA,cntA);
  if (regs & DMA_GBLCNTB)  DMA_RSET(GBLCNTB,cntB);
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
IDEF void DMA_globalGetConfig(Uint32 regs, DMA_GlobalConfig *config) {

  Uint32 gie;
  volatile DMA_GlobalConfig* cfg = (volatile DMA_GlobalConfig*)config;

  gie = IRQ_globalDisable();
  if (regs & DMA_GBLADDRA) cfg->addrA = DMA_RGET(GBLADDRA);
  if (regs & DMA_GBLADDRB) cfg->addrB = DMA_RGET(GBLADDRB);
  if (regs & DMA_GBLADDRC) cfg->addrC = DMA_RGET(GBLADDRC);
  if (regs & DMA_GBLADDRD) cfg->addrD = DMA_RGET(GBLADDRD);
  if (regs & DMA_GBLIDXA)  cfg->idxA  = DMA_RGET(GBLIDXA);
  if (regs & DMA_GBLIDXB)  cfg->idxB  = DMA_RGET(GBLIDXB);
  if (regs & DMA_GBLCNTA)  cfg->cntA  = DMA_RGET(GBLCNTA);
  if (regs & DMA_GBLCNTB)  cfg->cntB  = DMA_RGET(GBLCNTB);
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* DMA_SUPPORT */
#endif /* _CSL_DMA_H_ */
/******************************************************************************\
* End of csl_dma.h
\******************************************************************************/


csl_dmahal.h/   1055155788  0     0     0       45809     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_dmahal.h
* DATE CREATED.. 03/12/1999 
* LAST MODIFIED. 02/05/2002 added 6204/6205 to DMA_COND1
*------------------------------------------------------------------------------
* REGISTERS
*
* AUXCTL   - auxiliary control register 
* PRICTL0  - channel primary control register 0
* PRICTL1  - channel primary control register 1
* PRICTL2  - channel primary control register 2
* PRICTL3  - channel primary control register 3
* SECCTL0  - channel seccondary control register 0
* SECCTL1  - channel seccondary control register 1
* SECCTL2  - channel seccondary control register 2
* SECCTL3  - channel seccondary control register 3
* SRC0     - channel src address register 0
* SRC1     - channel src address register 1
* SRC2     - channel src address register 2
* SRC3     - channel src address register 3
* DST0     - channel destination address register 0
* DST1     - channel destination address register 1
* DST2     - channel destination address register 2
* DST3     - channel destination address register 3
* XFRCNT0  - channel transfer count register 0
* XFRCNT1  - channel transfer count register 1
* XFRCNT2  - channel transfer count register 2
* XFRCNT3  - channel transfer count register 3
* GBLCNTA  - global count reload register A
* GBLCNTB  - global count reload register B
* GBLIDXA  - global index register A
* GBLIDXB  - global index register B
* GBLADDRA - global address reload register A
* GBLADDRB - global address reload register B
* GBLADDRC - global address reload register C
* GBLADDRD - global address reload register D
*
\******************************************************************************/
#ifndef _CSL_DMAHAL_H_
#define _CSL_DMAHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (DMA_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/

  #define _DMA_COND1   (CHIP_6202|CHIP_6203|CHIP_6204|CHIP_6205)

  #define _DMA_BASE_CHA0    0x01840000u
  #define _DMA_BASE_CHA1    0x01840040u
  #define _DMA_BASE_CHA2    0x01840004u
  #define _DMA_BASE_CHA3    0x01840044u


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define DMA_FMK(REG,FIELD,x)\
    _PER_FMK(DMA,##REG,##FIELD,x)

  #define DMA_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(DMA,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define DMA_ADDR(REG)\
    _DMA_##REG##_ADDR

  #define DMA_RGET(REG)\
    _PER_RGET(_DMA_##REG##_ADDR,DMA,##REG)

  #define DMA_RSET(REG,x)\
    _PER_RSET(_DMA_##REG##_ADDR,DMA,##REG,x)

  #define DMA_FGET(REG,FIELD)\
    _DMA_##REG##_FGET(##FIELD)

  #define DMA_FSET(REG,FIELD,x)\
    _DMA_##REG##_FSET(##FIELD,##x)

  #define DMA_FSETS(REG,FIELD,SYM)\
    _DMA_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define DMA_RGETA(addr,REG)\
    _PER_RGET(addr,DMA,##REG)

  #define DMA_RSETA(addr,REG,x)\
    _PER_RSET(addr,DMA,##REG,x)

  #define DMA_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,DMA,##REG,##FIELD)

  #define DMA_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,DMA,##REG,##FIELD,x)

  #define DMA_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,DMA,##REG,##FIELD,##SYM)


  /* ----------------------------------------- */
  /* HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define DMA_ADDRH(h,REG)\
    (Uint32)(&((h)->baseAddr[_DMA_##REG##_OFFSET]))

  #define DMA_RGETH(h,REG)\
    DMA_RGETA(DMA_ADDRH(h,##REG),##REG)


  #define DMA_RSETH(h,REG,x)\
    DMA_RSETA(DMA_ADDRH(h,##REG),##REG,x)


  #define DMA_FGETH(h,REG,FIELD)\
    DMA_FGETA(DMA_ADDRH(h,##REG),##REG,##FIELD)


  #define DMA_FSETH(h,REG,FIELD,x)\
    DMA_FSETA(DMA_ADDRH(h,##REG),##REG,##FIELD,x)


  #define DMA_FSETSH(h,REG,FIELD,SYM)\
    DMA_FSETSA(DMA_ADDRH(h,##REG),##REG,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  A U X C T L      |
* |___________________|
*
* AUXCTL   - auxiliary control register
*
* FIELDS (msb -> lsb)
* (rw) AUXPRI
* (rw) CHPRI
*
\******************************************************************************/
  #define _DMA_AUXCTL_ADDR              0x01840070u

  #define _DMA_AUXCTL_AUXPRI_MASK       0x00000010u
  #define _DMA_AUXCTL_AUXPRI_SHIFT      0x00000004u
  #define  DMA_AUXCTL_AUXPRI_DEFAULT    0x00000000u
  #define  DMA_AUXCTL_AUXPRI_OF(x)      _VALUEOF(x)
  #define  DMA_AUXCTL_AUXPRI_CPU        0x00000000u
  #define  DMA_AUXCTL_AUXPRI_DMA        0x00000001u

  #define _DMA_AUXCTL_CHPRI_MASK        0x0000000Fu
  #define _DMA_AUXCTL_CHPRI_SHIFT       0x00000000u
  #define  DMA_AUXCTL_CHPRI_DEFAULT     0x00000000u
  #define  DMA_AUXCTL_CHPRI_OF(x)       _VALUEOF(x)
  #define  DMA_AUXCTL_CHPRI_HIGHEST     0x00000000u
  #define  DMA_AUXCTL_CHPRI_2ND         0x00000001u
  #define  DMA_AUXCTL_CHPRI_3RD         0x00000002u
  #define  DMA_AUXCTL_CHPRI_4TH         0x00000003u
  #define  DMA_AUXCTL_CHPRI_LOWEST      0x00000004u

  #define  DMA_AUXCTL_OF(x)             _VALUEOF(x)

  #define DMA_AUXCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,AUXCTL,AUXPRI) \
    |_PER_FDEFAULT(DMA,AUXCTL,CHPRI) \
  )

  #define DMA_AUXCTL_RMK(auxpri,chpri) (Uint32)( \
     _PER_FMK(DMA,AUXCTL,AUXPRI,auxpri) \
    |_PER_FMK(DMA,AUXCTL,CHPRI,chpri) \
  )

  #define _DMA_AUXCTL_FGET(FIELD)\
    _PER_FGET(_DMA_AUXCTL_ADDR,DMA,AUXCTL,##FIELD)

  #define _DMA_AUXCTL_FSET(FIELD,field)\
    _PER_FSET(_DMA_AUXCTL_ADDR,DMA,AUXCTL,##FIELD,field)

  #define _DMA_AUXCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_DMA_AUXCTL_ADDR,DMA,AUXCTL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  P R I C T L      |
* |___________________|
*
* PRICTL0  - channel primary control register 0
* PRICTL1  - channel primary control register 1
* PRICTL2  - channel primary control register 2
* PRICTL3  - channel primary control register 3
*
* FIELDS (msb -> lsb)
* (rw) DSTRLD
* (rw) SRCRLD
* (rw) EMOD
* (rw) FS
* (rw) TCINT
* (rw) PRI
* (rw) WSYNC
* (rw) RSYNC
* (rw) INDEX
* (rw) CNTRLD
* (rw) SPLIT
* (rw) ESIZE
* (rw) DSTDIR
* (rw) SRCDIR
* (r)  STATUS
* (rw) START
*
\******************************************************************************/
  #define _DMA_PRICTL_OFFSET            0

  #define _DMA_PRICTL0_ADDR             0x01840000u
  #define _DMA_PRICTL1_ADDR             0x01840040u
  #define _DMA_PRICTL2_ADDR             0x01840004u
  #define _DMA_PRICTL3_ADDR             0x01840044u

  #define _DMA_PRICTL_DSTRLD_MASK       0xC0000000u
  #define _DMA_PRICTL_DSTRLD_SHIFT      0x0000001Eu
  #define  DMA_PRICTL_DSTRLD_DEFAULT    0x00000000u
  #define  DMA_PRICTL_DSTRLD_OF(x)      _VALUEOF(x)
  #define  DMA_PRICTL_DSTRLD_NONE       0x00000000u
  #define  DMA_PRICTL_DSTRLD_B          0x00000001u
  #define  DMA_PRICTL_DSTRLD_C          0x00000002u
  #define  DMA_PRICTL_DSTRLD_D          0x00000003u

  #define _DMA_PRICTL_SRCRLD_MASK       0x30000000u
  #define _DMA_PRICTL_SRCRLD_SHIFT      0x0000001Cu
  #define  DMA_PRICTL_SRCRLD_DEFAULT    0x00000000u
  #define  DMA_PRICTL_SRCRLD_OF(x)      _VALUEOF(x)
  #define  DMA_PRICTL_SRCRLD_NONE       0x00000000u
  #define  DMA_PRICTL_SRCRLD_B          0x00000001u
  #define  DMA_PRICTL_SRCRLD_C          0x00000002u
  #define  DMA_PRICTL_SRCRLD_D          0x00000003u

  #define _DMA_PRICTL_EMOD_MASK         0x08000000u
  #define _DMA_PRICTL_EMOD_SHIFT        0x0000001Bu
  #define  DMA_PRICTL_EMOD_DEFAULT      0x00000000u
  #define  DMA_PRICTL_EMOD_OF(x)        _VALUEOF(x)
  #define  DMA_PRICTL_EMOD_NOHALT       0x00000000u
  #define  DMA_PRICTL_EMOD_HALT         0x00000001u

  #define _DMA_PRICTL_FS_MASK           0x04000000u
  #define _DMA_PRICTL_FS_SHIFT          0x0000001Au
  #define  DMA_PRICTL_FS_DEFAULT        0x00000000u
  #define  DMA_PRICTL_FS_OF(x)          _VALUEOF(x)
  #define  DMA_PRICTL_FS_DISABLE        0x00000000u
  #define  DMA_PRICTL_FS_RSYNC          0x00000001u

  #define _DMA_PRICTL_TCINT_MASK        0x02000000u
  #define _DMA_PRICTL_TCINT_SHIFT       0x00000019u
  #define  DMA_PRICTL_TCINT_DEFAULT     0x00000000u
  #define  DMA_PRICTL_TCINT_OF(x)       _VALUEOF(x)
  #define  DMA_PRICTL_TCINT_DISABLE     0x00000000u
  #define  DMA_PRICTL_TCINT_ENABLE      0x00000001u

  #define _DMA_PRICTL_PRI_MASK          0x01000000u
  #define _DMA_PRICTL_PRI_SHIFT         0x00000018u
  #define  DMA_PRICTL_PRI_DEFAULT       0x00000000u
  #define  DMA_PRICTL_PRI_OF(x)         _VALUEOF(x)
  #define  DMA_PRICTL_PRI_CPU           0x00000000u
  #define  DMA_PRICTL_PRI_DMA           0x00000001u

  #define _DMA_PRICTL_WSYNC_MASK        0x00F80000u
  #define _DMA_PRICTL_WSYNC_SHIFT       0x00000013u
  #define  DMA_PRICTL_WSYNC_DEFAULT     0x00000000u
  #define  DMA_PRICTL_WSYNC_OF(x)       _VALUEOF(x)
  #define  DMA_PRICTL_WSYNC_NONE        0x00000000u
  #define  DMA_PRICTL_WSYNC_TINT0       0x00000001u
  #define  DMA_PRICTL_WSYNC_TINT1       0x00000002u
  #define  DMA_PRICTL_WSYNC_SDINT       0x00000003u
  #define  DMA_PRICTL_WSYNC_EXTINT4     0x00000004u
  #define  DMA_PRICTL_WSYNC_EXTINT5     0x00000005u
  #define  DMA_PRICTL_WSYNC_EXTINT6     0x00000006u
  #define  DMA_PRICTL_WSYNC_EXTINT7     0x00000007u
  #define  DMA_PRICTL_WSYNC_DMAINT0     0x00000008u
  #define  DMA_PRICTL_WSYNC_DMAINT1     0x00000009u
  #define  DMA_PRICTL_WSYNC_DMAINT2     0x0000000Au
  #define  DMA_PRICTL_WSYNC_DMAINT3     0x0000000Bu
  #define  DMA_PRICTL_WSYNC_XEVT0       0x0000000Cu
  #define  DMA_PRICTL_WSYNC_REVT0       0x0000000Du
  #define  DMA_PRICTL_WSYNC_XEVT1       0x0000000Eu
  #define  DMA_PRICTL_WSYNC_REVT1       0x0000000Fu
  #define  DMA_PRICTL_WSYNC_DSPINT      0x00000010u
  #define  DMA_PRICTL_WSYNC_XEVT2       0x00000011u
  #define  DMA_PRICTL_WSYNC_REVT2       0x00000012u

  #define _DMA_PRICTL_RSYNC_MASK        0x0007C000u
  #define _DMA_PRICTL_RSYNC_SHIFT       0x0000000Eu
  #define  DMA_PRICTL_RSYNC_DEFAULT     0x00000000u
  #define  DMA_PRICTL_RSYNC_OF(x)       _VALUEOF(x)
  #define  DMA_PRICTL_RSYNC_NONE        0x00000000u
  #define  DMA_PRICTL_RSYNC_TINT0       0x00000001u
  #define  DMA_PRICTL_RSYNC_TINT1       0x00000002u
  #define  DMA_PRICTL_RSYNC_SDINT       0x00000003u
  #define  DMA_PRICTL_RSYNC_EXTINT4     0x00000004u
  #define  DMA_PRICTL_RSYNC_EXTINT5     0x00000005u
  #define  DMA_PRICTL_RSYNC_EXTINT6     0x00000006u
  #define  DMA_PRICTL_RSYNC_EXTINT7     0x00000007u
  #define  DMA_PRICTL_RSYNC_DMAINT0     0x00000008u
  #define  DMA_PRICTL_RSYNC_DMAINT1     0x00000009u
  #define  DMA_PRICTL_RSYNC_DMAINT2     0x0000000Au
  #define  DMA_PRICTL_RSYNC_DMAINT3     0x0000000Bu
  #define  DMA_PRICTL_RSYNC_XEVT0       0x0000000Cu
  #define  DMA_PRICTL_RSYNC_REVT0       0x0000000Du
  #define  DMA_PRICTL_RSYNC_XEVT1       0x0000000Eu
  #define  DMA_PRICTL_RSYNC_REVT1       0x0000000Fu
  #define  DMA_PRICTL_RSYNC_DSPINT      0x00000010u
  #define  DMA_PRICTL_RSYNC_XEVT2       0x00000011u
  #define  DMA_PRICTL_RSYNC_REVT2       0x00000012u

  #define _DMA_PRICTL_INDEX_MASK        0x00002000u
  #define _DMA_PRICTL_INDEX_SHIFT       0x0000000Du
  #define  DMA_PRICTL_INDEX_DEFAULT     0x00000000u
  #define  DMA_PRICTL_INDEX_OF(x)       _VALUEOF(x)
  #define  DMA_PRICTL_INDEX_NA          0x00000000u
  #define  DMA_PRICTL_INDEX_A           0x00000000u
  #define  DMA_PRICTL_INDEX_B           0x00000001u

  #define _DMA_PRICTL_CNTRLD_MASK       0x00001000u
  #define _DMA_PRICTL_CNTRLD_SHIFT      0x0000000Cu
  #define  DMA_PRICTL_CNTRLD_DEFAULT    0x00000000u
  #define  DMA_PRICTL_CNTRLD_OF(x)      _VALUEOF(x)
  #define  DMA_PRICTL_CNTRLD_NA         0x00000000u
  #define  DMA_PRICTL_CNTRLD_A          0x00000000u
  #define  DMA_PRICTL_CNTRLD_B          0x00000001u

  #define _DMA_PRICTL_SPLIT_MASK        0x00000C00u
  #define _DMA_PRICTL_SPLIT_SHIFT       0x0000000Au
  #define  DMA_PRICTL_SPLIT_DEFAULT     0x00000000u
  #define  DMA_PRICTL_SPLIT_OF(x)       _VALUEOF(x)
  #define  DMA_PRICTL_SPLIT_DISABLE     0x00000000u
  #define  DMA_PRICTL_SPLIT_A           0x00000001u
  #define  DMA_PRICTL_SPLIT_B           0x00000002u
  #define  DMA_PRICTL_SPLIT_C           0x00000003u

  #define _DMA_PRICTL_ESIZE_MASK        0x00000300u
  #define _DMA_PRICTL_ESIZE_SHIFT       0x00000008u
  #define  DMA_PRICTL_ESIZE_DEFAULT     0x00000000u
  #define  DMA_PRICTL_ESIZE_OF(x)       _VALUEOF(x)
  #define  DMA_PRICTL_ESIZE_32BIT       0x00000000u
  #define  DMA_PRICTL_ESIZE_16BIT       0x00000001u
  #define  DMA_PRICTL_ESIZE_8BIT        0x00000002u

  #define _DMA_PRICTL_DSTDIR_MASK       0x000000C0u
  #define _DMA_PRICTL_DSTDIR_SHIFT      0x00000006u
  #define  DMA_PRICTL_DSTDIR_DEFAULT    0x00000000u
  #define  DMA_PRICTL_DSTDIR_OF(x)      _VALUEOF(x)
  #define  DMA_PRICTL_DSTDIR_NONE       0x00000000u
  #define  DMA_PRICTL_DSTDIR_INC        0x00000001u
  #define  DMA_PRICTL_DSTDIR_DEC        0x00000002u
  #define  DMA_PRICTL_DSTDIR_IDX        0x00000003u

  #define _DMA_PRICTL_SRCDIR_MASK       0x00000030u
  #define _DMA_PRICTL_SRCDIR_SHIFT      0x00000004u
  #define  DMA_PRICTL_SRCDIR_DEFAULT    0x00000000u
  #define  DMA_PRICTL_SRCDIR_OF(x)      _VALUEOF(x)
  #define  DMA_PRICTL_SRCDIR_NONE       0x00000000u
  #define  DMA_PRICTL_SRCDIR_INC        0x00000001u
  #define  DMA_PRICTL_SRCDIR_DEC        0x00000002u
  #define  DMA_PRICTL_SRCDIR_IDX        0x00000003u

  #define _DMA_PRICTL_STATUS_MASK       0x0000000Cu
  #define _DMA_PRICTL_STATUS_SHIFT      0x00000002u
  #define  DMA_PRICTL_STATUS_DEFAULT    0x00000000u
  #define  DMA_PRICTL_STATUS_OF(x)      _VALUEOF(x)
  #define  DMA_PRICTL_STATUS_STOPPED    0x00000000u
  #define  DMA_PRICTL_STATUS_RUNNING    0x00000001u
  #define  DMA_PRICTL_STATUS_PAUSED     0x00000002u
  #define  DMA_PRICTL_STATUS_AUTORUNNING 0x00000003u

  #define _DMA_PRICTL_START_MASK        0x00000003u
  #define _DMA_PRICTL_START_SHIFT       0x00000000u
  #define  DMA_PRICTL_START_DEFAULT     0x00000000u
  #define  DMA_PRICTL_START_OF(x)       _VALUEOF(x)
  #define  DMA_PRICTL_START_STOP        0x00000000u
  #define  DMA_PRICTL_START_NORMAL      0x00000001u
  #define  DMA_PRICTL_START_PAUSE       0x00000002u
  #define  DMA_PRICTL_START_AUTOINIT    0x00000003u

  #define  DMA_PRICTL_OF(x)             _VALUEOF(x)

  #define DMA_PRICTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,PRICTL,DSTRLD)\
    |_PER_FDEFAULT(DMA,PRICTL,SRCRLD)\
    |_PER_FDEFAULT(DMA,PRICTL,EMOD)\
    |_PER_FDEFAULT(DMA,PRICTL,FS)\
    |_PER_FDEFAULT(DMA,PRICTL,TCINT)\
    |_PER_FDEFAULT(DMA,PRICTL,PRI)\
    |_PER_FDEFAULT(DMA,PRICTL,WSYNC)\
    |_PER_FDEFAULT(DMA,PRICTL,RSYNC)\
    |_PER_FDEFAULT(DMA,PRICTL,INDEX)\
    |_PER_FDEFAULT(DMA,PRICTL,CNTRLD)\
    |_PER_FDEFAULT(DMA,PRICTL,SPLIT)\
    |_PER_FDEFAULT(DMA,PRICTL,ESIZE)\
    |_PER_FDEFAULT(DMA,PRICTL,DSTDIR)\
    |_PER_FDEFAULT(DMA,PRICTL,SRCDIR)\
    |_PER_FDEFAULT(DMA,PRICTL,STATUS)\
    |_PER_FDEFAULT(DMA,PRICTL,START)\
  )

  #define DMA_PRICTL_RMK(dstrld,srcrld,emod,fs,tcint,pri,wsync,rsync,index,\
    cntrld,split,esize,dstdir,srcdir,start) (Uint32)( \
     _PER_FMK(DMA,PRICTL,DSTRLD,dstrld)\
    |_PER_FMK(DMA,PRICTL,SRCRLD,srcrld)\
    |_PER_FMK(DMA,PRICTL,EMOD,emod)\
    |_PER_FMK(DMA,PRICTL,FS,fs)\
    |_PER_FMK(DMA,PRICTL,TCINT,tcint)\
    |_PER_FMK(DMA,PRICTL,PRI,pri)\
    |_PER_FMK(DMA,PRICTL,WSYNC,wsync)\
    |_PER_FMK(DMA,PRICTL,RSYNC,rsync)\
    |_PER_FMK(DMA,PRICTL,INDEX,index)\
    |_PER_FMK(DMA,PRICTL,CNTRLD,cntrld)\
    |_PER_FMK(DMA,PRICTL,SPLIT,split)\
    |_PER_FMK(DMA,PRICTL,ESIZE,esize)\
    |_PER_FMK(DMA,PRICTL,DSTDIR,dstdir)\
    |_PER_FMK(DMA,PRICTL,SRCDIR,srcdir)\
    |_PER_FMK(DMA,PRICTL,START,start)\
  )

  #define _DMA_PRICTL_FGET(N,FIELD)\
    _PER_FGET(_DMA_PRICTL##N##_ADDR,DMA,PRICTL,##FIELD)

  #define _DMA_PRICTL_FSET(N,FIELD,field)\
    _PER_FSET(_DMA_PRICTL##N##_ADDR,DMA,PRICTL,##FIELD,field)

  #define _DMA_PRICTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_DMA_PRICTL##N##_ADDR,DMA,PRICTL,##FIELD,##SYM)

  #define _DMA_PRICTL0_FGET(FIELD) _DMA_PRICTL_FGET(0,##FIELD)
  #define _DMA_PRICTL1_FGET(FIELD) _DMA_PRICTL_FGET(1,##FIELD)
  #define _DMA_PRICTL2_FGET(FIELD) _DMA_PRICTL_FGET(2,##FIELD)
  #define _DMA_PRICTL3_FGET(FIELD) _DMA_PRICTL_FGET(3,##FIELD)

  #define _DMA_PRICTL0_FSET(FIELD,f) _DMA_PRICTL_FSET(0,##FIELD,f)
  #define _DMA_PRICTL1_FSET(FIELD,f) _DMA_PRICTL_FSET(1,##FIELD,f)
  #define _DMA_PRICTL2_FSET(FIELD,f) _DMA_PRICTL_FSET(2,##FIELD,f)
  #define _DMA_PRICTL3_FSET(FIELD,f) _DMA_PRICTL_FSET(3,##FIELD,f)

  #define _DMA_PRICTL0_FSETS(FIELD,SYM) _DMA_PRICTL_FSETS(0,##FIELD,##SYM)
  #define _DMA_PRICTL1_FSETS(FIELD,SYM) _DMA_PRICTL_FSETS(1,##FIELD,##SYM)
  #define _DMA_PRICTL2_FSETS(FIELD,SYM) _DMA_PRICTL_FSETS(2,##FIELD,##SYM)
  #define _DMA_PRICTL3_FSETS(FIELD,SYM) _DMA_PRICTL_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S E C C T L      |
* |___________________|
*
* SECCTL0  - channel seccondary control register 0
* SECCTL1  - channel seccondary control register 1
* SECCTL2  - channel seccondary control register 2
* SECCTL3  - channel seccondary control register 3
*
* FIELDS (msb -> lsb)
* (rw) WSPOL (1)
* (rw) RSPOL (1)
* (rw) FSIG  (1)
* (rw) DMACEN
* (rw) WSYNCCLR
* (rw) WSYNCSTAT
* (rw) RSYNCCLR
* (rw) RSYNCSTAT
* (rw) WDROPIE
* (rw) WDROPCOND
* (rw) RDROPIE
* (rw) RDROPCOND
* (rw) BLOCKIE
* (rw) BLOCKCOND
* (rw) LASTIE
* (rw) LASTCOND
* (rw) FRAMEIE
* (rw) FRAMECOND
* (rw) SXIE
* (rw) SXCOND
*
* (1) only on 6202 / 6203 /6204 /6205 devices
*
\******************************************************************************/
  #define _DMA_SECCTL_OFFSET            2

  #define _DMA_SECCTL0_ADDR             0x01840008u
  #define _DMA_SECCTL1_ADDR             0x01840048u
  #define _DMA_SECCTL2_ADDR             0x0184000Cu
  #define _DMA_SECCTL3_ADDR             0x0184004Cu

#if (_DMA_COND1)
  #define _DMA_SECCTL_WSPOL_MASK        0x00200000u
  #define _DMA_SECCTL_WSPOL_SHIFT       0x00000015u
  #define  DMA_SECCTL_WSPOL_DEFAULT     0x00000000u
  #define  DMA_SECCTL_WSPOL_OF(x)       _VALUEOF(x)
  #define  DMA_SECCTL_WSPOL_NA          0x00000000u
  #define  DMA_SECCTL_WSPOL_ACTIVEHIGH  0x00000000u
  #define  DMA_SECCTL_WSPOL_ACTIVELOW   0x00000001u

  #define _DMA_SECCTL_RSPOL_MASK        0x00100000u
  #define _DMA_SECCTL_RSPOL_SHIFT       0x00000014u
  #define  DMA_SECCTL_RSPOL_DEFAULT     0x00000000u
  #define  DMA_SECCTL_RSPOL_OF(x)       _VALUEOF(x)
  #define  DMA_SECCTL_RSPOL_NA          0x00000000u
  #define  DMA_SECCTL_RSPOL_ACTIVEHIGH  0x00000000u
  #define  DMA_SECCTL_RSPOL_ACTIVELOW   0x00000001u

  #define _DMA_SECCTL_FSIG_MASK         0x00080000u
  #define _DMA_SECCTL_FSIG_SHIFT        0x00000013u
  #define  DMA_SECCTL_FSIG_DEFAULT      0x00000000u
  #define  DMA_SECCTL_FSIG_OF(x)        _VALUEOF(x)
  #define  DMA_SECCTL_FSIG_NA           0x00000000u
  #define  DMA_SECCTL_FSIG_NORMAL       0x00000000u
  #define  DMA_SECCTL_FSIG_IGNORE       0x00000001u
#endif

  #define _DMA_SECCTL_DMACEN_MASK       0x00070000u
  #define _DMA_SECCTL_DMACEN_SHIFT      0x00000010u
  #define  DMA_SECCTL_DMACEN_DEFAULT    0x00000000u
  #define  DMA_SECCTL_DMACEN_OF(x)      _VALUEOF(x)
  #define  DMA_SECCTL_DMACEN_LOW        0x00000000u
  #define  DMA_SECCTL_DMACEN_HIGH       0x00000001u
  #define  DMA_SECCTL_DMACEN_RSYNCSTAT  0x00000002u
  #define  DMA_SECCTL_DMACEN_WSYNCSTAT  0x00000003u
  #define  DMA_SECCTL_DMACEN_FRAMECOND  0x00000004u
  #define  DMA_SECCTL_DMACEN_BLOCKCOND  0x00000005u

  #define _DMA_SECCTL_WSYNCCLR_MASK     0x00008000u
  #define _DMA_SECCTL_WSYNCCLR_SHIFT    0x0000000Fu
  #define  DMA_SECCTL_WSYNCCLR_DEFAULT  0x00000000u
  #define  DMA_SECCTL_WSYNCCLR_OF(x)    _VALUEOF(x)
  #define  DMA_SECCTL_WSYNCCLR_NOTHING  0x00000000u
  #define  DMA_SECCTL_WSYNCCLR_CLEAR    0x00000001u

  #define _DMA_SECCTL_WSYNCSTAT_MASK    0x00004000u
  #define _DMA_SECCTL_WSYNCSTAT_SHIFT   0x0000000Eu
  #define  DMA_SECCTL_WSYNCSTAT_DEFAULT 0x00000000u
  #define  DMA_SECCTL_WSYNCSTAT_OF(x)   _VALUEOF(x)
  #define  DMA_SECCTL_WSYNCSTAT_CLEAR   0x00000000u
  #define  DMA_SECCTL_WSYNCSTAT_SET     0x00000001u

  #define _DMA_SECCTL_RSYNCCLR_MASK     0x00002000u
  #define _DMA_SECCTL_RSYNCCLR_SHIFT    0x0000000Du
  #define  DMA_SECCTL_RSYNCCLR_DEFAULT  0x00000000u
  #define  DMA_SECCTL_RSYNCCLR_OF(x)    _VALUEOF(x)
  #define  DMA_SECCTL_RSYNCCLR_NOTHING  0x00000000u
  #define  DMA_SECCTL_RSYNCCLR_CLEAR    0x00000001u

  #define _DMA_SECCTL_RSYNCSTAT_MASK    0x00001000u
  #define _DMA_SECCTL_RSYNCSTAT_SHIFT   0x0000000Cu
  #define  DMA_SECCTL_RSYNCSTAT_DEFAULT 0x00000000u
  #define  DMA_SECCTL_RSYNCSTAT_OF(x)   _VALUEOF(x)
  #define  DMA_SECCTL_RSYNCSTAT_CLEAR   0x00000000u
  #define  DMA_SECCTL_RSYNCSTAT_SET     0x00000001u

  #define _DMA_SECCTL_WDROPIE_MASK      0x00000800u
  #define _DMA_SECCTL_WDROPIE_SHIFT     0x0000000Bu
  #define  DMA_SECCTL_WDROPIE_DEFAULT   0x00000000u
  #define  DMA_SECCTL_WDROPIE_OF(x)     _VALUEOF(x)
  #define  DMA_SECCTL_WDROPIE_DISABLE   0x00000000u
  #define  DMA_SECCTL_WDROPIE_ENABLE    0x00000001u

  #define _DMA_SECCTL_WDROPCOND_MASK    0x00000400u
  #define _DMA_SECCTL_WDROPCOND_SHIFT   0x0000000Au
  #define  DMA_SECCTL_WDROPCOND_DEFAULT 0x00000000u
  #define  DMA_SECCTL_WDROPCOND_OF(x)   _VALUEOF(x)
  #define  DMA_SECCTL_WDROPCOND_CLEAR   0x00000000u
  #define  DMA_SECCTL_WDROPCOND_SET     0x00000001u

  #define _DMA_SECCTL_RDROPIE_MASK      0x00000200u
  #define _DMA_SECCTL_RDROPIE_SHIFT     0x00000009u
  #define  DMA_SECCTL_RDROPIE_DEFAULT   0x00000000u
  #define  DMA_SECCTL_RDROPIE_OF(x)     _VALUEOF(x)
  #define  DMA_SECCTL_RDROPIE_DISABLE   0x00000000u
  #define  DMA_SECCTL_RDROPIE_ENABLE    0x00000001u

  #define _DMA_SECCTL_RDROPCOND_MASK    0x00000100u
  #define _DMA_SECCTL_RDROPCOND_SHIFT   0x00000008u
  #define  DMA_SECCTL_RDROPCOND_DEFAULT 0x00000000u
  #define  DMA_SECCTL_RDROPCOND_OF(x)   _VALUEOF(x)
  #define  DMA_SECCTL_RDROPCOND_CLEAR   0x00000000u
  #define  DMA_SECCTL_RDROPCOND_SET     0x00000001u

  #define _DMA_SECCTL_BLOCKIE_MASK      0x00000080u
  #define _DMA_SECCTL_BLOCKIE_SHIFT     0x00000007u
  #define  DMA_SECCTL_BLOCKIE_DEFAULT   0x00000001u
  #define  DMA_SECCTL_BLOCKIE_OF(x)     _VALUEOF(x)
  #define  DMA_SECCTL_BLOCKIE_DISABLE   0x00000000u
  #define  DMA_SECCTL_BLOCKIE_ENABLE    0x00000001u

  #define _DMA_SECCTL_BLOCKCOND_MASK    0x00000040u
  #define _DMA_SECCTL_BLOCKCOND_SHIFT   0x00000006u
  #define  DMA_SECCTL_BLOCKCOND_DEFAULT 0x00000000u
  #define  DMA_SECCTL_BLOCKCOND_OF(x)   _VALUEOF(x)
  #define  DMA_SECCTL_BLOCKCOND_CLEAR   0x00000000u
  #define  DMA_SECCTL_BLOCKCOND_SET     0x00000001u

  #define _DMA_SECCTL_LASTIE_MASK       0x00000020u
  #define _DMA_SECCTL_LASTIE_SHIFT      0x00000005u
  #define  DMA_SECCTL_LASTIE_DEFAULT    0x00000000u
  #define  DMA_SECCTL_LASTIE_OF(x)      _VALUEOF(x)
  #define  DMA_SECCTL_LASTIE_DISABLE    0x00000000u
  #define  DMA_SECCTL_LASTIE_ENABLE     0x00000001u

  #define _DMA_SECCTL_LASTCOND_MASK     0x00000010u
  #define _DMA_SECCTL_LASTCOND_SHIFT    0x00000004u
  #define  DMA_SECCTL_LASTCOND_DEFAULT  0x00000000u
  #define  DMA_SECCTL_LASTCOND_OF(x)    _VALUEOF(x)
  #define  DMA_SECCTL_LASTCOND_CLEAR    0x00000000u
  #define  DMA_SECCTL_LASTCOND_SET      0x00000001u

  #define _DMA_SECCTL_FRAMEIE_MASK      0x00000008u
  #define _DMA_SECCTL_FRAMEIE_SHIFT     0x00000003u
  #define  DMA_SECCTL_FRAMEIE_DEFAULT   0x00000000u
  #define  DMA_SECCTL_FRAMEIE_OF(x)     _VALUEOF(x)
  #define  DMA_SECCTL_FRAMEIE_DISABLE   0x00000000u
  #define  DMA_SECCTL_FRAMEIE_ENABLE    0x00000001u

  #define _DMA_SECCTL_FRAMECOND_MASK    0x00000004u
  #define _DMA_SECCTL_FRAMECOND_SHIFT   0x00000002u
  #define  DMA_SECCTL_FRAMECOND_DEFAULT 0x00000000u
  #define  DMA_SECCTL_FRAMECOND_OF(x)   _VALUEOF(x)
  #define  DMA_SECCTL_FRAMECOND_CLEAR   0x00000000u
  #define  DMA_SECCTL_FRAMECOND_SET     0x00000001u

  #define _DMA_SECCTL_SXIE_MASK         0x00000002u
  #define _DMA_SECCTL_SXIE_SHIFT        0x00000001u
  #define  DMA_SECCTL_SXIE_DEFAULT      0x00000000u
  #define  DMA_SECCTL_SXIE_OF(x)        _VALUEOF(x)
  #define  DMA_SECCTL_SXIE_DISABLE      0x00000000u
  #define  DMA_SECCTL_SXIE_ENABLE       0x00000001u

  #define _DMA_SECCTL_SXCOND_MASK       0x00000001u
  #define _DMA_SECCTL_SXCOND_SHIFT      0x00000000u
  #define  DMA_SECCTL_SXCOND_DEFAULT    0x00000000u
  #define  DMA_SECCTL_SXCOND_OF(x)      _VALUEOF(x)
  #define  DMA_SECCTL_SXCOND_CLEAR      0x00000000u
  #define  DMA_SECCTL_SXCOND_SET        0x00000001u

  #define  DMA_SECCTL_OF(x)             _VALUEOF(x)

#if (_DMA_COND1)
  #define DMA_SECCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,SECCTL,WSPOL)\
    |_PER_FDEFAULT(DMA,SECCTL,RSPOL)\
    |_PER_FDEFAULT(DMA,SECCTL,FSIG)\
    |_PER_FDEFAULT(DMA,SECCTL,DMACEN)\
    |_PER_FDEFAULT(DMA,SECCTL,WSYNCCLR)\
    |_PER_FDEFAULT(DMA,SECCTL,WSYNCSTAT)\
    |_PER_FDEFAULT(DMA,SECCTL,RSYNCCLR)\
    |_PER_FDEFAULT(DMA,SECCTL,RSYNCSTAT)\
    |_PER_FDEFAULT(DMA,SECCTL,WDROPIE)\
    |_PER_FDEFAULT(DMA,SECCTL,WDROPCOND)\
    |_PER_FDEFAULT(DMA,SECCTL,RDROPIE)\
    |_PER_FDEFAULT(DMA,SECCTL,RDROPCOND)\
    |_PER_FDEFAULT(DMA,SECCTL,BLOCKIE)\
    |_PER_FDEFAULT(DMA,SECCTL,BLOCKCOND)\
    |_PER_FDEFAULT(DMA,SECCTL,LASTIE)\
    |_PER_FDEFAULT(DMA,SECCTL,LASTCOND)\
    |_PER_FDEFAULT(DMA,SECCTL,FRAMEIE)\
    |_PER_FDEFAULT(DMA,SECCTL,FRAMECOND)\
    |_PER_FDEFAULT(DMA,SECCTL,SXIE)\
    |_PER_FDEFAULT(DMA,SECCTL,SXCOND)\
  )

  #define DMA_SECCTL_RMK(wspol,rspol,fsig,dmacen,wsyncclr,wsyncstat,rsyncclr,\
    rsyncstat,wdropie,wdropcond,rdropie,rdropcond,blockie,blockcond,\
    lastie,lastcond,frameie,framecond,sxie,sxcond) (Uint32)( \
     _PER_FMK(DMA,SECCTL,WSPOL,wspol)\
    |_PER_FMK(DMA,SECCTL,RSPOL,rspol)\
    |_PER_FMK(DMA,SECCTL,FSIG,fsig)\
    |_PER_FMK(DMA,SECCTL,DMACEN,dmacen)\
    |_PER_FMK(DMA,SECCTL,WSYNCCLR,wsyncclr)\
    |_PER_FMK(DMA,SECCTL,WSYNCSTAT,wsyncstat)\
    |_PER_FMK(DMA,SECCTL,RSYNCCLR,rsyncclr)\
    |_PER_FMK(DMA,SECCTL,RSYNCSTAT,rsyncstat)\
    |_PER_FMK(DMA,SECCTL,WDROPIE,wdropie)\
    |_PER_FMK(DMA,SECCTL,WDROPCOND,wdropcond)\
    |_PER_FMK(DMA,SECCTL,RDROPIE,rdropie)\
    |_PER_FMK(DMA,SECCTL,RDROPCOND,rdropcond)\
    |_PER_FMK(DMA,SECCTL,BLOCKIE,blockie)\
    |_PER_FMK(DMA,SECCTL,BLOCKCOND,blockcond)\
    |_PER_FMK(DMA,SECCTL,LASTIE,lastie)\
    |_PER_FMK(DMA,SECCTL,LASTCOND,lastcond)\
    |_PER_FMK(DMA,SECCTL,FRAMEIE,frameie)\
    |_PER_FMK(DMA,SECCTL,FRAMECOND,framecond)\
    |_PER_FMK(DMA,SECCTL,SXIE,sxie)\
    |_PER_FMK(DMA,SECCTL,SXCOND,sxcond)\
  )
#endif

#if (!_DMA_COND1)
  #define DMA_SECCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,SECCTL,DMACEN)\
    |_PER_FDEFAULT(DMA,SECCTL,WSYNCCLR)\
    |_PER_FDEFAULT(DMA,SECCTL,WSYNCSTAT)\
    |_PER_FDEFAULT(DMA,SECCTL,RSYNCCLR)\
    |_PER_FDEFAULT(DMA,SECCTL,RSYNCSTAT)\
    |_PER_FDEFAULT(DMA,SECCTL,WDROPIE)\
    |_PER_FDEFAULT(DMA,SECCTL,WDROPCOND)\
    |_PER_FDEFAULT(DMA,SECCTL,RDROPIE)\
    |_PER_FDEFAULT(DMA,SECCTL,RDROPCOND)\
    |_PER_FDEFAULT(DMA,SECCTL,BLOCKIE)\
    |_PER_FDEFAULT(DMA,SECCTL,BLOCKCOND)\
    |_PER_FDEFAULT(DMA,SECCTL,LASTIE)\
    |_PER_FDEFAULT(DMA,SECCTL,LASTCOND)\
    |_PER_FDEFAULT(DMA,SECCTL,FRAMEIE)\
    |_PER_FDEFAULT(DMA,SECCTL,FRAMECOND)\
    |_PER_FDEFAULT(DMA,SECCTL,SXIE)\
    |_PER_FDEFAULT(DMA,SECCTL,SXCOND)\
  )

  #define DMA_SECCTL_RMK(dmacen,wsyncclr,wsyncstat,rsyncclr,\
    rsyncstat,wdropie,wdropcond,rdropie,rdropcond,blockie,blockcond,\
    lastie,lastcond,frameie,framecond,sxie,sxcond) (Uint32)( \
     _PER_FMK(DMA,SECCTL,DMACEN,dmacen)\
    |_PER_FMK(DMA,SECCTL,WSYNCCLR,wsyncclr)\
    |_PER_FMK(DMA,SECCTL,WSYNCSTAT,wsyncstat)\
    |_PER_FMK(DMA,SECCTL,RSYNCCLR,rsyncclr)\
    |_PER_FMK(DMA,SECCTL,RSYNCSTAT,rsyncstat)\
    |_PER_FMK(DMA,SECCTL,WDROPIE,wdropie)\
    |_PER_FMK(DMA,SECCTL,WDROPCOND,wdropcond)\
    |_PER_FMK(DMA,SECCTL,RDROPIE,rdropie)\
    |_PER_FMK(DMA,SECCTL,RDROPCOND,rdropcond)\
    |_PER_FMK(DMA,SECCTL,BLOCKIE,blockie)\
    |_PER_FMK(DMA,SECCTL,BLOCKCOND,blockcond)\
    |_PER_FMK(DMA,SECCTL,LASTIE,lastie)\
    |_PER_FMK(DMA,SECCTL,LASTCOND,lastcond)\
    |_PER_FMK(DMA,SECCTL,FRAMEIE,frameie)\
    |_PER_FMK(DMA,SECCTL,FRAMECOND,framecond)\
    |_PER_FMK(DMA,SECCTL,SXIE,sxie)\
    |_PER_FMK(DMA,SECCTL,SXCOND,sxcond)\
  )
#endif

  #define _DMA_SECCTL_COND_MASK (\
     _DMA_SECCTL_WDROPCOND_MASK\
    |_DMA_SECCTL_RDROPCOND_MASK\
    |_DMA_SECCTL_BLOCKCOND_MASK\
    |_DMA_SECCTL_LASTCOND_MASK\
    |_DMA_SECCTL_FRAMECOND_MASK\
    |_DMA_SECCTL_SXCOND_MASK\
  )

  #define _DMA_SECCTL_IE_MASK (\
     _DMA_SECCTL_WDROPIE_MASK\
    |_DMA_SECCTL_RDROPIE_MASK\
    |_DMA_SECCTL_BLOCKIE_MASK\
    |_DMA_SECCTL_LASTIE_MASK\
    |_DMA_SECCTL_FRAMEIE_MASK\
    |_DMA_SECCTL_SXIE_MASK\
  )

  #define _DMA_SECCTL_STAT_MASK (\
     _DMA_SECCTL_WSYNCSTAT_MASK\
    |_DMA_SECCTL_RSYNCSTAT_MASK\
  )

  #define _DMA_SECCTL_CLR_MASK (\
     _DMA_SECCTL_WSYNCCLR_MASK\
    |_DMA_SECCTL_RSYNCCLR_MASK\
  )

  #define _DMA_SECCTL_FGET(N,FIELD)\
    _PER_FGET(_DMA_SECCTL##N##_ADDR,DMA,SECCTL,##FIELD)

  #define _DMA_SECCTL_FSET(N,FIELD,field)\
    _PER_RAOI(_DMA_SECCTL##N##_ADDR,DMA,SECCTL,\
      (0xFFFF0AAA&~_DMA_SECCTL_##FIELD##_MASK),\
      (0x00000555&~_DMA_SECCTL_##FIELD##_MASK)\
      |_PER_FMK(DMA,SECCTL,##FIELD,field),\
      0x00000000\
    )

  #define _DMA_SECCTL_FSETS(N,FIELD,SYM)\
    _PER_RAOI(_DMA_SECCTL##N##_ADDR,DMA,SECCTL,\
      (0xFFFF0AAA&~_DMA_SECCTL_##FIELD##_MASK),\
      (0x00000555&~_DMA_SECCTL_##FIELD##_MASK)\
      |_PER_FMKS(DMA,SECCTL,##FIELD,##SYM),\
      0x00000000\
    )

  #define _DMA_SECCTL0_FGET(FIELD) _DMA_SECCTL_FGET(0,##FIELD)
  #define _DMA_SECCTL1_FGET(FIELD) _DMA_SECCTL_FGET(1,##FIELD)
  #define _DMA_SECCTL2_FGET(FIELD) _DMA_SECCTL_FGET(2,##FIELD)
  #define _DMA_SECCTL3_FGET(FIELD) _DMA_SECCTL_FGET(3,##FIELD)

  #define _DMA_SECCTL0_FSET(FIELD,f) _DMA_SECCTL_FSET(0,##FIELD,f)
  #define _DMA_SECCTL1_FSET(FIELD,f) _DMA_SECCTL_FSET(1,##FIELD,f)
  #define _DMA_SECCTL2_FSET(FIELD,f) _DMA_SECCTL_FSET(2,##FIELD,f)
  #define _DMA_SECCTL3_FSET(FIELD,f) _DMA_SECCTL_FSET(3,##FIELD,f)

  #define _DMA_SECCTL0_FSETS(FIELD,SYM) _DMA_SECCTL_FSETS(0,##FIELD,##SYM)
  #define _DMA_SECCTL1_FSETS(FIELD,SYM) _DMA_SECCTL_FSETS(1,##FIELD,##SYM)
  #define _DMA_SECCTL2_FSETS(FIELD,SYM) _DMA_SECCTL_FSETS(2,##FIELD,##SYM)
  #define _DMA_SECCTL3_FSETS(FIELD,SYM) _DMA_SECCTL_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S R C            |
* |___________________|
*
* SRC0     - channel src address register 0
* SRC1     - channel src address register 1
* SRC2     - channel src address register 2
* SRC3     - channel src address register 3
*
* FIELDS (msb -> lsb)
* (rw) SRC
*
\******************************************************************************/
  #define _DMA_SRC_OFFSET               4

  #define _DMA_SRC0_ADDR                0x01840010u
  #define _DMA_SRC1_ADDR                0x01840050u
  #define _DMA_SRC2_ADDR                0x01840014u
  #define _DMA_SRC3_ADDR                0x01840054u

  #define _DMA_SRC_SRC_MASK             0xFFFFFFFFu
  #define _DMA_SRC_SRC_SHIFT            0x00000000u
  #define  DMA_SRC_SRC_DEFAULT          0x00000000u
  #define  DMA_SRC_SRC_OF(x)            _VALUEOF(x)

  #define  DMA_SRC_OF(x)                _VALUEOF(x)

  #define DMA_SRC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,SRC,SRC) \
  )

  #define DMA_SRC_RMK(src) (Uint32)( \
     _PER_FMK(DMA,SRC,SRC,src) \
  )

  #define _DMA_SRC_FGET(N,FIELD)\
    _PER_FGET(_DMA_SRC##N##_ADDR,DMA,SRC,##FIELD)

  #define _DMA_SRC_FSET(N,FIELD,field)\
    _PER_FSET(_DMA_SRC##N##_ADDR,DMA,SRC,##FIELD,field)

  #define _DMA_SRC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_DMA_SRC##N##_ADDR,DMA,SRC,##FIELD,##SYM)

  #define _DMA_SRC0_FGET(FIELD) _DMA_SRC_FGET(0,##FIELD)
  #define _DMA_SRC1_FGET(FIELD) _DMA_SRC_FGET(1,##FIELD)
  #define _DMA_SRC2_FGET(FIELD) _DMA_SRC_FGET(2,##FIELD)
  #define _DMA_SRC3_FGET(FIELD) _DMA_SRC_FGET(3,##FIELD)

  #define _DMA_SRC0_FSET(FIELD,f) _DMA_SRC_FSET(0,##FIELD,f)
  #define _DMA_SRC1_FSET(FIELD,f) _DMA_SRC_FSET(1,##FIELD,f)
  #define _DMA_SRC2_FSET(FIELD,f) _DMA_SRC_FSET(2,##FIELD,f)
  #define _DMA_SRC3_FSET(FIELD,f) _DMA_SRC_FSET(3,##FIELD,f)

  #define _DMA_SRC0_FSETS(FIELD,SYM) _DMA_SRC_FSETS(0,##FIELD,##SYM)
  #define _DMA_SRC1_FSETS(FIELD,SYM) _DMA_SRC_FSETS(1,##FIELD,##SYM)
  #define _DMA_SRC2_FSETS(FIELD,SYM) _DMA_SRC_FSETS(2,##FIELD,##SYM)
  #define _DMA_SRC3_FSETS(FIELD,SYM) _DMA_SRC_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  D S T            |
* |___________________|
*
* DST0     - channel destination address register 0
* DST1     - channel destination address register 1
* DST2     - channel destination address register 2
* DST3     - channel destination address register 3
*
* * - handle based
*
* FIELDS (msb -> lsb)
* (rw) DST
*
\******************************************************************************/
  #define _DMA_DST_OFFSET               6

  #define _DMA_DST0_ADDR                0x01840018u
  #define _DMA_DST1_ADDR                0x01840058u
  #define _DMA_DST2_ADDR                0x0184001Cu
  #define _DMA_DST3_ADDR                0x0184005Cu

  #define _DMA_DST_DST_MASK             0xFFFFFFFFu
  #define _DMA_DST_DST_SHIFT            0x00000000u
  #define  DMA_DST_DST_DEFAULT          0x00000000u
  #define  DMA_DST_DST_OF(x)            _VALUEOF(x)

  #define  DMA_DST_OF(x)                _VALUEOF(x)

  #define DMA_DST_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,DST,DST) \
  )

  #define DMA_DST_RMK(dst) (Uint32)( \
     _PER_FMK(DMA,DST,DST,dst) \
  )

  #define _DMA_DST_FGET(N,FIELD)\
    _PER_FGET(_DMA_DST##N##_ADDR,DMA,DST,##FIELD)

  #define _DMA_DST_FSET(N,FIELD,field)\
    _PER_FSET(_DMA_DST##N##_ADDR,DMA,DST,##FIELD,field)

  #define _DMA_DST_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_DMA_DST##N##_ADDR,DMA,DST,##FIELD,##SYM)

  #define _DMA_DST0_FGET(FIELD) _DMA_DST_FGET(0,##FIELD)
  #define _DMA_DST1_FGET(FIELD) _DMA_DST_FGET(1,##FIELD)
  #define _DMA_DST2_FGET(FIELD) _DMA_DST_FGET(2,##FIELD)
  #define _DMA_DST3_FGET(FIELD) _DMA_DST_FGET(3,##FIELD)

  #define _DMA_DST0_FSET(FIELD,f) _DMA_DST_FSET(0,##FIELD,f)
  #define _DMA_DST1_FSET(FIELD,f) _DMA_DST_FSET(1,##FIELD,f)
  #define _DMA_DST2_FSET(FIELD,f) _DMA_DST_FSET(2,##FIELD,f)
  #define _DMA_DST3_FSET(FIELD,f) _DMA_DST_FSET(3,##FIELD,f)

  #define _DMA_DST0_FSETS(FIELD,SYM) _DMA_DST_FSETS(0,##FIELD,##SYM)
  #define _DMA_DST1_FSETS(FIELD,SYM) _DMA_DST_FSETS(1,##FIELD,##SYM)
  #define _DMA_DST2_FSETS(FIELD,SYM) _DMA_DST_FSETS(2,##FIELD,##SYM)
  #define _DMA_DST3_FSETS(FIELD,SYM) _DMA_DST_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  X F R C N T      |
* |___________________|
*
* XFRCNT0  - channel transfer count register 0
* XFRCNT1  - channel transfer count register 1
* XFRCNT2  - channel transfer count register 2
* XFRCNT3  - channel transfer count register 3
*
* * - handle based
*
* FIELDS (msb -> lsb)
* (rw) FRMCNT
* (rw) ELECNT
*
\******************************************************************************/
  #define _DMA_XFRCNT_OFFSET            8

  #define _DMA_XFRCNT0_ADDR             0x01840020u
  #define _DMA_XFRCNT1_ADDR             0x01840060u
  #define _DMA_XFRCNT2_ADDR             0x01840024u
  #define _DMA_XFRCNT3_ADDR             0x01840064u

  #define _DMA_XFRCNT_FRMCNT_MASK       0xFFFF0000u
  #define _DMA_XFRCNT_FRMCNT_SHIFT      0x00000010u
  #define  DMA_XFRCNT_FRMCNT_DEFAULT    0x00000000u
  #define  DMA_XFRCNT_FRMCNT_OF(x)      _VALUEOF(x)

  #define _DMA_XFRCNT_ELECNT_MASK       0x0000FFFFu
  #define _DMA_XFRCNT_ELECNT_SHIFT      0x00000000u
  #define  DMA_XFRCNT_ELECNT_DEFAULT    0x00000000u
  #define  DMA_XFRCNT_ELECNT_OF(x)      _VALUEOF(x)

  #define  DMA_XFRCNT_OF(x)             _VALUEOF(x)

  #define DMA_XFRCNT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,XFRCNT,FRMCNT) \
    |_PER_FDEFAULT(DMA,XFRCNT,ELECNT) \
  )

  #define DMA_XFRCNT_RMK(frmcnt,elecnt) (Uint32)( \
     _PER_FMK(DMA,XFRCNT,FRMCNT,frmcnt) \
    |_PER_FMK(DMA,XFRCNT,ELECNT,elecnt) \
  )

  #define _DMA_XFRCNT_FGET(N,FIELD)\
    _PER_FGET(_DMA_XFRCNT##N##_ADDR,DMA,XFRCNT,##FIELD)

  #define _DMA_XFRCNT_FSET(N,FIELD,field)\
    _PER_FSET(_DMA_XFRCNT##N##_ADDR,DMA,XFRCNT,##FIELD,field)

  #define _DMA_XFRCNT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_DMA_XFRCNT##N##_ADDR,DMA,XFRCNT,##FIELD,##SYM)

  #define _DMA_XFRCNT0_FGET(FIELD) _DMA_XFRCNT_FGET(0,##FIELD)
  #define _DMA_XFRCNT1_FGET(FIELD) _DMA_XFRCNT_FGET(1,##FIELD)
  #define _DMA_XFRCNT2_FGET(FIELD) _DMA_XFRCNT_FGET(2,##FIELD)
  #define _DMA_XFRCNT3_FGET(FIELD) _DMA_XFRCNT_FGET(3,##FIELD)

  #define _DMA_XFRCNT0_FSET(FIELD,f) _DMA_XFRCNT_FSET(0,##FIELD,f)
  #define _DMA_XFRCNT1_FSET(FIELD,f) _DMA_XFRCNT_FSET(1,##FIELD,f)
  #define _DMA_XFRCNT2_FSET(FIELD,f) _DMA_XFRCNT_FSET(2,##FIELD,f)
  #define _DMA_XFRCNT3_FSET(FIELD,f) _DMA_XFRCNT_FSET(3,##FIELD,f)

  #define _DMA_XFRCNT0_FSETS(FIELD,SYM) _DMA_XFRCNT_FSETS(0,##FIELD,##SYM)
  #define _DMA_XFRCNT1_FSETS(FIELD,SYM) _DMA_XFRCNT_FSETS(1,##FIELD,##SYM)
  #define _DMA_XFRCNT2_FSETS(FIELD,SYM) _DMA_XFRCNT_FSETS(2,##FIELD,##SYM)
  #define _DMA_XFRCNT3_FSETS(FIELD,SYM) _DMA_XFRCNT_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  G B L C N T      |
* |___________________|
*
* GBLCNTA  - global count reload register A
* GBLCNTB  - global count reload register B
*
* FIELDS (msb -> lsb)
* (rw) FRMCNT
* (rw) ELECNT
*
\******************************************************************************/
  #define _DMA_GBLCNTA_ADDR             0x01840028u
  #define _DMA_GBLCNTB_ADDR             0x0184002Cu

  #define _DMA_GBLCNT_FRMCNT_MASK       0xFFFF0000u
  #define _DMA_GBLCNT_FRMCNT_SHIFT      0x00000010u
  #define  DMA_GBLCNT_FRMCNT_DEFAULT    0x00000000u
  #define  DMA_GBLCNT_FRMCNT_OF(x)      _VALUEOF(x)

  #define _DMA_GBLCNT_ELECNT_MASK       0x0000FFFFu
  #define _DMA_GBLCNT_ELECNT_SHIFT      0x00000000u
  #define  DMA_GBLCNT_ELECNT_DEFAULT    0x00000000u
  #define  DMA_GBLCNT_ELECNT_OF(x)      _VALUEOF(x)

  #define  DMA_GBLCNT_OF(x)             _VALUEOF(x)

  #define DMA_GBLCNT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,GBLCNT,FRMCNT) \
    |_PER_FDEFAULT(DMA,GBLCNT,ELECNT) \
  )

  #define DMA_GBLCNT_RMK(frmcnt,elecnt) (Uint32)( \
     _PER_FMK(DMA,GBLCNT,FRMCNT,frmcnt) \
    |_PER_FMK(DMA,GBLCNT,ELECNT,elecnt) \
  )

  #define _DMA_GBLCNT_FGET(N,FIELD)\
    _PER_FGET(_DMA_GBLCNT##N##_ADDR,DMA,GBLCNT,##FIELD)

  #define _DMA_GBLCNT_FSET(N,FIELD,field)\
    _PER_FSET(_DMA_GBLCNT##N##_ADDR,DMA,GBLCNT,##FIELD,field)

  #define _DMA_GBLCNT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_DMA_GBLCNT##N##_ADDR,DMA,GBLCNT,##FIELD,##SYM)

  #define _DMA_GBLCNTA_FGET(FIELD) _DMA_GBLCNT_FGET(A,FIELD)
  #define _DMA_GBLCNTB_FGET(FIELD) _DMA_GBLCNT_FGET(B,FIELD)

  #define _DMA_GBLCNTA_FSET(FIELD,f) _DMA_GBLCNT_FSET(A,FIELD,f)
  #define _DMA_GBLCNTB_FSET(FIELD,f) _DMA_GBLCNT_FSET(B,FIELD,f)

  #define _DMA_GBLCNTA_FSETS(FIELD,SYM) _DMA_GBLCNT_FSETS(A,FIELD,SYM)
  #define _DMA_GBLCNTB_FSETS(FIELD,SYM) _DMA_GBLCNT_FSETS(B,FIELD,SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  G B L I D X      |
* |___________________|
*
* GBLIDXA  - global index register A
* GBLIDXB  - global index register B
*
* FIELDS (msb -> lsb)
* (rw) FRMIDX
* (rw) ELEIDX
*
\******************************************************************************/
  #define _DMA_GBLIDXA_ADDR             0x01840030u
  #define _DMA_GBLIDXB_ADDR             0x01840034u

  #define _DMA_GBLIDX_FRMIDX_MASK       0xFFFF0000u
  #define _DMA_GBLIDX_FRMIDX_SHIFT      0x00000010u
  #define  DMA_GBLIDX_FRMIDX_DEFAULT    0x00000000u
  #define  DMA_GBLIDX_FRMIDX_OF(x)      _VALUEOF(x)

  #define _DMA_GBLIDX_ELEIDX_MASK       0x0000FFFFu
  #define _DMA_GBLIDX_ELEIDX_SHIFT      0x00000000u
  #define  DMA_GBLIDX_ELEIDX_DEFAULT    0x00000000u
  #define  DMA_GBLIDX_ELEIDX_OF(x)      _VALUEOF(x)

  #define  DMA_GBLIDX_OF(x)             _VALUEOF(x)

  #define DMA_GBLIDX_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,GBLIDX,FRMIDX) \
    |_PER_FDEFAULT(DMA,GBLIDX,ELEIDX) \
  )

  #define DMA_GBLIDX_RMK(frmidx,eleidx) (Uint32)( \
     _PER_FMK(DMA,GBLIDX,FRMIDX,frmidx) \
    |_PER_FMK(DMA,GBLIDX,ELEIDX,eleidx) \
  )

  #define _DMA_GBLIDX_FGET(N,FIELD)\
    _PER_FGET(_DMA_GBLIDX##N##_ADDR,DMA,GBLIDX,##FIELD)

  #define _DMA_GBLIDX_FSET(N,FIELD,field)\
    _PER_FSET(_DMA_GBLIDX##N##_ADDR,DMA,GBLIDX,##FIELD,field)

  #define _DMA_GBLIDX_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_DMA_GBLIDX##N##_ADDR,DMA,GBLIDX,##FIELD,##SYM)

  #define _DMA_GBLIDXA_FGET(FIELD) _DMA_GBLIDX_FGET(A,FIELD)
  #define _DMA_GBLIDXB_FGET(FIELD) _DMA_GBLIDX_FGET(B,FIELD)

  #define _DMA_GBLIDXA_FSET(FIELD,f) _DMA_GBLIDX_FSET(A,FIELD,f)
  #define _DMA_GBLIDXB_FSET(FIELD,f) _DMA_GBLIDX_FSET(B,FIELD,f)

  #define _DMA_GBLIDXA_FSETS(FIELD,SYM) _DMA_GBLIDX_FSETS(A,FIELD,SYM)
  #define _DMA_GBLIDXB_FSETS(FIELD,SYM) _DMA_GBLIDX_FSETS(B,FIELD,SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  G B L A D D R    |
* |___________________|
*
* GBLADDRA - global address reload register A
* GBLADDRB - global address reload register B
* GBLADDRC - global address reload register C
* GBLADDRD - global address reload register D
*
* FIELDS (msb -> lsb)
* (rw) GBLADDR
*
\******************************************************************************/
  #define _DMA_GBLADDRA_ADDR              0x01840038u
  #define _DMA_GBLADDRB_ADDR              0x0184003Cu
  #define _DMA_GBLADDRC_ADDR              0x01840068u
  #define _DMA_GBLADDRD_ADDR              0x0184006Cu

  #define _DMA_GBLADDR_GBLADDR_MASK       0xFFFFFFFFu
  #define _DMA_GBLADDR_GBLADDR_SHIFT      0x00000000u
  #define  DMA_GBLADDR_GBLADDR_DEFAULT    0x00000000u
  #define  DMA_GBLADDR_GBLADDR_OF(x)      _VALUEOF(x)

  #define  DMA_GBLADDR_OF(x)              _VALUEOF(x)

  #define DMA_GBLADDR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(DMA,GBLADDR,GBLADDR) \
  )

  #define DMA_GBLADDR_RMK(gbladdr) (Uint32)( \
     _PER_FMK(DMA,GBLADDR,GBLADDR,gbladdr) \
  )

  #define _DMA_GBLADDR_FGET(N,FIELD)\
    _PER_FGET(_DMA_GBLADDR##N##_ADDR,DMA,GBLADDR,##FIELD)

  #define _DMA_GBLADDR_FSET(N,FIELD,field)\
    _PER_FSET(_DMA_GBLADDR##N##_ADDR,DMA,GBLADDR,##FIELD,field)

  #define _DMA_GBLADDR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_DMA_GBLADDR##N##_ADDR,DMA,GBLADDR,##FIELD,##SYM)

  #define _DMA_GBLADDRA_FGET(FIELD) _DMA_GBLADDR_FGET(A,FIELD)
  #define _DMA_GBLADDRB_FGET(FIELD) _DMA_GBLADDR_FGET(B,FIELD)
  #define _DMA_GBLADDRC_FGET(FIELD) _DMA_GBLADDR_FGET(C,FIELD)
  #define _DMA_GBLADDRD_FGET(FIELD) _DMA_GBLADDR_FGET(D,FIELD)

  #define _DMA_GBLADDRA_FSET(FIELD,f) _DMA_GBLADDR_FSET(A,FIELD,f)
  #define _DMA_GBLADDRB_FSET(FIELD,f) _DMA_GBLADDR_FSET(B,FIELD,f)
  #define _DMA_GBLADDRC_FSET(FIELD,f) _DMA_GBLADDR_FSET(C,FIELD,f)
  #define _DMA_GBLADDRD_FSET(FIELD,f) _DMA_GBLADDR_FSET(D,FIELD,f)

  #define _DMA_GBLADDRA_FSETS(FIELD,SYM) _DMA_GBLADDR_FSETS(A,FIELD,SYM)
  #define _DMA_GBLADDRB_FSETS(FIELD,SYM) _DMA_GBLADDR_FSETS(B,FIELD,SYM)
  #define _DMA_GBLADDRC_FSETS(FIELD,SYM) _DMA_GBLADDR_FSETS(C,FIELD,SYM)
  #define _DMA_GBLADDRD_FSETS(FIELD,SYM) _DMA_GBLADDR_FSETS(D,FIELD,SYM)


/*----------------------------------------------------------------------------*/

#endif /* DMA_SUPPORT */
#endif /* _CSL_DMAHAL_H_ */
/******************************************************************************\
* End of csl_dmahal.h
\******************************************************************************/

csl_edma.h/     1092402796  0     0     0       26465     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_edma.h
* DATE CREATED.. 06/11/1999
* LAST MODIFIED. 08/13/2004 Modified tccAllocTable type from static to global fn.
*                08/02/2004 - Adding support for C6418
*                04/16/2004 Modified tccAllocTable[0] entry to 0.
*                02/09/2004 Removed volatile variable type from EDMA_chain inline fn.
*                06/17/2003 added support for 6712C
*                05/28/2003 added support for 6711C
*                02/15/2002 added EDMA channel events 6713/DM642 - EDMA_map()
*                04/16/2001
\******************************************************************************/
#ifndef _CSL_EDMA_H_
#define _CSL_EDMA_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_edmahal.h>


#if (EDMA_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _EDMA_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/
#define EDMA_CHA_CNT              (_EDMA_CHA_CNT)
#define EDMA_TABLE_CNT            (_EDMA_LINK_CNT)
#define EDMA_ALLOC_ANY            (-1)

#define EDMA_OPEN_RESET           (0x00000001)
#define EDMA_OPEN_ENABLE          (0x00000002)


#if(CHIP_6201|CHIP_6202|CHIP_6203|CHIP_6204|CHIP_6205|CHIP_6701|C11_SUPPORT)
  #define EDMA_CHA_ANY      -1
  #define EDMA_CHA_DSPINT   0
  #define EDMA_CHA_TINT0    1
  #define EDMA_CHA_TINT1    2
  #define EDMA_CHA_SDINT    3
  #define EDMA_CHA_EXTINT4  4
  #define EDMA_CHA_EXTINT5  5
  #define EDMA_CHA_EXTINT6  6
  #define EDMA_CHA_EXTINT7  7
  #define EDMA_CHA_TCC8     8
  #define EDMA_CHA_TCC9     9
  #define EDMA_CHA_TCC10    10
  #define EDMA_CHA_TCC11    11
  #define EDMA_CHA_XEVT0    12
  #define EDMA_CHA_REVT0    13
  #define EDMA_CHA_XEVT1    14
  #define EDMA_CHA_REVT1    15
#endif
#if (CHIP_6711C || CHIP_6712C)
  #define EDMA_CHA_GPINT4    4
  #define EDMA_CHA_GPINT5    5
  #define EDMA_CHA_GPINT6    6
  #define EDMA_CHA_GPINT7    7
  #define EDMA_CHA_GPINT2   10
#endif

#if (CHIP_6713 | CHIP_DA610 | CHIP_6414 | CHIP_6415 | CHIP_6416 | \
     CHIP_6411 | CHIP_6410 | CHIP_6413 | CHIP_6418)
  #define EDMA_CHA_ANY      -1
  #define EDMA_CHA_DSPINT    0
  #define EDMA_CHA_TINT0     1
  #define EDMA_CHA_TINT1     2
  #define EDMA_CHA_SDINT     3
  #define EDMA_CHA_EXTINT4   4
  #define EDMA_CHA_GPINT4    4
  #define EDMA_CHA_EXTINT5   5
  #define EDMA_CHA_GPINT5    5
  #define EDMA_CHA_EXTINT6   6
  #define EDMA_CHA_GPINT6    6
  #define EDMA_CHA_EXTINT7   7
  #define EDMA_CHA_GPINT7    7
  #define EDMA_CHA_TCC8      8
  #define EDMA_CHA_GPINT0    8
  #define EDMA_CHA_TCC9      9
  #define EDMA_CHA_GPINT1    9
  #define EDMA_CHA_TCC10    10
  #define EDMA_CHA_GPINT2   10
  #define EDMA_CHA_TCC11    11
  #define EDMA_CHA_GPINT3   11
  #define EDMA_CHA_XEVT0    12
  #define EDMA_CHA_REVT0    13
  #define EDMA_CHA_XEVT1    14
  #define EDMA_CHA_REVT1    15

/* Individual mappings for next few events are specified under #ifdefs below. */

  #define EDMA_CHA_GPINT8   48
  #define EDMA_CHA_GPINT9   49
  #define EDMA_CHA_GPINT10  50
  #define EDMA_CHA_GPINT11  51
  #define EDMA_CHA_GPINT12  52
  #define EDMA_CHA_GPINT13  53
  #define EDMA_CHA_GPINT14  54
  #define EDMA_CHA_GPINT15  55
#endif


/* 3rd MCBSP/ PCI / UTOPIA / VCP / TCP channel numbers for EDMA_open() */
#if (CHIP_6414 || CHIP_6415 || CHIP_6416 )
  #define EDMA_CHA_XEVT2    17
  #define EDMA_CHA_REVT2    18
  #define EDMA_CHA_TINT2    19
  #define EDMA_CHA_SDINTB   20
  #define EDMA_CHA_PCI      21
  #define EDMA_CHA_VCPREVT  28
  #define EDMA_CHA_VCPXEVT  29
  #define EDMA_CHA_TCPREVT  30
  #define EDMA_CHA_TCPXEVT  31
  #define EDMA_CHA_UREVT    32
  #define EDMA_CHA_UREVT0   32
  #define EDMA_CHA_UREVT1   33
  #define EDMA_CHA_UREVT2   34
  #define EDMA_CHA_UREVT3   35
  #define EDMA_CHA_UREVT4   36
  #define EDMA_CHA_UREVT5   37
  #define EDMA_CHA_UREVT6   38
  #define EDMA_CHA_UREVT7   39
  #define EDMA_CHA_UXEVT    40
  #define EDMA_CHA_UXEVT0   40
  #define EDMA_CHA_UXEVT1   41
  #define EDMA_CHA_UXEVT2   42
  #define EDMA_CHA_UXEVT3   43
  #define EDMA_CHA_UXEVT4   44
  #define EDMA_CHA_UXEVT5   45
  #define EDMA_CHA_UXEVT6   46
  #define EDMA_CHA_UXEVT7   47
#endif

/* 2 MCASPs - 2 I2Cs channels */
#if (CHIP_6713 || CHIP_DA610)
  #define EDMA_CHA_AXEVTE0  32
  #define EDMA_CHA_AXEVTO0  33
  #define EDMA_CHA_AXEVT0   34
  #define EDMA_CHA_AREVTE0  35
  #define EDMA_CHA_AREVTO0  36
  #define EDMA_CHA_AREVT0   37
  #define EDMA_CHA_AXEVTE1  38
  #define EDMA_CHA_AXEVTO1  39
  #define EDMA_CHA_AXEVT1   40
  #define EDMA_CHA_AREVTE1  41
  #define EDMA_CHA_AREVTO1  42
  #define EDMA_CHA_AREVT1   43
  #define EDMA_CHA_ICREVT0  44
  #define EDMA_CHA_ICXEVT0  45
  #define EDMA_CHA_ICREVT1  46
  #define EDMA_CHA_ICXEVT1  47
#endif

#if (CHIP_6410 || CHIP_6413| CHIP_6418)
  #define EDMA_CHA_TINT2    19

 #if (CHIP_6418)
  #define EDMA_CHA_VCPREVT0 28  
  #define EDMA_CHA_VCPXEVT0 29  
 #endif

  #define EDMA_CHA_AXEVTE0  32  
  #define EDMA_CHA_AXEVTO0  33  
  #define EDMA_CHA_AXEVT0   34  
  #define EDMA_CHA_AREVTE0  35  
  #define EDMA_CHA_AREVTO0  36  
  #define EDMA_CHA_AREVT0   37  
  #define EDMA_CHA_AXEVTE1  38  
  #define EDMA_CHA_AXEVTO1  39  
  #define EDMA_CHA_AXEVT1   40  
  #define EDMA_CHA_AREVTE1  41  
  #define EDMA_CHA_AREVTO1  42  
  #define EDMA_CHA_AREVT1   43  
  #define EDMA_CHA_ICREVT0  44  
  #define EDMA_CHA_ICXEVT0  45  
  #define EDMA_CHA_ICREVT1  46  
  #define EDMA_CHA_ICXEVT1  47  
#endif

#if (CHIP_DM642 || CHIP_DM641 || CHIP_DM640 || CHIP_6412)
  #define EDMA_CHA_ANY      -1

 #if !(CHIP_DM640)
  #define EDMA_CHA_DSPINT   0
 #endif

  #define EDMA_CHA_TINT0    1
  #define EDMA_CHA_TINT1    2
  #define EDMA_CHA_SDINT    3
  #define EDMA_CHA_EXTINT4  4
  #define EDMA_CHA_GPINT4   4
  #define EDMA_CHA_EXTINT5  5
  #define EDMA_CHA_GPINT5   5
  #define EDMA_CHA_EXTINT6  6
  #define EDMA_CHA_GPINT6   6
  #define EDMA_CHA_EXTINT7  7
  #define EDMA_CHA_GPINT7   7
  #define EDMA_CHA_GPINT0   8
  #define EDMA_CHA_TCC8     8
  #define EDMA_CHA_GPINT1   9
  #define EDMA_CHA_TCC9     9
  #define EDMA_CHA_GPINT2   10
  #define EDMA_CHA_TCC10    10
  #define EDMA_CHA_GPINT3   11
  #define EDMA_CHA_TCC11    11
  #define EDMA_CHA_XEVT0    12
  #define EDMA_CHA_REVT0    13
  #define EDMA_CHA_XEVT1    14
  #define EDMA_CHA_REVT1    15

/* Note: EDMA_CHA_TCC8, EDMA_CHA_TCC9, EDMA_CHA_TCC10 and EDMA_CHA_TCC11 are 
   NOT defined here, but they are included here for C64x consistency purposes */

 #if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640)
  #define EDMA_CHA_VP0EVTYA 16
  #define EDMA_CHA_VP0EVTUA 17
  #define EDMA_CHA_VP0EVTVA 18
 #endif

  #define EDMA_CHA_TINT2    19

 #if (CHIP_DM642)
  #define EDMA_CHA_VP0EVTYB 24
  #define EDMA_CHA_VP0EVTUB 25
  #define EDMA_CHA_VP0EVTVB 26
 #endif

 #if !(CHIP_6412)
  #define EDMA_CHA_AXEVTE0  32
  #define EDMA_CHA_AXEVTO0  33
  #define EDMA_CHA_AXEVT0   34
  #define EDMA_CHA_AREVTE0  35
  #define EDMA_CHA_AREVTO0  36
  #define EDMA_CHA_AREVT0   37
 #endif

 #if (CHIP_DM642)
  #define EDMA_CHA_VP1EVTYB 38
  #define EDMA_CHA_VP1EVTUB 39
  #define EDMA_CHA_VP1EVTVB 40
  #define EDMA_CHA_VP2EVTYB 41
  #define EDMA_CHA_VP2EVTUB 42
  #define EDMA_CHA_VP2EVTVB 43
 #endif
 
  #define EDMA_CHA_ICREVT0  44
  #define EDMA_CHA_ICXEVT0  45

  #define EDMA_CHA_GPINT8   48
  #define EDMA_CHA_GPINT9   49
  #define EDMA_CHA_GPINT10  50
  #define EDMA_CHA_GPINT11  51
  #define EDMA_CHA_GPINT12  52
  #define EDMA_CHA_GPINT13  53
  #define EDMA_CHA_GPINT14  54
  #define EDMA_CHA_GPINT15  55


 #if (CHIP_DM642 | CHIP_DM641)
  #define EDMA_CHA_VP1EVTYA 56
  #define EDMA_CHA_VP1EVTUA 57
  #define EDMA_CHA_VP1EVTVA 58
 #endif

 #if (CHIP_DM642)
  #define EDMA_CHA_VP2EVTYA 59
  #define EDMA_CHA_VP2EVTUA 60
  #define EDMA_CHA_VP2EVTVA 61
 #endif

#endif

#define _EDMA_TYPE_C   (0x80000000)
#define _EDMA_TYPE_T   (0x40000000)
#define _EDMA_TYPE_Q   (0x20000000)
#define _EDMA_TYPE_S   (0x10000000)


#define _EDMA_MK_HANDLE(base,index,flags) (EDMA_Handle)(\
  ((base)&0x0000FFFF)|(((index)<<16)&0x00FF0000)|((flags)&0xFF000000)\
)

#define EDMA_HQDMA    _EDMA_MK_HANDLE(0x00000000,0,_EDMA_TYPE_Q)
#define EDMA_HQSDMA   _EDMA_MK_HANDLE(0x00000000,0,_EDMA_TYPE_S)
#define EDMA_HINV     _EDMA_MK_HANDLE(0x00000000,0,0)

#define EDMA_HNULL    _EDMA_MK_HANDLE(_EDMA_NULL_PARAM,0,_EDMA_TYPE_T)
#define NULL_FUNC     0

/* Priority Queues */
#define EDMA_Q0       0
#define EDMA_Q1       1
#define EDMA_Q2       2
#define EDMA_Q3       3

/* Event Polarity */
#define EDMA_EVT_LOWHIGH   0
#define EDMA_EVT_HIGHLOW   1

/* Chaining Flag */
#define EDMA_TCC_SET       1
#define EDMA_ATCC_SET      1

/******************************************************************************\
* global typedef declarations
\******************************************************************************/
typedef Uint32 EDMA_Handle;

typedef struct {
  Uint32 opt;
  Uint32 src;
  Uint32 cnt;
  Uint32 dst;
  Uint32 idx;
  Uint32 rld;
} EDMA_Config;

typedef void (*EDMA_IntHandler)(int tccNum);

/******************************************************************************\
* global variable declarations
\******************************************************************************/
#define EDMA_hNull EDMA_HNULL

extern far Uint8 tccAllocTable[64];

/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void EDMA_reset(EDMA_Handle hEdma);
CSLAPI void EDMA_resetAll();

CSLAPI EDMA_Handle EDMA_open(int chaNum, Uint32 flags);
CSLAPI void EDMA_close(EDMA_Handle hEdma);
CSLAPI EDMA_Handle EDMA_allocTable(int tableNum);
CSLAPI void EDMA_freeTable(EDMA_Handle hEdma);

CSLAPI int EDMA_allocTableEx(int cnt, EDMA_Handle *array);
CSLAPI void EDMA_freeTableEx(int cnt, EDMA_Handle *array);

CSLAPI void EDMA_clearPram(Uint32 val);

CSLAPI int EDMA_intAlloc(int tcc);
CSLAPI void EDMA_intFree(int tcc);
/* 6713? */

#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
CSLAPI int EDMA_map(int eventNum,int chaNum);
#endif

CSLAPI EDMA_IntHandler EDMA_intHook(int tccNum, EDMA_IntHandler funcAddr);
CSLAPI void EDMA_intDefaultHandler(int tccNum);
CSLAPI void EDMA_intDispatcher();

/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 EDMA_getScratchAddr();
IDECL Uint32 EDMA_getScratchSize();
IDECL Uint32 EDMA_getPriQStatus();
#if (C64_SUPPORT)
IDECL void   EDMA_setPriQLength(Uint32 priNum, Uint32 length);
IDECL void   EDMA_resetPriQLength(Uint32 priNum);
#endif

IDECL void   EDMA_enableChannel(EDMA_Handle hEdma);
IDECL void   EDMA_disableChannel(EDMA_Handle hEdma);
IDECL void   EDMA_setChannel(EDMA_Handle hEdma);
IDECL Uint32 EDMA_getChannel(EDMA_Handle hEdma);
IDECL void   EDMA_clearChannel(EDMA_Handle hEdma);
#if (C64_SUPPORT)
IDECL void   EDMA_setEvtPolarity(EDMA_Handle hEdma,int polarity);
#endif
IDECL Uint32 EDMA_getTableAddress(EDMA_Handle hEdma);

IDECL void   EDMA_intEnable(Uint32 tccIntNum);
IDECL void   EDMA_intDisable(Uint32 tccIntNum);
IDECL void   EDMA_intClear(Uint32 tccIntNum);
IDECL Uint32 EDMA_intTest(Uint32 tccIntNum);
IDECL void   EDMA_intReset(Uint32 tccIntNum);
IDECL void   EDMA_intResetAll();

IDECL void   EDMA_link(EDMA_Handle parent, EDMA_Handle child);

IDECL void EDMA_config(EDMA_Handle hEdma, EDMA_Config *config);
IDECL void EDMA_configArgs(EDMA_Handle hEdma, Uint32 opt, Uint32 src,
  Uint32 cnt, Uint32 dst, Uint32 idx, Uint32 rld);
IDECL void EDMA_getConfig(EDMA_Handle hEdma, EDMA_Config *config);

IDECL void EDMA_qdmaConfig(EDMA_Config *config);
IDECL void EDMA_qdmaConfigArgs(Uint32 opt, Uint32 src, Uint32 cnt, Uint32 dst,
  Uint32 idx);
IDECL void EDMA_qdmaGetConfig(EDMA_Config *config);

IDECL void EDMA_enableChaining(EDMA_Handle hEdma);
IDECL void EDMA_disableChaining(EDMA_Handle hEdma);
IDECL  void EDMA_chain(EDMA_Handle parent, EDMA_Handle nextChannel,int tccflag, int atccflag);

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 EDMA_getScratchAddr() {
  return (Uint32)_EDMA_SCRATCH_START;
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 EDMA_getScratchSize() {
  return (Uint32)_EDMA_SCRATCH_SIZE;
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 EDMA_getPriQStatus() {
  return (Uint32)EDMA_RGET(PQSR);
}
/*----------------------------------------------------------------------------*/
#if (C64_SUPPORT)
IDEF void EDMA_setPriQLength(Uint32 priNum, Uint32 length) {
  if (priNum == 0x0) {
   EDMA_RSET(PQAR0,(0x00000007 & length));
   } else {
          if (priNum == 0x1) {
           EDMA_RSET(PQAR1,(0x00000007 & length));
          }else {
                if (priNum == 0x2) {
                EDMA_RSET(PQAR2,(0x00000007 & length));
                } else {
                       if (priNum == 0x3) {
                       EDMA_RSET(PQAR3,(0x00000007 & length));
                       }
                  }
           }
    }
}
/*----------------------------------------------------------------------------*/

IDEF void EDMA_resetPriQLength(Uint32 priNum) {
 if (priNum == 0x0) {
   EDMA_FSET(PQAR0,PQA,EDMA_PQAR0_PQA_DEFAULT);
   } else {
          if (priNum == 0x1) {
          EDMA_FSET(PQAR1,PQA,EDMA_PQAR1_PQA_DEFAULT);
          } else {
                 if (priNum == 0x2) {
                 EDMA_FSET(PQAR2,PQA,EDMA_PQAR2_PQA_DEFAULT);
                 }else {
                      if (priNum == 0x3) {
                      EDMA_FSET(PQAR3,PQA,EDMA_PQAR3_PQA_DEFAULT);
                       }
                  }
           }
   }
}
#endif
/*----------------------------------------------------------------------------*/
IDEF void EDMA_enableChannel(EDMA_Handle hEdma) {

  int gie;
  int chaNum = (hEdma & 0x00FF0000)>>16;

  gie = IRQ_globalDisable();
  #if (C64_SUPPORT)
    if (chaNum < 32) EDMA_RSET(EERL,EDMA_RGET(EERL) | (1<<chaNum));
    else EDMA_RSET(EERH,EDMA_RGET(EERH) | (1<<(chaNum-32)));
  #else
    EDMA_RSET(EER,EDMA_RGET(EER) | (1<<chaNum));
  #endif
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_enableChaining(EDMA_Handle hEdma) {

  int gie;
  int chaNum = (hEdma & 0x00FF0000)>>16;

  gie = IRQ_globalDisable();
  #if (C64_SUPPORT)
    if (chaNum < 32) EDMA_RSET(CCERL,EDMA_RGET(CCERL) | (1<<chaNum));
    else EDMA_RSET(CCERH,EDMA_RGET(CCERH) | (1<<(chaNum-32)));
  #else

    EDMA_RSET(CCER,EDMA_RGET(CCER) | (1<<chaNum));
  #endif
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_chain(EDMA_Handle parent, EDMA_Handle nextChannel,int tccflag, int atccflag) {

  Uint32 tccm,tcc;
  int TccNum = (nextChannel & 0x00FF0000)>>16;
  int gie;

  gie = IRQ_globalDisable();

 if (tccflag) {
  #if (C64_SUPPORT) /* SET TCCM and TCC fields */
   if (TccNum < 16) {  tccm = 0 ; tcc = TccNum;}
   else {
        if ( TccNum  > 15 && TccNum < 32 ) { tccm = 1 ; tcc = TccNum-16;}
         else  {
              if ( TccNum  > 31 && TccNum < 48 ) { tccm = 2 ; tcc = TccNum-32;}
              else {   /* channel > 47 */
                     tccm = 3 ; tcc = TccNum-48;
                   }
         }
    }
      EDMA_FSETH(parent,OPT,TCCM,tccm);
      EDMA_FSETH(parent,OPT,TCC,tcc);
      EDMA_FSETH(parent,OPT,TCINT,1);
  #else
    EDMA_FSETH(parent,OPT,TCC,TccNum);
    EDMA_FSETH(parent,OPT,TCINT,1);
  #endif
}
/* ATCC */
if (atccflag) {
    #if C64_SUPPORT
    EDMA_FSETH(parent,OPT,ATCC,TccNum);
    EDMA_FSETH(parent,OPT,ATCINT,1);
    #endif
}
  tccAllocTable[TccNum] = 1;
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_disableChannel(EDMA_Handle hEdma) {

  int chaNum = (hEdma & 0x00FF0000)>>16;
  int gie;

  gie = IRQ_globalDisable();

  #if (C64_SUPPORT)
    if (chaNum < 32) EDMA_RSET(EERL,EDMA_RGET(EERL) & ~(1<<chaNum));
    else EDMA_RSET(EERH,EDMA_RGET(EERH) & ~(1<<(chaNum-32)));
  #else
    EDMA_RSET(EER,EDMA_RGET(EER) & ~(1<<chaNum));
  #endif
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_disableChaining(EDMA_Handle hEdma) {

 int chaNum = (hEdma & 0x00FF0000)>>16;
 int gie;

  gie = IRQ_globalDisable();
  #if (C64_SUPPORT)
    if (chaNum < 32) EDMA_RSET(CCERL,EDMA_RGET(CCERL) & ~(1<<chaNum));
    else EDMA_RSET(CCERH,EDMA_RGET(CCERH) & ~(1<<(chaNum-32)));
  #else
    EDMA_RSET(CCER,EDMA_RGET(CCER) & ~(1<<chaNum));
  #endif
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_setChannel(EDMA_Handle hEdma) {

  int chaNum = (hEdma & 0x00FF0000)>>16;

  #if (C64_SUPPORT)
    if (chaNum < 32) EDMA_RSET(ESRL,1<<chaNum);
    else EDMA_RSET(ESRH,1<<(chaNum-32));
  #else
    EDMA_RSET(ESR,1<<chaNum);
  #endif
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 EDMA_getChannel(EDMA_Handle hEdma) {

  int chaNum = (hEdma & 0x00FF0000)>>16;

  #if (C64_SUPPORT)
    if (chaNum < 32) return (Uint32)((EDMA_RGET(ERL) & (1<<chaNum))==1);
    else return (Uint32)((EDMA_RGET(ERH) & (1<<(chaNum-32)))==1);
  #else
    return (Uint32)((EDMA_RGET(ER) & (1<<chaNum))==1);
  #endif
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_clearChannel(EDMA_Handle hEdma) {

  int chaNum = (hEdma & 0x00FF0000)>>16;

  #if (C64_SUPPORT)
    if (chaNum < 32) EDMA_RSET(ECRL,1<<chaNum);
    else EDMA_RSET(ECRH,1<<(chaNum-32));
  #else
    EDMA_RSET(ECR,1<<chaNum);
  #endif
}
/*----------------------------------------------------------------------------*/
#if (C64_SUPPORT)
IDEF void   EDMA_setEvtPolarity(EDMA_Handle hEdma,int polarity) {

    int chaNum = (hEdma & 0x00FF0000)>>16;

  #if (C64_SUPPORT)
    if (chaNum < 32) EDMA_RSET(EPRL,polarity<<chaNum);
    else EDMA_RSET(EPRH,polarity<<(chaNum-32));
  #endif
}
#endif
/*----------------------------------------------------------------------------*/
IDEF Uint32 EDMA_getTableAddress(EDMA_Handle hEdma) {

  return (hEdma&0x0000FFFF)+_EDMA_PRAM_START;
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_intEnable(Uint32 tccIntNum) {
  int gie;

  gie = IRQ_globalDisable();

  #if (C64_SUPPORT)
    if (tccIntNum < 32) EDMA_RSET(CIERL,EDMA_RGET(CIERL) | (1<<tccIntNum));
    else EDMA_RSET(CIERH,EDMA_RGET(CIERH) | (1<<(tccIntNum-32)));
  #else
    EDMA_RSET(CIER,EDMA_RGET(CIER) | (1<<tccIntNum));
  #endif

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_intDisable(Uint32 tccIntNum) {
  int gie;

  gie = IRQ_globalDisable();

  #if (C64_SUPPORT)
    if (tccIntNum < 32) EDMA_RSET(CIERL,EDMA_RGET(CIERL) & ~(1<<tccIntNum));
    else EDMA_RSET(CIERH,EDMA_RGET(CIERH) & ~(1<<(tccIntNum-32)));
  #else
    EDMA_RSET(CIER,EDMA_RGET(CIER) & ~(1<<tccIntNum));
  #endif

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_intClear(Uint32 tccIntNum) {

  #if (C64_SUPPORT)
    if (tccIntNum < 32) EDMA_RSET(CIPRL,1<<tccIntNum);
    else EDMA_RSET(CIPRH,1<<(tccIntNum-32));
  #else
    EDMA_RSET(CIPR,1<<tccIntNum);
  #endif
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 EDMA_intTest(Uint32 tccIntNum) {

  #if (C64_SUPPORT)
    if (tccIntNum < 32) return ((EDMA_RGET(CIPRL) & (1<<tccIntNum)) ? 1 : 0);
    else return ((EDMA_RGET(CIPRH) & (1<<(tccIntNum-32))) ? 1 : 0);
  #else
    return ((EDMA_RGET(CIPR) & (1<<tccIntNum)) ? 1 : 0);
  #endif
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_intReset(Uint32 tccIntNum) {
  int gie;

  gie = IRQ_globalDisable();

  /* disable then clear interrupt */
  #if (C64_SUPPORT)
    if (tccIntNum < 32) {
      EDMA_RSET(CIERL,EDMA_RGET(CIERL) & ~(1<<tccIntNum));
      EDMA_RSET(CIPRL,1<<tccIntNum);
    } else {
      EDMA_RSET(CIERH,EDMA_RGET(CIERH) & ~(1<<(tccIntNum-32)));
      EDMA_RSET(CIPRH,1<<(tccIntNum-32));
    }
  #else
    EDMA_RSET(CIER,EDMA_RGET(CIER) & ~(1<<tccIntNum));
    EDMA_RSET(CIPR,1<<tccIntNum);
  #endif
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_intResetAll() {

  int gie = IRQ_globalDisable();
  /* disable then clear all interrupts */

  #if (C64_SUPPORT)
    EDMA_RSET(CIERL, 0x00000000);
    EDMA_RSET(CIERH, 0x00000000);
    EDMA_RSET(CIPRL, 0xFFFFFFFF);
    EDMA_RSET(CIPRH, 0xFFFFFFFF);
  #else
    EDMA_RSET(CIER, 0x00000000);
    EDMA_RSET(CIPR, 0xFFFFFFFF);
  #endif

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_link(EDMA_Handle parent, EDMA_Handle child) {
  EDMA_FSETH(parent,RLD,LINK,child);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_config(EDMA_Handle hEdma, EDMA_Config *config) {

  Uint32 gie;
  volatile Uint32 *base;
  register Uint32 x0,x1,x2,x3,x4,x5;

/* Test if QDMA handle was passed with CCS 1.2 */
 if ( hEdma == (0x20000000) || hEdma == (0x10000000)) {
        EDMA_qdmaConfig(config);
 }else{

  gie = IRQ_globalDisable();

  x0 = config->opt;
  x1 = config->src;
  x2 = config->cnt;
  x3 = config->dst;
  x4 = config->idx;
  x5 = config->rld;

  base = (volatile Uint32 *)((hEdma&0x0000FFFF)+_EDMA_PRAM_START);
  base[_EDMA_OPT_OFFSET] = 0x00000000;
  base[_EDMA_SRC_OFFSET] = x1;
  base[_EDMA_CNT_OFFSET] = x2;
  base[_EDMA_DST_OFFSET] = x3;
  base[_EDMA_IDX_OFFSET] = x4;
  base[_EDMA_RLD_OFFSET] = x5;
  base[_EDMA_OPT_OFFSET] = x0;
  IRQ_globalRestore(gie);
  }
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_configArgs(EDMA_Handle hEdma, Uint32 opt, Uint32 src,
  Uint32 cnt, Uint32 dst, Uint32 idx, Uint32 rld) {

  Uint32 gie;
  volatile Uint32 *base;
 /* Test if QDMA handle was passed with CCS 1.2 */
 if ( hEdma == (0x20000000) || hEdma == (0x10000000)) {
        EDMA_qdmaConfigArgs(opt, src, cnt, dst, idx);
 }else{
  gie = IRQ_globalDisable();
  base = (volatile Uint32*)((hEdma&0x0000FFFF)+_EDMA_PRAM_START);
  base[_EDMA_OPT_OFFSET] = 0x00000000;
  base[_EDMA_SRC_OFFSET] = src;
  base[_EDMA_CNT_OFFSET] = cnt;
  base[_EDMA_DST_OFFSET] = dst;
  base[_EDMA_IDX_OFFSET] = idx;
  base[_EDMA_RLD_OFFSET] = rld;
  base[_EDMA_OPT_OFFSET] = opt;
  IRQ_globalRestore(gie);
 }
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_getConfig(EDMA_Handle hEdma, EDMA_Config *config) {

  Uint32 gie;
  volatile Uint32 *base;
  register Uint32 x0,x1,x2,x3,x4,x5;

  gie = IRQ_globalDisable();

  base = (volatile Uint32 *)((hEdma&0x0000FFFF)+_EDMA_PRAM_START);
  x0 = base[_EDMA_OPT_OFFSET];
  x1 = base[_EDMA_SRC_OFFSET];
  x2 = base[_EDMA_CNT_OFFSET];
  x3 = base[_EDMA_DST_OFFSET];
  x4 = base[_EDMA_IDX_OFFSET];
  x5 = base[_EDMA_RLD_OFFSET];

  config->opt = x0;
  config->src = x1;
  config->cnt = x2;
  config->dst = x3;
  config->idx = x4;
  config->rld = x5;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_qdmaConfig(EDMA_Config *config) {

  Uint32 gie;
  volatile Uint32 *base;
  register Uint32 x0,x1,x2,x3,x4;

  gie = IRQ_globalDisable();

  x0 = config->opt;
  x1 = config->src;
  x2 = config->cnt;
  x3 = config->dst;
  x4 = config->idx;

  base = (volatile Uint32 *)(_EDMA_QOPT_ADDR);
  base[_EDMA_QSRC_OFFSET]  = x1;
  base[_EDMA_QCNT_OFFSET]  = x2;
  base[_EDMA_QDST_OFFSET]  = x3;
  base[_EDMA_QIDX_OFFSET]  = x4;
  base[_EDMA_QSOPT_OFFSET] = x0;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_qdmaConfigArgs(Uint32 opt, Uint32 src, Uint32 cnt, Uint32 dst,
  Uint32 idx) {

  Uint32 gie;
  volatile Uint32 *base;

  gie = IRQ_globalDisable();

  base = (volatile Uint32*)(_EDMA_QOPT_ADDR);
  base[_EDMA_QSRC_OFFSET]  = src;
  base[_EDMA_QCNT_OFFSET]  = cnt;
  base[_EDMA_QDST_OFFSET]  = dst;
  base[_EDMA_QIDX_OFFSET]  = idx;
  base[_EDMA_QSOPT_OFFSET] = opt;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void EDMA_qdmaGetConfig(EDMA_Config *config) {

  Uint32 gie;
  volatile Uint32 *base;
  volatile EDMA_Config* cfg = (volatile EDMA_Config*)config;
  register Uint32 x0,x1,x2,x3,x4;

  gie = IRQ_globalDisable();

  base = (volatile Uint32 *)(_EDMA_QOPT_ADDR);
  x0 = base[_EDMA_QOPT_OFFSET];
  x1 = base[_EDMA_QSRC_OFFSET];
  x2 = base[_EDMA_QCNT_OFFSET];
  x3 = base[_EDMA_QDST_OFFSET];
  x4 = base[_EDMA_QIDX_OFFSET];

  cfg->opt = x0;
  cfg->src = x1;
  cfg->cnt = x2;
  cfg->dst = x3;
  cfg->idx = x4;
  cfg->rld = 0x00000000;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* EDMA_SUPPORT */
#endif /* _CSL_EDMA_H_ */
/******************************************************************************\
* End of csl_edma.h
\******************************************************************************/


csl_edmahal.h/  1092218719  0     0     0       66411     `
/*****************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_edmahal.h
* DATE CREATED.. 12 Jun 1999
* LAST MODIFIED. 02 Aug 2004  Adding support for C6418
*                17 Jun 2003  6712C
*                28 May 2003  6711C
*                22 Feb 2002  DM642
*------------------------------------------------------------------------------
* REGISTERS/PARAMETERS
*
* OPT    - options parameter
* SRC    - source address parameter
* CNT    - transfer count parameter
* DST    - destination address parameter
* IDX    - index parameter
* RLD    - count reload + link parameter
* QOPT   - QDMA options register
* QSRC   - QDMA source address register
* QCNT   - QDMA transfer count register
* QDST   - QDMA destination address register
* QIDX   - QDMA index register
* QSOPT  - QDMA options pseudo register
* QSSRC  - QDMA source address pseudo register
* QSCNT  - QDMA transfer count pseudo register
* QSDST  - QDMA destination address pseudo register
* QSIDX  - QDMA index pseudo register
* PQSR   - priority queue status register
* PQAR0  - priority queue allocation register 0
* PQAR1  - priority queue allocation register 1
* PQAR2  - priority queue allocation register 2
* PQAR3  - priority queue allocation register 3
* CIPR   - channel interrupt pending register
* CIPRL  - channel interrupt pending register, low half (1)
* CIPRH  - channel interrupt pending register, high half (1)
* CIER   - channel interrupt enable register
* CIERL  - channel interrupt enable register, low half (1)
* CIERH  - channel interrupt enable register, high half (1)
* CCER   - channel chain enable register
* CCERL  - channel chain enable register, low half (1)
* CCERH  - channel chain enable register, high half (1)
* ER     - event register
* ERL    - event register, low half (1)
* ERH    - event register, high half (1)
* EER    - event enable register
* EERL   - event enable register, low half (1)
* EERH   - event enable register, high half (1)
* EPRL   - event polarity register, low half (1)
* EPRH   - event polarity register, high half (1)
* ECR    - event clear register
* ECRL   - event clear register, low half (1)
* ECRH   - event clear register, high half (1)
* ESR    - event set register
* ESRL   - event set register, low half (1)
* ESRH   - event set register, high half (1)
*
*
* CHIP_6713, CHIP_DA610, CHIP_6711C and CHIP_6712C
* ESEL0  - event selection register 0 (2)
* ESEL1  - event selection register 1 (2)
* ESEL2  - event selection register 2 (2) (3)
* ESEL3  - event selection register 3 (2)
*
* (1) - only supported on C64x devices
* (2) - only supported on C6713, DA610, 6711C and 6712C
* (3) - the whole register is reserved
\******************************************************************************/
#ifndef _CSL_EDMAHAL_H
#define _CSL_EDMAHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (EDMA_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/

#if (CHIP_6414 | CHIP_6415 | CHIP_6416 | CHIP_6411 )
  #define _EDMA_CHA_CNT         64
  #define _EDMA_BASE_PRAM       0x01A00000u
  #define _EDMA_PRAM_START      _EDMA_BASE_PRAM
  #define _EDMA_PRAM_SIZE       0x00000800u
  #define _EDMA_PRAM_ERASE       0x00000600u
#endif

#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412 | CHIP_6410 | CHIP_6413 | CHIP_6418)
  #define _EDMA_CHA_CNT         64
  #define _EDMA_BASE_PRAM       0x01A00000u
  #define _EDMA_PRAM_START      _EDMA_BASE_PRAM
  #define _EDMA_PRAM_SIZE       0x00001400u
  #define _EDMA_PRAM_ERASE      0x00000600u
#endif

#if (CHIP_6211 | CHIP_6711 | CHIP_6712 | CHIP_6713 | CHIP_DA610 | CHIP_6711C | CHIP_6712C)
  #define _EDMA_CHA_CNT         16
  #define _EDMA_BASE_PRAM       0x01A00000u
  #define _EDMA_PRAM_START      _EDMA_BASE_PRAM
  #define _EDMA_PRAM_SIZE       0x00000800u
  #define _EDMA_PRAM_ERASE      0x00000180u
#endif

  #define _EDMA_ENTRY_SIZE      0x00000018u
  #define _EDMA_NULL_PARAM      (_EDMA_PRAM_START+_EDMA_ENTRY_SIZE*_EDMA_CHA_CNT)
  #define _EDMA_RSVD_PARAM      (_EDMA_NULL_PARAM+_EDMA_ENTRY_SIZE)
  #define _EDMA_LINK_START      (_EDMA_RSVD_PARAM+_EDMA_ENTRY_SIZE)
  #define _EDMA_LINK_CNT        ((_EDMA_PRAM_SIZE/_EDMA_ENTRY_SIZE)-(_EDMA_CHA_CNT+2))
  #define _EDMA_SCRATCH_START   (_EDMA_LINK_START+_EDMA_LINK_CNT*_EDMA_ENTRY_SIZE)
  #define _EDMA_SCRATCH_SIZE    (_EDMA_PRAM_START+_EDMA_PRAM_SIZE-_EDMA_SCRATCH_START)

/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define EDMA_FMK(REG,FIELD,x)\
    _PER_FMK(EDMA,##REG,##FIELD,x)

  #define EDMA_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(EDMA,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define EDMA_REG(REG)  (*(volatile Uint32*)(_EDMA_##REG##_ADDR))

  #define EDMA_ADDR(REG)\
    _EDMA_##REG##_ADDR

  #define EDMA_RGET(REG)\
    _PER_RGET(_EDMA_##REG##_ADDR,EDMA,##REG)

  #define EDMA_RSET(REG,x)\
    _PER_RSET(_EDMA_##REG##_ADDR,EDMA,##REG,x)

  #define EDMA_FGET(REG,FIELD)\
    _EDMA_##REG##_FGET(##FIELD)

  #define EDMA_FSET(REG,FIELD,x)\
    _EDMA_##REG##_FSET(##FIELD,##x)

  #define EDMA_FSETS(REG,FIELD,SYM)\
    _EDMA_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define EDMA_RGETA(addr,REG)\
    _PER_RGET(addr,EDMA,##REG)

  #define EDMA_RSETA(addr,REG,x)\
    _PER_RSET(addr,EDMA,##REG,x)

  #define EDMA_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,EDMA,##REG,##FIELD)

  #define EDMA_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,EDMA,##REG,##FIELD,x)

  #define EDMA_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,EDMA,##REG,##FIELD,##SYM)


  /* ----------------------------------------- */
  /* HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define EDMA_ADDRH(h,REG)\
    ((((Uint32)(h))&0x0000FFFF)+_EDMA_PRAM_START+(_EDMA_##REG##_OFFSET<<2))

  #define EDMA_RGETH(h,REG)\
    EDMA_RGETA(EDMA_ADDRH(h,##REG),##REG)


  #define EDMA_RSETH(h,REG,x)\
    EDMA_RSETA(EDMA_ADDRH(h,##REG),##REG,x)


  #define EDMA_FGETH(h,REG,FIELD)\
    EDMA_FGETA(EDMA_ADDRH(h,##REG),##REG,##FIELD)


  #define EDMA_FSETH(h,REG,FIELD,x)\
    EDMA_FSETA(EDMA_ADDRH(h,##REG),##REG,##FIELD,x)


  #define EDMA_FSETSH(h,REG,FIELD,SYM)\
    EDMA_FSETSA(EDMA_ADDRH(h,##REG),##REG,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  O P T            |
* |  Q O P T          |
* |  Q S O P T        |
* |___________________|
*
* OPT    - options parameter
* QOPT   - QDMA options register
* QSOPT  - QDMA options pseudo register
*
* FIELDS (msb -> lsb)
* (rw) PRI
* (rw) ESIZE
* (rw) 2DS
* (rw) SUM
* (rw) 2DD
* (rw) DUM
* (rw) TCINT
* (rw) TCC
* (rw) TCCM (1)
* (rw) ATCINT (1)
* (rw) ATCC (1)
* (rw) PDTS (1)
* (rw) PDTD (1)
* (rw) LINK
* (rw) FS
*
* (1) - only supported on C64x devices
*
\******************************************************************************/
  #define _EDMA_OPT_OFFSET             0
  #define _EDMA_QOPT_OFFSET            0
  #define _EDMA_QSOPT_OFFSET           8

  #define _EDMA_QOPT_ADDR              0x02000000u
  #define _EDMA_QSOPT_ADDR             0x02000020u

  #define  EDMA_QOPT                   EDMA_REG(QOPT)
  #define  EDMA_QSOPT                  EDMA_REG(QSOPT)

  #define _EDMA_OPT_PRI_MASK           0xE0000000u
  #define _EDMA_OPT_PRI_SHIFT          0x0000001Du
  #define  EDMA_OPT_PRI_DEFAULT        0x00000000u
  #define  EDMA_OPT_PRI_OF(x)          _VALUEOF(x)
  #if (C64_SUPPORT)
    #define  EDMA_OPT_PRI_URGENT       0x00000000u
    #define  EDMA_OPT_PRI_HIGH         0x00000001u
    #define  EDMA_OPT_PRI_MEDIUM       0x00000002u
    #define  EDMA_OPT_PRI_LOW          0x00000003u
  #else
    #define  EDMA_OPT_PRI_HIGH         0x00000001u
    #define  EDMA_OPT_PRI_LOW          0x00000002u
  #endif

  #define _EDMA_OPT_ESIZE_MASK         0x18000000u
  #define _EDMA_OPT_ESIZE_SHIFT        0x0000001Bu
  #define  EDMA_OPT_ESIZE_DEFAULT      0x00000000u
  #define  EDMA_OPT_ESIZE_OF(x)        _VALUEOF(x)
  #define  EDMA_OPT_ESIZE_32BIT        0x00000000u
  #define  EDMA_OPT_ESIZE_16BIT        0x00000001u
  #define  EDMA_OPT_ESIZE_8BIT         0x00000002u

  #define _EDMA_OPT_2DS_MASK           0x04000000u
  #define _EDMA_OPT_2DS_SHIFT          0x0000001Au
  #define  EDMA_OPT_2DS_DEFAULT        0x00000000u
  #define  EDMA_OPT_2DS_OF(x)          _VALUEOF(x)
  #define  EDMA_OPT_2DS_NO             0x00000000u
  #define  EDMA_OPT_2DS_YES            0x00000001u

  #define _EDMA_OPT_SUM_MASK           0x03000000u
  #define _EDMA_OPT_SUM_SHIFT          0x00000018u
  #define  EDMA_OPT_SUM_DEFAULT        0x00000000u
  #define  EDMA_OPT_SUM_OF(x)          _VALUEOF(x)
  #define  EDMA_OPT_SUM_NONE           0x00000000u
  #define  EDMA_OPT_SUM_INC            0x00000001u
  #define  EDMA_OPT_SUM_DEC            0x00000002u
  #define  EDMA_OPT_SUM_IDX            0x00000003u

  #define _EDMA_OPT_2DD_MASK           0x00800000u
  #define _EDMA_OPT_2DD_SHIFT          0x00000017u
  #define  EDMA_OPT_2DD_DEFAULT        0x00000000u
  #define  EDMA_OPT_2DD_OF(x)          _VALUEOF(x)
  #define  EDMA_OPT_2DD_NO             0x00000000u
  #define  EDMA_OPT_2DD_YES            0x00000001u

  #define _EDMA_OPT_DUM_MASK           0x00600000u
  #define _EDMA_OPT_DUM_SHIFT          0x00000015u
  #define  EDMA_OPT_DUM_DEFAULT        0x00000000u
  #define  EDMA_OPT_DUM_OF(x)          _VALUEOF(x)
  #define  EDMA_OPT_DUM_NONE           0x00000000u
  #define  EDMA_OPT_DUM_INC            0x00000001u
  #define  EDMA_OPT_DUM_DEC            0x00000002u
  #define  EDMA_OPT_DUM_IDX            0x00000003u

  #define _EDMA_OPT_TCINT_MASK         0x00100000u
  #define _EDMA_OPT_TCINT_SHIFT        0x00000014u
  #define  EDMA_OPT_TCINT_DEFAULT      0x00000000u
  #define  EDMA_OPT_TCINT_OF(x)        _VALUEOF(x)
  #define  EDMA_OPT_TCINT_NO           0x00000000u
  #define  EDMA_OPT_TCINT_YES          0x00000001u

  #define _EDMA_OPT_TCC_MASK           0x000F0000u
  #define _EDMA_OPT_TCC_SHIFT          0x00000010u
  #define  EDMA_OPT_TCC_DEFAULT        0x00000000u
  #define  EDMA_OPT_TCC_OF(x)          _VALUEOF(x)

#if (C64_SUPPORT)
  #define _EDMA_OPT_TCCM_MASK          0x00006000u
  #define _EDMA_OPT_TCCM_SHIFT         0x0000000Du
  #define  EDMA_OPT_TCCM_DEFAULT       0x00000000u
  #define  EDMA_OPT_TCCM_OF(x)         _VALUEOF(x)

  #define _EDMA_OPT_ATCINT_MASK        0x00001000u
  #define _EDMA_OPT_ATCINT_SHIFT       0x0000000Cu
  #define  EDMA_OPT_ATCINT_DEFAULT     0x00000000u
  #define  EDMA_OPT_ATCINT_OF(x)       _VALUEOF(x)
  #define  EDMA_OPT_ATCINT_NO          0x00000000u
  #define  EDMA_OPT_ATCINT_YES         0x00000001u

  #define _EDMA_OPT_ATCC_MASK          0x000007E0u
  #define _EDMA_OPT_ATCC_SHIFT         0x00000005u
  #define  EDMA_OPT_ATCC_DEFAULT       0x00000000u
  #define  EDMA_OPT_ATCC_OF(x)         _VALUEOF(x)

  #define _EDMA_OPT_PDTS_MASK          0x00000008u
  #define _EDMA_OPT_PDTS_SHIFT         0x00000003u
  #define  EDMA_OPT_PDTS_DEFAULT       0x00000000u
  #define  EDMA_OPT_PDTS_OF(x)         _VALUEOF(x)
  #define  EDMA_OPT_PDTS_DISABLE       0x00000000u
  #define  EDMA_OPT_PDTS_ENABLE        0x00000001u

  #define _EDMA_OPT_PDTD_MASK          0x00000004u
  #define _EDMA_OPT_PDTD_SHIFT         0x00000002u
  #define  EDMA_OPT_PDTD_DEFAULT       0x00000000u
  #define  EDMA_OPT_PDTD_OF(x)         _VALUEOF(x)
  #define  EDMA_OPT_PDTD_DISABLE       0x00000000u
  #define  EDMA_OPT_PDTD_ENABLE        0x00000001u
#endif

  #define _EDMA_OPT_LINK_MASK          0x00000002u
  #define _EDMA_OPT_LINK_SHIFT         0x00000001u
  #define  EDMA_OPT_LINK_DEFAULT       0x00000000u
  #define  EDMA_OPT_LINK_OF(x)         _VALUEOF(x)
  #define  EDMA_OPT_LINK_NA            0x00000000u
  #define  EDMA_OPT_LINK_NO            0x00000000u
  #define  EDMA_OPT_LINK_YES           0x00000001u

  #define _EDMA_OPT_FS_MASK            0x00000001u
  #define _EDMA_OPT_FS_SHIFT           0x00000000u
  #define  EDMA_OPT_FS_DEFAULT         0x00000000u
  #define  EDMA_OPT_FS_OF(x)           _VALUEOF(x)
  #define  EDMA_OPT_FS_NO              0x00000000u
  #define  EDMA_OPT_FS_YES             0x00000001u

  #define  EDMA_OPT_OF(x)              _VALUEOF(x)

#if (C64_SUPPORT)
  #define EDMA_OPT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,OPT,PRI)\
    |_PER_FDEFAULT(EDMA,OPT,ESIZE)\
    |_PER_FDEFAULT(EDMA,OPT,2DS)\
    |_PER_FDEFAULT(EDMA,OPT,SUM)\
    |_PER_FDEFAULT(EDMA,OPT,2DD)\
    |_PER_FDEFAULT(EDMA,OPT,DUM)\
    |_PER_FDEFAULT(EDMA,OPT,TCINT)\
    |_PER_FDEFAULT(EDMA,OPT,TCC)\
    |_PER_FDEFAULT(EDMA,OPT,TCCM)\
    |_PER_FDEFAULT(EDMA,OPT,ATCINT) \
    |_PER_FDEFAULT(EDMA,OPT,ATCC) \
    |_PER_FDEFAULT(EDMA,OPT,PDTS) \
    |_PER_FDEFAULT(EDMA,OPT,PDTD) \
    |_PER_FDEFAULT(EDMA,OPT,LINK)\
    |_PER_FDEFAULT(EDMA,OPT,FS)\
  )

  #define EDMA_OPT_RMK(pri,esize,ds2,sum,dd2,dum,tcint,tcc,tccm,atcint,atcc,\
    pdts,pdtd,link,fs) (Uint32)(\
     _PER_FMK(EDMA,OPT,PRI,pri) \
    |_PER_FMK(EDMA,OPT,ESIZE,esize) \
    |_PER_FMK(EDMA,OPT,2DS,ds2) \
    |_PER_FMK(EDMA,OPT,SUM,sum) \
    |_PER_FMK(EDMA,OPT,2DD,dd2) \
    |_PER_FMK(EDMA,OPT,DUM,dum) \
    |_PER_FMK(EDMA,OPT,TCINT,tcint) \
    |_PER_FMK(EDMA,OPT,TCC,tcc) \
    |_PER_FMK(EDMA,OPT,TCCM,tccm) \
    |_PER_FMK(EDMA,OPT,ATCINT,atcint) \
    |_PER_FMK(EDMA,OPT,ATCC,atcc) \
    |_PER_FMK(EDMA,OPT,PDTS,pdts) \
    |_PER_FMK(EDMA,OPT,PDTD,pdtd) \
    |_PER_FMK(EDMA,OPT,LINK,link) \
    |_PER_FMK(EDMA,OPT,FS,fs) \
  )
#endif

#if (!C64_SUPPORT)
  #define EDMA_OPT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,OPT,PRI)\
    |_PER_FDEFAULT(EDMA,OPT,ESIZE)\
    |_PER_FDEFAULT(EDMA,OPT,2DS)\
    |_PER_FDEFAULT(EDMA,OPT,SUM)\
    |_PER_FDEFAULT(EDMA,OPT,2DD)\
    |_PER_FDEFAULT(EDMA,OPT,DUM)\
    |_PER_FDEFAULT(EDMA,OPT,TCINT)\
    |_PER_FDEFAULT(EDMA,OPT,TCC)\
    |_PER_FDEFAULT(EDMA,OPT,LINK)\
    |_PER_FDEFAULT(EDMA,OPT,FS)\
  )

  #define EDMA_OPT_RMK(pri,esize,ds2,sum,dd2,dum,tcint,tcc,link,fs) (Uint32)(\
     _PER_FMK(EDMA,OPT,PRI,pri) \
    |_PER_FMK(EDMA,OPT,ESIZE,esize) \
    |_PER_FMK(EDMA,OPT,2DS,ds2) \
    |_PER_FMK(EDMA,OPT,SUM,sum) \
    |_PER_FMK(EDMA,OPT,2DD,dd2) \
    |_PER_FMK(EDMA,OPT,DUM,dum) \
    |_PER_FMK(EDMA,OPT,TCINT,tcint) \
    |_PER_FMK(EDMA,OPT,TCC,tcc) \
    |_PER_FMK(EDMA,OPT,LINK,link) \
    |_PER_FMK(EDMA,OPT,FS,fs) \
  )
#endif

  #define _EDMA_QOPT_FGET(FIELD)\
    _PER_FGET(_EDMA_QOPT_ADDR,EDMA,OPT,##FIELD)

  #define _EDMA_QOPT_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QOPT_ADDR,EDMA,OPT,##FIELD,field)

  #define _EDMA_QOPT_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QOPT_ADDR,EDMA,OPT,##FIELD,##SYM)

  #define _EDMA_QSOPT_FGET(FIELD)\
    _PER_FGET(_EDMA_QSOPT_ADDR,EDMA,OPT,##FIELD)

  #define _EDMA_QSOPT_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QSOPT_ADDR,EDMA,OPT,##FIELD,field)

  #define _EDMA_QSOPT_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QSOPT_ADDR,EDMA,OPT,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S R C            |
* |  Q S R C          |
* |  Q S S R C        |
* |___________________|
*
* SRC    - source address parameter
* QSRC   - QDMA source address register
* QSSRC  - QDMA source address pseudo register
*
* FIELDS (msb -> lsb)
* (rw) SRC
*
\******************************************************************************/
  #define _EDMA_SRC_OFFSET             1
  #define _EDMA_QSRC_OFFSET            1
  #define _EDMA_QSSRC_OFFSET           9

  #define _EDMA_QSRC_ADDR              0x02000004u
  #define _EDMA_QSSRC_ADDR             0x02000024u

  #define  EDMA_QSRC                   EDMA_REG(QSRC)
  #define  EDMA_QSSRC                  EDMA_REG(QSSRC)

  #define _EDMA_SRC_SRC_MASK           0xFFFFFFFFu
  #define _EDMA_SRC_SRC_SHIFT          0x00000000u
  #define  EDMA_SRC_SRC_DEFAULT        0x00000000u
  #define  EDMA_SRC_SRC_OF(x)          _VALUEOF(x)

  #define  EDMA_SRC_OF(x)              _VALUEOF(x)

  #define EDMA_SRC_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,SRC,SRC)\
  )

  #define EDMA_SRC_RMK(src) (Uint32)(\
     _PER_FMK(EDMA,SRC,SRC,src) \
  )

  #define _EDMA_QSRC_FGET(FIELD)\
    _PER_FGET(_EDMA_QSRC_ADDR,EDMA,SRC,##FIELD)

  #define _EDMA_QSRC_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QSRC_ADDR,EDMA,SRC,##FIELD,field)

  #define _EDMA_QSRC_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QSRC_ADDR,EDMA,SRC,##FIELD,##SYM)

  #define _EDMA_QSSRC_FGET(FIELD)\
    _PER_FGET(_EDMA_QSSRC_ADDR,EDMA,SRC,##FIELD)

  #define _EDMA_QSSRC_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QSSRC_ADDR,EDMA,SRC,##FIELD,field)

  #define _EDMA_QSSRC_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QSSRC_ADDR,EDMA,SRC,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C N T            |
* |  Q C N T          |
* |  Q S C N T        |
* |___________________|
*
* CNT    - transfer count parameter
* QCNT   - QDMA transfer count register
* QSCNT  - QDMA transfer count pseudo register
*
* FIELDS (msb -> lsb)
* (rw) FRMCNT
* (rw) ELECNT
*
\******************************************************************************/
  #define _EDMA_CNT_OFFSET             2
  #define _EDMA_QCNT_OFFSET            2
  #define _EDMA_QSCNT_OFFSET           10

  #define _EDMA_QCNT_ADDR              0x02000008u
  #define _EDMA_QSCNT_ADDR             0x02000028u

  #define  EDMA_QCNT                   EDMA_REG(QCNT)
  #define  EDMA_QSCNT                  EDMA_REG(QSCNT)

  #define _EDMA_CNT_FRMCNT_MASK        0xFFFF0000u
  #define _EDMA_CNT_FRMCNT_SHIFT       0x00000010u
  #define  EDMA_CNT_FRMCNT_DEFAULT     0x00000000u
  #define  EDMA_CNT_FRMCNT_OF(x)       _VALUEOF(x)

  #define _EDMA_CNT_ELECNT_MASK        0x0000FFFFu
  #define _EDMA_CNT_ELECNT_SHIFT       0x00000000u
  #define  EDMA_CNT_ELECNT_DEFAULT     0x00000000u
  #define  EDMA_CNT_ELECNT_OF(x)       _VALUEOF(x)

  #define  EDMA_CNT_OF(x)              _VALUEOF(x)

  #define EDMA_CNT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CNT,FRMCNT)\
    |_PER_FDEFAULT(EDMA,CNT,ELECNT)\
  )

  #define EDMA_CNT_RMK(frmcnt,elecnt) (Uint32)(\
     _PER_FMK(EDMA,CNT,FRMCNT,frmcnt) \
    |_PER_FMK(EDMA,CNT,ELECNT,elecnt) \
  )

  #define _EDMA_QCNT_FGET(FIELD)\
    _PER_FGET(_EDMA_QCNT_ADDR,EDMA,CNT,##FIELD)

  #define _EDMA_QCNT_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QCNT_ADDR,EDMA,CNT,##FIELD,field)

  #define _EDMA_QCNT_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QCNT_ADDR,EDMA,CNT,##FIELD,##SYM)

  #define _EDMA_QSCNT_FGET(FIELD)\
    _PER_FGET(_EDMA_QSCNT_ADDR,EDMA,CNT,##FIELD)

  #define _EDMA_QSCNT_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QSCNT_ADDR,EDMA,CNT,##FIELD,field)

  #define _EDMA_QSCNT_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QSCNT_ADDR,EDMA,CNT,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  D S T            |
* |  Q D S T          |
* |  Q S D S T        |
* |___________________|
*
* DST    - destination address parameter
* QDST   - QDMA destination address register
* QSDST  - QDMA destination address pseudo register
*
* FIELDS (msb -> lsb)
* (rw) DST
*
\******************************************************************************/
  #define _EDMA_DST_OFFSET             3
  #define _EDMA_QDST_OFFSET            3
  #define _EDMA_QSDST_OFFSET           11

  #define _EDMA_QDST_ADDR              0x0200000Cu
  #define _EDMA_QSDST_ADDR             0x0200002Cu

  #define  EDMA_QDST                   EDMA_REG(QDST)
  #define  EDMA_QSDST                  EDMA_REG(QSDST)

  #define _EDMA_DST_DST_MASK           0xFFFFFFFFu
  #define _EDMA_DST_DST_SHIFT          0x00000000u
  #define  EDMA_DST_DST_DEFAULT        0x00000000u
  #define  EDMA_DST_DST_OF(x)          _VALUEOF(x)

  #define  EDMA_DST_OF(x)              _VALUEOF(x)

  #define EDMA_DST_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,DST,DST)\
  )

  #define EDMA_DST_RMK(dst) (Uint32)(\
     _PER_FMK(EDMA,DST,DST,dst) \
  )

  #define _EDMA_QDST_FGET(FIELD)\
    _PER_FGET(_EDMA_QDST_ADDR,EDMA,DST,##FIELD)

  #define _EDMA_QDST_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QDST_ADDR,EDMA,DST,##FIELD,field)

  #define _EDMA_QDST_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QDST_ADDR,EDMA,DST,##FIELD,##SYM)

  #define _EDMA_QSDST_FGET(FIELD)\
    _PER_FGET(_EDMA_QSDST_ADDR,EDMA,DST,##FIELD)

  #define _EDMA_QSDST_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QSDST_ADDR,EDMA,DST,##FIELD,field)

  #define _EDMA_QSDST_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QSDST_ADDR,EDMA,DST,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  I D X            |
* |  Q I D X          |
* |  Q S I D X        |
* |___________________|
*
* IDX    - index parameter
* QIDX   - QDMA index register
* QSIDX  - QDMA index pseudo register
*
* FIELDS (msb -> lsb)
* (rw) FRMIDX
* (rw) ELEIDX
*
\******************************************************************************/
  #define _EDMA_IDX_OFFSET             4
  #define _EDMA_QIDX_OFFSET            4
  #define _EDMA_QSIDX_OFFSET           12

  #define _EDMA_QIDX_ADDR              0x02000010u
  #define _EDMA_QSIDX_ADDR             0x02000030u

  #define  EDMA_QIDX                   EDMA_REG(QIDX)
  #define  EDMA_QSIDX                  EDMA_REG(QSIDX)

  #define _EDMA_IDX_FRMIDX_MASK        0xFFFF0000u
  #define _EDMA_IDX_FRMIDX_SHIFT       0x00000010u
  #define  EDMA_IDX_FRMIDX_DEFAULT     0x00000000u
  #define  EDMA_IDX_FRMIDX_OF(x)       _VALUEOF(x)

  #define _EDMA_IDX_ELEIDX_MASK        0x0000FFFFu
  #define _EDMA_IDX_ELEIDX_SHIFT       0x00000000u
  #define  EDMA_IDX_ELEIDX_DEFAULT     0x00000000u
  #define  EDMA_IDX_ELEIDX_OF(x)       _VALUEOF(x)

  #define  EDMA_IDX_OF(x)              _VALUEOF(x)

  #define EDMA_IDX_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,IDX,FRMIDX)\
    |_PER_FDEFAULT(EDMA,IDX,ELEIDX)\
  )

  #define EDMA_IDX_RMK(frmidx,eleidx) (Uint32)(\
     _PER_FMK(EDMA,IDX,FRMIDX,frmidx) \
    |_PER_FMK(EDMA,IDX,ELEIDX,eleidx) \
  )

  #define _EDMA_QIDX_FGET(FIELD)\
    _PER_FGET(_EDMA_QIDX_ADDR,EDMA,IDX,##FIELD)

  #define _EDMA_QIDX_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QIDX_ADDR,EDMA,IDX,##FIELD,field)

  #define _EDMA_QIDX_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QIDX_ADDR,EDMA,IDX,##FIELD,##SYM)

  #define _EDMA_QSIDX_FGET(FIELD)\
    _PER_FGET(_EDMA_QSIDX_ADDR,EDMA,IDX,##FIELD)

  #define _EDMA_QSIDX_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QSIDX_ADDR,EDMA,IDX,##FIELD,field)

  #define _EDMA_QSIDX_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QSIDX_ADDR,EDMA,IDX,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  R L D            |
* |  Q R L D          |
* |  Q S R L D        |
* |___________________|
*
* RLD - count reload/link parameter
*
* FIELDS (msb -> lsb)
* (rw) ELECNT
* (rw) LINK
*
\******************************************************************************/
  #define _EDMA_RLD_OFFSET             5
  #define _EDMA_QRLD_OFFSET            5
  #define _EDMA_QSRLD_OFFSET           13

  #define _EDMA_QRLD_ADDR              0x02000014u
  #define _EDMA_QSRLD_ADDR             0x02000034u

  #define  EDMA_QRLD                   EDMA_REG(QRLD)
  #define  EDMA_QSRLD                  EDMA_REG(QSRLD)

  #define _EDMA_RLD_ELERLD_MASK        0xFFFF0000u
  #define _EDMA_RLD_ELERLD_SHIFT       0x00000010u
  #define  EDMA_RLD_ELERLD_DEFAULT     0x00000000u
  #define  EDMA_RLD_ELERLD_OF(x)       _VALUEOF(x)

  #define _EDMA_RLD_LINK_MASK          0x0000FFFFu
  #define _EDMA_RLD_LINK_SHIFT         0x00000000u
  #define  EDMA_RLD_LINK_DEFAULT       0x00000000u
  #define  EDMA_RLD_LINK_OF(x)         _VALUEOF(x)

  #define  EDMA_RLD_OF(x)              _VALUEOF(x)

  #define EDMA_RLD_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,RLD,ELERLD)\
    |_PER_FDEFAULT(EDMA,RLD,LINK)\
  )

  #define EDMA_RLD_RMK(elerld,link) (Uint32)(\
     _PER_FMK(EDMA,RLD,ELERLD,elerld) \
    |_PER_FMK(EDMA,RLD,LINK,link) \
  )

  #define _EDMA_QRLD_FGET(FIELD)\
    _PER_FGET(_EDMA_QRLD_ADDR,EDMA,RLD,##FIELD)

  #define _EDMA_QRLD_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QRLD_ADDR,EDMA,RLD,##FIELD,field)

  #define _EDMA_QRLD_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QRLD_ADDR,EDMA,RLD,##FIELD,##SYM)

  #define _EDMA_QSRLD_FGET(FIELD)\
    _PER_FGET(_EDMA_QSRLD_ADDR,EDMA,RLD,##FIELD)

  #define _EDMA_QSRLD_FSET(FIELD,field)\
    _PER_FSET(_EDMA_QSRLD_ADDR,EDMA,RLD,##FIELD,field)

  #define _EDMA_QSRLD_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_QSRLD_ADDR,EDMA,RLD,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  P Q S R          |
* |___________________|
*
* PQSR - priority queue status register
*
* FIELDS (msb -> lsb)
* (r) PQ
*
\******************************************************************************/
  #define _EDMA_PQSR_ADDR              0x01A0FFE0u

  #define  EDMA_PQSR                   EDMA_REG(PQSR)

#if (C64_SUPPORT)
  #define _EDMA_PQSR_PQ_MASK           0x0000000Fu
  #define _EDMA_PQSR_PQ_SHIFT          0x00000000u
  #define  EDMA_PQSR_PQ_DEFAULT        0x0000000Fu
  #define  EDMA_PQSR_PQ_OF(x)          _VALUEOF(x)
#else
  #define _EDMA_PQSR_PQ_MASK           0x00000007u
  #define _EDMA_PQSR_PQ_SHIFT          0x00000000u
  #define  EDMA_PQSR_PQ_DEFAULT        0x00000007u
  #define  EDMA_PQSR_PQ_OF(x)          _VALUEOF(x)
#endif

  #define  EDMA_PQSR_OF(x)             _VALUEOF(x)

  #define EDMA_PQSR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,PQSR,PQ)\
  )
 #if (!(CHIP_6410 | CHIP_6413 | CHIP_6418))
  #define EDMA_PQSR_RMK(pq) (Uint32)(\
     _PER_FMK(EDMA,PQSR,PQ,pq)\
  )
 #endif
  
  #define _EDMA_PQSR_FGET(FIELD)\
    _PER_FGET(_EDMA_PQSR_ADDR,EDMA,PQSR,##FIELD)

  #define _EDMA_PQSR_FSET(FIELD,field)\
    _PER_FSET(_EDMA_PQSR_ADDR,EDMA,PQSR,##FIELD,field)

  #define _EDMA_PQSR_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_PQSR_ADDR,EDMA,PQSR,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  P Q A R 0        |
* |___________________|
*
* PQAR0 - priority queue allocation register 0
*
* FIELDS (msb -> lsb)
* (r) PQA
*
\******************************************************************************/
  #if (C64_SUPPORT)
  #define _EDMA_PQAR0_ADDR              0x01A0FFC0u

  #define  EDMA_PQAR0                   EDMA_REG(PQAR0)

  #define _EDMA_PQAR0_PQA_MASK           0x00000007u
  #define _EDMA_PQAR0_PQA_SHIFT          0x00000000u
  #define  EDMA_PQAR0_PQA_DEFAULT        0x00000002u
  #define  EDMA_PQAR0_PQA_OF(x)          _VALUEOF(x)

  #define  EDMA_PQAR0_OF(x)             _VALUEOF(x)

  #define EDMA_PQAR0_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,PQAR0,PQA)\
  )

  #if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
    #define EDMA_PQAR0_RMK(pqa) (Uint32)(\
       _PER_FMK(EDMA,PQAR0,PQA,pqa)\
    )  
  #endif

  #define _EDMA_PQAR0_FSET(FIELD,field)\
    _PER_FSET(_EDMA_PQAR0_ADDR,EDMA,PQAR0,FIELD,field)

  #define _EDMA_PQAR0_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_PQAR0_ADDR,EDMA,PQAR0,FIELD,##SYM)

  #define _EDMA_PQAR0_FGET(FIELD)\
    _PER_FGET(_EDMA_PQAR0_ADDR,EDMA,PQAR0,FIELD)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  P Q A R 1        |
* |___________________|
*
* PQAR1 - priority queue allocation register 1
*
* FIELDS (msb -> lsb)
* (r) PQA
*
\******************************************************************************/
  #if (C64_SUPPORT)
  #define _EDMA_PQAR1_ADDR              0x01A0FFC4u

  #define  EDMA_PQAR1                   EDMA_REG(PQAR1)

  #define _EDMA_PQAR1_PQA_MASK           0x00000007u
  #define _EDMA_PQAR1_PQA_SHIFT          0x00000000u
  #define  EDMA_PQAR1_PQA_DEFAULT        0x00000006u
  #define  EDMA_PQAR1_PQA_OF(x)          _VALUEOF(x)

  #define  EDMA_PQAR1_OF(x)             _VALUEOF(x)

  #if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
     #define EDMA_PQAR1_RMK(pqa) (Uint32)(\
        _PER_FMK(EDMA,PQAR1,PQA,pqa)\
     )
  #endif
   
  #define EDMA_PQAR1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,PQAR1,PQA)\
  )

  #define _EDMA_PQAR1_FGET(FIELD)\
    _PER_FGET(_EDMA_PQAR1_ADDR,EDMA,PQAR1,FIELD)

  #define _EDMA_PQAR1_FSET(FIELD,field)\
    _PER_FSET(_EDMA_PQAR1_ADDR,EDMA,PQAR1,FIELD,field)
                                                    
  #define _EDMA_PQAR1_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_PQAR1_ADDR,EDMA,PQAR1,FIELD,##SYM)
   
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  P Q A R 2        |
* |___________________|
*
* PQAR2 - priority queue allocation register 2
*
* FIELDS (msb -> lsb)
* (r) PQA
*
\******************************************************************************/
  #if (C64_SUPPORT)
  #define _EDMA_PQAR2_ADDR              0x01A0FFC8u

  #define  EDMA_PQAR2                   EDMA_REG(PQAR2)

  #define _EDMA_PQAR2_PQA_MASK           0x00000007u
  #define _EDMA_PQAR2_PQA_SHIFT          0x00000000u
  #define  EDMA_PQAR2_PQA_DEFAULT        0x00000002u
  #define  EDMA_PQAR2_PQA_OF(x)          _VALUEOF(x)

  #define  EDMA_PQAR2_OF(x)             _VALUEOF(x)

  #define EDMA_PQAR2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,PQAR2,PQA)\
  )

  #if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
      #define EDMA_PQAR2_RMK(pqa) (Uint32)(\
         _PER_FMK(EDMA,PQAR2,PQA,pqa)\
      )
  #endif

  #define _EDMA_PQAR2_FGET(FIELD)\
    _PER_FGET(_EDMA_PQAR2_ADDR,EDMA,PQAR2,FIELD)

  #define _EDMA_PQAR2_FSET(FIELD,field)\
    _PER_FSET(_EDMA_PQAR2_ADDR,EDMA,PQAR2,FIELD,field)
                                                    
  #define _EDMA_PQAR2_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_PQAR2_ADDR,EDMA,PQAR2,FIELD,##SYM)
    
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  P Q A R 3        |
* |___________________|
*
* PQAR3 - priority queue allocation register 3
*
* FIELDS (msb -> lsb)
* (r) PQA
*
\******************************************************************************/
  #if (C64_SUPPORT)
  #define _EDMA_PQAR3_ADDR              0x01A0FFCCu

  #define  EDMA_PQAR3                   EDMA_REG(PQAR3)

  #define _EDMA_PQAR3_PQA_MASK           0x00000007u
  #define _EDMA_PQAR3_PQA_SHIFT          0x00000000u
  #define  EDMA_PQAR3_PQA_DEFAULT        0x00000006u
  #define  EDMA_PQAR3_PQA_OF(x)          _VALUEOF(x)

  #define  EDMA_PQAR3_OF(x)             _VALUEOF(x)

  #define EDMA_PQAR3_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,PQAR3,PQA)\
  )

  #if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
      #define EDMA_PQAR3_RMK(pqa) (Uint32)(\
         _PER_FMK(EDMA,PQAR3,PQA,pqa)\
      )
  #endif

  #define _EDMA_PQAR3_FGET(FIELD)\
    _PER_FGET(_EDMA_PQAR3_ADDR,EDMA,PQAR3,FIELD)

  #define _EDMA_PQAR3_FSET(FIELD,field)\
    _PER_FSET(_EDMA_PQAR3_ADDR,EDMA,PQAR3,FIELD,field)
                                                     
  #define _EDMA_PQAR3_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_PQAR3_ADDR,EDMA,PQAR3,FIELD,##SYM)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  C I P R          |
* |___________________|
*
* CIPR  - channel interrupt pending register
*
* FIELDS (msb -> lsb)
* (rw) CIP
*
\******************************************************************************/
 #define _EDMA_CIPR_ADDR              0x01A0FFE4u

  #define  EDMA_CIPR                   EDMA_REG(CIPR)

#if (C64_SUPPORT)
  #define _EDMA_CIPR_CIP_MASK          0xFFFFFFFFu
  #define _EDMA_CIPR_CIP_SHIFT         0x00000000u
  #define  EDMA_CIPR_CIP_DEFAULT       0x00000000u
  #define  EDMA_CIPR_CIP_OF(x)         _VALUEOF(x)
#else
  #define _EDMA_CIPR_CIP_MASK          0x0000FFFFu
  #define _EDMA_CIPR_CIP_SHIFT         0x00000000u
  #define  EDMA_CIPR_CIP_DEFAULT       0x00000000u
  #define  EDMA_CIPR_CIP_OF(x)         _VALUEOF(x)
#endif

  #define  EDMA_CIPR_OF(x)             _VALUEOF(x)

  #define EDMA_CIPR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CIPR,CIP)\
  )

  #define EDMA_CIPR_RMK(cip) (Uint32)(\
     _PER_FMK(EDMA,CIPR,CIP,cip)\
  )

  #define _EDMA_CIPR_FGET(FIELD)\
    _PER_FGET(_EDMA_CIPR_ADDR,EDMA,CIPR,##FIELD)

  #define _EDMA_CIPR_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CIPR_ADDR,EDMA,CIPR,##FIELD,field)

  #define _EDMA_CIPR_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CIPR_ADDR,EDMA,CIPR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C I P R L        |
* |___________________|
*
* CIPRL - channel interrupt pending register, low half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) CIP
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_CIPRL_ADDR              0x01A0FFE4u

  #define  EDMA_CIPRL                   EDMA_REG(CIPRL)

  #define _EDMA_CIPRL_CIP_MASK          0xFFFFFFFFu
  #define _EDMA_CIPRL_CIP_SHIFT         0x00000000u
  #define  EDMA_CIPRL_CIP_DEFAULT       0x00000000u
  #define  EDMA_CIPRL_CIP_OF(x)         _VALUEOF(x)

  #define  EDMA_CIPRL_OF(x)             _VALUEOF(x)

  #define EDMA_CIPRL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CIPRL,CIP)\
  )

  #define EDMA_CIPRL_RMK(cip) (Uint32)(\
     _PER_FMK(EDMA,CIPRL,CIP,cip)\
  )

  #define _EDMA_CIPRL_FGET(FIELD)\
    _PER_FGET(_EDMA_CIPRL_ADDR,EDMA,CIPRL,##FIELD)

  #define _EDMA_CIPRL_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CIPRL_ADDR,EDMA,CIPRL,##FIELD,field)

  #define _EDMA_CIPRL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CIPRL_ADDR,EDMA,CIPRL,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  C I P R H        |
* |___________________|
*
* CIPRH - channel interrupt pending register, high half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) CIP
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_CIPRH_ADDR              0x01A0FFA4u

  #define  EDMA_CIPRH                   EDMA_REG(CIPRH)

  #define _EDMA_CIPRH_CIP_MASK          0xFFFFFFFFu
  #define _EDMA_CIPRH_CIP_SHIFT         0x00000000u
  #define  EDMA_CIPRH_CIP_DEFAULT       0x00000000u
  #define  EDMA_CIPRH_CIP_OF(x)         _VALUEOF(x)

  #define  EDMA_CIPRH_OF(x)             _VALUEOF(x)

  #define EDMA_CIPRH_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CIPRH,CIP)\
  )

  #define EDMA_CIPRH_RMK(cip) (Uint32)(\
     _PER_FMK(EDMA,CIPRH,CIP,cip)\
  )

  #define _EDMA_CIPRH_FGET(FIELD)\
    _PER_FGET(_EDMA_CIPRH_ADDR,EDMA,CIPRH,##FIELD)

  #define _EDMA_CIPRH_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CIPRH_ADDR,EDMA,CIPRH,##FIELD,field)

  #define _EDMA_CIPRH_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CIPRH_ADDR,EDMA,CIPRH,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  C I E R          |
* |___________________|
*
* CIER - channel interrupt enable register
*
* FIELDS (msb -> lsb)
* (rw) CIE
*
\******************************************************************************/
  #define _EDMA_CIER_ADDR              0x01A0FFE8u

  #define  EDMA_CIER                   EDMA_REG(CIER)

#if (C64_SUPPORT)
  #define _EDMA_CIER_CIE_MASK          0xFFFFFFFFu
  #define _EDMA_CIER_CIE_SHIFT         0x00000000u
  #define  EDMA_CIER_CIE_DEFAULT       0x00000000u
  #define  EDMA_CIER_CIE_OF(x)         _VALUEOF(x)
#else
  #define _EDMA_CIER_CIE_MASK          0x0000FFFFu
  #define _EDMA_CIER_CIE_SHIFT         0x00000000u
  #define  EDMA_CIER_CIE_DEFAULT       0x00000000u
  #define  EDMA_CIER_CIE_OF(x)         _VALUEOF(x)
#endif

  #define  EDMA_CIER_OF(x)             _VALUEOF(x)

  #define EDMA_CIER_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CIER,CIE)\
  )

  #define EDMA_CIER_RMK(cie) (Uint32)(\
     _PER_FMK(EDMA,CIER,CIE,cie)\
  )

  #define _EDMA_CIER_FGET(FIELD)\
    _PER_FGET(_EDMA_CIER_ADDR,EDMA,CIER,##FIELD)

  #define _EDMA_CIER_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CIER_ADDR,EDMA,CIER,##FIELD,field)

  #define _EDMA_CIER_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CIER_ADDR,EDMA,CIER,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C I E R L        |
* |___________________|
*
* CIERL - channel interrupt enable register, low half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) CIE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_CIERL_ADDR              0x01A0FFE8u

  #define  EDMA_CIERL                   EDMA_REG(CIERL)

  #define _EDMA_CIERL_CIE_MASK          0xFFFFFFFFu
  #define _EDMA_CIERL_CIE_SHIFT         0x00000000u
  #define  EDMA_CIERL_CIE_DEFAULT       0x00000000u
  #define  EDMA_CIERL_CIE_OF(x)         _VALUEOF(x)

  #define  EDMA_CIERL_OF(x)             _VALUEOF(x)

  #define EDMA_CIERL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CIERL,CIE)\
  )

  #define EDMA_CIERL_RMK(cie) (Uint32)(\
     _PER_FMK(EDMA,CIERL,CIE,cie)\
  )

  #define _EDMA_CIERL_FGET(FIELD)\
    _PER_FGET(_EDMA_CIERL_ADDR,EDMA,CIERL,##FIELD)

  #define _EDMA_CIERL_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CIERL_ADDR,EDMA,CIERL,##FIELD,field)

  #define _EDMA_CIERL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CIERL_ADDR,EDMA,CIERL,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  C I E R H        |
* |___________________|
*
* CIERL - channel interrupt enable register, high half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) CIE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_CIERH_ADDR              0x01A0FFA8u

  #define  EDMA_CIERH                   EDMA_REG(CIERH)

  #define _EDMA_CIERH_CIE_MASK          0xFFFFFFFFu
  #define _EDMA_CIERH_CIE_SHIFT         0x00000000u
  #define  EDMA_CIERH_CIE_DEFAULT       0x00000000u
  #define  EDMA_CIERH_CIE_OF(x)         _VALUEOF(x)

  #define  EDMA_CIERH_OF(x)             _VALUEOF(x)

  #define EDMA_CIERH_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CIERH,CIE)\
  )

  #define EDMA_CIERH_RMK(cie) (Uint32)(\
     _PER_FMK(EDMA,CIERH,CIE,cie)\
  )

  #define _EDMA_CIERH_FGET(FIELD)\
    _PER_FGET(_EDMA_CIERH_ADDR,EDMA,CIERH,##FIELD)

  #define _EDMA_CIERH_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CIERH_ADDR,EDMA,CIERH,##FIELD,field)

  #define _EDMA_CIERH_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CIERH_ADDR,EDMA,CIERH,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  C C E R          |
* |___________________|
*
* CCER - channel chain enable register
*
* FIELDS (msb -> lsb)
* (rw) CCE
*
\******************************************************************************/
  #define _EDMA_CCER_ADDR              0x01A0FFECu

  #define  EDMA_CCER                   EDMA_REG(CCER)

#if (C64_SUPPORT)
  #define _EDMA_CCER_CCE_MASK          0xFFFFFFFFu
  #define _EDMA_CCER_CCE_SHIFT         0x00000000u
  #define  EDMA_CCER_CCE_DEFAULT       0x00000000u
  #define  EDMA_CCER_CCE_OF(x)         _VALUEOF(x)
#else
  #define _EDMA_CCER_CCE_MASK          0x00000F00u
  #define _EDMA_CCER_CCE_SHIFT         0x00000008u
  #define  EDMA_CCER_CCE_DEFAULT       0x00000000u
  #define  EDMA_CCER_CCE_OF(x)         _VALUEOF(x)
#endif

  #define  EDMA_CCER_OF(x)             _VALUEOF(x)

  #define EDMA_CCER_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CCER,CCE)\
  )

  #define EDMA_CCER_RMK(cce) (Uint32)(\
     _PER_FMK(EDMA,CCER,CCE,cce)\
  )

  #define _EDMA_CCER_FGET(FIELD)\
    _PER_FGET(_EDMA_CCER_ADDR,EDMA,CCER,##FIELD)

  #define _EDMA_CCER_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CCER_ADDR,EDMA,CCER,##FIELD,field)

  #define _EDMA_CCER_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CCER_ADDR,EDMA,CCER,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C C E R L        |
* |___________________|
*
* CCERL - channel chain enable register, low half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) CCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_CCERL_ADDR              0x01A0FFECu

  #define  EDMA_CCERL                   EDMA_REG(CCERL)

  #define _EDMA_CCERL_CCE_MASK          0xFFFFFFFFu
  #define _EDMA_CCERL_CCE_SHIFT         0x00000000u
  #define  EDMA_CCERL_CCE_DEFAULT       0x00000000u
  #define  EDMA_CCERL_CCE_OF(x)         _VALUEOF(x)

  #define  EDMA_CCERL_OF(x)             _VALUEOF(x)

  #define EDMA_CCERL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CCERL,CCE)\
  )

  #define EDMA_CCERL_RMK(cce) (Uint32)(\
     _PER_FMK(EDMA,CCERL,CCE,cce)\
  )

  #define _EDMA_CCERL_FGET(FIELD)\
    _PER_FGET(_EDMA_CCERL_ADDR,EDMA,CCERL,##FIELD)

  #define _EDMA_CCERL_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CCERL_ADDR,EDMA,CCERL,##FIELD,field)

  #define _EDMA_CCERL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CCERL_ADDR,EDMA,CCERL,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  C C E R H        |
* |___________________|
*
* CCERH - channel chain enable register, high half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) CCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_CCERH_ADDR              0x01A0FFACu

  #define  EDMA_CCERH                   EDMA_REG(CCERH)

  #define _EDMA_CCERH_CCE_MASK          0xFFFFFFFFu
  #define _EDMA_CCERH_CCE_SHIFT         0x00000000u
  #define  EDMA_CCERH_CCE_DEFAULT       0x00000000u
  #define  EDMA_CCERH_CCE_OF(x)         _VALUEOF(x)

  #define  EDMA_CCERH_OF(x)             _VALUEOF(x)

  #define EDMA_CCERH_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,CCERH,CCE)\
  )

  #define EDMA_CCERH_RMK(cce) (Uint32)(\
     _PER_FMK(EDMA,CCERH,CCE,cce)\
  )

  #define _EDMA_CCERH_FGET(FIELD)\
    _PER_FGET(_EDMA_CCERH_ADDR,EDMA,CCERH,##FIELD)

  #define _EDMA_CCERH_FSET(FIELD,field)\
    _PER_FSET(_EDMA_CCERH_ADDR,EDMA,CCERH,##FIELD,field)

  #define _EDMA_CCERH_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_CCERH_ADDR,EDMA,CCERH,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  E R              |
* |___________________|
*
* ER - event register
*
* FIELDS (msb -> lsb)
* (r) EVT
*
\******************************************************************************/
  #define _EDMA_ER_ADDR              0x01A0FFF0u

  #define  EDMA_ER                   EDMA_REG(ER)

#if (C64_SUPPORT)
  #define _EDMA_ER_EVT_MASK          0xFFFFFFFFu
  #define _EDMA_ER_EVT_SHIFT         0x00000000u
  #define  EDMA_ER_EVT_DEFAULT       0x00000000u
  #define  EDMA_ER_EVT_OF(x)         _VALUEOF(x)
#else
  #define _EDMA_ER_EVT_MASK          0x0000FFFFu
  #define _EDMA_ER_EVT_SHIFT         0x00000000u
  #define  EDMA_ER_EVT_DEFAULT       0x00000000u
  #define  EDMA_ER_EVT_OF(x)         _VALUEOF(x)
#endif

  #define  EDMA_ER_OF(x)             _VALUEOF(x)

  #define EDMA_ER_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ER,EVT)\
  )

  #define _EDMA_ER_FGET(FIELD)\
    _PER_FGET(_EDMA_ER_ADDR,EDMA,ER,##FIELD)

/******************************************************************************\
* _____________________
* |                   |
* |  E R L            |
* |___________________|
*
* ERL - event register, low half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (r) EVT
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_ERL_ADDR              0x01A0FFF0u

  #define  EDMA_ERL                   EDMA_REG(ERL)

  #define _EDMA_ERL_EVT_MASK          0xFFFFFFFFu
  #define _EDMA_ERL_EVT_SHIFT         0x00000000u
  #define  EDMA_ERL_EVT_DEFAULT       0x00000000u
  #define  EDMA_ERL_EVT_OF(x)         _VALUEOF(x)

  #define  EDMA_ERL_OF(x)             _VALUEOF(x)

  #define EDMA_ERL_DEFAULT (Uint32)(\
     _PERL_FDEFAULT(EDMA,ERL,EVT)\
  )

  #define _EDMA_ERL_FGET(FIELD)\
    _PERL_FGET(_EDMA_ERL_ADDR,EDMA,ERL,FIELD)

#endif


/******************************************************************************\
* _____________________
* |                   |
* |  E R H            |
* |___________________|
*
* ERH - event register, high half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (r) EVT
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_ERH_ADDR              0x01A0FFB0u

  #define  EDMA_ERH                   EDMA_REG(ERH)

  #define _EDMA_ERH_EVT_MASK          0xFFFFFFFFu
  #define _EDMA_ERH_EVT_SHIFT         0x00000000u
  #define  EDMA_ERH_EVT_DEFAULT       0x00000000u
  #define  EDMA_ERH_EVT_OF(x)         _VALUEOF(x)

  #define  EDMA_ERH_OF(x)             _VALUEOF(x)

  #define EDMA_ERH_DEFAULT (Uint32)(\
     _PERH_FDEFAULT(EDMA,ERH,EVT)\
  )

  #define _EDMA_ERH_FGET(FIELD)\
    _PERH_FGET(_EDMA_ERH_ADDR,EDMA,ERH,FIELD)

#endif


/******************************************************************************\
* _____________________
* |                   |
* |  E E R            |
* |___________________|
*
* EER - event enable register
*
* FIELDS (msb -> lsb)
* (rw) EE
*
\******************************************************************************/
  #define _EDMA_EER_ADDR             0x01A0FFF4u

  #define  EDMA_EER                  EDMA_REG(EER)

#if (C64_SUPPORT)
  #define _EDMA_EER_EE_MASK          0xFFFFFFFFu
  #define _EDMA_EER_EE_SHIFT         0x00000000u
  #define  EDMA_EER_EE_DEFAULT       0x00000000u
  #define  EDMA_EER_EE_OF(x)         _VALUEOF(x)
#else
  #define _EDMA_EER_EE_MASK          0x0000FFFFu
  #define _EDMA_EER_EE_SHIFT         0x00000000u
  #define  EDMA_EER_EE_DEFAULT       0x00000000u
  #define  EDMA_EER_EE_OF(x)         _VALUEOF(x)
#endif

  #define  EDMA_EER_OF(x)            _VALUEOF(x)

  #define EDMA_EER_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,EER,EE)\
  )

  #define EDMA_EER_RMK(ee) (Uint32)(\
     _PER_FMK(EDMA,EER,EE,ee)\
  )

  #define _EDMA_EER_FGET(FIELD)\
    _PER_FGET(_EDMA_EER_ADDR,EDMA,EER,##FIELD)

  #define _EDMA_EER_FSET(FIELD,field)\
    _PER_FSET(_EDMA_EER_ADDR,EDMA,EER,##FIELD,field)

  #define _EDMA_EER_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_EER_ADDR,EDMA,EER,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  E E R L          |
* |___________________|
*
* EERL - event enable register, low half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) EE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_EERL_ADDR             0x01A0FFF4u

  #define  EDMA_EERL                  EDMA_REG(EERL)

  #define _EDMA_EERL_EE_MASK          0xFFFFFFFFu
  #define _EDMA_EERL_EE_SHIFT         0x00000000u
  #define  EDMA_EERL_EE_DEFAULT       0x00000000u
  #define  EDMA_EERL_EE_OF(x)         _VALUEOF(x)

  #define  EDMA_EERL_OF(x)            _VALUEOF(x)

  #define EDMA_EERL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,EERL,EE)\
  )

  #define EDMA_EERL_RMK(ee) (Uint32)(\
     _PER_FMK(EDMA,EERL,EE,ee)\
  )

  #define _EDMA_EERL_FGET(FIELD)\
    _PER_FGET(_EDMA_EERL_ADDR,EDMA,EERL,##FIELD)

  #define _EDMA_EERL_FSET(FIELD,field)\
    _PER_FSET(_EDMA_EERL_ADDR,EDMA,EERL,##FIELD,field)

  #define _EDMA_EERL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_EERL_ADDR,EDMA,EERL,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  E E R H          |
* |___________________|
*
* EERH - event enable register, high half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) EE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_EERH_ADDR             0x01A0FFB4u

  #define  EDMA_EERH                  EDMA_REG(EERH)

  #define _EDMA_EERH_EE_MASK          0xFFFFFFFFu
  #define _EDMA_EERH_EE_SHIFT         0x00000000u
  #define  EDMA_EERH_EE_DEFAULT       0x00000000u
  #define  EDMA_EERH_EE_OF(x)         _VALUEOF(x)

  #define  EDMA_EERH_OF(x)            _VALUEOF(x)

  #define EDMA_EERH_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,EERH,EE)\
  )

  #define EDMA_EERH_RMK(ee) (Uint32)(\
     _PER_FMK(EDMA,EERH,EE,ee)\
  )

  #define _EDMA_EERH_FGET(FIELD)\
    _PER_FGET(_EDMA_EERH_ADDR,EDMA,EERH,##FIELD)

  #define _EDMA_EERH_FSET(FIELD,field)\
    _PER_FSET(_EDMA_EERH_ADDR,EDMA,EERH,##FIELD,field)

  #define _EDMA_EERH_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_EERH_ADDR,EDMA,EERH,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  E P R L          |
* |___________________|
*
* EPRL - event polarity register, low half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) EP
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_EPRL_ADDR             0x01A0FFDCu

  #define  EDMA_EPRL                  EDMA_REG(EPRL)

  #define _EDMA_EPRL_EP_MASK          0xFFFFFFFFu
  #define _EDMA_EPRL_EP_SHIFT         0x00000000u
  #define  EDMA_EPRL_EP_DEFAULT       0x00000000u
  #define  EDMA_EPRL_EP_OF(x)         _VALUEOF(x)

  #define  EDMA_EPRL_OF(x)            _VALUEOF(x)

  #define EDMA_EPRL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,EPRL,EP)\
  )

  #define EDMA_EPRL_RMK(ep) (Uint32)(\
     _PER_FMK(EDMA,EPRL,EP,ep)\
  )

  #define _EDMA_EPRL_FGET(FIELD)\
    _PER_FGET(_EDMA_EPRL_ADDR,EDMA,EPRL,##FIELD)

  #define _EDMA_EPRL_FSET(FIELD,field)\
    _PER_FSET(_EDMA_EPRL_ADDR,EDMA,EPRL,##FIELD,field)

  #define _EDMA_EPRL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_EPRL_ADDR,EDMA,EPRL,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  E E R H          |
* |___________________|
*
* EPRH - event enable register, high half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) EP
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_EPRH_ADDR             0x01A0FF9Cu

  #define  EDMA_EPRH                  EDMA_REG(EPRH)

  #define _EDMA_EPRH_EP_MASK          0xFFFFFFFFu
  #define _EDMA_EPRH_EP_SHIFT         0x00000000u
  #define  EDMA_EPRH_EP_DEFAULT       0x00000000u
  #define  EDMA_EPRH_EP_OF(x)         _VALUEOF(x)

  #define  EDMA_EPRH_OF(x)            _VALUEOF(x)

  #define EDMA_EPRH_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,EPRH,EP)\
  )

  #define EDMA_EPRH_RMK(ep) (Uint32)(\
     _PER_FMK(EDMA,EPRH,EP,ep)\
  )

  #define _EDMA_EPRH_FGET(FIELD)\
    _PER_FGET(_EDMA_EPRH_ADDR,EDMA,EPRH,##FIELD)

  #define _EDMA_EPRH_FSET(FIELD,field)\
    _PER_FSET(_EDMA_EPRH_ADDR,EDMA,EPRH,##FIELD,field)

  #define _EDMA_EPRH_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_EPRH_ADDR,EDMA,EPRH,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  E C R            |
* |___________________|
*
* ECR - event clear register
*
* FIELDS (msb -> lsb)
* (rw) EC
*
\******************************************************************************/
  #define _EDMA_ECR_ADDR             0x01A0FFF8u

  #define  EDMA_ECR                  EDMA_REG(ECR)

#if (C64_SUPPORT)
  #define _EDMA_ECR_EC_MASK          0xFFFFFFFFu
  #define _EDMA_ECR_EC_SHIFT         0x00000000u
  #define  EDMA_ECR_EC_DEFAULT       0x00000000u
  #define  EDMA_ECR_EC_OF(x)         _VALUEOF(x)
#else
  #define _EDMA_ECR_EC_MASK          0x0000FFFFu
  #define _EDMA_ECR_EC_SHIFT         0x00000000u
  #define  EDMA_ECR_EC_DEFAULT       0x00000000u
  #define  EDMA_ECR_EC_OF(x)         _VALUEOF(x)
#endif

  #define  EDMA_EPR_OF(x)            _VALUEOF(x)

  #define EDMA_ECR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ECR,EC)\
  )

  #define EDMA_ECR_RMK(ec) (Uint32)(\
     _PER_FMK(EDMA,ECR,EC,ec)\
  )

  #define _EDMA_ECR_FGET(FIELD)\
    _PER_FGET(_EDMA_ECR_ADDR,EDMA,ECR,##FIELD)

  #define _EDMA_ECR_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ECR_ADDR,EDMA,ECR,##FIELD,field)

  #define _EDMA_ECR_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ECR_ADDR,EDMA,ECR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  E C R L          |
* |___________________|
*
* ECRL - event clear register, low half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) EC
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_ECRL_ADDR             0x01A0FFF8u

  #define  EDMA_ECRL                  EDMA_REG(ECRL)

  #define _EDMA_ECRL_EC_MASK          0xFFFFFFFFu
  #define _EDMA_ECRL_EC_SHIFT         0x00000000u
  #define  EDMA_ECRL_EC_DEFAULT       0x00000000u
  #define  EDMA_ECRL_EC_OF(x)         _VALUEOF(x)

  #define  EDMA_EER_OF(x)            _VALUEOF(x)

  #define EDMA_ECRL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ECRL,EC)\
  )

  #define EDMA_ECRL_RMK(ec) (Uint32)(\
     _PER_FMK(EDMA,ECRL,EC,ec)\
  )

  #define _EDMA_ECRL_FGET(FIELD)\
    _PER_FGET(_EDMA_ECRL_ADDR,EDMA,ECRL,##FIELD)

  #define _EDMA_ECRL_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ECRL_ADDR,EDMA,ECRL,##FIELD,field)

  #define _EDMA_ECRL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ECRL_ADDR,EDMA,ECRL,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  E C R H          |
* |___________________|
*
* ECRH - event clear register, high half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) EC
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_ECRH_ADDR             0x01A0FFB8u

  #define  EDMA_ECRH                  EDMA_REG(ECRH)

  #define _EDMA_ECRH_EC_MASK          0xFFFFFFFFu
  #define _EDMA_ECRH_EC_SHIFT         0x00000000u
  #define  EDMA_ECRH_EC_DEFAULT       0x00000000u
  #define  EDMA_ECRH_EC_OF(x)         _VALUEOF(x)

  #define  EDMA_EER_OF(x)            _VALUEOF(x)

  #define EDMA_ECRH_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ECRH,EC)\
  )

  #define EDMA_ECRH_RMK(ec) (Uint32)(\
     _PER_FMK(EDMA,ECRH,EC,ec)\
  )

  #define _EDMA_ECRH_FGET(FIELD)\
    _PER_FGET(_EDMA_ECRH_ADDR,EDMA,ECRH,##FIELD)

  #define _EDMA_ECRH_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ECRH_ADDR,EDMA,ECRH,##FIELD,field)

  #define _EDMA_ECRH_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ECRH_ADDR,EDMA,ECRH,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  E S R            |
* |___________________|
*
* ESR - event set register
*
* FIELDS (msb -> lsb)
* (rw) ES
*
\******************************************************************************/
  #define _EDMA_ESR_ADDR             0x01A0FFFCu

  #define  EDMA_ESR                  EDMA_REG(ESR)

#if (C64_SUPPORT)
  #define _EDMA_ESR_ES_MASK          0xFFFFFFFFu
  #define _EDMA_ESR_ES_SHIFT         0x00000000u
  #define  EDMA_ESR_ES_DEFAULT       0x00000000u
  #define  EDMA_ESR_ES_OF(x)         _VALUEOF(x)
#else
  #define _EDMA_ESR_ES_MASK          0x0000FFFFu
  #define _EDMA_ESR_ES_SHIFT         0x00000000u
  #define  EDMA_ESR_ES_DEFAULT       0x00000000u
  #define  EDMA_ESR_ES_OF(x)         _VALUEOF(x)
#endif

  #define  EDMA_ESR_OF(x)            _VALUEOF(x)

  #define EDMA_ESR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ESR,ES)\
  )

  #define EDMA_ESR_RMK(es) (Uint32)(\
     _PER_FMK(EDMA,ESR,ES,es)\
  )

  #define _EDMA_ESR_FGET(FIELD)\
    _PER_FGET(_EDMA_ESR_ADDR,EDMA,ESR,##FIELD)

  #define _EDMA_ESR_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ESR_ADDR,EDMA,ESR,##FIELD,field)

  #define _EDMA_ESR_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ESR_ADDR,EDMA,ESR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  E S R L          |
* |___________________|
*
* ESRL - event set register, low half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) ES
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_ESRL_ADDR             0x01A0FFFCu

  #define  EDMA_ESRL                  EDMA_REG(ESRL)

  #define _EDMA_ESRL_ES_MASK          0xFFFFFFFFu
  #define _EDMA_ESRL_ES_SHIFT         0x00000000u
  #define  EDMA_ESRL_ES_DEFAULT       0x00000000u
  #define  EDMA_ESRL_ES_OF(x)         _VALUEOF(x)

  #define  EDMA_ESRL_OF(x)            _VALUEOF(x)

  #define EDMA_ESRL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ESRL,ES)\
  )

  #define EDMA_ESRL_RMK(es) (Uint32)(\
     _PER_FMK(EDMA,ESRL,ES,es)\
  )

  #define _EDMA_ESRL_FGET(FIELD)\
    _PER_FGET(_EDMA_ESRL_ADDR,EDMA,ESRL,##FIELD)

  #define _EDMA_ESRL_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ESRL_ADDR,EDMA,ESRL,##FIELD,field)

  #define _EDMA_ESRL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ESRL_ADDR,EDMA,ESRL,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  E S R H          |
* |___________________|
*
* ESRH - event set register, high half (1)
*
* (1) - C64x devices only
*
* FIELDS (msb -> lsb)
* (rw) ES
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _EDMA_ESRH_ADDR             0x01A0FFBCu

  #define  EDMA_ESRH                  EDMA_REG(ESRH)

  #define _EDMA_ESRH_ES_MASK          0xFFFFFFFFu
  #define _EDMA_ESRH_ES_SHIFT         0x00000000u
  #define  EDMA_ESRH_ES_DEFAULT       0x00000000u
  #define  EDMA_ESRH_ES_OF(x)         _VALUEOF(x)

  #define  EDMA_ESRH_OF(x)            _VALUEOF(x)

  #define EDMA_ESRH_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ESRH,ES)\
  )

  #define EDMA_ESRH_RMK(es) (Uint32)(\
     _PER_FMK(EDMA,ESRH,ES,es)\
  )

  #define _EDMA_ESRH_FGET(FIELD)\
    _PER_FGET(_EDMA_ESRH_ADDR,EDMA,ESRH,##FIELD)

  #define _EDMA_ESRH_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ESRH_ADDR,EDMA,ESRH,##FIELD,field)

  #define _EDMA_ESRH_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ESRH_ADDR,EDMA,ESRH,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  E S E L 0        |
* |___________________|
*
* ESEL0 - event selection register 0
*
* FIELDS (msb -> lsb)
* (rw) EVTSEL3
* (rw) EVTSEL2
* (rw) EVTSEL1
* (rw) EVTSEL0
*
\******************************************************************************/
#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
  #define _EDMA_ESEL0_ADDR             0x01A0FF00u

  #define  EDMA_ESEL0                  EDMA_REG(ESEL0)

  #define _EDMA_ESEL0_EVTSEL0_MASK     0x0000003Fu
  #define _EDMA_ESEL0_EVTSEL0_SHIFT    0x00000000u
  #define  EDMA_ESEL0_EVTSEL0_DEFAULT  0x00000000u
  #define  EDMA_ESEL0_EVTSEL0_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL0_EVTSEL1_MASK     0x00003F00u
  #define _EDMA_ESEL0_EVTSEL1_SHIFT    0x00000008u
  #define  EDMA_ESEL0_EVTSEL1_DEFAULT  0x00000001u
  #define  EDMA_ESEL0_EVTSEL1_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL0_EVTSEL2_MASK     0x003F0000u
  #define _EDMA_ESEL0_EVTSEL2_SHIFT    0x00000010u
  #define  EDMA_ESEL0_EVTSEL2_DEFAULT  0x00000002u
  #define  EDMA_ESEL0_EVTSEL2_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL0_EVTSEL3_MASK     0x3F000000u
  #define _EDMA_ESEL0_EVTSEL3_SHIFT    0x00000018u
  #define  EDMA_ESEL0_EVTSEL3_DEFAULT  0x00000003u
  #define  EDMA_ESEL0_EVTSEL3_OF(x)    _VALUEOF(x)

  #define  EDMA_ESEL0_OF(x)            _VALUEOF(x)

  #define EDMA_ESEL0_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ESEL0,EVTSEL0)\
    |_PER_FDEFAULT(EDMA,ESEL0,EVTSEL1)\
    |_PER_FDEFAULT(EDMA,ESEL0,EVTSEL2)\
    |_PER_FDEFAULT(EDMA,ESEL0,EVTSEL3)\
  )

  #define EDMA_ESEL0_RMK(evtsel0, evtsel1, evtsel2, evtsel3) (Uint32)(\
     _PER_FMK(EDMA,ESEL0,EVTSEL0,evtsel0)\
    |_PER_FMK(EDMA,ESEL0,EVTSEL1,evtsel1)\
    |_PER_FMK(EDMA,ESEL0,EVTSEL2,evtsel2)\
    |_PER_FMK(EDMA,ESEL0,EVTSEL3,evtsel3)\
  )

  #define _EDMA_ESEL0_FGET(FIELD)\
    _PER_FGET(_EDMA_ESEL0_ADDR,EDMA,ESEL0,##FIELD)

  #define _EDMA_ESEL0_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ESEL0_ADDR,EDMA,ESEL0,##FIELD,field)

  #define _EDMA_ESEL0_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ESEL0_ADDR,EDMA,ESEL0,##FIELD,##SYM)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  E S E L 1        |
* |___________________|
*
* ESEL1 - event selection register 1
*
* FIELDS (msb -> lsb)
* (rw) EVTSEL7
* (rw) EVTSEL6
* (rw) EVTSEL5
* (rw) EVTSEL4
*
\******************************************************************************/
#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
  #define _EDMA_ESEL1_ADDR             0x01A0FF04u

  #define  EDMA_ESEL1                  EDMA_REG(ESEL1)

  #define _EDMA_ESEL1_EVTSEL4_MASK     0x0000003Fu
  #define _EDMA_ESEL1_EVTSEL4_SHIFT    0x00000000u
  #define  EDMA_ESEL1_EVTSEL4_DEFAULT  0x00000004u
  #define  EDMA_ESEL1_EVTSEL4_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL1_EVTSEL5_MASK     0x00003F00u
  #define _EDMA_ESEL1_EVTSEL5_SHIFT    0x00000008u
  #define  EDMA_ESEL1_EVTSEL5_DEFAULT  0x00000005u
  #define  EDMA_ESEL1_EVTSEL5_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL1_EVTSEL6_MASK     0x003F0000u
  #define _EDMA_ESEL1_EVTSEL6_SHIFT    0x00000010u
  #define  EDMA_ESEL1_EVTSEL6_DEFAULT  0x00000006u
  #define  EDMA_ESEL1_EVTSEL6_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL1_EVTSEL7_MASK     0x3F000000u
  #define _EDMA_ESEL1_EVTSEL7_SHIFT    0x00000018u
  #define  EDMA_ESEL1_EVTSEL7_DEFAULT  0x00000007u
  #define  EDMA_ESEL1_EVTSEL7_OF(x)    _VALUEOF(x)

  #define  EDMA_ESEL1_OF(x)            _VALUEOF(x)

  #define EDMA_ESEL1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ESEL1,EVTSEL4)\
    |_PER_FDEFAULT(EDMA,ESEL1,EVTSEL5)\
    |_PER_FDEFAULT(EDMA,ESEL1,EVTSEL6)\
    |_PER_FDEFAULT(EDMA,ESEL1,EVTSEL7)\
  )

  #define EDMA_ESEL1_RMK(evtsel4, evtsel5, evtsel6, evtsel7) (Uint32)(\
     _PER_FMK(EDMA,ESEL1,EVTSEL4,evtsel4)\
    |_PER_FMK(EDMA,ESEL1,EVTSEL5,evtsel5)\
    |_PER_FMK(EDMA,ESEL1,EVTSEL6,evtsel6)\
    |_PER_FMK(EDMA,ESEL1,EVTSEL7,evtsel7)\
  )

  #define _EDMA_ESEL1_FGET(FIELD)\
    _PER_FGET(_EDMA_ESEL1_ADDR,EDMA,ESEL1,##FIELD)

  #define _EDMA_ESEL1_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ESEL1_ADDR,EDMA,ESEL1,##FIELD,field)

  #define _EDMA_ESEL1_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ESEL1_ADDR,EDMA,ESEL1,##FIELD,##SYM)

#endif

/******************************************************************************\
* _____________________
* |                   |
* |  E S E L 3        |
* |___________________|
*
* ESEL3 - event selection register 3
*
* FIELDS (msb -> lsb)
* (rw) EVTSEL15
* (rw) EVTSEL14
* (rw) EVTSEL13
* (rw) EVTSEL12
*
\******************************************************************************/
#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
  #define _EDMA_ESEL3_ADDR             0x01A0FF0Cu

  #define  EDMA_ESEL3                  EDMA_REG(ESEL3)

  #define _EDMA_ESEL3_EVTSEL12_MASK     0x0000003Fu
  #define _EDMA_ESEL3_EVTSEL12_SHIFT    0x00000000u
  #define  EDMA_ESEL3_EVTSEL12_DEFAULT  0x0000000Cu
  #define  EDMA_ESEL3_EVTSEL12_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL3_EVTSEL13_MASK     0x00003F00u
  #define _EDMA_ESEL3_EVTSEL13_SHIFT    0x00000008u
  #define  EDMA_ESEL3_EVTSEL13_DEFAULT  0x0000000Du
  #define  EDMA_ESEL3_EVTSEL13_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL3_EVTSEL14_MASK     0x003F0000u
  #define _EDMA_ESEL3_EVTSEL14_SHIFT    0x00000010u
  #define  EDMA_ESEL3_EVTSEL14_DEFAULT  0x0000000Eu
  #define  EDMA_ESEL3_EVTSEL14_OF(x)    _VALUEOF(x)

  #define _EDMA_ESEL3_EVTSEL15_MASK     0x3F000000u
  #define _EDMA_ESEL3_EVTSEL15_SHIFT    0x00000018u
  #define  EDMA_ESEL3_EVTSEL15_DEFAULT  0x0000000Fu
  #define  EDMA_ESEL3_EVTSEL15_OF(x)    _VALUEOF(x)

  #define  EDMA_ESEL3_OF(x)            _VALUEOF(x)

  #define EDMA_ESEL3_DEFAULT (Uint32)(\
     _PER_FDEFAULT(EDMA,ESEL3,EVTSEL12)\
    |_PER_FDEFAULT(EDMA,ESEL3,EVTSEL13)\
    |_PER_FDEFAULT(EDMA,ESEL3,EVTSEL14)\
    |_PER_FDEFAULT(EDMA,ESEL3,EVTSEL15)\
  )

  #define EDMA_ESEL3_RMK(evtsel12, evtsel13, evtsel14, evtsel15) (Uint32)(\
     _PER_FMK(EDMA,ESEL3,EVTSEL12,evtsel12)\
    |_PER_FMK(EDMA,ESEL3,EVTSEL13,evtsel13)\
    |_PER_FMK(EDMA,ESEL3,EVTSEL14,evtsel14)\
    |_PER_FMK(EDMA,ESEL3,EVTSEL15,evtsel15)\
  )

  #define _EDMA_ESEL3_FGET(FIELD)\
    _PER_FGET(_EDMA_ESEL3_ADDR,EDMA,ESEL3,##FIELD)

  #define _EDMA_ESEL3_FSET(FIELD,field)\
    _PER_FSET(_EDMA_ESEL3_ADDR,EDMA,ESEL3,##FIELD,field)

  #define _EDMA_ESEL3_FSETS(FIELD,SYM)\
    _PER_FSETS(_EDMA_ESEL3_ADDR,EDMA,ESEL3,##FIELD,##SYM)

#endif

/*----------------------------------------------------------------------------*/

#endif /* (EDMA_SUPPORT) */
#endif /* _CSL_EDMAHAL_H_ */
/******************************************************************************\
* End of csl_edmahal.h
\******************************************************************************/

csl_emac.h/     1057236662  0     0     0       28692     `
/*****************************************************************************\
*           Copyright (C) 1999-2003 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emac.h
* DATE CREATED.. 02/08/2002
* LAST MODIFIED. 04/24/2003
*------------------------------------------------------------------------------
* NOTE:
*   When used in an multitasking environment, no EMAC function may be
*   called while another EMAC function is operating on the same device
*   handle in another thread. It is the responsibility of the application
*   to assure adherence to this restriction.
*
\******************************************************************************/
#ifndef _CSL_EMAC_H
#define _CSL_EMAC_H_

/* Include the main CSL file */
#include <csl.h>

#include <csl_mdio.h>

#if (EMAC_SUPPORT)
/*-----------------------------------------------------------------------*\
* NEW TYPES
\*-----------------------------------------------------------------------*/
#ifndef _CSL_EMAC_TYPES
#define _CSL_EMAC_TYPES
typedef unsigned int uint;
typedef void * Handle;
#endif

/*-----------------------------------------------------------------------*\
* STANDARD DATA STRUCTURES
\*-----------------------------------------------------------------------*/

/*-----------------------------------------------------------------------*\
* EMAC_Pkt
*
* The packet structure defines the basic unit of memory used to hold data
* packets for the EMAC device.
*
* A packet is comprised of one or more packet buffers. Each packet buffer
* contains a packet buffer header, and a pointer to the buffer data.
* The EMAC_Pkt structure defines the packet buffer header.
*
* The pDataBuffer field points to the packet data. This is set when the
* buffer is allocated, and is not altered.
*
* BufferLen holds the the total length of the data buffer that is used to
* store the packet (or packet fragment). This size is set by the entity
* that originally allocates the buffer, and is not altered.
*
* The Flags field contains additional information about the packet
*
* ValidLen holds the length of the valid data currently contained in the
* data buffer.
*
* DataOffset is the byte offset from the start of the data buffer to the
* first byte of valid data. Thus (ValidLen+DataOffet)<=BufferLen.
*
* Note that for receive buffer packets, the DataOffset field may be
* assigned before there is any valid data in the packet buffer. This allows
* the application to reserve space at the top of data buffer for private
* use. In all instances, the DataOffset field must be valid for all packets
* handled by EMAC.
*
* The data portion of the packet buffer represents a packet or a fragment
* of a larger packet. This is determined by the Flags parameter. At the
* start of every packet, the SOP bit is set in Flags. If the EOP bit is
* also set, then the packet is not fragmented. Otherwise; the next packet
* structure pointed to by the pNext field will contain the next fragment in
* the packet. On either type of buffer, when the SOP bit is set in Flags,
* then the PktChannel, PktLength, and PktFrags fields must also be valid.
* These fields contain additional information about the packet.
*
* The PktChannel field detetmines what channel the packet has arrived on,
* or what channel it should be transmitted on. The EMAC library supports
* only a single receive channel, but allows for up to eight transmit
* channels. Transmit channels can be treated as round-robin or priority
* queues.
*
* The PktLength field holds the size of the entire packet. On single frag
* packets (both SOP and EOP set in BufFlags), PktLength and ValidLen will
* be equal.
*
* The PktFrags field holds the number of fragments (EMAC_Pkt records) used
* to describe the packet. If more than 1 frag is present, the first record
* must have EMAC_PKT_FLAGS_SOP flag set, with corresponding fields validated.
* Each frag/record must be linked list using the pNext field, and the final
* frag/record must have EMAC_PKT_FLAGS_EOP flag set and pNext=0.
*
* In systems where the packet resides in cacheable memory, the data buffer
* must start on a cache line boundary and be an even multiple of cache
* lines in size. The EMAC_Pkt header must not appear in the same cache line
* as the data portion of the packet. On multi-fragment packets, some packet
* fragments may reside in cacheable memory where others do not.
*
* ** NOTE: It is up to the caller to assure that all packet buffers    **
* ** residing in cacheable memory are not currently stored in L1 or L2 **
* ** cache when passed to any EMAC function                             **
*
* Some of the packet Flags can only be set if the device is in the
* proper configuration to receive the corresponding frames. In order to
* enable these flags, the following modes must be set:
*       RxCrc Flag  : RXCRC Mode in EMAC_Config
*       RxErr Flags : PASSERROR Mode in EMAC_Config
*       RxCtl Flags : PASSCONTROL Mode in EMAC_Config
*       RxPrm Flag  : EMAC_RXFILTER_ALL in EMAC_setReceiveFilter()
*
\*-----------------------------------------------------------------------*/
typedef struct _EMAC_Pkt {
    Uint32           AppPrivate;   /* For use by the application            */
    struct _EMAC_Pkt *pPrev;       /* Previous record                       */
    struct _EMAC_Pkt *pNext;       /* Next record                           */
    Uint8            *pDataBuffer; /* Pointer to Data Buffer (read only)    */
    Uint32          BufferLen;    /* Physical Length of buffer (read only) */
    Uint32          Flags;        /* Packet Flags                          */
    Uint32          ValidLen;     /* Length of valid data in buffer        */
    Uint32          DataOffset;   /* Byte offset to valid data             */
    Uint32          PktChannel;   /* Tx/Rx Channel/Priority 0-7 (SOP only) */
    Uint32          PktLength;    /* Length of Packet (SOP only)           */
                                  /* (same as ValidLen on single frag Pkt) */
    Uint32          PktFrags;     /* Number of frags in packet (SOP only)  */
                                   /* (frag is EMAC_Pkt record - normally 1)*/
    } EMAC_Pkt;

/*
// Packet Buffer Flags set in Flags
*/
#define EMAC_PKT_FLAGS_SOP         0x80000000u /* Start of packet           */
#define EMAC_PKT_FLAGS_EOP         0x40000000u /* End of packet             */

/*
// The Following Packet flags are set in Flags on RX packets only
*/
#define EMAC_PKT_FLAGS_HASCRC      0x04000000u /* RxCrc: PKT has 4byte CRC  */
#define EMAC_PKT_FLAGS_JABBER      0x02000000u /* RxErr: Jabber             */
#define EMAC_PKT_FLAGS_OVERSIZE    0x01000000u /* RxErr: Oversize           */
#define EMAC_PKT_FLAGS_FRAGMENT    0x00800000u /* RxErr: Fragment           */
#define EMAC_PKT_FLAGS_UNDERSIZED  0x00400000u /* RxErr: Undersized         */
#define EMAC_PKT_FLAGS_CONTROL     0x00200000u /* RxCtl: Control Frame      */
#define EMAC_PKT_FLAGS_OVERRUN     0x00100000u /* RxErr: Overrun            */
#define EMAC_PKT_FLAGS_CODEERROR   0x00080000u /* RxErr: Code Error         */
#define EMAC_PKT_FLAGS_ALIGNERROR  0x00040000u /* RxErr: Alignment Error    */
#define EMAC_PKT_FLAGS_CRCERROR    0x00020000u /* RxErr: Bad CRC            */
#define EMAC_PKT_FLAGS_NOMATCH     0x00010000u /* RxPrm: No Match           */


/*-----------------------------------------------------------------------*\
* EMAC_Config
*
* The config structure defines how the EMAC device should operate. It is
* passed to the device when the device is opened, and remains in effect
* until the device is closed.
*
* The following is a short description of the configuration fields:
*
* ModeFlags    - Specify the Fixed Operating Mode of the Device
* EMAC_CONFIG_MODEFLG_CHPRIORITY  - Treat TX channels as Priority Levels
*                                  (Channel 7 is highest, 0 is lowest)
* EMAC_CONFIG_MODEFLG_MACLOOPBACK - Set MAC in Internal Loopback for Testing
* EMAC_CONFIG_MODEFLG_RXCRC       - Include the 4 byte EtherCRC in RX frames
* EMAC_CONFIG_MODEFLG_TXCRC       - Assume TX Frames Include 4 byte EtherCRC
* EMAC_CONFIG_MODEFLG_PASSERROR   - Receive Error Frames for Testing
* EMAC_CONFIG_MODEFLG_PASSCONTROL - Receive Control Frames for Testing
*
* MdioModeFlags - Specify the MDIO/PHY Operation (See EMACMDIO.H)
*
* TxChannels    - Number of TX Channels to use (1-8, usually 1)
*
* MacAddr       - Device MAC address
*
* RxMaxPktPool  - Max Rx packet buffers to get from pool
*                 (Must be in the range of 8 to 192)
*
* A list of callback functions is used to register callback functions with
* a particular instance of the EMAC peripheral. Callback functions are
* used by EMAC to communicate with the application. These functions are
* REQUIRED for operation. The same callback table can be used for multiple
* driver instances.
*
* The callback functions can be used by EMAC during any EMAC function, but
* mostly occur during calls to EMAC_statusIsr() and EMAC_statusPoll().
*
* pfcbGetPacket -  Called by EMAC to get a free packet buffer from the
*                  application layer for receive data. This function
*                  should return NULL is no free packets are available.
*                  The size of the packet buffer must be large enough
*                  to accommodate a full sized packet (1514 or 1518
*                  depending on the EMAC_CONFIG_MODEFLG_RXCRC flag), plus
*                  any application buffer padding (DataOffset).
*
* pfcbFreePacket - Called by EMAC to give a free packet buffer back to
*                  the application layer. This function is used to
*                  return transmit packets. Note that at the time of the
*                  call, structure fields other than pDataBuffer and
*                  BufferLen are in an undefined state.
*
* pfcbRxPacket   - Called to give a received data packet to the application
*                  layer. The applicaiton must accept the packet.
*                  When the application is finished with the packet, it
*                  can return it to its own free queue.
*
*                  This function also returns a pointer to a free packet to
*                  replace the received packet on the EMAC free list. It
*                  returns NULL when no free packets are available. The
*                  return packet is the same as would be returned by
*                  pfcbGetPacket.
*
*                  Thus if a newly received packet is not desired, it can
*                  simply be returned to EMAC via the return value.
*
* pfcbStatus     - Called to indicate to the application that it
*                  should call EMAC_getStatus() to read the current
*                  device status. This call is made when device status
*                  changes.
*
* pfcbStatistics - Called to indicate to the application that it
*                  should call EMAC_getStatistics() to read the
*                  current Ethernet statistics. Called when the
*                  statistic counters are to the point of overflow.
*
* The hApplication calling calling argument is the application's handle
* as supplied to the EMAC device in the EMAC_open() function.
\*-----------------------------------------------------------------------*/
typedef struct _EMAC_Config {
    uint        ModeFlags;      /* Configuation Mode Flags                */
    uint        MdioModeFlags;  /* CSL_MDIO Mode Flags (see CSL_MDIO.H)   */
    uint        TxChannels;     /* Number of Tx Channels to use (1-8)     */
    Uint8       MacAddr[6];     /* Mac Address                            */
    uint        RxMaxPktPool;   /* Max Rx packet buffers to get from pool */
    EMAC_Pkt *  (*pfcbGetPacket)(Handle hApplication);
    void        (*pfcbFreePacket)(Handle hApplication, EMAC_Pkt *pPacket);
    EMAC_Pkt *  (*pfcbRxPacket)(Handle hApplication, EMAC_Pkt *pPacket);
    void        (*pfcbStatus)(Handle hApplication);
    void        (*pfcbStatistics)(Handle hApplication);
} EMAC_Config;

/*
//  Configuration Mode Flags
*/
#define EMAC_CONFIG_MODEFLG_CHPRIORITY  0x0001 /* Use Tx channel priority  */
#define EMAC_CONFIG_MODEFLG_MACLOOPBACK 0x0002 /* MAC internal loopback    */
#define EMAC_CONFIG_MODEFLG_RXCRC       0x0004 /* Include CRC in RX frames */
#define EMAC_CONFIG_MODEFLG_TXCRC       0x0008 /* Tx frames include CRC    */
#define EMAC_CONFIG_MODEFLG_PASSERROR   0x0010 /* Pass error frames        */
#define EMAC_CONFIG_MODEFLG_PASSCONTROL 0x0020 /* Pass control frames      */

/*-----------------------------------------------------------------------*\
* EMAC_Status
*
* The status structure contains information about the MAC's run-time
* status.
*
* The following is a short description of the configuration fields:
*
* MdioLinkStatus - Current link status (non-zero on link) (see CSL_MDIO.H)
*
* PhyDev         - Current PHY device in use (0-31)
*
* RxPktHeld      - Current number of Rx packets held by the EMAC device
*
* TxPktHeld      - Current number of Tx packets held by the EMAC device
*
* FatalError     - Fatal Error Code (TBD)
\*-----------------------------------------------------------------------*/
typedef struct _EMAC_Status {
    uint        MdioLinkStatus; /* CSL_MDIO Link status (see CSL_MDIO.H) */
    uint        PhyDev;         /* Current PHY device in use (0-31)      */
    uint        RxPktHeld;      /* Number of packets held for Rx         */
    uint        TxPktHeld;      /* Number of packets held for Tx         */
    uint        FatalError;     /* Fatal Error when non-zero             */
} EMAC_Status;


/*-----------------------------------------------------------------------*\
* EMAC_Statistics
*
* The statistics structure is the used to retrieve the current count
* of various packet events in the system. These values represent the
* delta values from the last time the statistics were read.
\*-----------------------------------------------------------------------*/
typedef struct _EMAC_Statistics {
    Uint32 RxGoodFrames;     /* Good Frames Received                         */
    Uint32 RxBCastFrames;    /* Good Broadcast Frames Received               */
    Uint32 RxMCastFrames;    /* Good Multicast Frames Received               */
    Uint32 RxPauseFrames;    /* PauseRx Frames Received                      */
    Uint32 RxCRCErrors;      /* Frames Received with CRC Errors              */
    Uint32 RxAlignCodeErrors;/* Frames Received with Alignment/Code Errors   */
    Uint32 RxOversized;      /* Oversized Frames Received                    */
    Uint32 RxJabber;         /* Jabber Frames Received                       */
    Uint32 RxUndersized;     /* Undersized Frames Received                   */
    Uint32 RxFragments;      /* Rx Frame Fragments Received                  */
    Uint32 RxFiltered;       /* Rx Frames Filtered Based on Address          */
    Uint32 RxQOSFiltered;    /* Rx Frames Filtered Based on QoS Filtering    */
    Uint32 RxOctets;         /* Total Received Bytes in Good Frames          */
    Uint32 TxGoodFrames;     /* Good Frames Sent                             */
    Uint32 TxBCastFrames;    /* Good Broadcast Frames Sent                   */
    Uint32 TxMCastFrames;    /* Good Multicast Frames Sent                   */
    Uint32 TxPauseFrames;    /* PauseTx Frames Sent                          */
    Uint32 TxDeferred;       /* Frames Where Transmission was Deferred       */
    Uint32 TxCollision;      /* Total Frames Sent With Collision             */
    Uint32 TxSingleColl;     /* Frames Sent with Exactly One Collision       */
    Uint32 TxMultiColl;      /* Frames Sent with Multiple Colisions          */
    Uint32 TxExcessiveColl;  /* Tx Frames Lost Due to Excessive Collisions   */
    Uint32 TxLateColl;       /* Tx Frames Lost Due to a Late Collision       */
    Uint32 TxUnderrun;       /* Tx Frames Lost with Transmit Underrun Error  */
    Uint32 TxCarrierSLoss;   /* Tx Frames Lost Due to Carrier Sense Loss     */
    Uint32 TxOctets;         /* Total Transmitted Bytes in Good Frames       */
    Uint32 Frame64;          /* Total Tx&Rx with Octet Size of 64            */
    Uint32 Frame65t127;      /* Total Tx&Rx with Octet Size of 65 to 127     */
    Uint32 Frame128t255;     /* Total Tx&Rx with Octet Size of 128 to 255    */
    Uint32 Frame256t511;     /* Total Tx&Rx with Octet Size of 256 to 511    */
    Uint32 Frame512t1023;    /* Total Tx&Rx with Octet Size of 512 to 1023   */
    Uint32 Frame1024tUp;     /* Total Tx&Rx with Octet Size of >=1024      */
    Uint32 NetOctets;        /* Sum of all Octets Tx or Rx on the Network    */
    Uint32 RxSOFOverruns;    /* Total Rx Start of Frame Overruns             */
    Uint32 RxMOFOverruns;    /* Total Rx Middle of Frame Overruns            */
    Uint32 RxDMAOverruns;    /* Total Rx DMA Overruns                        */
} EMAC_Statistics;


/*-----------------------------------------------------------------------*\
* Packet Filtering
*
* Packet Filtering Settings (cumulative)
\*-----------------------------------------------------------------------*/
#define EMAC_RXFILTER_NOTHING      0
#define EMAC_RXFILTER_DIRECT       1
#define EMAC_RXFILTER_BROADCAST    2
#define EMAC_RXFILTER_MULTICAST    3
#define EMAC_RXFILTER_ALLMULTICAST 4
#define EMAC_RXFILTER_ALL          5

/*-----------------------------------------------------------------------*\
* STANDARD ERROR CODES
\*-----------------------------------------------------------------------*/
#define EMAC_ERROR_ALREADY   1   /* Operation has already been started        */
#define EMAC_ERROR_NOTREADY  2   /* Device is not open or not ready           */
#define EMAC_ERROR_DEVICE    3   /* Device hardware error                     */
#define EMAC_ERROR_INVALID   4   /* Function or calling parameter is invalid  */
#define EMAC_ERROR_BADPACKET 5   /* Supplied packet was invalid               */
#define EMAC_ERROR_MACFATAL  6   /* Fatal Error in MAC - EMAC_close() required */

/*-----------------------------------------------------------------------*\
* STANDARD API FUNCTIONS
*
* IMPORTANT NOTE
* --------------
*   The application is charged with verifying that only one of the
* following API calls may only be executing at a given time across
* all threads and all interrupt functions.
*
\*-----------------------------------------------------------------------*/

/*-----------------------------------------------------------------------*\
* EMAC_enumerate()
*
* Enumerates the EMAC peripherals installed in the system and returns an
* integer count. The EMAC devices are enumerated in a consistent
* fashion so that each device can be later referenced by its physical
* index value ranging from "1" to "n" where "n" is the count returned
* by this function.
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_enumerate( void );


/*-----------------------------------------------------------------------*\
* EMAC_open()
*
* Opens the EMAC peripheral at the given physical index and initializes
* it to an embryonic state.
*
* The calling application must supply a operating configuration that
* includes a callback function table. Data from this config structure is
* copied into the device's internal instance structure so the structure
* may be discarded after EMAC_open() returns. In order to change an item
* in the configuration, the the EMAC device must be closed and then
* re-opened with the new configuration.
*
* The application layer may pass in an hApplication callback handle,
* that will be supplied by the EMAC device when making calls to the
* application callback functions.
*
* An EMAC device handle is written to phEMAC. This handle must be saved
* by the caller and then passed to other EMAC device functions.
*
* The default receive filter prevents normal packets from being received
* until the receive filter is specified by calling EMAC_receiveFilter().
*
* A device reset is achieved by calling EMAC_close() followed by EMAC_open().
*
* The function returns zero on success, or an error code on failure.
*
* Possible error codes include:
*   EMAC_ERROR_ALREADY   - The device is already open
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_open( int physicalIndex, Handle hApplication,
                       EMAC_Config *pEMACConfig, Handle *phEMAC );


/*-----------------------------------------------------------------------*\
* EMAC_close()
*
* Closed the EMAC peripheral indicated by the supplied instance handle.
* When called, the EMAC device will shutdown both send and receive
* operations, and free all pending transmit and receive packets.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_close( Handle hEMAC );


/*-----------------------------------------------------------------------*\
* EMAC_getStatus()
*
* Called to get the current status of the device. The device status
* is copied into the supplied data structure.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_getStatus( Handle hEMAC, EMAC_Status *pStatus );


/*-----------------------------------------------------------------------*\
* EMAC_setReceiveFilter()
*
* Called to set the packet filter for received packets. The filtering
* level is inclusive, so BROADCAST would include both BROADCAST and
* DIRECTED (UNICAST) packets.
*
* Available filtering modes include the following:
*  EMAC_RXFILTER_NOTHING      - Receive nothing
*  EMAC_RXFILTER_DIRECT       - Receive only Unicast to local MAC addr
*  EMAC_RXFILTER_BROADCAST    - Receive direct and Broadcast
*  EMAC_RXFILTER_MULTICAST    - Receive above plus multicast in mcast list
*  EMAC_RXFILTER_ALLMULTICAST - Receive above plus all multicast
*  EMAC_RXFILTER_ALL          - Receive all packets
*
* Note that if error frames and control frames are desired, reception of
* these must be specified in the device configuration.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_setReceiveFilter( Handle hEMAC, uint ReceiveFilter );


/*-----------------------------------------------------------------------*\
* EMAC_getReceiveFilter()
*
* Called to get the current packet filter setting for received packets.
* The filter values are the same as those used in EMAC_setReceiveFilter().
*
* The current filter value is writter to the pointer supplied in
* pReceiveFilter.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_getReceiveFilter( Handle hEMAC, uint *pReceiveFilter );


/*-----------------------------------------------------------------------*\
* EMAC_getStatistics()
*
* Called to get the current device statistics. The statistics structure
* contains a collection of event counts for various packet sent and
* receive properties. Reading the statistics also clears the current
* statistic counters, so the values read represent a delta from the last
* call.
*
* The statistics information is copied into the structure pointed to
* by the pStatistics argument.
*
* The function returns zero on success, or an error code on failure.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_getStatistics( Handle hEMAC, EMAC_Statistics *pStatistics );


/*-----------------------------------------------------------------------*\
* EMAC_setMulticast()
*
* This function is called to install a list of multicast addresses for
* use in multicast address filtering. Each time this function is called,
* any current multicast configuration is discarded in favor of the new
* list. Thus a set with a list size of zero will remove all multicast
* addresses from the device.
*
* Note that the multicast list configuration is stateless in that the
* list of multicast addresses used to build the configuration is not
* retained. Thus it is impossible to examine a list of currently installed
* addresses.
*
* The addresses to install are pointed to by pMCastList. The length of
* this list in bytes is 6 times the value of AddrCnt. When AddrCnt is
* zero, the pMCastList parameter can be NULL.
*
* The function returns zero on success, or an error code on failure.
* The multicast list settings are not altered in the event of a failure
* code.
*
* Possible error code include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_setMulticast( Handle hEMAC, uint AddrCnt, Uint8 *pMCastList );



/*-----------------------------------------------------------------------*\
* EMAC_sendPacket()
*
* Sends a Ethernet data packet out the EMAC device. On a non-error return,
* the EMAC device takes ownership of the packet. The packet is returned
* to the application's free pool once it has been transmitted.
*
* The function returns zero on success, or an error code on failure.
* When an error code is returned, the EMAC device has not taken ownership
* of the packet.
*
* Possible error codes include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*   EMAC_ERROR_BADPACKET - The packet structure is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_sendPacket( Handle hEMAC, EMAC_Pkt *pPacket );


/*-----------------------------------------------------------------------*\
* EMAC_serviceCheck()
*
* This function should be called every time there is an EMAC device
* interrupt. It maintains the status the EMAC.
*
* Note that the application has the responsibility for mapping the
* physical device index to the correct EMAC_serviceCheck() function. If
* more than one EMAC device is on the same interrupt, the function must be
* called for each device.
*
* Possible error codes include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*   EMAC_ERROR_MACFATAL  - Fatal error in the MAC - Call EMAC_close()
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_serviceCheck( Handle hEMAC );


/*-----------------------------------------------------------------------*\
* EMAC_timerTick()
*
* This function should be called for each device in the system on a
* periodic basis of 100mS (10 times a second). It is used to check the
* status of the EMAC and MDIO device, and to potentially recover from
* low Rx buffer conditions.
*
* Strict timing is not required, but the application should make a
* reasonable attempt to adhere to the 100mS mark. A missed call should
* not be "made up" by making mulitple sequential calls.
*
* A "polling" driver (one that calls EMAC_serviceCheck() in a tight loop),
* must also adhere to the 100mS timing on this function.
*
* Possible error codes include:
*   EMAC_ERROR_INVALID   - A calling parameter is invalid
*
\*-----------------------------------------------------------------------*/
CSLAPI uint EMAC_timerTick( Handle hEMAC );

#endif /* EMAC_SUPPORT */
#endif /* _CSL_EMAC_H_ */

/******************************************************************************\
* End of emi.h
\******************************************************************************/

csl_emachal.h/  1080217106  0     0     0       96360     `
/*****************************************************************************\
*           Copyright (C) 1999-2003 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emachal.h
* DATE CREATED.. 02/04/2002
* LAST MODIFIED. 03/05/2003
*------------------------------------------------------------------------------
* REGISTERS/PARAMETERS
*
* TXIDVER           - TX Identification and Version Register
* TXCONTROL         - TX Control Register
* TXTEARDOWN        - TX Teardown Register
* RXIDVER           - RX Identification and Version Register
* RXCONTROL         - RX Control Register
* RXTEARDOWN        - RX Teardown Register
* RXMBPENABLE       - RX Mulicast/Bcast/Promisc Channel Enable Register
* RXUNICASTSET      - RX Unicast Set Register
* RXUNICASTCLEAR    - RX Unicast Clear Register
* RXMAXLEN          - RX Maximum Length Register
* RXBUFFEROFFSET    - RX Buffer Offset Register
* RXFILTERLOWTHRESH - RX Filer Low Priority Packets Threshhold
* RX0FLOWTHRESH     - RX Channel 0 Flow Control Threshhold
* RX1FLOWTHRESH     - RX Channel 1 Flow Control Threshhold
* RX2FLOWTHRESH     - RX Channel 2 Flow Control Threshhold
* RX3FLOWTHRESH     - RX Channel 3 Flow Control Threshhold
* RX4FLOWTHRESH     - RX Channel 4 Flow Control Threshhold
* RX5FLOWTHRESH     - RX Channel 5 Flow Control Threshhold
* RX6FLOWTHRESH     - RX Channel 6 Flow Control Threshhold
* RX7FLOWTHRESH     - RX Channel 7 Flow Control Threshhold
* RX0FREEBUFFER     - RX Channel 0 Free Buffer Count Register
* RX1FREEBUFFER     - RX Channel 1 Free Buffer Count Register
* RX2FREEBUFFER     - RX Channel 2 Free Buffer Count Register
* RX3FREEBUFFER     - RX Channel 3 Free Buffer Count Register
* RX4FREEBUFFER     - RX Channel 4 Free Buffer Count Register
* RX5FREEBUFFER     - RX Channel 5 Free Buffer Count Register
* RX6FREEBUFFER     - RX Channel 6 Free Buffer Count Register
* RX7FREEBUFFER     - RX Channel 7 Free Buffer Count Register
* MACCONTROL        - MAC Control Register
* MACSTATUS         - MAC Status Register
* EMCONTROL         - Emulation Control Register
* TXINTSTATRAW      - TX Interrupt Status Register (Unmasked)
* TXINTSTATMASKED   - TX Interrupt Status Register (Masked)
* TXINTMASKSET      - TX Interrupt Mask Set Register
* TXINTMASKCLEAR    - TX Interrupt Mask Clear Register
* MACINVECTOR       - MAC Input Vector
* MACEOIVECTOR      - MAC EOI Vector
* RXINTSTATRAW      - RX Interrupt Status Register (Unmasked)
* RXINTSTATMASKED   - RX Interrupt Status Register (Masked)
* RXINTMASKSET      - RX Interrupt Mask Set Register
* RXINTMASKCLEAR    - RX Interrupt Mask Clear Register
* MACINTSTATRAW     - MAC Interrupt Status Register (Unmasked)
* MACINTSTATMASKED  - MAC Interrupt Status Register (Masked)
* MACINTMASKSET     - MAC Interrupt Mask Set Register
* MACINTMASKCLEAR   - MAC Interrupt Mask Clear Register
* MACADDRL0         - MAC Address Channel 0 Lower Byte Register
* MACADDRL1         - MAC Address Channel 1 Lower Byte Register
* MACADDRL2         - MAC Address Channel 2 Lower Byte Register
* MACADDRL3         - MAC Address Channel 3 Lower Byte Register
* MACADDRL4         - MAC Address Channel 4 Lower Byte Register
* MACADDRL5         - MAC Address Channel 5 Lower Byte Register
* MACADDRL6         - MAC Address Channel 6 Lower Byte Register
* MACADDRL7         - MAC Address Channel 7 Lower Byte Register
* MACADDRM          - MAC Address Middle Byte Register
* MACADDRH          - MAC Address High Bytes Register
* MACHASH1          - MAC Address Hash 1 Register
* MACHASH2          - MAC Address Hash 2 Register
* BOFFTEST          - Backoff Test Register
* TPACETEST         - Transmit Pacing Test Register
* RXPAUSE           - Receive Pause Timer Register
* TXPAUSE           - Transmit Pause Timer Register
* RXGOODFRAMES      - Number of Good Frames Received
* RXBCASTFRAMES     - Number of Good Broadcast Frames Received
* RXMCASTFRAMES     - Number of Good Multicast Frames Received
* RXPAUSEFRAMES     - Number of PauseRX Frames Received
* RXCRCERRORS       - Number of Frames Received with CRC Errors
* RXALIGNCODEERRORS - Number of Frames Received with Alignment/Code Errors
* RXOVERSIZED       - Number of Oversized Frames Received
* RXJABBER          - Number of Jabber Frames Received
* RXUNDERSIZED      - Number of Undersized Frames Received
* RXFRAGMENTS       - Number of RX Frame Fragments Received
* RXFILTERED        - Number of RX Frames Filtered Based on Address
* RXQOSFILTERED     - Number of RX Frames Filtered Based on QoS Filtering
* RXOCTETS          - Total Number of Received Bytes in Good Frames
* TXGOODFRAMES      - Number of Good Frames Sent
* TXBCASTFRAMES     - Number of Good Broadcast Frames Sent
* TXMCASTFRAMES     - Number of Good Multicast Frames Sent
* TXPAUSEFRAMES     - Number of PauseTX Frames Sent
* TXDEFERRED        - Number of Frames Where Transmission was Deferred
* TXCOLLISION       - Total Number of Frames Sent That Experienced a Collision
* TXSINGLECOLL      - Number of Frames Sent with Exactly One Collision
* TXMULTICOLL       - Number of Frames Sent with Multiple Colisions
* TXEXCESSIVECOLL   - Number of TX Frames Lost Due to Excessive Collisions
* TXLATECOLL        - Number of TX Frames Lost Due to a Late Collision
* TXUNDERRUN        - Number of TX Frames Lost with Transmit Underrun Error
* TXCARRIERSLOSS    - Numebr of TX Frames Lost Due to Carrier Sense Loss
* TXOCTETS          - Total Nu,ber of Transmitted Bytes in Good Frames
* FRAME64           - Total TX & RX Frames with Octet Size of 64
* FRAME65T127       - Total TX & RX Frames with Octet Size of 65 to 127
* FRAME128T255      - Total TX & RX Frames with Octet Size of 128 to 255
* FRAME256T511      - Total TX & RX Frames with Octet Size of 256 to 511
* FRAME512T1023     - Total TX & RX Frames with Octet Size of 512 to 1023
* FRAME1024TUP      - Total TX & RX Frames with Octet Size of 1024 or above
* NETOCTETS         - Sum of all Octets Sent or Received on the Network
* RXSOFOVERRUNS     - Total RX Start of Frame Overruns (FIFO or DMA)
* RXMOFOVERRUNS     - Total RX Middle of Frame Overruns (FIFO or DMA)
* RXDMAOVERRUNS     - Total RX DMA Overruns
* TX0HDP            - TX Channel 0 DMA Head Descriptor Pointer Register
* TX1HDP            - TX Channel 1 DMA Head Descriptor Pointer Register
* TX2HDP            - TX Channel 2 DMA Head Descriptor Pointer Register
* TX3HDP            - TX Channel 3 DMA Head Descriptor Pointer Register
* TX4HDP            - TX Channel 4 DMA Head Descriptor Pointer Register
* TX5HDP            - TX Channel 5 DMA Head Descriptor Pointer Register
* TX6HDP            - TX Channel 6 DMA Head Descriptor Pointer Register
* TX7HDP            - TX Channel 7 DMA Head Descriptor Pointer Register
* RX0HDP            - RX Channel 0 DMA Head Descriptor Pointer Register
* RX1HDP            - RX Channel 1 DMA Head Descriptor Pointer Register
* RX2HDP            - RX Channel 2 DMA Head Descriptor Pointer Register
* RX3HDP            - RX Channel 3 DMA Head Descriptor Pointer Register
* RX4HDP            - RX Channel 4 DMA Head Descriptor Pointer Register
* RX5HDP            - RX Channel 5 DMA Head Descriptor Pointer Register
* RX6HDP            - RX Channel 6 DMA Head Descriptor Pointer Register
* RX7HDP            - RX Channel 7 DMA Head Descriptor Pointer Register
* TX0INTACK         - TX Channel 0 Interrupt Acknowledge Register
* TX1INTACK         - TX Channel 1 Interrupt Acknowledge Register
* TX2INTACK         - TX Channel 2 Interrupt Acknowledge Register
* TX3INTACK         - TX Channel 3 Interrupt Acknowledge Register
* TX4INTACK         - TX Channel 4 Interrupt Acknowledge Register
* TX5INTACK         - TX Channel 5 Interrupt Acknowledge Register
* TX6INTACK         - TX Channel 6 Interrupt Acknowledge Register
* TX7INTACK         - TX Channel 7 Interrupt Acknowledge Register
* RX0INTACK         - RX Channel 0 Interrupt Acknowledge Register
* RX1INTACK         - RX Channel 1 Interrupt Acknowledge Register
* RX2INTACK         - RX Channel 2 Interrupt Acknowledge Register
* RX3INTACK         - RX Channel 3 Interrupt Acknowledge Register
* RX4INTACK         - RX Channel 4 Interrupt Acknowledge Register
* RX5INTACK         - RX Channel 5 Interrupt Acknowledge Register
* RX6INTACK         - RX Channel 6 Interrupt Acknowledge Register
* RX7INTACK         - RX Channel 7 Interrupt Acknowledge Register
*
*
* WRAPPER REGISTERS
*
* INTCTL            - Interrupt control register
*
*
* DESCRIPTOR FIELDS
*
* DSC_NEXTDSC       - Pointer to Next Descriptor
* DSC_BUFFER        - Pointer to Buffer
* DSC_OFFLEN        - Buffer Offset and Length
* DSC_STATUS        - Packet Status
*
*\******************************************************************************/
#ifndef _CSL_EMACHAL_H
#define _CSL_EMACHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>


#if (EMAC_SUPPORT)
/******************************************************************************\
* EMAC Register section
\******************************************************************************/

#define _EMAC_BASE_ADDR             0x01c80000u

/* ----------------- */
/* FIELD MAKE MACROS */
/* ----------------- */

/* User Supplied Value */
#define EMAC_FMK(REG,FIELD,x)\
  ((x<<_EMAC_##REG##_##FIELD##_SHIFT)&_EMAC_##REG##_##FIELD##_MASK)

/* Symbolic Value Name */
#define EMAC_FMKS(REG,FIELD,SYM)\
  ((EMAC_##REG##_##FIELD##_##SYM<<_EMAC_##REG##_##FIELD##_SHIFT)\
  &_EMAC_##REG##_##FIELD##_MASK)

/* Channel Flag */
#define EMAC_FMKCHF(CHANNEL)    (1u<<(CHANNEL))


/* -------------------------------- */
/* RAW REGISTER/FIELD ACCESS MACROS */
/* -------------------------------- */

#define EMAC_ADDR(REG)\
    ((volatile Uint32 *)_EMAC_##REG##_ADDR)

#define EMAC_REG(REG)\
    *(volatile Uint32*)(_EMAC_##REG##_ADDR)

/* Standard Registers */
#define EMAC_RGET(REG)\
    (*(volatile Uint32*)(_EMAC_##REG##_ADDR))

#define EMAC_RSET(REG,x)\
    (*(volatile Uint32*)(_EMAC_##REG##_ADDR)=(x))

#define EMAC_FGET(REG,FIELD)\
    ((EMAC_RGET(REG)&_EMAC_##REG##_##FIELD##_MASK)\
    >>_EMAC_##REG##_##FIELD##_SHIFT)

#define EMAC_FSET(REG,FIELD,x)\
    EMAC_RSET(REG,(EMAC_RGET(REG)&~_EMAC_##REG##_##FIELD##_MASK)|\
    EMAC_FMK(REG,FIELD,x))

#define EMAC_FSETS(REG,FIELD,SYM)\
    EMAC_RSET(REG,(EMAC_RGET(REG)&~_EMAC_##REG##_##FIELD##_MASK)|\
    EMAC_FMKS(REG,FIELD,SYM))


/* Index Based Registers */
#define EMAC_RGETI(REGBASE,IDX)\
    (*(volatile Uint32*)(_EMAC_##REGBASE##_BASEADDR+((IDX)*sizeof(Uint32 *))))

#define EMAC_RSETI(REGBASE,IDX,x)\
    (*(volatile Uint32*)(_EMAC_##REGBASE##_BASEADDR+((IDX)*sizeof(Uint32 *)))=(x))

#define EMAC_FGETI(REGBASE,IDX,FIELD)\
    ((EMAC_RGETI(REGBASE,IDX)&_EMAC_##REGBASE##_##FIELD##_MASK)\
    >>_EMAC_##REGBASE##_##FIELD##_SHIFT)

#define EMAC_FSETI(REGBASE,IDX,FIELD,x)\
    EMAC_RSETI(REGBASE,IDX,(EMAC_RGETI(REGBASE,IDX)&\
    ~_EMAC_##REGBASE##_##FIELD##_MASK)|EMAC_FMK(REGBASE,FIELD,x))

#define EMAC_FSETSI(REGBASE,IDX,FIELD,SYM)\
    EMAC_RSETI(REGBASE,IDX,(EMAC_RGETI(REGBASE,IDX)&\
    ~_EMAC_##REGBASE##_##FIELD##_MASK)|EMAC_FMKS(REGBASE,FIELD,SYM))



/******************************************************************************\
* EMAC Descriptor section
\******************************************************************************/

#define _EMAC_DSC_BASE_ADDR         0x01c81000u

/* EMAC Descriptor Size and Element Count */
#define _EMAC_DSC_SIZE              4096
#define _EMAC_DSC_ENTRY_SIZE        16
#define _EDMA_DSC_ENTRY_COUNT       (_EMAC_DSC_SIZE/_EMAC_DSC_ENTRY_SIZE)


/*
// EMAC Descriptor
//
// The following is the format of a single buffer descriptor
// on the EMAC.
*/
typedef struct _EMAC_Desc {
  struct _EMAC_Desc *pNext;     /* Pointer to next descriptor in chain */
  Uint8             *pBuffer;   /* Pointer to data buffer              */
  Uint32            BufOffLen;  /* Buffer Offset(MSW) and Length(LSW)  */
  Uint32            PktFlgLen;  /* Packet Flags(MSW) and Length(LSW)   */
} EMAC_Desc;


/* ------------------------ */
/* DESCRIPTOR ACCESS MACROS */
/* ------------------------ */

/* Packet Flags */
#define EMAC_DSC_FLAG_SOP                       0x80000000u
#define EMAC_DSC_FLAG_EOP                       0x40000000u
#define EMAC_DSC_FLAG_OWNER                     0x20000000u
#define EMAC_DSC_FLAG_EOQ                       0x10000000u
#define EMAC_DSC_FLAG_TDOWNCMPLT                0x08000000u
#define EMAC_DSC_FLAG_PASSCRC                   0x04000000u
#define EMAC_DSC_FLAG_JABBER                    0x02000000u
#define EMAC_DSC_FLAG_OVERSIZE                  0x01000000u
#define EMAC_DSC_FLAG_FRAGMENT                  0x00800000u
#define EMAC_DSC_FLAG_UNDERSIZED                0x00400000u
#define EMAC_DSC_FLAG_CONTROL                   0x00200000u
#define EMAC_DSC_FLAG_OVERRUN                   0x00100000u
#define EMAC_DSC_FLAG_CODEERROR                 0x00080000u
#define EMAC_DSC_FLAG_ALIGNERROR                0x00040000u
#define EMAC_DSC_FLAG_CRCERROR                  0x00020000u
#define EMAC_DSC_FLAG_NOMATCH                   0x00010000u


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

/******************************************************************************\
* _____________________
* |                   |
* |  TXIDVER          |
* |___________________|
*
* TXIDVER           - TX Identification and Version Register
*
* FIELDS (msb -> lsb)
* (r)   TXIDENT
* (r)   TXMAJORVER
* (r)   TXMINORVER
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_TXIDVER_ADDR                      (_EMAC_BASE_ADDR+0x0000u)

#define EMAC_TXIDVER                            EMAC_REG(TXIDVER)

#define _EMAC_TXIDVER_TXIDENT_MASK              0xFFFF0000u
#define _EMAC_TXIDVER_TXIDENT_SHIFT             16u
#define  EMAC_TXIDVER_TXIDENT_DEFAULT           0x00000004u

#define _EMAC_TXIDVER_TXMAJORVER_MASK           0x0000FF00u
#define _EMAC_TXIDVER_TXMAJORVER_SHIFT          8u
#define  EMAC_TXIDVER_TXMAJORVER_DEFAULT        0x00000000u

#define _EMAC_TXIDVER_TXMINORVER_MASK           0x000000FFu
#define _EMAC_TXIDVER_TXMINORVER_SHIFT          0u
#define  EMAC_TXIDVER_TXMINORVER_DEFAULT        0x00000000u



/******************************************************************************\
* _____________________
* |                   |
* |  TXCONTROL        |
* |___________________|
*
* TXCONTROL         - TX Control Register
*
* FIELDS (msb -> lsb)
* (rw)  TXEN        - Transmit Enable
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    y
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_TXCONTROL_ADDR                    (_EMAC_BASE_ADDR+0x0004u)

#define EMAC_TXCONTROL                          EMAC_REG(TXCONTROL)

#define _EMAC_TXCONTROL_TXEN_MASK               0x00000001u
#define _EMAC_TXCONTROL_TXEN_SHIFT              0u
#define  EMAC_TXCONTROL_TXEN_DEFAULT		0x00000000u
#define EMAC_TXCONTROL_TXEN_DISABLE             0u
#define EMAC_TXCONTROL_TXEN_ENABLE              1u



/******************************************************************************\
* _____________________
* |                   |
* |  TXTEARDOWN       |
* |___________________|
*
* TXTEARDOWN        - TX Teardown Register
*
* FIELDS (msb -> lsb)
* (w)  TXTDNCH      - Teardown Channel Number
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_TXTEARDOWN_ADDR                   (_EMAC_BASE_ADDR+0x0008u)

#define EMAC_TXTEARDOWN                         EMAC_REG(TXTEARDOWN)

#define _EMAC_TXTEARDOWN_TXTDNCH_MASK           0x00000007u
#define _EMAC_TXTEARDOWN_TXTDNCH_SHIFT          0u
#define  EMAC_TXTEARDOWN_TXTDNCH_DEFAULT	0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |  RXIDVER          |
* |___________________|
*
* RXIDVER           - RX Identification and Version Register
*
* FIELDS (msb -> lsb)
* (r)   RXIDENT
* (r)   RXMAJORVER
* (r)   RXMINORVER
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXIDVER_ADDR                      (_EMAC_BASE_ADDR+0x0010u)

#define EMAC_RXIDVER                            EMAC_REG(RXIDVER)

#define _EMAC_RXIDVER_RXIDENT_MASK              0xFFFF0000u
#define _EMAC_RXIDVER_RXIDENT_SHIFT             16u
#define  EMAC_RXIDVER_RXIDENT_DEFAULT		0x00000004u

#define _EMAC_RXIDVER_RXMAJORVER_MASK           0x0000FF00u
#define _EMAC_RXIDVER_RXMAJORVER_SHIFT          8u
#define	 EMAC_RXIDVER_RXMAJORVER_DEFAULT	0x00000000u

#define _EMAC_RXIDVER_RXMINORVER_MASK           0x000000FFu
#define _EMAC_RXIDVER_RXMINORVER_SHIFT          0u
#define  EMAC_RXIDVER_RXMINORVER_DEFAULT	0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |  RXCONTROL        |
* |___________________|
*
* RXCONTROL         - RX Control Register
*
* FIELDS (msb -> lsb)
* (rw)  RXEN        - Receive Enable
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    y
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   y
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXCONTROL_ADDR                    (_EMAC_BASE_ADDR+0x0014u)

#define EMAC_RXCONTROL                          EMAC_REG(RXCONTROL)

#define _EMAC_RXCONTROL_RXEN_MASK               0x00000001u
#define _EMAC_RXCONTROL_RXEN_SHIFT              0u
#define  EMAC_RXCONTROL_RXEN_DEFAULT		0x00000000u
#define EMAC_RXCONTROL_RXEN_DISABLE             0u
#define EMAC_RXCONTROL_RXEN_ENABLE              1u



/******************************************************************************\
* _____________________
* |                   |
* |  RXTEARDOWN       |
* |___________________|
*
* RXTEARDOWN        - RX Teardown Register
*
* FIELDS (msb -> lsb)
* (w)  RXTDNCH      - Teardown Channel Number
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXTEARDOWN_ADDR                   (_EMAC_BASE_ADDR+0x0018u)

#define EMAC_RXTEARDOWN                         EMAC_REG(RXTEARDOWN)

#define _EMAC_RXTEARDOWN_RXTDNCH_MASK           0x000000007u
#define _EMAC_RXTEARDOWN_RXTDNCH_SHIFT          0u
#define  EMAC_RXTEARDOWN_RXTDNCH_DEFAULT	0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |  RXMBPENABLE      |
* |___________________|
*
* RXMBPENABLE       - RX Mulicast/Bcast/Promisc Channel Enable Register
*
* FIELDS (msb -> lsb)
* (rw)  RXPASSCRC   - Pass Receive CRC
* (rw)  RXQOSEN     - RX QOS Enable
* (rw)  RXNOCHAIN   - RX No Buffer Chaining
* (rw)  RXCMFEN     - RX Copy MAC Control Frames Enable
* (rw)  RXCSFEN     - RX Copy Short Frames Enable
* (rw)  RXCEFEN     - RX Copy Error Frames Enable
* (rw)  RXCAFEN     - RX Copy All Frames Enable
* (rw)  RXPROMCH    - RX Promiscusous Channel Select
* (rw)  RXBROADEN   - RX Broadcast Frame Enable
* (rw)  RXBROADCH   - RX Broadcast Channel Select
* (rw)  RXMULTEN    - RX Multicast Enable
* (rw)  RXMULTCH    - RX Multicast Channel Select
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    y
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   y
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXMBPENABLE_ADDR                  (_EMAC_BASE_ADDR+0x0100u)

#define EMAC_RXMBPENABLE                        EMAC_REG(RXMBPENABLE)

#define _EMAC_RXMBPENABLE_RXPASSCRC_MASK        0x40000000u
#define _EMAC_RXMBPENABLE_RXPASSCRC_SHIFT       30u
#define  EMAC_RXMBPENABLE_RXPASSCRC_DEFAULT	0x00000000u
#define EMAC_RXMBPENABLE_RXPASSCRC_DISCARD      0u
#define EMAC_RXMBPENABLE_RXPASSCRC_INCLUDE      1u

#define _EMAC_RXMBPENABLE_RXQOSEN_MASK          0x20000000u
#define _EMAC_RXMBPENABLE_RXQOSEN_SHIFT         29u
#define  EMAC_RXMBPENABLE_RXQOSEN_DEFAULT	0x00000000u
#define EMAC_RXMBPENABLE_RXQOSEN_DISABLE        0u
#define EMAC_RXMBPENABLE_RXQOSEN_ENABLE         1u

#define _EMAC_RXMBPENABLE_RXNOCHAIN_MASK        0x10000000u
#define _EMAC_RXMBPENABLE_RXNOCHAIN_SHIFT       28u
#define  EMAC_RXMBPENABLE_RXNOCHAIN_DEFAULT	0x00000000u
#define EMAC_RXMBPENABLE_RXNOCHAIN_DISABLE      0u
#define EMAC_RXMBPENABLE_RXNOCHAIN_ENABLE       1u

#define _EMAC_RXMBPENABLE_RXCMFEN_MASK          0x01000000u
#define _EMAC_RXMBPENABLE_RXCMFEN_SHIFT         24u
#define  EMAC_RXMBPENABLE_RXCMFEN_DEFAULT	0x00000000u
#define EMAC_RXMBPENABLE_RXCMFEN_DISABLE        0u
#define EMAC_RXMBPENABLE_RXCMFEN_ENABLE         1u

#define _EMAC_RXMBPENABLE_RXCSFEN_MASK          0x00800000u
#define _EMAC_RXMBPENABLE_RXCSFEN_SHIFT         23u
#define  EMAC_RXMBPENABLE_RXCSFEN_DEFAULT	0x00000000u
#define EMAC_RXMBPENABLE_RXCSFEN_DISABLE        0u
#define EMAC_RXMBPENABLE_RXCSFEN_ENABLE         1u

#define _EMAC_RXMBPENABLE_RXCEFEN_MASK          0x00400000u
#define _EMAC_RXMBPENABLE_RXCEFEN_SHIFT         22u
#define  EMAC_RXMBPENABLE_RXCEFEN_DEFAULT	0x00000000u
#define EMAC_RXMBPENABLE_RXCEFEN_DISABLE        0u
#define EMAC_RXMBPENABLE_RXCEFEN_ENABLE         1u

#define _EMAC_RXMBPENABLE_RXCAFEN_MASK          0x00200000u
#define _EMAC_RXMBPENABLE_RXCAFEN_SHIFT         21u
#define  EMAC_RXMBPENABLE_RXCAFEN_DEFAULT	0x00000000u
#define EMAC_RXMBPENABLE_RXCAFEN_DISABLE        0u
#define EMAC_RXMBPENABLE_RXCAFEN_ENABLE         1u

#define _EMAC_RXMBPENABLE_PROMCH_MASK           0x00070000u
#define _EMAC_RXMBPENABLE_PROMCH_SHIFT          16u
#define  EMAC_RXMBPENABLE_PROMCH_DEFAULT	0x00000000u

#define _EMAC_RXMBPENABLE_BROADEN_MASK          0x00002000u
#define _EMAC_RXMBPENABLE_BROADEN_SHIFT         13u
#define  EMAC_RXMBPENABLE_BROADEN_DEFAULT	0x00000000u
#define  EMAC_RXMBPENABLE_BROADEN_DISABLE	0u
#define  EMAC_RXMBPENABLE_BROADEN_ENABLE         1u

#define _EMAC_RXMBPENABLE_BROADCH_MASK          0x00000700u
#define _EMAC_RXMBPENABLE_BROADCH_SHIFT         8u
#define  EMAC_RXMBPENABLE_BROADCH_DEFAULT	0x00000000u

#define _EMAC_RXMBPENABLE_MULTEN_MASK           0x00000020u
#define _EMAC_RXMBPENABLE_MULTEN_SHIFT          5u
#define  EMAC_RXMBPENABLE_MULTEN_DEFAULT	0x00000000u
#define EMAC_RXMBPENABLE_MULTEN_DISABLE         0u
#define EMAC_RXMBPENABLE_MULTEN_ENABLE          1u

#define _EMAC_RXMBPENABLE_MULTCH_MASK           0x00000007u
#define _EMAC_RXMBPENABLE_MULTCH_SHIFT          0u
#define  EMAC_RXMBPENABLE_MULTCH_DEFAULT	0x00000000u
/******************************************************************************\
* _____________________
* |                   |
* |  RXUNICASTSET     |
* |  RXUNICASTCLEAR   |
* |___________________|
*
* RXUNICASTSET      - RX Unicast Set Register
* RXUNICASTCLEAR    - RX Unicast Clear Register
*
* FIELDS (msb -> lsb)
*  (r/ws)(r/wc)  Channel Flags (use EMAC_FMKCHF)
*
* MACROS SUPPORTED
*  EMAC_FMK     .
*  EMAC_FMKS    .
*  EMAC_FMKCHF  y
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    .
*  EMAC_FSET    .
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXUNICASTSET_ADDR                 (_EMAC_BASE_ADDR+0x0104u)
#define _EMAC_RXUNICASTCLEAR_ADDR               (_EMAC_BASE_ADDR+0x0108u)

#define EMAC_RXUNICASTSET                       EMAC_REG(RXUNICASTSET)
#define EMAC_RXUNICASTCLEAR                     EMAC_REG(RXUNICASTCLEAR)



/******************************************************************************\
* _____________________
* |                   |
* |  RXMAXLEN         |
* |___________________|
*
* MAXLEN            - RX Maximum Length Register
*
* FIELDS (msb -> lsb)
*  (rw)  RXMAXLEN
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXMAXLEN_ADDR                     (_EMAC_BASE_ADDR+0x010Cu)

#define EMAC_RXMAXLEN                           EMAC_REG(RXMAXLEN)

#define _EMAC_RXMAXLEN_MAXLEN_MASK              0x0000FFFFu
#define _EMAC_RXMAXLEN_MAXLEN_SHIFT             0u
#define  EMAC_RXMAXLEN_MAXLEN_DEFAULT		0x000005EEu

/******************************************************************************\
* _____________________
* |                   |
* |  RXBUFFEROFFSET   |
* |___________________|
*
* RXBUFFEROFFSET        - RX Buffer Offset Register
*
* FIELDS (msb -> lsb)
*  (rw)  BUFFEROFFSET
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXBUFFEROFFSET_ADDR               (_EMAC_BASE_ADDR+0x0110u)

#define EMAC_RXBUFFEROFFSET                     EMAC_REG(RXBUFFEROFFSET)

#define _EMAC_RXBUFFEROFFSET_BUFFEROFFSET_MASK  0x0000FFFFu
#define _EMAC_RXBUFFEROFFSET_BUFFEROFFSET_SHIFT 0u
#define  EMAC_RXBUFFEROFFSET_BUFFEROFFSET_DEFAULT 0x00000000u
/******************************************************************************\
* _____________________
* |                   |
* | RXFILTERLOWTHRESH |
* |___________________|
*
* RXFILTERLOWTHRESH - RX Filer Low Priority Packets Threshhold
*
* FIELDS (msb -> lsb)
*  (rw)  FILTERTHRESH
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXFILTERLOWTHRESH_ADDR            (_EMAC_BASE_ADDR+0x0114u)

#define EMAC_RXFILTERLOWTHRESH                  EMAC_REG(RXFILTERLOWTHRESH)

#define _EMAC_RXFILTERLOWTHRESH_FILTERTHRESH_MASK    0x000000FFu
#define _EMAC_RXFILTERLOWTHRESH_FILTERTHRESH_SHIFT   0u
#define  EMAC_RXFILTERLOWTHRESH_FILTERTHRESH_DEFAULT 0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |   RXFLOWTHRESH    |
* |   RXnFLOWTHRESH   |
* |___________________|
*
* RXFLOWTHRESH      - RX Flow Control Threshhold for RSETI/RGETI
* RX0FLOWTHRESH     - RX Channel 0 Flow Control Threshhold
* RX1FLOWTHRESH     - RX Channel 1 Flow Control Threshhold
* RX2FLOWTHRESH     - RX Channel 2 Flow Control Threshhold
* RX3FLOWTHRESH     - RX Channel 3 Flow Control Threshhold
* RX4FLOWTHRESH     - RX Channel 4 Flow Control Threshhold
* RX5FLOWTHRESH     - RX Channel 5 Flow Control Threshhold
* RX6FLOWTHRESH     - RX Channel 6 Flow Control Threshhold
* RX7FLOWTHRESH     - RX Channel 7 Flow Control Threshhold
*
* FIELDS (msb -> lsb)
*  (rw)  FLOWTHRESH
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   y
*  EMAC_RSETI   y
*  EMAC_FGETI   y
*  EMAC_FSETI   y
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXFLOWTHRESH_BASEADDR             (_EMAC_BASE_ADDR+0x0120u)
#define _EMAC_RX0FLOWTHRESH_ADDR                (_EMAC_BASE_ADDR+0x0120u)
#define _EMAC_RX1FLOWTHRESH_ADDR                (_EMAC_BASE_ADDR+0x0124u)
#define _EMAC_RX2FLOWTHRESH_ADDR                (_EMAC_BASE_ADDR+0x0128u)
#define _EMAC_RX3FLOWTHRESH_ADDR                (_EMAC_BASE_ADDR+0x012Cu)
#define _EMAC_RX4FLOWTHRESH_ADDR                (_EMAC_BASE_ADDR+0x0130u)
#define _EMAC_RX5FLOWTHRESH_ADDR                (_EMAC_BASE_ADDR+0x0134u)
#define _EMAC_RX6FLOWTHRESH_ADDR                (_EMAC_BASE_ADDR+0x0138u)
#define _EMAC_RX7FLOWTHRESH_ADDR                (_EMAC_BASE_ADDR+0x013Cu)

#define EMAC_RX0FLOWTHRESH                      EMAC_REG(RX0FLOWTHRESH)
#define EMAC_RX1FLOWTHRESH                      EMAC_REG(RX1FLOWTHRESH)
#define EMAC_RX2FLOWTHRESH                      EMAC_REG(RX2FLOWTHRESH)
#define EMAC_RX3FLOWTHRESH                      EMAC_REG(RX3FLOWTHRESH)
#define EMAC_RX4FLOWTHRESH                      EMAC_REG(RX4FLOWTHRESH)
#define EMAC_RX5FLOWTHRESH                      EMAC_REG(RX5FLOWTHRESH)
#define EMAC_RX6FLOWTHRESH                      EMAC_REG(RX6FLOWTHRESH)
#define EMAC_RX7FLOWTHRESH                      EMAC_REG(RX7FLOWTHRESH)

#define _EMAC_RXFLOWTHRESH_FLOWTHRESH_MASK      0x000000FFu
#define _EMAC_RXFLOWTHRESH_FLOWTHRESH_SHIFT     0u
#define  EMAC_RXFLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
#define _EMAC_RX0FLOWTHRESH_FLOWTHRESH_MASK     0x000000FFu
#define _EMAC_RX0FLOWTHRESH_FLOWTHRESH_SHIFT    0u
#define  EMAC_RX0FLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
#define _EMAC_RX1FLOWTHRESH_FLOWTHRESH_MASK     0x000000FFu
#define _EMAC_RX1FLOWTHRESH_FLOWTHRESH_SHIFT    0u
#define  EMAC_RX1FLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
#define _EMAC_RX2FLOWTHRESH_FLOWTHRESH_MASK     0x000000FFu
#define _EMAC_RX2FLOWTHRESH_FLOWTHRESH_SHIFT    0u
#define  EMAC_RX2FLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
#define _EMAC_RX3FLOWTHRESH_FLOWTHRESH_MASK     0x000000FFu
#define _EMAC_RX3FLOWTHRESH_FLOWTHRESH_SHIFT    0u
#define  EMAC_RX3FLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
#define _EMAC_RX4FLOWTHRESH_FLOWTHRESH_MASK     0x000000FFu
#define _EMAC_RX4FLOWTHRESH_FLOWTHRESH_SHIFT    0u
#define  EMAC_RX4FLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
#define _EMAC_RX5FLOWTHRESH_FLOWTHRESH_MASK     0x000000FFu
#define _EMAC_RX5FLOWTHRESH_FLOWTHRESH_SHIFT    0u
#define  EMAC_RX5FLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
#define _EMAC_RX6FLOWTHRESH_FLOWTHRESH_MASK     0x000000FFu
#define _EMAC_RX6FLOWTHRESH_FLOWTHRESH_SHIFT    0u
#define  EMAC_RX6FLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
#define _EMAC_RX7FLOWTHRESH_FLOWTHRESH_MASK     0x000000FFu
#define _EMAC_RX7FLOWTHRESH_FLOWTHRESH_SHIFT    0u
#define  EMAC_RX7FLOWTHRESH_FLOWTHRESH_DEFAULT	0x00000000u
/******************************************************************************\
* _____________________
* |                   |
* |   RXFREEBUFFER    |
* |   RXnFREEBUFFER   |
* |___________________|
*
* RXFREEBUFFER      - RX Free Buffer Count for RSETI/RGETI
* RX0FREEBUFFER     - RX Channel 0 Free Buffer Count Register
* RX1FREEBUFFER     - RX Channel 1 Free Buffer Count Register
* RX2FREEBUFFER     - RX Channel 2 Free Buffer Count Register
* RX3FREEBUFFER     - RX Channel 3 Free Buffer Count Register
* RX4FREEBUFFER     - RX Channel 4 Free Buffer Count Register
* RX5FREEBUFFER     - RX Channel 5 Free Buffer Count Register
* RX6FREEBUFFER     - RX Channel 6 Free Buffer Count Register
* RX7FREEBUFFER     - RX Channel 7 Free Buffer Count Register
*
* FIELDS (msb -> lsb)
*  (rw)  FREEBUF
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   y
*  EMAC_RSETI   y
*  EMAC_FGETI   y
*  EMAC_FSETI   y
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXFREEBUFFER_BASEADDR             (_EMAC_BASE_ADDR+0x0140u)
#define _EMAC_RX0FREEBUFFER_ADDR                (_EMAC_BASE_ADDR+0x0140u)
#define _EMAC_RX1FREEBUFFER_ADDR                (_EMAC_BASE_ADDR+0x0144u)
#define _EMAC_RX2FREEBUFFER_ADDR                (_EMAC_BASE_ADDR+0x0148u)
#define _EMAC_RX3FREEBUFFER_ADDR                (_EMAC_BASE_ADDR+0x014Cu)
#define _EMAC_RX4FREEBUFFER_ADDR                (_EMAC_BASE_ADDR+0x0150u)
#define _EMAC_RX5FREEBUFFER_ADDR                (_EMAC_BASE_ADDR+0x0154u)
#define _EMAC_RX6FREEBUFFER_ADDR                (_EMAC_BASE_ADDR+0x0158u)
#define _EMAC_RX7FREEBUFFER_ADDR                (_EMAC_BASE_ADDR+0x015Cu)

#define EMAC_RX0FREEBUFFER                      EMAC_REG(RX0FREEBUFFER)
#define EMAC_RX1FREEBUFFER                      EMAC_REG(RX1FREEBUFFER)
#define EMAC_RX2FREEBUFFER                      EMAC_REG(RX2FREEBUFFER)
#define EMAC_RX3FREEBUFFER                      EMAC_REG(RX3FREEBUFFER)
#define EMAC_RX4FREEBUFFER                      EMAC_REG(RX4FREEBUFFER)
#define EMAC_RX5FREEBUFFER                      EMAC_REG(RX5FREEBUFFER)
#define EMAC_RX6FREEBUFFER                      EMAC_REG(RX6FREEBUFFER)
#define EMAC_RX7FREEBUFFER                      EMAC_REG(RX7FREEBUFFER)

#define _EMAC_RXFREEBUFFER_FREEBUF_MASK         0x0000FFFFu
#define _EMAC_RXFREEBUFFER_FREEBUF_SHIFT        0u
#define	 EMAC_RXFREEBUFFER_FREEBUF_DEFAULT	0x00000000u
#define _EMAC_RX0FREEBUFFER_FREEBUF_MASK        0x0000FFFFu
#define _EMAC_RX0FREEBUFFER_FREEBUF_SHIFT       0u
#define  EMAC_RX0FREEBUFFER_FREEBUF_DEFAULT	0x00000000u
#define _EMAC_RX1FREEBUFFER_FREEBUF_MASK        0x0000FFFFu
#define _EMAC_RX1FREEBUFFER_FREEBUF_SHIFT       0u
#define  EMAC_RX1FREEBUFFER_FREEBUF_DEFAULT	0x00000000u
#define _EMAC_RX2FREEBUFFER_FREEBUF_MASK        0x0000FFFFu
#define _EMAC_RX2FREEBUFFER_FREEBUF_SHIFT       0u
#define  EMAC_RX2FREEBUFFER_FREEBUF_DEFAULT	0x00000000u
#define _EMAC_RX3FREEBUFFER_FREEBUF_MASK        0x0000FFFFu
#define _EMAC_RX3FREEBUFFER_FREEBUF_SHIFT       0u
#define  EMAC_RX3FREEBUFFER_FREEBUF_DEFAULT	0x00000000u
#define _EMAC_RX4FREEBUFFER_FREEBUF_MASK        0x0000FFFFu
#define _EMAC_RX4FREEBUFFER_FREEBUF_SHIFT       0u
#define  EMAC_RX4FREEBUFFER_FREEBUF_DEFAULT	0x00000000u
#define _EMAC_RX5FREEBUFFER_FREEBUF_MASK        0x0000FFFFu
#define _EMAC_RX5FREEBUFFER_FREEBUF_SHIFT       0u
#define  EMAC_RX5FREEBUFFER_FREEBUF_DEFAULT	0x00000000u
#define _EMAC_RX6FREEBUFFER_FREEBUF_MASK        0x0000FFFFu
#define _EMAC_RX6FREEBUFFER_FREEBUF_SHIFT       0u
#define  EMAC_RX6FREEBUFFER_FREEBUF_DEFAULT	0x00000000u
#define _EMAC_RX7FREEBUFFER_FREEBUF_MASK        0x0000FFFFu
#define _EMAC_RX7FREEBUFFER_FREEBUF_SHIFT       0u
#define  EMAC_RX7FREEBUFFER_FREEBUF_DEFAULT	0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |   MACCONTROL      |
* |___________________|
*
* MACCONTROL        - MAC Control Register
*
* FIELDS (msb -> lsb)
* (rw)  TXPTYPE     - TX Priority Queue Type
* (rw)  TXPACE      - TX Pacing Enable
* (rw)  MIIEN       - MII Enable
* (rw)  TXFLOWEN    - TX Flow Control Enable
* (rw)  RXFLOWEN    - RX Flow Control Enable
* (rw)  MTEST       - Manufacturer's Test Enable
* (rw)  LOOPBACK    - Loopback Mode Enable
* (rw)  FULLDUPLEX  - Full Duplex Mode Enable
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    y
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   y
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACCONTROL_ADDR                   (_EMAC_BASE_ADDR+0x0160u)

#define EMAC_MACCONTROL                         EMAC_REG(MACCONTROL)

#define _EMAC_MACCONTROL_TXPTYPE_MASK           0x00000200u
#define _EMAC_MACCONTROL_TXPTYPE_SHIFT          9u
#define  EMAC_MACCONTROL_TXPTYPE_DEFAULT	0x00000000u
#define EMAC_MACCONTROL_TXPTYPE_RROBIN          0u
#define EMAC_MACCONTROL_TXPTYPE_CHANNELPRI      1u

#define _EMAC_MACCONTROL_TXPACE_MASK            0x00000040u
#define _EMAC_MACCONTROL_TXPACE_SHIFT           6u
#define  EMAC_MACCONTROL_TXPACE_DEFAULT		0x00000000u
#define EMAC_MACCONTROL_TXPACE_DISABLE          0u
#define EMAC_MACCONTROL_TXPACE_ENABLE           1u

#define _EMAC_MACCONTROL_MIIEN_MASK             0x00000020u
#define _EMAC_MACCONTROL_MIIEN_SHIFT            5u
#define  EMAC_MACCONTROL_MIIEN_DEFAULT		0x00000000u
#define EMAC_MACCONTROL_MIIEN_DISABLE           0u
#define EMAC_MACCONTROL_MIIEN_ENABLE            1u

#define _EMAC_MACCONTROL_TXFLOWEN_MASK          0x00000010u
#define _EMAC_MACCONTROL_TXFLOWEN_SHIFT         4u
#define  EMAC_MACCONTROL_TXFLOWEN_DEFAULT	0x00000000u
#define EMAC_MACCONTROL_TXFLOWEN_DISABLE        0u
#define EMAC_MACCONTROL_TXFLOWEN_ENABLE         1u

#define _EMAC_MACCONTROL_RXFLOWEN_MASK          0x00000008u
#define _EMAC_MACCONTROL_RXFLOWEN_SHIFT         3u
#define  EMAC_MACCONTROL_RXFLOWEN_DEFAULT	0x00000000u
#define EMAC_MACCONTROL_RXFLOWEN_DISABLE        0u
#define EMAC_MACCONTROL_RXFLOWEN_ENABLE         1u

#define _EMAC_MACCONTROL_MTEST_MASK             0x00000004u
#define _EMAC_MACCONTROL_MTEST_SHIFT            2u
#define  EMAC_MACCONTROL_MTEST_DEFAULT		0x00000000u
#define EMAC_MACCONTROL_MTEST_DISABLE           0u
#define EMAC_MACCONTROL_MTEST_ENABLE            1u

#define _EMAC_MACCONTROL_LOOPBACK_MASK          0x00000002u
#define _EMAC_MACCONTROL_LOOPBACK_SHIFT         1u
#define  EMAC_MACCONTROL_LOOPBACK_DEFAULT	0x00000000u
#define EMAC_MACCONTROL_LOOPBACK_DISABLE        0u
#define EMAC_MACCONTROL_LOOPBACK_ENABLE         1u

#define _EMAC_MACCONTROL_FULLDUPLEX_MASK        0x00000001u
#define _EMAC_MACCONTROL_FULLDUPLEX_SHIFT       0u
#define  EMAC_MACCONTROL_FULLDUPLEX_DEFAULT	0x00000000u
#define EMAC_MACCONTROL_FULLDUPLEX_DISABLE      0u
#define EMAC_MACCONTROL_FULLDUPLEX_ENABLE       1u



/******************************************************************************\
* _____________________
* |                   |
* |   MACSTATUS       |
* |___________________|
*
* MACSTATUS         - MAC Status Register
*
* FIELDS (msb -> lsb)
* (r)  TXERRCODE    - TX Host Error Code
* (r)  THERRCH      - TX Host Error Channel
* (r)  RXERRCODE    - RX Host Error Code
* (r)  RXERRCH      - RX Host Error Channel
* (r)  RXQOSACT     - RX QOS Service Currently Active
* (r)  RXFLOWACT    - RX Flow Control Currently Active
* (r)  TXFLOWACT    - TX Flow Control Currently Active
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    y
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   y
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACSTATUS_ADDR                    (_EMAC_BASE_ADDR+0x0164u)

#define EMAC_MACSTATUS                          EMAC_REG(MACSTATUS)

#define _EMAC_MACSTATUS_TXERRCODE_MASK          0x00F00000u
#define _EMAC_MACSTATUS_TXERRCODE_SHIFT         20u
#define  EMAC_MACSTATUS_TXERRCODE_DEFAULT	0x00000000u
#define EMAC_MACSTATUS_TXERRCODE_NOERROR        0u
#define EMAC_MACSTATUS_TXERRCODE_SOPERROR       1u
#define EMAC_MACSTATUS_TXERRCODE_OWNERSHIP      2u
#define EMAC_MACSTATUS_TXERRCODE_NOEOP          3u
#define EMAC_MACSTATUS_TXERRCODE_NULLPTR        4u
#define EMAC_MACSTATUS_TXERRCODE_NULLLEN        5u
#define EMAC_MACSTATUS_TXERRCODE_LENRRROR       6u

#define _EMAC_MACSTATUS_TXERRCH_MASK            0x00070000u
#define _EMAC_MACSTATUS_TXERRCH_SHIFT           16u
#define  EMAC_MACSTATUS_TXERRCH_DEFAULT		0x00000000u

#define _EMAC_MACSTATUS_RXERRCODE_MASK          0x0000F000u
#define _EMAC_MACSTATUS_RXERRCODE_SHIFT         12u
#define  EMAC_MACSTATUS_RXERRCODE_DEFAULT	0x00000000u
#define EMAC_MACSTATUS_RXERRCODE_NOERROR        0u
#define EMAC_MACSTATUS_RXERRCODE_SOPERROR       1u
#define EMAC_MACSTATUS_RXERRCODE_OWNERSHIP      2u
#define EMAC_MACSTATUS_RXERRCODE_NOEOP          3u
#define EMAC_MACSTATUS_RXERRCODE_NULLPTR        4u
#define EMAC_MACSTATUS_RXERRCODE_NULLLEN        5u
#define EMAC_MACSTATUS_RXERRCODE_LENRRROR       6u

#define _EMAC_MACSTATUS_RXERRCH_MASK            0x00000700u
#define _EMAC_MACSTATUS_RXERRCH_SHIFT           8u
#define  EMAC_MACSTATUS_RXERRCH_DEFAULT		0x00000000u

#define _EMAC_MACSTATUS_RXQOSACT_MASK           0x00000004u
#define _EMAC_MACSTATUS_RXQOSACT_SHIFT          2u
#define  EMAC_MACSTATUS_RXQOSACT_DEFAULT	0x00000000u

#define _EMAC_MACSTATUS_RXFLOWACT_MASK          0x00000002u
#define _EMAC_MACSTATUS_RXFLOWACT_SHIFT         1u
#define  EMAC_MACSTATUS_RXFLOWACT_DEFAULT	0x00000000u

#define _EMAC_MACSTATUS_TXFLOWACT_MASK          0x00000001u
#define _EMAC_MACSTATUS_TXFLOWACT_SHIFT         0u
#define  EMAC_MACSTATUS_TXFLOWACT_DEFAULT	0x00000000u

/******************************************************************************\
* _____________________
* |                   |
* |   EMCONTROL       |
* |___________________|
*
* EMCONTROL         - Emulation Control Register
*
* FIELDS (msb -> lsb)
* (rw)  SOFT    - Emulation Soft Bit
* (rw)  FREE    - Emulation Free Bit
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_EMCONTROL_ADDR                    (_EMAC_BASE_ADDR+0x0168u)

#define EMAC_EMCONTROL                          EMAC_REG(EMCONTROL)

#define _EMAC_EMCONTROL_SOFT_MASK               0x00000002u
#define _EMAC_EMCONTROL_SOFT_SHIFT              1u

#define _EMAC_EMCONTROL_FREE_MASK               0x00000001u
#define _EMAC_EMCONTROL_FREE_SHIFT              0u



/******************************************************************************\
* _____________________
* |                   |
* |  MACINVECTOR      |
* |___________________|
*
* MACINVECTOR       - MAC Input Vector
*
* FIELDS (msb -> lsb)
*  (r) USERINT  - MDIO User Interrupt
*  (r) LINKINT  - MDIO Link Change Interrupt
*  (r) HOSTPEND - Host Pending Interrupt
*  (r) STATPEND - Statistics Interrupt
*  (r) RXPEND   - RX Pending Interrupt Flags (7-0)
*  (r) TXPEND   - TX Pending Interrupt Falgs (7-0)
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    .
*  EMAC_FGET    y
*  EMAC_FSET    .
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACINVECTOR_ADDR                  (_EMAC_BASE_ADDR+0x0180u)

#define EMAC_MACINVECTOR                        EMAC_REG(MACINVECTOR)

#define _EMAC_MACINVECTOR_USERINT_MASK          0x80000000u
#define _EMAC_MACINVECTOR_USERINT_SHIFT         31u
#define  EMAC_MACINVECTOR_USERINT_DEFAULT	0x00000000u
#define _EMAC_MACINVECTOR_LINKINT_MASK          0x40000000u
#define _EMAC_MACINVECTOR_LINKINT_SHIFT         30u
#define  EMAC_MACINVECTOR_LINKINT_DEFAULT	0x00000000u
#define _EMAC_MACINVECTOR_HOSTPEND_MASK         0x00020000u
#define _EMAC_MACINVECTOR_HOSTPEND_SHIFT        17u
#define  EMAC_MACINVECTOR_HOSTPEND_DEFAULT	0x00000000u
#define _EMAC_MACINVECTOR_STATPEND_MASK         0x00010000u
#define _EMAC_MACINVECTOR_STATPEND_SHIFT        16u
#define  EMAC_MACINVECTOR_STATPEND_DEFAULT	0x00000000u
#define _EMAC_MACINVECTOR_RXPEND_MASK           0x0000FF00u
#define _EMAC_MACINVECTOR_RXPEND_SHIFT          8u
#define  EMAC_MACINVECTOR_RXPEND_DEFAULT	0x00000000u
#define _EMAC_MACINVECTOR_TXPEND_MASK           0x000000FFu
#define _EMAC_MACINVECTOR_TXPEND_SHIFT          0u
#define  EMAC_MACINVECTOR_TXPEND_DEFAULT	0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |  MACEOIVECTOR     |
* |___________________|
*
* MACEOIVECTOR      - MAC EOI Vector
*
* FIELDS (msb -> lsb)
*  (r/w) Flags
*
* MACROS SUPPORTED
*  EMAC_FMK     .
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    .
*  EMAC_FSET    .
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACEOIVECTOR_ADDR                 (_EMAC_BASE_ADDR+0x0184u)

#define EMAC_MACEOIVECTOR                       EMAC_REG(MACEOIVECTOR)


/******************************************************************************\
* _____________________
* |                   |
* |  TXINTSTATRAW     |
* |  TXINTSTATMASKED  |
* |  TXINTMASKSET     |
* |  TXINTMASKCLEAR   |
* |  RXINTSTATRAW     |
* |  RXINTSTATMASKED  |
* |  RXINTMASKSET     |
* |  RXINTMASKCLEAR   |
* |___________________|
*
* TXINTSTATRAW      - TX Interrupt Status Register (Unmasked)
* TXINTSTATMASKED   - TX Interrupt Status Register (Masked)
* TXINTMASKSET      - TX Interrupt Mask Set Register
* TXINTMASKCLEAR    - TX Interrupt Mask Clear Register
* RXINTSTATRAW      - RX Interrupt Status Register (Unmasked)
* RXINTSTATMASKED   - RX Interrupt Status Register (Masked)
* RXINTMASKSET      - RX Interrupt Mask Set Register
* RXINTMASKCLEAR    - RX Interrupt Mask Clear Register
*
* FIELDS (msb -> lsb)
*  (r)(r/ws)(r/wc) Channel Flags (use EMAC_FMKCHF)
*
* MACROS SUPPORTED
*  EMAC_FMK     .
*  EMAC_FMKS    .
*  EMAC_FMKCHF  y
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    .
*  EMAC_FSET    .
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_TXINTSTATRAW_ADDR                 (_EMAC_BASE_ADDR+0x0170u)
#define _EMAC_TXINTSTATMASKED_ADDR              (_EMAC_BASE_ADDR+0x0174u)
#define _EMAC_TXINTMASKSET_ADDR                 (_EMAC_BASE_ADDR+0x0178u)
#define _EMAC_TXINTMASKCLEAR_ADDR               (_EMAC_BASE_ADDR+0x017Cu)
#define _EMAC_RXINTSTATRAW_ADDR                 (_EMAC_BASE_ADDR+0x0190u)
#define _EMAC_RXINTSTATMASKED_ADDR              (_EMAC_BASE_ADDR+0x0194u)
#define _EMAC_RXINTMASKSET_ADDR                 (_EMAC_BASE_ADDR+0x0198u)
#define _EMAC_RXINTMASKCLEAR_ADDR               (_EMAC_BASE_ADDR+0x019Cu)

#define EMAC_TXINTSTATRAW                       EMAC_REG(TXINTSTATRAW)
#define EMAC_TXINTSTATMASKED                    EMAC_REG(TXINTSTATMASKED)
#define EMAC_TXINTMASKSET                       EMAC_REG(TXINTMASKSET)
#define EMAC_TXINTMASKCLEAR                     EMAC_REG(TXINTMASKCLEAR)
#define EMAC_RXINTSTATRAW                       EMAC_REG(RXINTSTATRAW)
#define EMAC_RXINTSTATMASKED                    EMAC_REG(RXINTSTATMASKED)
#define EMAC_RXINTMASKSET                       EMAC_REG(RXINTMASKSET)
#define EMAC_RXINTMASKCLEAR                     EMAC_REG(RXINTMASKCLEAR)



/******************************************************************************\
* _____________________
* |                   |
* |  MACINTSTATRAW    |
* |  MACINTSTATMASKED |
* |  MACINTMASKSET    |
* |  MACINTMASKCLEAR  |
* |___________________|
*
* MACINTSTATRAW     - MAC Interrupt Status Register (Unmasked)
* MACINTSTATMASKED  - MAC Interrupt Status Register (Masked)
* MACINTMASKSET     - MAC Interrupt Mask Set Register
* MACINTMASKCLEAR   - MAC Interrupt Mask Clear Register
*
* FIELDS (msb -> lsb)
* (r)(r/ws)(r/wc) HOSTERRINT  - Host Error Interrupt
* (r)(r/ws)(r/wc) STATINT     - Statistics Interrupt
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACINTSTATRAW_ADDR                (_EMAC_BASE_ADDR+0x01A0u)
#define _EMAC_MACINTSTATMASKED_ADDR             (_EMAC_BASE_ADDR+0x01A4u)
#define _EMAC_MACINTMASKSET_ADDR                (_EMAC_BASE_ADDR+0x01A8u)
#define _EMAC_MACINTMASKCLEAR_ADDR              (_EMAC_BASE_ADDR+0x01ACu)

#define EMAC_MACINTSTATRAW                      EMAC_REG(MACINTSTATRAW)
#define EMAC_MACINTSTATMASKED                   EMAC_REG(MACINTSTATMASKED)
#define EMAC_MACINTMASKSET                      EMAC_REG(MACINTMASKSET)
#define EMAC_MACINTMASKCLEAR                    EMAC_REG(MACINTMASKCLEAR)

#define _EMAC_MACINTSTATRAW_HOSTERRINT_MASK     0x00000002u
#define _EMAC_MACINTSTATMASKED_HOSTERRINT_MASK  0x00000002u
#define _EMAC_MACINTMASKSET_HOSTERRINT_MASK     0x00000002u
#define _EMAC_MACINTMASKCLEAR_HOSTERRINT_MASK   0x00000002u
#define _EMAC_MACINTSTATRAW_HOSTERRINT_SHIFT    1u
#define  EMAC_MACINTSTATRAW_HOSTERRINT_DEFAULT	0x00000000u
#define _EMAC_MACINTSTATMASKED_HOSTERRINT_SHIFT 1u
#define  EMAC_MACINTSTATMASKED_HOSTERRINT_DEFAULT 0x00000000u
#define _EMAC_MACINTMASKSET_HOSTERRINT_SHIFT    1u
#define  EMAC_MACINTMASKSET_HOSTERRINT_DEFAULT	0x00000000u
#define _EMAC_MACINTMASKCLEAR_HOSTERRINT_SHIFT  1u
#define  EMAC_MACINTMASKCLEAR_HOSTERRINT_DEFAULT 0x00000000u

#define _EMAC_MACINTSTATRAW_STATINT_MASK        0x00000001u
#define _EMAC_MACINTSTATMASKED_STATINT_MASK     0x00000001u
#define _EMAC_MACINTMASKSET_STATINT_MASK        0x00000001u
#define _EMAC_MACINTMASKCLEAR_STATINT_MASK      0x00000001u
#define _EMAC_MACINTSTATRAW_STATINT_SHIFT       0u
#define  EMAC_MACINTSTATRAW_STATINT_DEFAULT	0x00000000u
#define _EMAC_MACINTSTATMASKED_STATINT_SHIFT    0u
#define  EMAC_MACINTSTATMASKED_STATINT_DEFAULT	0x00000000u
#define _EMAC_MACINTMASKSET_STATINT_SHIFT       0u
#define  EMAC_MACINTMASKSET_STATINT_DEFAULT	0x00000000u
#define _EMAC_MACINTMASKCLEAR_STATINT_SHIFT     0u
#define  EMAC_MACINTMASKCLEAR_STATINT_DEFAULT	0x00000000u

/******************************************************************************\
* _____________________
* |                   |
* |   MACADDRL        |
* |   MACADDRLn       |
* |___________________|
*
* MACADDRL          - MAC Address Lower Byte Register for RSETI/RGETI
* MACADDRL0         - MAC Address Channel 0 Lower Byte Register
* MACADDRL1         - MAC Address Channel 1 Lower Byte Register
* MACADDRL2         - MAC Address Channel 2 Lower Byte Register
* MACADDRL3         - MAC Address Channel 3 Lower Byte Register
* MACADDRL4         - MAC Address Channel 4 Lower Byte Register
* MACADDRL5         - MAC Address Channel 5 Lower Byte Register
* MACADDRL6         - MAC Address Channel 6 Lower Byte Register
* MACADDRL7         - MAC Address Channel 7 Lower Byte Register
*
* FIELDS (msb -> lsb)
*  (rw)  MACADDR8   - 8 bits of MAC Address
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   y
*  EMAC_RSETI   y
*  EMAC_FGETI   y
*  EMAC_FSETI   y
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACADDRL_BASEADDR                 (_EMAC_BASE_ADDR+0x01B0u)
#define _EMAC_MACADDRL0_ADDR                    (_EMAC_BASE_ADDR+0x01B0u)
#define _EMAC_MACADDRL1_ADDR                    (_EMAC_BASE_ADDR+0x01B4u)
#define _EMAC_MACADDRL2_ADDR                    (_EMAC_BASE_ADDR+0x01B8u)
#define _EMAC_MACADDRL3_ADDR                    (_EMAC_BASE_ADDR+0x01BCu)
#define _EMAC_MACADDRL4_ADDR                    (_EMAC_BASE_ADDR+0x01C0u)
#define _EMAC_MACADDRL5_ADDR                    (_EMAC_BASE_ADDR+0x01C4u)
#define _EMAC_MACADDRL6_ADDR                    (_EMAC_BASE_ADDR+0x01C8u)
#define _EMAC_MACADDRL7_ADDR                    (_EMAC_BASE_ADDR+0x01CCu)

#define EMAC_MACADDRL0                          EMAC_REG(MACADDRL0)
#define EMAC_MACADDRL1                          EMAC_REG(MACADDRL1)
#define EMAC_MACADDRL2                          EMAC_REG(MACADDRL2)
#define EMAC_MACADDRL3                          EMAC_REG(MACADDRL3)
#define EMAC_MACADDRL4                          EMAC_REG(MACADDRL4)
#define EMAC_MACADDRL5                          EMAC_REG(MACADDRL5)
#define EMAC_MACADDRL6                          EMAC_REG(MACADDRL6)
#define EMAC_MACADDRL7                          EMAC_REG(MACADDRL7)

#define _EMAC_MACADDRL_MACADDR8_MASK            0x000000FFu
#define _EMAC_MACADDRL_MACADDR8_SHIFT           0u
#define  EMAC_MACADDRL_MACADDR8_DEFAULT		0x00000000u
#define _EMAC_MACADDRL0_MACADDR8_MASK           0x000000FFu
#define _EMAC_MACADDRL0_MACADDR8_SHIFT          0u
#define  EMAC_MACADDRL0_MACADDR8_DEFAULT	0x00000000u
#define _EMAC_MACADDRL1_MACADDR8_MASK           0x000000FFu
#define _EMAC_MACADDRL1_MACADDR8_SHIFT          0u
#define  EMAC_MACADDRL1_MACADDR8_DEFAULT	0x00000000u
#define _EMAC_MACADDRL2_MACADDR8_MASK           0x000000FFu
#define _EMAC_MACADDRL2_MACADDR8_SHIFT          0u
#define  EMAC_MACADDRL2_MACADDR8_DEFAULT	0x00000000u
#define _EMAC_MACADDRL3_MACADDR8_MASK           0x000000FFu
#define _EMAC_MACADDRL3_MACADDR8_SHIFT          0u
#define  EMAC_MACADDRL3_MACADDR8_DEFAULT	0x00000000u
#define _EMAC_MACADDRL4_MACADDR8_MASK           0x000000FFu
#define _EMAC_MACADDRL4_MACADDR8_SHIFT          0u
#define  EMAC_MACADDRL4_MACADDR8_DEFAULT	0x00000000u
#define _EMAC_MACADDRL5_MACADDR8_MASK           0x000000FFu
#define _EMAC_MACADDRL5_MACADDR8_SHIFT          0u
#define  EMAC_MACADDRL5_MACADDR8_DEFAULT	0x00000000u
#define _EMAC_MACADDRL6_MACADDR8_MASK           0x000000FFu
#define _EMAC_MACADDRL6_MACADDR8_SHIFT          0u
#define  EMAC_MACADDRL6_MACADDR8_DEFAULT	0x00000000u
#define _EMAC_MACADDRL7_MACADDR8_MASK           0x000000FFu
#define _EMAC_MACADDRL7_MACADDR8_SHIFT          0u
#define  EMAC_MACADDRL7_MACADDR8_DEFAULT	0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |   MACADDRM        |
* |___________________|
*
* MACADDRM          - MAC Address Byte 1 Register (bits 15:8)
*
* FIELDS (msb -> lsb)
*  (rw)  MACADDR8   - 8 bits of MAC Address
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACADDRM_ADDR                     (_EMAC_BASE_ADDR+0x01D0u)

#define EMAC_MACADDRM                           EMAC_REG(MACADDRM)

#define _EMAC_MACADDRM_MACADDR8_MASK            0x000000FFu
#define _EMAC_MACADDRM_MACADDR8_SHIFT           0u
#define  EMAC_MACADDRM_MACADDR8_DEFAULT		0x00000000u



/******************************************************************************\
* _____________________
* |                   |
* |   MACADDRH        |
* |___________________|
*
* MACADDRH          - MAC Address High Bytes Register (bits 47:16)
*
* FIELDS (msb -> lsb)
*  (rw)  MACADDR32  - 32 bits of MAC Address
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACADDRH_ADDR                     (_EMAC_BASE_ADDR+0x01D4u)

#define EMAC_MACADDRH                           EMAC_REG(MACADDRH)

#define _EMAC_MACADDRH_MACADDR32_MASK           0xFFFFFFFFu
#define _EMAC_MACADDRH_MACADDR32_SHIFT          0u
#define  EMAC_MACADDRH_MACADDR32_DEFAULT	0x00000000u



/******************************************************************************\
* _____________________
* |                   |
* |   MACHASH1        |
* |   MACHASH2        |
* |___________________|
*
* MACHASH1          - MAC Address Hash 1 Register
* MACHASH2          - MAC Address Hash 2 Register
*
* FIELDS (msb -> lsb)
*  (rw)  HASHBITS   - 32 Hash Bits
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_MACHASH1_ADDR                     (_EMAC_BASE_ADDR+0x01D8u)
#define _EMAC_MACHASH2_ADDR                     (_EMAC_BASE_ADDR+0x01DCu)

#define EMAC_MACHASH1                           EMAC_REG(MACHASH1)
#define EMAC_MACHASH2                           EMAC_REG(MACHASH2)

#define _EMAC_MACHASH1_HASHBITS_MASK            0xFFFFFFFFu
#define  EMAC_MACHASH1_HASHBITS_DEFAULT		0x00000000u
#define _EMAC_MACHASH1_HASHBITS_SHIFT           0u
#define _EMAC_MACHASH2_HASHBITS_MASK            0xFFFFFFFFu
#define _EMAC_MACHASH2_HASHBITS_SHIFT           0u
#define  EMAC_MACHASH2_HASHBITS_DEFAULT		0x00000000u




/******************************************************************************\
* _____________________
* |                   |
* |   BOFFTEST        |
* |___________________|
*
* BOFFTEST          - Backoff Test Register
*
* FIELDS (msb -> lsb)
*  (rw)  BOFFHALT   - Halt Random Number Generator
*  (rw)  ATTEMPT    - Initial Collision Attempt Count
*  (rw)  BOFFRNG    - Backoff Random Number Generator
*  (rw)  RETRYCOUNT - Retry Count
*  (rw)  BOFFCOUNT  - Backoff Current Count
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_BOFFTEST_ADDR                     (_EMAC_BASE_ADDR+0x01E0u)

#define EMAC_BOFFTEST                           EMAC_REG(BOFFTEST)

#define _EMAC_BOFFTEST_BOFFHALT_MASK            0x8000000u
#define _EMAC_BOFFTEST_BOFFHALT_SHIFT           31u
#define	 EMAC_BOFFTEST_BOFFHALT_DEFAULT		0x00000000u

#define _EMAC_BOFFTEST_ATTEMPT_MASK             0x78000000u
#define _EMAC_BOFFTEST_ATTEMPT_SHIFT            27u
#define  EMAC_BOFFTEST_ATTEMPT_DEFAULT		0x00000000u

#define _EMAC_BOFFTEST_BOFFRNG_MASK             0x07FF0000u
#define _EMAC_BOFFTEST_BOFFRNG_SHIFT            16u
#define  EMAC_BOFFTEST_BOFFRNG_DEFAULT		0x00000000u

#define _EMAC_BOFFTEST_RETRYCOUNT_MASK          0x0000F000u
#define _EMAC_BOFFTEST_RETRYCOUNT_SHIFT         12u
#define  EMAC_BOFFTEST_RETRYCOUNT_DEFAULT	0x00000000u

#define _EMAC_BOFFTEST_BOFFCOUNT_MASK           0x000003FFu
#define _EMAC_BOFFTEST_BOFFCOUNT_SHIFT          0u
#define  EMAC_BOFFTEST_BOFFCOUNT_DEFAULT	0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |   TPACETEST       |
* |___________________|
*
* TPACETEST         - Transmit Pacing Test Register
*
* FIELDS (msb -> lsb)
*  (rw)  PACEVAL    - Pace Register Current Value
*  (rw)  PACEINIT   - Pace Register Initial Value
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_TPACETEST_ADDR                      (_EMAC_BASE_ADDR+0x01E4u)

#define EMAC_TPACETEST                            EMAC_REG(TPACETEST)

#define _EMAC_TPACETEST_PACEVAL_MASK              0x0000001Fu
#define _EMAC_TPACETEST_PACEVAL_SHIFT             0u
#define  EMAC_TPACETEST_PACEVAL_DEFAULT		  0x00000000u 

/******************************************************************************\
* _____________________
* |                   |
* |    RXPAUSE        |
* |    TXPAUSE        |
* |___________________|
*
* RXPAUSE           - Receive Pause Timer Register
* TXPAUSE           - Transmit Pause Timer Register
*
* FIELDS (msb -> lsb)
*  (rw)  PAUSETIMER - Pause Timer
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXPAUSE_ADDR                      (_EMAC_BASE_ADDR+0x01E8u)
#define _EMAC_TXPAUSE_ADDR                      (_EMAC_BASE_ADDR+0x01ECu)

#define EMAC_RXPAUSE                            EMAC_REG(RXPAUSE)
#define EMAC_TXPAUSE                            EMAC_REG(TXPAUSE)

#define _EMAC_RXPAUSE_PAUSETIMER_MASK           0x0000FFFFu
#define _EMAC_RXPAUSE_PAUSETIMER_SHIFT          0u
#define  EMAC_RXPAUSE_PAUSETIMER_DEFAULT	0x00000000u

#define _EMAC_TXPAUSE_PAUSETIMER_MASK           0x0000FFFFu
#define _EMAC_TXPAUSE_PAUSETIMER_SHIFT          0u
#define  EMAC_TXPAUSE_PAUSETIMER_DEFAULT	0x00000000u

/******************************************************************************\
* _____________________
* |                   |
* |   TXHDP           |
* |   TXnHDP          |
* |___________________|
*
* TXHDP             - TX DMA Head Descriptor Pointer Register for RSETI/RGETI
* TX0HDP            - TX Channel 0 DMA Head Descriptor Pointer Register
* TX1HDP            - TX Channel 1 DMA Head Descriptor Pointer Register
* TX2HDP            - TX Channel 2 DMA Head Descriptor Pointer Register
* TX3HDP            - TX Channel 3 DMA Head Descriptor Pointer Register
* TX4HDP            - TX Channel 4 DMA Head Descriptor Pointer Register
* TX5HDP            - TX Channel 5 DMA Head Descriptor Pointer Register
* TX6HDP            - TX Channel 6 DMA Head Descriptor Pointer Register
* TX7HDP            - TX Channel 7 DMA Head Descriptor Pointer Register
*
* FIELDS (msb -> lsb)
*  (rw) DESCPTR     - Descriptor Pointer
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   y
*  EMAC_RSETI   y
*  EMAC_FGETI   y
*  EMAC_FSETI   y
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_TXHDP_BASEADDR                (_EMAC_BASE_ADDR+0x0600u)
#define _EMAC_TX0HDP_ADDR                   (_EMAC_BASE_ADDR+0x0600u)
#define _EMAC_TX1HDP_ADDR                   (_EMAC_BASE_ADDR+0x0604u)
#define _EMAC_TX2HDP_ADDR                   (_EMAC_BASE_ADDR+0x0608u)
#define _EMAC_TX3HDP_ADDR                   (_EMAC_BASE_ADDR+0x060Cu)
#define _EMAC_TX4HDP_ADDR                   (_EMAC_BASE_ADDR+0x0610u)
#define _EMAC_TX5HDP_ADDR                   (_EMAC_BASE_ADDR+0x0614u)
#define _EMAC_TX6HDP_ADDR                   (_EMAC_BASE_ADDR+0x0618u)
#define _EMAC_TX7HDP_ADDR                   (_EMAC_BASE_ADDR+0x061Cu)

#define EMAC_TX0HDP                         EMAC_REG(TX0HDP)
#define EMAC_TX1HDP                         EMAC_REG(TX1HDP)
#define EMAC_TX2HDP                         EMAC_REG(TX2HDP)
#define EMAC_TX3HDP                         EMAC_REG(TX3HDP)
#define EMAC_TX4HDP                         EMAC_REG(TX4HDP)
#define EMAC_TX5HDP                         EMAC_REG(TX5HDP)
#define EMAC_TX6HDP                         EMAC_REG(TX6HDP)
#define EMAC_TX7HDP                         EMAC_REG(TX7HDP)

#define _EMAC_TXHDP_DESCPTR_MASK            0xFFFFFFFFu
#define _EMAC_TXHDP_DESCPTR_SHIFT           0u
#define  EMAC_TXHDP_DESCPTR_DEFAULT         0x00000000u  
#define _EMAC_TX0HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_TX0HDP_DESCPTR_SHIFT          0u
#define  EMAC_TX0HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX1HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_TX1HDP_DESCPTR_SHIFT          0u
#define  EMAC_TX1HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX2HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_TX2HDP_DESCPTR_SHIFT          0u
#define  EMAC_TX2HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX3HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_TX3HDP_DESCPTR_SHIFT          0u
#define  EMAC_TX3HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX4HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_TX4HDP_DESCPTR_SHIFT          0u
#define  EMAC_TX4HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX5HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_TX5HDP_DESCPTR_SHIFT          0u
#define  EMAC_TX5HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX6HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_TX6HDP_DESCPTR_SHIFT          0u
#define  EMAC_TX6HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX7HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_TX7HDP_DESCPTR_SHIFT          0u
#define  EMAC_TX7HDP_DESCPTR_DEFAULT	    0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |   RXHDP           |
* |   RXnHDP          |
* |___________________|
*
* RXHDP             - RX DMA Head Descriptor Pointer Register for RSETI/RGETI
* RX0HDP            - RX Channel 0 DMA Head Descriptor Pointer Register
* RX1HDP            - RX Channel 1 DMA Head Descriptor Pointer Register
* RX2HDP            - RX Channel 2 DMA Head Descriptor Pointer Register
* RX3HDP            - RX Channel 3 DMA Head Descriptor Pointer Register
* RX4HDP            - RX Channel 4 DMA Head Descriptor Pointer Register
* RX5HDP            - RX Channel 5 DMA Head Descriptor Pointer Register
* RX6HDP            - RX Channel 6 DMA Head Descriptor Pointer Register
* RX7HDP            - RX Channel 7 DMA Head Descriptor Pointer Register
*
* FIELDS (msb -> lsb)
*  (rw) DESCPTR     - Descriptor Pointer
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   y
*  EMAC_RSETI   y
*  EMAC_FGETI   y
*  EMAC_FSETI   y
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXHDP_BASEADDR                (_EMAC_BASE_ADDR+0x0620u)
#define _EMAC_RX0HDP_ADDR                   (_EMAC_BASE_ADDR+0x0620u)
#define _EMAC_RX1HDP_ADDR                   (_EMAC_BASE_ADDR+0x0624u)
#define _EMAC_RX2HDP_ADDR                   (_EMAC_BASE_ADDR+0x0628u)
#define _EMAC_RX3HDP_ADDR                   (_EMAC_BASE_ADDR+0x062Cu)
#define _EMAC_RX4HDP_ADDR                   (_EMAC_BASE_ADDR+0x0630u)
#define _EMAC_RX5HDP_ADDR                   (_EMAC_BASE_ADDR+0x0634u)
#define _EMAC_RX6HDP_ADDR                   (_EMAC_BASE_ADDR+0x0638u)
#define _EMAC_RX7HDP_ADDR                   (_EMAC_BASE_ADDR+0x063Cu)

#define EMAC_RX0HDP                         EMAC_REG(RX0HDP)
#define EMAC_RX1HDP                         EMAC_REG(RX1HDP)
#define EMAC_RX2HDP                         EMAC_REG(RX2HDP)
#define EMAC_RX3HDP                         EMAC_REG(RX3HDP)
#define EMAC_RX4HDP                         EMAC_REG(RX4HDP)
#define EMAC_RX5HDP                         EMAC_REG(RX5HDP)
#define EMAC_RX6HDP                         EMAC_REG(RX6HDP)
#define EMAC_RX7HDP                         EMAC_REG(RX7HDP)

#define _EMAC_RXHDP_DESCPTR_MASK            0xFFFFFFFFu
#define _EMAC_RXHDP_DESCPTR_SHIFT           0u
#define  EMAC_RXHDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX0HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_RX0HDP_DESCPTR_SHIFT          0u
#define  EMAC_RX0HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX1HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_RX1HDP_DESCPTR_SHIFT          0u
#define  EMAC_RX1HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX2HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_RX2HDP_DESCPTR_SHIFT          0u
#define  EMAC_RX2HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX3HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_RX3HDP_DESCPTR_SHIFT          0u
#define  EMAC_Rx3HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX4HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_RX4HDP_DESCPTR_SHIFT          0u
#define  EMAC_RX4HDP_DESCPTR_DEFAULT        0x00000000u
#define _EMAC_RX5HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_RX5HDP_DESCPTR_SHIFT          0u
#define  EMAC_RX5HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX6HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_RX6HDP_DESCPTR_SHIFT          0u
#define  EMAC_RX6HDP_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX7HDP_DESCPTR_MASK           0xFFFFFFFFu
#define _EMAC_RX7HDP_DESCPTR_SHIFT          0u
#define  EMAC_RX7HDP_DESCPTR_DEFAULT	    0x00000000u
/***************************************************************************************************************************\
*  ___________________
* |   TXINTACK        |
* |   TXnINTACK       |
* |___________________|
*
* TXINTACK          - TX Interrupt Ack Register for RSETI/RGETI
* TX0INTACK         - TX Channel 0 Interrupt Acknowledge Register
* TX1INTACK         - TX Channel 1 Interrupt Acknowledge Register
* TX2INTACK         - TX Channel 2 Interrupt Acknowledge Register
* TX3INTACK         - TX Channel 3 Interrupt Acknowledge Register
* TX4INTACK         - TX Channel 4 Interrupt Acknowledge Register
* TX5INTACK         - TX Channel 5 Interrupt Acknowledge Register
* TX6INTACK         - TX Channel 6 Interrupt Acknowledge Register
* TX7INTACK         - TX Channel 7 Interrupt Acknowledge Register
*
* FIELDS (msb -> lsb)
*  (rw) DESCPTR     - Descriptor Pointer
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   y
*  EMAC_RSETI   y
*  EMAC_FGETI   y
*  EMAC_FSETI   y
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_TXINTACK_BASEADDR             (_EMAC_BASE_ADDR+0x0640u)
#define _EMAC_TX0INTACK_ADDR                (_EMAC_BASE_ADDR+0x0640u)
#define _EMAC_TX1INTACK_ADDR                (_EMAC_BASE_ADDR+0x0644u)
#define _EMAC_TX2INTACK_ADDR                (_EMAC_BASE_ADDR+0x0648u)
#define _EMAC_TX3INTACK_ADDR                (_EMAC_BASE_ADDR+0x064Cu)
#define _EMAC_TX4INTACK_ADDR                (_EMAC_BASE_ADDR+0x0650u)
#define _EMAC_TX5INTACK_ADDR                (_EMAC_BASE_ADDR+0x0654u)
#define _EMAC_TX6INTACK_ADDR                (_EMAC_BASE_ADDR+0x0658u)
#define _EMAC_TX7INTACK_ADDR                (_EMAC_BASE_ADDR+0x065Cu)

#define EMAC_TX0INTACK                      EMAC_REG(TX0INTACK)
#define EMAC_TX1INTACK                      EMAC_REG(TX1INTACK)
#define EMAC_TX2INTACK                      EMAC_REG(TX2INTACK)
#define EMAC_TX3INTACK                      EMAC_REG(TX3INTACK)
#define EMAC_TX4INTACK                      EMAC_REG(TX4INTACK)
#define EMAC_TX5INTACK                      EMAC_REG(TX5INTACK)
#define EMAC_TX6INTACK                      EMAC_REG(TX6INTACK)
#define EMAC_TX7INTACK                      EMAC_REG(TX7INTACK)

#define _EMAC_TXINTACK_DESCPTR_MASK         0xFFFFFFFFu
#define _EMAC_TXINTACK_DESCPTR_SHIFT        0u
#define  EMAC_TXINTACK_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX0INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_TX0INTACK_DESCPTR_SHIFT       0u
#define  EMAC_TX0INTACK_DESCPTR_DEFAULT	    0x00000000u 	 
#define _EMAC_TX1INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_TX1INTACK_DESCPTR_SHIFT       0u
#define  EMAC_TX1INTACK_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX2INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_TX2INTACK_DESCPTR_SHIFT       0u
#define  EMAC_TX2INTACK_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX3INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_TX3INTACK_DESCPTR_SHIFT       0u
#define  EMAC_TX3INTACK_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX4INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_TX4INTACK_DESCPTR_SHIFT       0u
#define  EMAC_TX4INTACK_DESCPTR_DEFAULT     0x00000000u
#define _EMAC_TX5INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_TX5INTACK_DESCPTR_SHIFT       0u
#define  EMAC_TX5INTACK_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX6INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_TX6INTACK_DESCPTR_SHIFT       0u
#define  EMAC_TX6INTACK_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_TX7INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_TX7INTACK_DESCPTR_SHIFT       0u
#define  EMAC_TX7INTACK_DESCPTR_DEFAULT	    0x00000000u

/******************************************************************************\
* _____________________
* |                   |
* |   RXINTACK        |
* |   RXnINTACK       |
* |___________________|
*
* RXINTACK          - RX Channel 0 Interrupt Ack Register for RSETI/RGETI
* RX0INTACK         - RX Channel 0 Interrupt Acknowledge Register
* RX1INTACK         - RX Channel 1 Interrupt Acknowledge Register
* RX2INTACK         - RX Channel 2 Interrupt Acknowledge Register
* RX3INTACK         - RX Channel 3 Interrupt Acknowledge Register
* RX4INTACK         - RX Channel 4 Interrupt Acknowledge Register
* RX5INTACK         - RX Channel 5 Interrupt Acknowledge Register
* RX6INTACK         - RX Channel 6 Interrupt Acknowledge Register
* RX7INTACK         - RX Channel 7 Interrupt Acknowledge Register
*
* FIELDS (msb -> lsb)
*  (rw) DESCPTR     - Descriptor Pointer
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   y
*  EMAC_RSETI   y
*  EMAC_FGETI   y
*  EMAC_FSETI   y
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXINTACK_BASEADDR             (_EMAC_BASE_ADDR+0x0660u)
#define _EMAC_RX0INTACK_ADDR                (_EMAC_BASE_ADDR+0x0660u)
#define _EMAC_RX1INTACK_ADDR                (_EMAC_BASE_ADDR+0x0664u)
#define _EMAC_RX2INTACK_ADDR                (_EMAC_BASE_ADDR+0x0668u)
#define _EMAC_RX3INTACK_ADDR                (_EMAC_BASE_ADDR+0x066Cu)
#define _EMAC_RX4INTACK_ADDR                (_EMAC_BASE_ADDR+0x0670u)
#define _EMAC_RX5INTACK_ADDR                (_EMAC_BASE_ADDR+0x0674u)
#define _EMAC_RX6INTACK_ADDR                (_EMAC_BASE_ADDR+0x0678u)
#define _EMAC_RX7INTACK_ADDR                (_EMAC_BASE_ADDR+0x067Cu)

#define EMAC_RX0INTACK                      EMAC_REG(RX0INTACK)
#define EMAC_RX1INTACK                      EMAC_REG(RX1INTACK)
#define EMAC_RX2INTACK                      EMAC_REG(RX2INTACK)
#define EMAC_RX3INTACK                      EMAC_REG(RX3INTACK)
#define EMAC_RX4INTACK                      EMAC_REG(RX4INTACK)
#define EMAC_RX5INTACK                      EMAC_REG(RX5INTACK)
#define EMAC_RX6INTACK                      EMAC_REG(RX6INTACK)
#define EMAC_RX7INTACK                      EMAC_REG(RX7INTACK)

#define _EMAC_RXINTACK_DESCPTR_MASK         0xFFFFFFFFu
#define _EMAC_RXINTACK_DESCPTR_SHIFT        0u
#define  EMAC_RXINTACK_DESCPTR_DEFAULT      0x00000000u
#define _EMAC_RX0INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_RX0INTACK_DESCPTR_SHIFT       0u
#define  EMAC_RX0INTACK_DESCPTR_DEFAULT     0x00000000u
#define _EMAC_RX1INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_RX1INTACK_DESCPTR_SHIFT       0u
#define  EMAC_RX1INTACK_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX2INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_RX2INTACK_DESCPTR_SHIFT       0u
#define  EMAC_RX2INTACK_DESCPTR_DEFAULT     0x00000000u
#define _EMAC_RX3INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_RX3INTACK_DESCPTR_SHIFT       0u
#define  EMAC_RX3INTACK_DESCPTR_DEFAULT	    0x00000000u
#define _EMAC_RX4INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_RX4INTACK_DESCPTR_SHIFT       0u
#define  EMAC_RX4INTACK_DESCPTR_DEFAULT     0x00000000u
#define _EMAC_RX5INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_RX5INTACK_DESCPTR_SHIFT       0u
#define  EMAC_RX5INTACK_DESCPTR_DEFAULT     0x00000000u
#define _EMAC_RX6INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_RX6INTACK_DESCPTR_SHIFT       0u
#define  EMAC_RX6INTACK_DESCPTR_DEFAULT     0x00000000u
#define _EMAC_RX7INTACK_DESCPTR_MASK        0xFFFFFFFFu
#define _EMAC_RX7INTACK_DESCPTR_SHIFT       0u
#define  EMAC_RX7INTACK_DESCPTR_DEFAULT     0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* | RXGOODFRAMES      |
* | RXBCASTFRAMES     |
* | RXMCASTFRAMES     |
* | RXPAUSEFRAMES     |
* | RXCRCERRORS       |
* | RXALIGNCODEERRORS |
* | RXOVERSIZED       |
* | RXJABBER          |
* | RXUNDERSIZED      |
* | RXFRAGMENTS       |
* | RXFILTERED        |
* | RXQOSFILTERED     |
* | RXOCTETS          |
* | TXGOODFRAMES      |
* | TXBCASTFRAMES     |
* | TXMCASTFRAMES     |
* | TXPAUSEFRAMES     |
* | TXDEFERRED        |
* | TXCOLLISION       |
* | TXSINGLECOLL      |
* | TXMULTICOLL       |
* | TXEXCESSIVECOLL   |
* | TXLATECOLL        |
* | TXUNDERRUN        |
* | TXCARRIERSLOSS    |
* | TXOCTETS          |
* | FRAME64           |
* | FRAME65T127       |
* | FRAME128T255      |
* | FRAME256T511      |
* | FRAME512T1023     |
* | FRAME1024TUP      |
* | NETOCTETS         |
* | RXSOFOVERRUNS     |
* | RXMOFOVERRUNS     |
* | RXDMAOVERRUNS     |
* |___________________|
*
* RXGOODFRAMES      - Number of Good Frames Received
* RXBCASTFRAMES     - Number of Good Broadcast Frames Received
* RXMCASTFRAMES     - Number of Good Multicast Frames Received
* RXPAUSEFRAMES     - Number of PauseRX Frames Received
* RXCRCERRORS       - Number of Frames Received with CRC Errors
* RXALIGNCODEERRORS - Number of Frames Received with Alignment/Code Errors
* RXOVERSIZED       - Number of Oversized Frames Received
* RXJABBER          - Number of Jabber Frames Received
* RXUNDERSIZED      - Number of Undersized Frames Received
* RXFRAGMENTS       - Number of RX Frame Fragments Received
* RXFILTERED        - Number of RX Frames Filtered Based on Address
* RXQOSFILTERED     - Number of RX Frames Filtered Based on QoS Filtering
* RXOCTETS          - Total Number of Received Bytes in Good Frames
* TXGOODFRAMES      - Number of Good Frames Sent
* TXBCASTFRAMES     - Number of Good Broadcast Frames Sent
* TXMCASTFRAMES     - Number of Good Multicast Frames Sent
* TXPAUSEFRAMES     - Number of PauseTX Frames Sent
* TXDEFERRED        - Number of Frames Where Transmission was Deferred
* TXCOLLISION       - Total Number of Frames Sent That Experienced a Collision
* TXSINGLECOLL      - Number of Frames Sent with Exactly One Collision
* TXMULTICOLL       - Number of Frames Sent with Multiple Colisions
* TXEXCESSIVECOLL   - Number of TX Frames Lost Due to Excessive Collisions
* TXLATECOLL        - Number of TX Frames Lost Due to a Late Collision
* TXUNDERRUN        - Number of TX Frames Lost with Transmit Underrun Error
* TXCARRIERSLOSS    - Numebr of TX Frames Lost Due to Carrier Sense Loss
* TXOCTETS          - Total Nu,ber of Transmitted Bytes in Good Frames
* FRAME64           - Total TX & RX Frames with Octet Size of 64
* FRAME65T127       - Total TX & RX Frames with Octet Size of 65 to 127
* FRAME128T255      - Total TX & RX Frames with Octet Size of 128 to 255
* FRAME256T511      - Total TX & RX Frames with Octet Size of 256 to 511
* FRAME512T1023     - Total TX & RX Frames with Octet Size of 512 to 1023
* FRAME1024TUP      - Total TX & RX Frames with Octet Size of 1024 or above
* NETOCTETS         - Sum of all Octets Sent or Received on the Network
* RXSOFOVERRUNS     - Total RX Start of Frame Overruns (FIFO or DMA)
* RXMOFOVERRUNS     - Total RX Middle of Frame Overruns (FIFO or DMA)
* RXDMAOVERRUNS     - Total RX DMA Overruns
*
* FIELDS (msb -> lsb)
*  (rw) COUNT       - 32 bit count value
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_RXGOODFRAMES_ADDR             (_EMAC_BASE_ADDR+0x0200u)
#define _EMAC_RXBCASTFRAMES_ADDR            (_EMAC_BASE_ADDR+0x0204u)
#define _EMAC_RXMCASTFRAMES_ADDR            (_EMAC_BASE_ADDR+0x0208u)
#define _EMAC_RXPAUSEFRAMES_ADDR            (_EMAC_BASE_ADDR+0x020Cu)
#define _EMAC_RXCRCERRORS_ADDR              (_EMAC_BASE_ADDR+0x0210u)
#define _EMAC_RXALIGNCODEERRORS_ADDR        (_EMAC_BASE_ADDR+0x0214u)
#define _EMAC_RXOVERSIZED_ADDR              (_EMAC_BASE_ADDR+0x0218u)
#define _EMAC_RXJABBER_ADDR                 (_EMAC_BASE_ADDR+0x021Cu)
#define _EMAC_RXUNDERSIZED_ADDR             (_EMAC_BASE_ADDR+0x0220u)
#define _EMAC_RXFRAGMENTS_ADDR              (_EMAC_BASE_ADDR+0x0224u)
#define _EMAC_RXFILTERED_ADDR               (_EMAC_BASE_ADDR+0x0228u)
#define _EMAC_RXQOSFILTERED_ADDR            (_EMAC_BASE_ADDR+0x022Cu)
#define _EMAC_RXOCTETS_ADDR                 (_EMAC_BASE_ADDR+0x0230u)
#define _EMAC_TXGOODFRAMES_ADDR             (_EMAC_BASE_ADDR+0x0234u)
#define _EMAC_TXBCASTFRAMES_ADDR            (_EMAC_BASE_ADDR+0x0238u)
#define _EMAC_TXMCASTFRAMES_ADDR            (_EMAC_BASE_ADDR+0x023Cu)
#define _EMAC_TXPAUSEFRAMES_ADDR            (_EMAC_BASE_ADDR+0x0240u)
#define _EMAC_TXDEFERRED_ADDR               (_EMAC_BASE_ADDR+0x0244u)
#define _EMAC_TXCOLLISION_ADDR              (_EMAC_BASE_ADDR+0x0248u)
#define _EMAC_TXSINGLECOLL_ADDR             (_EMAC_BASE_ADDR+0x024Cu)
#define _EMAC_TXMULTICOLL_ADDR              (_EMAC_BASE_ADDR+0x0250u)
#define _EMAC_TXEXCESSIVECOLL_ADDR          (_EMAC_BASE_ADDR+0x0254u)
#define _EMAC_TXLATECOLL_ADDR               (_EMAC_BASE_ADDR+0x0258u)
#define _EMAC_TXUNDERRUN_ADDR               (_EMAC_BASE_ADDR+0x025Cu)
#define _EMAC_TXCARRIERSLOSS_ADDR           (_EMAC_BASE_ADDR+0x0260u)
#define _EMAC_TXOCTETS_ADDR                 (_EMAC_BASE_ADDR+0x0264u)
#define _EMAC_FRAME64_ADDR                  (_EMAC_BASE_ADDR+0x0268u)
#define _EMAC_FRAME65T127_ADDR              (_EMAC_BASE_ADDR+0x026Cu)
#define _EMAC_FRAME128T255_ADDR             (_EMAC_BASE_ADDR+0x0270u)
#define _EMAC_FRAME256T511_ADDR             (_EMAC_BASE_ADDR+0x0274u)
#define _EMAC_FRAME512T1023_ADDR            (_EMAC_BASE_ADDR+0x0278u)
#define _EMAC_FRAME1024TUP_ADDR             (_EMAC_BASE_ADDR+0x027Cu)
#define _EMAC_NETOCTETS_ADDR                (_EMAC_BASE_ADDR+0x0280u)
#define _EMAC_RXSOFOVERRUNS_ADDR            (_EMAC_BASE_ADDR+0x0284u)
#define _EMAC_RXMOFOVERRUNS_ADDR            (_EMAC_BASE_ADDR+0x0288u)
#define _EMAC_RXDMAOVERRUNS_ADDR            (_EMAC_BASE_ADDR+0x028Cu)

#define EMAC_RXGOODFRAMES                   EMAC_REG(RXGOODFRAMES)
#define EMAC_RXBCASTFRAMES                  EMAC_REG(RXBCASTFRAMES)
#define EMAC_RXMCASTFRAMES                  EMAC_REG(RXMCASTFRAMES)
#define EMAC_RXPAUSEFRAMES                  EMAC_REG(RXPAUSEFRAMES)
#define EMAC_RXCRCERRORS                    EMAC_REG(RXCRCERRORS)
#define EMAC_RXALIGNCODEERRORS              EMAC_REG(RXALIGNCODEERRORS)
#define EMAC_RXOVERSIZED                    EMAC_REG(RXOVERSIZED)
#define EMAC_RXJABBER                       EMAC_REG(RXJABBER)
#define EMAC_RXUNDERSIZED                   EMAC_REG(RXUNDERSIZED)
#define EMAC_RXFRAGMENTS                    EMAC_REG(RXFRAGMENTS)
#define EMAC_RXFILTERED                     EMAC_REG(RXFILTERED)
#define EMAC_RXQOSFILTERED                  EMAC_REG(RXQOSFILTERED)
#define EMAC_RXOCTETS                       EMAC_REG(RXOCTETS)
#define EMAC_TXGOODFRAMES                   EMAC_REG(TXGOODFRAMES)
#define EMAC_TXBCASTFRAMES                  EMAC_REG(TXBCASTFRAMES)
#define EMAC_TXMCASTFRAMES                  EMAC_REG(TXMCASTFRAMES)
#define EMAC_TXPAUSEFRAMES                  EMAC_REG(TXPAUSEFRAMES)
#define EMAC_TXDEFERRED                     EMAC_REG(TXDEFERRED)
#define EMAC_TXCOLLISION                    EMAC_REG(TXCOLLISION)
#define EMAC_TXSINGLECOLL                   EMAC_REG(TXSINGLECOLL)
#define EMAC_TXMULTICOLL                    EMAC_REG(TXMULTICOLL)
#define EMAC_TXEXCESSIVECOLL                EMAC_REG(TXEXCESSIVECOLL)
#define EMAC_TXLATECOLL                     EMAC_REG(TXLATECOLL)
#define EMAC_TXUNDERRUN                     EMAC_REG(TXUNDERRUN)
#define EMAC_TXCARRIERSLOSS                 EMAC_REG(TXCARRIERSLOSS)
#define EMAC_TXOCTETS                       EMAC_REG(TXOCTETS)
#define EMAC_FRAME64                        EMAC_REG(FRAME64)
#define EMAC_FRAME65T127                    EMAC_REG(FRAME65T127)
#define EMAC_FRAME128T255                   EMAC_REG(FRAME128T255)
#define EMAC_FRAME256T511                   EMAC_REG(FRAME256T511)
#define EMAC_FRAME512T1023                  EMAC_REG(FRAME512T1023)
#define EMAC_FRAME1024TUP                   EMAC_REG(FRAME1024TUP)
#define EMAC_NETOCTETS                      EMAC_REG(NETOCTETS)
#define EMAC_RXSOFOVERRUNS                  EMAC_REG(RXSOFOVERRUNS)
#define EMAC_RXMOFOVERRUNS                  EMAC_REG(RXMOFOVERRUNS)
#define EMAC_RXDMAOVERRUNS                  EMAC_REG(RXDMAOVERRUNS)

#define _EMAC_RXGOODFRAMES_COUNT_MASK       0xFFFFFFFFu
#define _EMAC_RXBCASTFRAMES_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_RXMCASTFRAMES_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_RXPAUSEFRAMES_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_RXCRCERRORS_COUNT_MASK        0xFFFFFFFFu
#define _EMAC_RXALIGNCODEERRORS_COUNT_MASK  0xFFFFFFFFu
#define _EMAC_RXOVERSIZED_COUNT_MASK        0xFFFFFFFFu
#define _EMAC_RXJABBER_COUNT_MASK           0xFFFFFFFFu
#define _EMAC_RXUNDERSIZED_COUNT_MASK       0xFFFFFFFFu
#define _EMAC_RXFRAGMENTS_COUNT_MASK        0xFFFFFFFFu
#define _EMAC_RXFILTERED_COUNT_MASK         0xFFFFFFFFu
#define _EMAC_RXQOSFILTERED_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_RXOCTETS_COUNT_MASK           0xFFFFFFFFu
#define _EMAC_TXGOODFRAMES_COUNT_MASK       0xFFFFFFFFu
#define _EMAC_TXBCASTFRAMES_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_TXMCASTFRAMES_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_TXPAUSEFRAMES_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_TXDEFERRED_COUNT_MASK         0xFFFFFFFFu
#define _EMAC_TXCOLLISION_COUNT_MASK        0xFFFFFFFFu
#define _EMAC_TXSINGLECOLL_COUNT_MASK       0xFFFFFFFFu
#define _EMAC_TXMULTICOLL_COUNT_MASK        0xFFFFFFFFu
#define _EMAC_TXEXCESSIVECOLL_COUNT_MASK    0xFFFFFFFFu
#define _EMAC_TXLATECOLL_COUNT_MASK         0xFFFFFFFFu
#define _EMAC_TXUNDERRUN_COUNT_MASK         0xFFFFFFFFu
#define _EMAC_TXCARRIERSLOSS_COUNT_MASK     0xFFFFFFFFu
#define _EMAC_TXOCTETS_COUNT_MASK           0xFFFFFFFFu
#define _EMAC_FRAME64_COUNT_MASK            0xFFFFFFFFu
#define _EMAC_FRAME65T127_COUNT_MASK        0xFFFFFFFFu
#define _EMAC_FRAME128T255_COUNT_MASK       0xFFFFFFFFu
#define _EMAC_FRAME256T511_COUNT_MASK       0xFFFFFFFFu
#define _EMAC_FRAME512T1023_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_FRAME1024TUP_COUNT_MASK       0xFFFFFFFFu
#define _EMAC_NETOCTETS_COUNT_MASK          0xFFFFFFFFu
#define _EMAC_RXSOFOVERRUNS_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_RXMOFOVERRUNS_COUNT_MASK      0xFFFFFFFFu
#define _EMAC_RXDMAOVERRUNS_COUNT_MASK      0xFFFFFFFFu

#define _EMAC_RXGOODFRAMES_COUNT_SHIFT      0u
#define _EMAC_RXBCASTFRAMES_COUNT_SHIFT     0u
#define _EMAC_RXMCASTFRAMES_COUNT_SHIFT     0u
#define _EMAC_RXPAUSEFRAMES_COUNT_SHIFT     0u
#define _EMAC_RXCRCERRORS_COUNT_SHIFT       0u
#define _EMAC_RXALIGNCODEERRORS_COUNT_SHIFT 0u
#define _EMAC_RXOVERSIZED_COUNT_SHIFT       0u
#define _EMAC_RXJABBER_COUNT_SHIFT          0u
#define _EMAC_RXUNDERSIZED_COUNT_SHIFT      0u
#define _EMAC_RXFRAGMENTS_COUNT_SHIFT       0u
#define _EMAC_RXFILTERED_COUNT_SHIFT        0u
#define _EMAC_RXQOSFILTERED_COUNT_SHIFT     0u
#define _EMAC_RXOCTETS_COUNT_SHIFT          0u
#define _EMAC_TXGOODFRAMES_COUNT_SHIFT      0u
#define _EMAC_TXBCASTFRAMES_COUNT_SHIFT     0u
#define _EMAC_TXMCASTFRAMES_COUNT_SHIFT     0u
#define _EMAC_TXPAUSEFRAMES_COUNT_SHIFT     0u
#define _EMAC_TXDEFERRED_COUNT_SHIFT        0u
#define _EMAC_TXCOLLISION_COUNT_SHIFT       0u
#define _EMAC_TXSINGLECOLL_COUNT_SHIFT      0u
#define _EMAC_TXMULTICOLL_COUNT_SHIFT       0u
#define _EMAC_TXEXCESSIVECOLL_COUNT_SHIFT   0u
#define _EMAC_TXLATECOLL_COUNT_SHIFT        0u
#define _EMAC_TXUNDERRUN_COUNT_SHIFT        0u
#define _EMAC_TXCARRIERSLOSS_COUNT_SHIFT    0u
#define _EMAC_TXOCTETS_COUNT_SHIFT          0u
#define _EMAC_FRAME64_COUNT_SHIFT           0u
#define _EMAC_FRAME65T127_COUNT_SHIFT       0u
#define _EMAC_FRAME128T255_COUNT_SHIFT      0u
#define _EMAC_FRAME256T511_COUNT_SHIFT      0u
#define _EMAC_FRAME512T1023_COUNT_SHIFT     0u
#define _EMAC_FRAME1024TUP_COUNT_SHIFT      0u
#define _EMAC_NETOCTETS_COUNT_SHIFT         0u
#define _EMAC_RXSOFOVERRUNS_COUNT_SHIFT     0u
#define _EMAC_RXMOFOVERRUNS_COUNT_SHIFT     0u
#define _EMAC_RXDMAOVERRUNS_COUNT_SHIFT     0u

#define EMAC_RXGOODFRAMES_COUNT_DEFAULT	    0x00000000u
#define	EMAC_RXBCASTFRAMES_COUNT_DEFAULT    0x00000000u
#define EMAC_RXMCASTFRAMES_COUNT_DEFAULT    0x00000000u
#define EMAC_RXPAUSEFRAMES_COUNT_DEFAULT    0x00000000u
#define EMAC_RXCRCERRORS_COUNT_DEFAULT      0x00000000u
#define EMAC_RXALIGNCODEERRORS_COUNT_DEFAULT 0x00000000u
#define	EMAC_RXOVERSIZED_COUNT_DEFAULT       0x00000000u
#define EMAC_RXJABBER_COUNT_DEFAULT          0x00000000u
#define EMAC_RXUNDERSIZED_COUNT_DEFAULT      0X00000000u
#define EMAC_RXFRAGMENTS_COUNT_DEFAULT	     0x00000000u
#define EMAC_RXFILTERED_COUNT_DEFAULT        0x00000000u
#define EMAC_RXQOSFILTERED_COUNT_DEFAULT     0x00000000u
#define EMAC_RXOCTETS_COUNT_DEFAULT          0x00000000u
#define EMAC_TXGOODFRAMES_COUNT_DEFAULT	     0x00000000u
#define EMAC_TXBCASTFRAMES_COUNT_DEFAULT     0x00000000u
#define EMAC_TXMCASTFRAMES_COUNT_DEFAULT     0x00000000u
#define EMAC_TXPAUSEFRAMES_COUNT_DEFAULT     0x00000000u
#define EMAC_TXDEFERRED_COUNT_DEFAULT        0x00000000u
#define EMAC_TXCOLLISION_COUNT_DEFAULT       0x00000000u
#define EMAC_TXSINGLECOLL_COUNT_DEFAULT      0x00000000u
#define EMAC_TXMULTICOLL_COUNT_DEFAULT       0x00000000u
#define EMAC_TXEXCESSIVECOLL_COUNT_DEFAULT   0x00000000u
#define EMAC_TXLATECOLL_COUNT_DEFAULT        0x00000000u
#define EMAC_TXUNDERRUN_COUNT_DEFAULT        0x00000000u
#define EMAC_TXCARRIERSLOSS_COUNT_DEFAULT    0x00000000u
#define EMAC_TXOCTETS_COUNT_DEFAULT          0x00000000u
#define EMAC_FRAME64_COUNT_DEFAULT           0x00000000u
#define EMAC_FRAME65T127_COUNT_DEFAULT	     0x00000000u
#define EMAC_FRAME128T255_COUNT_DEFAULT      0x00000000u
#define EMAC_FRAME256T511_COUNT_DEFAULT      0x00000000u
#define EMAC_FRAME512T1023_COUNT_DEFAULT     0x00000000u
#define EMAC_FRAME1024TUP_COUNT_DEFAULT      0x00000000u
#define EMAC_NETOCTETS_COUNT_DEFAULT         0x00000000u
#define EMAC_RXSOFOVERRUNS_COUNT_DEFAULT     0x00000000u
#define EMAC_RXMOFOVERRUNS_COUNT_DEFAULT     0x00000000u
#define EMAC_RXDMAOVERRUNS_COUNT_DEFAULT     0x00000000u
/******************************************************************************\
* _____________________
* |                   |
* |   EWTRCTRL        |
* |___________________|
*
* EWTRCTRL         - TR Control
*
* FIELDS (msb -> lsb)
*
* MACROS SUPPORTED
*  EMAC_FMK     .
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    .
*  EMAC_FSET    .
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_EWTRCTRL_ADDR                     (_EMAC_BASE_ADDR+0x3000u)

#define EMAC_EWTRCTRL                           EMAC_REG(EWTRCTRL)

/******************************************************************************\
* _____________________
* |                   |
* |   EWCTL           |
* |___________________|
*
* EWCTL             - Interrupt control register
*
* FIELDS (msb -> lsb)
*  (rw)  EMACRST    - EMAC Reset
*  (rw)  MDIORST    - MDIO Reset
*  (rw)  INTEN      - EMAC/MDIO Global Interrupt Enable
*
* MACROS SUPPORTED
*  EMAC_FMK     y
*  EMAC_FMKS    y
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    y
*  EMAC_FSET    y
*  EMAC_FSETS   y
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_EWCTL_ADDR                        (_EMAC_BASE_ADDR+0x3004u)

#define EMAC_EWCTL                              EMAC_REG(EWCTL)

#define _EMAC_EWCTL_EMACRST_MASK                0x4u
#define _EMAC_EWCTL_EMACRST_SHIFT               2u
#define  EMAC_EWCTL_EMACRST_DEFAULT             0x00000000u
#define EMAC_EWCTL_EMACRST_YES                  1u
#define EMAC_EWCTL_EMACRST_NO                   0u

#define _EMAC_EWCTL_MDIORST_MASK                0x2u
#define _EMAC_EWCTL_MDIORST_SHIFT               1u
#define  EMAC_EWCTL_MDIORST_DEFAULT             0x00000000u
#define EMAC_EWCTL_MDIORST_YES                  1u
#define EMAC_EWCTL_MDIORST_NO                   0u

#define _EMAC_EWCTL_INTEN_MASK                  0x1u
#define _EMAC_EWCTL_INTEN_SHIFT                 0u
#define  EMAC_EWCTL_INTEN_DEFAULT               0x00000000u
#define EMAC_EWCTL_INTEN_ENABLE                 1u
#define EMAC_EWCTL_INTEN_DISABLE                0u

/******************************************************************************\
* _____________________
* |                   |
* |   EWINTTCNT       |
* |___________________|
*
* EWINTTCNT         - Interrupt Timer Count
*
* FIELDS (msb -> lsb)
*
* MACROS SUPPORTED
*  EMAC_FMK     .
*  EMAC_FMKS    .
*  EMAC_FMKCHF  .
*  EMAC_ADDR    y
*  EMAC_REG     y
*  EMAC_RGET    y
*  EMAC_RSET    y
*  EMAC_FGET    .
*  EMAC_FSET    .
*  EMAC_FSETS   .
*  EMAC_RGETI   .
*  EMAC_RSETI   .
*  EMAC_FGETI   .
*  EMAC_FSETI   .
*  EMAC_FSETSI  .
*
\******************************************************************************/
#define _EMAC_EWINTTCNT_ADDR                    (_EMAC_BASE_ADDR+0x3008u)

#define EMAC_EWINTTCNT                          EMAC_REG(EWINTTCNT)



#endif /* EMAC_SUPPORT */

#endif /* _CSL_EMACHAL_H_ */
/******************************************************************************\
* End of csl_emachal.h
\******************************************************************************/





csl_emif.h/     1037695784  0     0     0       6645      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emif.h
* DATE CREATED.. 06/11/1999 
* LAST MODIFIED. 01/31/2002 -SDCTL reg. setting after SDEXT reg. setting
\******************************************************************************/
#ifndef _CSL_EMIF_H_
#define _CSL_EMIF_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_emifhal.h>


#if (EMIF_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _EMIF_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* device configuration structure */
typedef struct {
  Uint32 gblctl;
  Uint32 cectl0;
  Uint32 cectl1;
  Uint32 cectl2;
  Uint32 cectl3;
  Uint32 sdctl;
  Uint32 sdtim;
  #if (C11_SUPPORT)
    Uint32 sdext;
  #endif
} EMIF_Config;


/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL void EMIF_config(EMIF_Config *config);

#if (C11_SUPPORT)
  IDECL void EMIF_configArgs(Uint32 gblctl, Uint32 cectl0, Uint32 cectl1,
    Uint32 cectl2, Uint32 cectl3, Uint32 sdctl, Uint32 sdtim, Uint32 sdext);
#else
  IDECL void EMIF_configArgs(Uint32 gblctl, Uint32 cectl0, Uint32 cectl1,
    Uint32 cectl2, Uint32 cectl3, Uint32 sdctl, Uint32 sdtim);
#endif

IDECL void EMIF_getConfig(EMIF_Config *config);


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void EMIF_config(EMIF_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIF_BASE_GLOBAL;
  register int x0,x1,x2,x3,x4,x5,x6;
  #if (C11_SUPPORT)
    register int x7;
  #endif

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */
  x0 = config->gblctl;
  x1 = config->cectl0;
  x2 = config->cectl1;
  x3 = config->cectl2;
  x4 = config->cectl3;
  x5 = config->sdctl;
  x6 = config->sdtim;
  #if (C11_SUPPORT)
    x7 = config->sdext;
  #endif

  base[_EMIF_GBLCTL_OFFSET] = x0;
  base[_EMIF_CECTL0_OFFSET] = x1;
  base[_EMIF_CECTL1_OFFSET] = x2;
  base[_EMIF_CECTL2_OFFSET] = x3;
  base[_EMIF_CECTL3_OFFSET] = x4;
  base[_EMIF_SDTIM_OFFSET]  = x6;
  #if (C11_SUPPORT)
    base[_EMIF_SDEXT_OFFSET]  = x7;
  #endif
  base[_EMIF_SDCTL_OFFSET]  = x5;

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)

IDEF void EMIF_configArgs(Uint32 gblctl, Uint32 cectl0, Uint32 cectl1,
  Uint32 cectl2, Uint32 cectl3, Uint32 sdctl, Uint32 sdtim, Uint32 sdext) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIF_BASE_GLOBAL;

  gie = IRQ_globalDisable();

  base[_EMIF_GBLCTL_OFFSET] = gblctl;
  base[_EMIF_CECTL0_OFFSET] = cectl0;
  base[_EMIF_CECTL1_OFFSET] = cectl1;
  base[_EMIF_CECTL2_OFFSET] = cectl2;
  base[_EMIF_CECTL3_OFFSET] = cectl3;  
  base[_EMIF_SDTIM_OFFSET]  = sdtim;
  base[_EMIF_SDEXT_OFFSET]  = sdext;
  base[_EMIF_SDCTL_OFFSET]  = sdctl;

  IRQ_globalRestore(gie);
}

#else

IDEF void EMIF_configArgs(Uint32 gblctl, Uint32 cectl0, Uint32 cectl1,
  Uint32 cectl2, Uint32 cectl3, Uint32 sdctl, Uint32 sdtim) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIF_BASE_GLOBAL;

  gie = IRQ_globalDisable();

  base[_EMIF_GBLCTL_OFFSET] = gblctl;
  base[_EMIF_CECTL0_OFFSET] = cectl0;
  base[_EMIF_CECTL1_OFFSET] = cectl1;
  base[_EMIF_CECTL2_OFFSET] = cectl2;
  base[_EMIF_CECTL3_OFFSET] = cectl3;
  base[_EMIF_SDTIM_OFFSET]  = sdtim;
  base[_EMIF_SDCTL_OFFSET]  = sdctl;

  IRQ_globalRestore(gie);
}

#endif /* (C11_SUPPORT) */

/*----------------------------------------------------------------------------*/
IDEF void EMIF_getConfig(EMIF_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIF_BASE_GLOBAL;
  volatile EMIF_Config* cfg = (volatile EMIF_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6;
  #if (C11_SUPPORT)
    register int x7;
  #endif

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */

  x0 = base[_EMIF_GBLCTL_OFFSET];
  x1 = base[_EMIF_CECTL0_OFFSET];
  x2 = base[_EMIF_CECTL1_OFFSET];
  x3 = base[_EMIF_CECTL2_OFFSET];
  x4 = base[_EMIF_CECTL3_OFFSET];
  x5 = base[_EMIF_SDCTL_OFFSET];
  x6 = base[_EMIF_SDTIM_OFFSET];
  #if (C11_SUPPORT)
    x7 = base[_EMIF_SDEXT_OFFSET];
  #endif

  cfg->gblctl = x0;
  cfg->cectl0 = x1;
  cfg->cectl1 = x2;
  cfg->cectl2 = x3;
  cfg->cectl3 = x4;
  cfg->sdctl  = x5;
  cfg->sdtim  = x6;
  #if (C11_SUPPORT)
    cfg->sdext  = x7;
  #endif

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* EMIF_SUPPORT */
#endif /* _CSL_EMIF_H_ */
/******************************************************************************\
* End of csl_emif.h
\******************************************************************************/


csl_emifa.h/    1030611960  0     0     0       7000      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emifa.h
* DATE CREATED.. 03/27/2001 
* LAST MODIFIED. 01/31/2002 SDCTL reg. setting after SDEXT reg.setting
\******************************************************************************/
#ifndef _CSL_EMIFA_H_
#define _CSL_EMIFA_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_emifahal.h>


#if (EMIFA_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _EMIFA_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* device configuration structure */
typedef struct {
  Uint32 gblctl;
  Uint32 cectl0;
  Uint32 cectl1;
  Uint32 cectl2;
  Uint32 cectl3;
  Uint32 sdctl;
  Uint32 sdtim;
  Uint32 sdext;
  Uint32 cesec0;
  Uint32 cesec1;
  Uint32 cesec2;
  Uint32 cesec3;
} EMIFA_Config;


/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/


/******************************************************************************\
* inline function declarations
\******************************************************************************/
#if C64_SUPPORT
IDECL void EMIFA_config(EMIFA_Config *config);
IDECL void EMIFA_configArgs(Uint32 gblctl, Uint32 cectl0, Uint32 cectl1,
    Uint32 cectl2, Uint32 cectl3, Uint32 sdctl, Uint32 sdtim, Uint32 sdext, Uint32 cesec0,
	Uint32 cesec1, Uint32 cesec2, Uint32 cesec3);
IDECL void EMIFA_getConfig(EMIFA_Config *config);
#endif

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
#if (C64_SUPPORT)
IDEF void EMIFA_config(EMIFA_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIFA_BASE_GLOBAL;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */
  x0  = config->gblctl;
  x1  = config->cectl0;
  x2  = config->cectl1;
  x3  = config->cectl2;
  x4  = config->cectl3;
  x5  = config->sdctl;
  x6  = config->sdtim;
  x7  = config->sdext;
  x8  = config->cesec0;
  x9  = config->cesec1;
  x10 = config->cesec2;
  x11 = config->cesec3;

  base[_EMIFA_GBLCTL_OFFSET]  = x0;
  base[_EMIFA_CECTL0_OFFSET]  = x1;
  base[_EMIFA_CECTL1_OFFSET]  = x2;
  base[_EMIFA_CECTL2_OFFSET]  = x3;
  base[_EMIFA_CECTL3_OFFSET]  = x4;
  
  base[_EMIFA_SDTIM_OFFSET]   = x6;
  base[_EMIFA_SDEXT_OFFSET]   = x7;
  base[_EMIFA_CESEC0_OFFSET]  = x8;
  base[_EMIFA_CESEC1_OFFSET]  = x9;
  base[_EMIFA_CESEC2_OFFSET]  = x10;
  base[_EMIFA_CESEC3_OFFSET]  = x11;

  base[_EMIFA_SDCTL_OFFSET]   = x5;

  IRQ_globalRestore(gie);
}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
#if C64_SUPPORT
IDEF void EMIFA_configArgs(Uint32 gblctl, Uint32 cectl0, Uint32 cectl1,
  Uint32 cectl2, Uint32 cectl3, Uint32 sdctl, Uint32 sdtim, Uint32 sdext,
  Uint32 cesec0, Uint32 cesec1, Uint32 cesec2, Uint32 cesec3) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIFA_BASE_GLOBAL;

  gie = IRQ_globalDisable();

  base[_EMIFA_GBLCTL_OFFSET]  = gblctl;
  base[_EMIFA_CECTL0_OFFSET]  = cectl0;
  base[_EMIFA_CECTL1_OFFSET]  = cectl1;
  base[_EMIFA_CECTL2_OFFSET]  = cectl2;
  base[_EMIFA_CECTL3_OFFSET]  = cectl3;
  base[_EMIFA_SDTIM_OFFSET]   = sdtim;
  base[_EMIFA_SDEXT_OFFSET]   = sdext;
  base[_EMIFA_CESEC0_OFFSET]  = cesec0;
  base[_EMIFA_CESEC1_OFFSET]  = cesec1;
  base[_EMIFA_CESEC2_OFFSET]  = cesec2;
  base[_EMIFA_CESEC3_OFFSET]  = cesec3;
  base[_EMIFA_SDCTL_OFFSET]   = sdctl;

  IRQ_globalRestore(gie);
}
#endif
/*----------------------------------------------------------------------------*/
#if (C64_SUPPORT)
IDEF void EMIFA_getConfig(EMIFA_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIFA_BASE_GLOBAL;
  volatile EMIFA_Config* cfg = (volatile EMIFA_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */

  x0  = base[_EMIFA_GBLCTL_OFFSET];
  x1  = base[_EMIFA_CECTL0_OFFSET];
  x2  = base[_EMIFA_CECTL1_OFFSET];
  x3  = base[_EMIFA_CECTL2_OFFSET];
  x4  = base[_EMIFA_CECTL3_OFFSET];

  x6  = base[_EMIFA_SDTIM_OFFSET];
  x7  = base[_EMIFA_SDEXT_OFFSET];
  x8  = base[_EMIFA_CESEC0_OFFSET];
  x9  = base[_EMIFA_CESEC1_OFFSET];
  x10 = base[_EMIFA_CESEC2_OFFSET];
  x11 = base[_EMIFA_CESEC3_OFFSET];

  x5  = base[_EMIFA_SDCTL_OFFSET];

  cfg->gblctl  = x0;
  cfg->cectl0  = x1;
  cfg->cectl1  = x2;
  cfg->cectl2  = x3;
  cfg->cectl3  = x4;
  cfg->sdctl   = x5;
  cfg->sdtim   = x6;
  cfg->sdext   = x7;
  cfg->cesec0  = x8;
  cfg->cesec1  = x9;
  cfg->cesec2  = x10;
  cfg->cesec3  = x11;

  IRQ_globalRestore(gie);
}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* EMIFA_SUPPORT */
#endif /* _CSL_EMIF_H_ */
/******************************************************************************\
* End of csl_emifa.h
\******************************************************************************/

csl_emifahal.h/ 1092218719  0     0     0       32531     `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emifahal.h
* DATE CREATED.. 03/27/2001 
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                03/27/2001
*                04/16/2004 Added PDTCTL register support 
*------------------------------------------------------------------------------
* REGISTERS
*
* GBLCTL  - global control register
* CECTL0  - CE space control register 0
* CECTL1  - CE space control register 1
* CECTL2  - CE space control register 2
* CECTL3  - CE space control register 3
* SDCTL   - SDRAM control regsiter
* SDTIM   - SDRAM timing register
* SDEXT   - SDRAM extension register 
* CESEC0  - EMIFA CE0 secondary control 
* CESEC1  - EMIFA CE1 secondary control 
* CESEC2  - EMIFA CE2 secondary control 
* CESEC3  - EMIFA CE3 secondary control 
* PDTCTL  - Peripheral device transfer control 
*
\******************************************************************************/
#ifndef _CSL_EMIFAHAL_H_
#define _CSL_EMIFAHAL_H_


#include <csl_stdinc.h>
#include <csl_chip.h>

#if (EMIFA_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#define _EMIFA_BASE_GLOBAL   0x01800000u

/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define EMIFA_FMK(REG,FIELD,x)\
    _PER_FMK(EMIFA,##REG,##FIELD,x)

  #define EMIFA_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(EMIFA,##REG,##FIELD,##SYM)
 
 
  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define EMIFA_ADDR(REG)\
    _EMIFA_##REG##_ADDR

  #define EMIFA_RGET(REG)\
    _PER_RGET(_EMIFA_##REG##_ADDR,EMIFA,##REG)

  #define EMIFA_RSET(REG,x)\
    _PER_RSET(_EMIFA_##REG##_ADDR,EMIFA,##REG,x)

  #define EMIFA_FGET(REG,FIELD)\
    _EMIFA_##REG##_FGET(##FIELD)

  #define EMIFA_FSET(REG,FIELD,x)\
    _EMIFA_##REG##_FSET(##FIELD,##x)

  #define EMIFA_FSETS(REG,FIELD,SYM)\
    _EMIFA_##REG##_FSETS(##FIELD,##SYM)
 
 
  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define EMIFA_RGETA(addr,REG)\
    _PER_RGET(addr,EMIFA,##REG)

  #define EMIFA_RSETA(addr,REG,x)\
    _PER_RSET(addr,EMIFA,##REG,x)

  #define EMIFA_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,EMIFA,##REG,##FIELD)

  #define EMIFA_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,EMIFA,##REG,##FIELD,x)

  #define EMIFA_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,EMIFA,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  G B L C T L      |
* |___________________|
*
* GBLCTL  - global control register
*
* FIELDS (msb -> lsb)
* (rw) EK2RATE
* (rw) EK2HZ
* (rw) EK2EN
* (rw) BRMODE
* (r)  BUSREQ
* (r)  ARDY
* (r)  HOLD
* (r)  HOLDA
* (rw) NOHOLD
* (rw) EK1HZ
* (rw) EK1EN
* (rw) CLK4EN
* (rw) CLK6EN
*
\******************************************************************************/
  #define _EMIFA_GBLCTL_OFFSET          0

  #define _EMIFA_GBLCTL_ADDR            0x01800000u

  #define _EMIFA_GBLCTL_EK2RATE_MASK     0x000C0000u
  #define _EMIFA_GBLCTL_EK2RATE_SHIFT    0x00000012u
  #define  EMIFA_GBLCTL_EK2RATE_DEFAULT  0x00000002u
  #define  EMIFA_GBLCTL_EK2RATE_OF(x)    _VALUEOF(x)
  #define  EMIFA_GBLCTL_EK2RATE_FULLCLK  0x00000000u 
  #define  EMIFA_GBLCTL_EK2RATE_HALFCLK  0x00000001u 
  #define  EMIFA_GBLCTL_EK2RATE_QUARCLK  0x00000002u 

  #define _EMIFA_GBLCTL_EK2HZ_MASK       0x00020000u
  #define _EMIFA_GBLCTL_EK2HZ_SHIFT      0x00000011u
  #define  EMIFA_GBLCTL_EK2HZ_DEFAULT    0x00000000u
  #define  EMIFA_GBLCTL_EK2HZ_OF(x)      _VALUEOF(x)
  #define  EMIFA_GBLCTL_EK2HZ_CLK        0x00000000u 
  #define  EMIFA_GBLCTL_EK2HZ_HIGHZ      0x00000001u 

  #define _EMIFA_GBLCTL_EK2EN_MASK       0x00010000u
  #define _EMIFA_GBLCTL_EK2EN_SHIFT      0x00000010u
  #define  EMIFA_GBLCTL_EK2EN_DEFAULT    0x00000001u
  #define  EMIFA_GBLCTL_EK2EN_OF(x)      _VALUEOF(x)
  #define  EMIFA_GBLCTL_EK2EN_DISABLE    0x00000000u 
  #define  EMIFA_GBLCTL_EK2EN_ENABLE     0x00000001u 

  #define _EMIFA_GBLCTL_BRMODE_MASK     0x00002000u
  #define _EMIFA_GBLCTL_BRMODE_SHIFT    0x0000000Du
  #define  EMIFA_GBLCTL_BRMODE_DEFAULT  0x00000001u
  #define  EMIFA_GBLCTL_BRMODE_OF(x)    _VALUEOF(x)
  #define  EMIFA_GBLCTL_BRMODE_MSTATUS  0x00000000u 
  #define  EMIFA_GBLCTL_BRMODE_MRSTATUS 0x00000001u 

  #define _EMIFA_GBLCTL_BUSREQ_MASK     0x00000800u
  #define _EMIFA_GBLCTL_BUSREQ_SHIFT    0x0000000Bu
  #define  EMIFA_GBLCTL_BUSREQ_DEFAULT  0x00000000u
  #define  EMIFA_GBLCTL_BUSREQ_OF(x)    _VALUEOF(x)
  #define  EMIFA_GBLCTL_BUSREQ_LOW      0x00000000u
  #define  EMIFA_GBLCTL_BUSREQ_HIGH     0x00000001u

  #define _EMIFA_GBLCTL_ARDY_MASK       0x00000400u
  #define _EMIFA_GBLCTL_ARDY_SHIFT      0x0000000Au
  #define  EMIFA_GBLCTL_ARDY_DEFAULT    0x00000000u
  #define  EMIFA_GBLCTL_ARDY_OF(x)      _VALUEOF(x)
  #define  EMIFA_GBLCTL_ARDY_LOW        0x00000000u
  #define  EMIFA_GBLCTL_ARDY_HIGH       0x00000001u

  #define _EMIFA_GBLCTL_HOLD_MASK       0x00000200u
  #define _EMIFA_GBLCTL_HOLD_SHIFT      0x00000009u
  #define  EMIFA_GBLCTL_HOLD_DEFAULT    0x00000000u
  #define  EMIFA_GBLCTL_HOLD_OF(x)      _VALUEOF(x)
  #define  EMIFA_GBLCTL_HOLD_LOW        0x00000000u
  #define  EMIFA_GBLCTL_HOLD_HIGH       0x00000001u

  #define _EMIFA_GBLCTL_HOLDA_MASK      0x00000100u
  #define _EMIFA_GBLCTL_HOLDA_SHIFT     0x00000008u
  #define  EMIFA_GBLCTL_HOLDA_DEFAULT   0x00000000u
  #define  EMIFA_GBLCTL_HOLDA_OF(x)     _VALUEOF(x)
  #define  EMIFA_GBLCTL_HOLDA_LOW       0x00000000u
  #define  EMIFA_GBLCTL_HOLDA_HIGH      0x00000001u

  #define _EMIFA_GBLCTL_NOHOLD_MASK     0x00000080u
  #define _EMIFA_GBLCTL_NOHOLD_SHIFT    0x00000007u
  #define  EMIFA_GBLCTL_NOHOLD_DEFAULT  0x00000000u
  #define  EMIFA_GBLCTL_NOHOLD_OF(x)    _VALUEOF(x)
  #define  EMIFA_GBLCTL_NOHOLD_DISABLE  0x00000000u
  #define  EMIFA_GBLCTL_NOHOLD_ENABLE   0x00000001u

  #define _EMIFA_GBLCTL_EK1HZ_MASK      0x00000040u
  #define _EMIFA_GBLCTL_EK1HZ_SHIFT     0x00000006u
  #define  EMIFA_GBLCTL_EK1HZ_DEFAULT   0x00000001u
  #define  EMIFA_GBLCTL_EK1HZ_OF(x)     _VALUEOF(x)
  #define  EMIFA_GBLCTL_EK1HZ_CLK       0x00000000u 
  #define  EMIFA_GBLCTL_EK1HZ_HIGHZ     0x00000001u 

  #define _EMIFA_GBLCTL_EK1EN_MASK      0x00000020u
  #define _EMIFA_GBLCTL_EK1EN_SHIFT     0x00000005u
  #define  EMIFA_GBLCTL_EK1EN_DEFAULT   0x00000001u
  #define  EMIFA_GBLCTL_EK1EN_OF(x)     _VALUEOF(x)
  #define  EMIFA_GBLCTL_EK1EN_DISABLE   0x00000000u
  #define  EMIFA_GBLCTL_EK1EN_ENABLE    0x00000001u

  #define _EMIFA_GBLCTL_CLK4EN_MASK     0x00000010u
  #define _EMIFA_GBLCTL_CLK4EN_SHIFT    0x00000004u
  #define  EMIFA_GBLCTL_CLK4EN_DEFAULT  0x00000001u
  #define  EMIFA_GBLCTL_CLK4EN_OF(x)    _VALUEOF(x)
  #define  EMIFA_GBLCTL_CLK4EN_DISABLE  0x00000000u
  #define  EMIFA_GBLCTL_CLK4EN_ENABLE   0x00000001u

  #define _EMIFA_GBLCTL_CLK6EN_MASK     0x00000008u
  #define _EMIFA_GBLCTL_CLK6EN_SHIFT    0x00000003u
  #define  EMIFA_GBLCTL_CLK6EN_DEFAULT  0x00000001u
  #define  EMIFA_GBLCTL_CLK6EN_OF(x)    _VALUEOF(x)
  #define  EMIFA_GBLCTL_CLK6EN_DISABLE  0x00000000u
  #define  EMIFA_GBLCTL_CLK6EN_ENABLE   0x00000001u

  #define  EMIFA_GBLCTL_OF(x)           _VALUEOF(x)

  #define EMIFA_GBLCTL_DEFAULT (Uint32)( \
    0x00000004\
    |_PER_FDEFAULT(EMIFA,GBLCTL,EK2RATE)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,EK2HZ)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,EK2EN)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,BRMODE)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,BUSREQ)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,ARDY)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,HOLD)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,HOLDA)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,NOHOLD)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,EK1HZ)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,EK1EN)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,CLK4EN)\
    |_PER_FDEFAULT(EMIFA,GBLCTL,CLK6EN)\
  )

  #define EMIFA_GBLCTL_RMK(ek2rate,ek2hz,ek2en,brmode,nohold,ek1hz,ek1en,clk4en,clk6en) \
    (Uint32)( \
     _PER_FMK(EMIFA,GBLCTL,EK2RATE,ek2rate)\
    |_PER_FMK(EMIFA,GBLCTL,EK2HZ,ek2hz)\
    |_PER_FMK(EMIFA,GBLCTL,EK2EN,ek2en)\
    |_PER_FMK(EMIFA,GBLCTL,BRMODE,brmode)\
    |_PER_FMK(EMIFA,GBLCTL,NOHOLD,nohold)\
    |_PER_FMK(EMIFA,GBLCTL,EK1HZ,ek1hz)\
    |_PER_FMK(EMIFA,GBLCTL,EK1EN,ek1en)\
    |_PER_FMK(EMIFA,GBLCTL,CLK4EN,clk4en)\
    |_PER_FMK(EMIFA,GBLCTL,CLK6EN,clk6en)\
  )

  #define _EMIFA_GBLCTL_FGET(FIELD)\
    _PER_FGET(_EMIFA_GBLCTL_ADDR,EMIFA,GBLCTL,##FIELD)

  #define _EMIFA_GBLCTL_FSET(FIELD,field)\
    _PER_FSET(_EMIFA_GBLCTL_ADDR,EMIFA,GBLCTL,##FIELD,field)

  #define _EMIFA_GBLCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFA_GBLCTL_ADDR,EMIFA,GBLCTL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C E C T L        |
* |___________________|
*
* CECTL0 - CE space control register 0
* CECTL1 - CE space control register 1
* CECTL2 - CE space control register 2
* CECTL3 - CE space control register 3
*
* FIELDS (msb -> lsb)
* (rw) WRSETUP
* (rw) WRSTRB
* (rw) WRHLD
* (rw) RDSETUP
* (rw) TA
* (rw) RDSTRB
* (rw) MTYPE
* (rw) RDHLD
*
\******************************************************************************/
  #define _EMIFA_CECTL0_OFFSET          2
  #define _EMIFA_CECTL1_OFFSET          1
  #define _EMIFA_CECTL2_OFFSET          4
  #define _EMIFA_CECTL3_OFFSET          5

  #define _EMIFA_CECTL0_ADDR            0x01800008u
  #define _EMIFA_CECTL1_ADDR            0x01800004u
  #define _EMIFA_CECTL2_ADDR            0x01800010u
  #define _EMIFA_CECTL3_ADDR            0x01800014u

  #define _EMIFA_CECTL_WRSETUP_MASK     0xF0000000u
  #define _EMIFA_CECTL_WRSETUP_SHIFT    0x0000001Cu
  #define  EMIFA_CECTL_WRSETUP_DEFAULT  0x0000000Fu
  #define  EMIFA_CECTL_WRSETUP_OF(x)    _VALUEOF(x)

  #define _EMIFA_CECTL_WRSTRB_MASK      0x0FC00000u
  #define _EMIFA_CECTL_WRSTRB_SHIFT     0x00000016u
  #define  EMIFA_CECTL_WRSTRB_DEFAULT   0x0000003Fu
  #define  EMIFA_CECTL_WRSTRB_OF(x)     _VALUEOF(x)

  #define _EMIFA_CECTL_WRHLD_MASK       0x00300000u
  #define _EMIFA_CECTL_WRHLD_SHIFT      0x00000014u
  #define  EMIFA_CECTL_WRHLD_DEFAULT    0x00000003u
  #define  EMIFA_CECTL_WRHLD_OF(x)      _VALUEOF(x)
  
  #define _EMIFA_CECTL_RDSETUP_MASK     0x000F0000u
  #define _EMIFA_CECTL_RDSETUP_SHIFT    0x00000010u
  #define  EMIFA_CECTL_RDSETUP_DEFAULT  0x0000000Fu
  #define  EMIFA_CECTL_RDSETUP_OF(x)    _VALUEOF(x)

  #define _EMIFA_CECTL_TA_MASK          0x0000C000u
  #define _EMIFA_CECTL_TA_SHIFT         0x0000000Eu
  #define  EMIFA_CECTL_TA_DEFAULT       0x00000003u
  #define  EMIFA_CECTL_TA_OF(x)         _VALUEOF(x)

  #define _EMIFA_CECTL_RDSTRB_MASK      0x00003F00u
  #define _EMIFA_CECTL_RDSTRB_SHIFT     0x00000008u
  #define  EMIFA_CECTL_RDSTRB_DEFAULT   0x0000003Fu
  #define  EMIFA_CECTL_RDSTRB_OF(x)     _VALUEOF(x)
  
  #define _EMIFA_CECTL_MTYPE_MASK       0x000000F0u
  #define _EMIFA_CECTL_MTYPE_SHIFT      0x00000004u
  #define  EMIFA_CECTL_MTYPE_DEFAULT    0x00000000u
  #define  EMIFA_CECTL_MTYPE_OF(x)      _VALUEOF(x)
  #define  EMIFA_CECTL_MTYPE_ASYNC8     0x00000000u
  #define  EMIFA_CECTL_MTYPE_ASYNC16    0x00000001u
  #define  EMIFA_CECTL_MTYPE_ASYNC32    0x00000002u
  #define  EMIFA_CECTL_MTYPE_SDRAM32    0x00000003u
  #define  EMIFA_CECTL_MTYPE_SYNC32     0x00000004u
  #define  EMIFA_CECTL_MTYPE_SDRAM8     0x00000008u
  #define  EMIFA_CECTL_MTYPE_SDRAM16    0x00000009u
  #define  EMIFA_CECTL_MTYPE_SYNC8      0x0000000Au
  #define  EMIFA_CECTL_MTYPE_SYNC16     0x0000000Bu
#if (!(CHIP_6410 || CHIP_6413 || CHIP_6418 ))
  #define  EMIFA_CECTL_MTYPE_ASYNC64    0x0000000Cu
  #define  EMIFA_CECTL_MTYPE_SDRAM64    0x0000000Du
  #define  EMIFA_CECTL_MTYPE_SYNC64     0x0000000Eu
#endif
  #define _EMIFA_CECTL_WRHLDMSB_MASK    0x00000008u
  #define _EMIFA_CECTL_WRHLDMSB_SHIFT   0x00000003u
  #define  EMIFA_CECTL_WRHLDMSB_DEFAULT 0x00000000u
  #define  EMIFA_CECTL_WRHLDMSB_OF(x)   _VALUEOF(x)

  #define _EMIFA_CECTL_RDHLD_MASK       0x00000007u
  #define _EMIFA_CECTL_RDHLD_SHIFT      0x00000000u
  #define  EMIFA_CECTL_RDHLD_DEFAULT    0x00000003u
  #define  EMIFA_CECTL_RDHLD_OF(x)      _VALUEOF(x)

  #define  EMIFA_CECTL_OF(x)            _VALUEOF(x)

  #define EMIFA_CECTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFA,CECTL,WRSETUP)\
    |_PER_FDEFAULT(EMIFA,CECTL,WRSTRB)\
    |_PER_FDEFAULT(EMIFA,CECTL,WRHLD)\
    |_PER_FDEFAULT(EMIFA,CECTL,RDSETUP)\
    |_PER_FDEFAULT(EMIFA,CECTL,TA)\
    |_PER_FDEFAULT(EMIFA,CECTL,RDSTRB)\
    |_PER_FDEFAULT(EMIFA,CECTL,MTYPE)\
    |_PER_FDEFAULT(EMIFA,CECTL,WRHLDMSB)\
    |_PER_FDEFAULT(EMIFA,CECTL,RDHLD)\
  )
#if (CHIP_6413 || CHIP_6418 || CHIP_6410)
  /*Read only field TA has a value of 0x3 */
  #define EMIFA_CECTL_RMK(wrsetup,wrstrb,wrhld,rdsetup,rdstrb,mtype,\
    wrhldmsb,rdhld) (Uint32)( \
     _PER_FMK(EMIFA,CECTL,WRSETUP,wrsetup)\
    |_PER_FMK(EMIFA,CECTL,WRSTRB,wrstrb)\
    |_PER_FMK(EMIFA,CECTL,WRHLD,wrhld)\
    |_PER_FMK(EMIFA,CECTL,TA,0x3)\
    |_PER_FMK(EMIFA,CECTL,RDSETUP,rdsetup)\
    |_PER_FMK(EMIFA,CECTL,RDSTRB,rdstrb)\
    |_PER_FMK(EMIFA,CECTL,MTYPE,mtype)\
    |_PER_FMK(EMIFA,CECTL,WRHLDMSB,wrhldmsb)\
    |_PER_FMK(EMIFA,CECTL,RDHLD,rdhld)\
  )
#else
   #define EMIFA_CECTL_RMK(wrsetup,wrstrb,wrhld,ta,rdsetup,rdstrb,mtype,\
    wrhldmsb,rdhld) (Uint32)( \
     _PER_FMK(EMIFA,CECTL,WRSETUP,wrsetup)\
    |_PER_FMK(EMIFA,CECTL,WRSTRB,wrstrb)\
    |_PER_FMK(EMIFA,CECTL,WRHLD,wrhld)\
    |_PER_FMK(EMIFA,CECTL,TA,ta)\
    |_PER_FMK(EMIFA,CECTL,RDSETUP,rdsetup)\
    |_PER_FMK(EMIFA,CECTL,RDSTRB,rdstrb)\
    |_PER_FMK(EMIFA,CECTL,MTYPE,mtype)\
    |_PER_FMK(EMIFA,CECTL,WRHLDMSB,wrhldmsb)\
    |_PER_FMK(EMIFA,CECTL,RDHLD,rdhld)\
  )  
#endif    
  #define _EMIFA_CECTL_FGET(N,FIELD)\
    _PER_FGET(_EMIFA_CECTL##N##_ADDR,EMIFA,CECTL,##FIELD)

  #define _EMIFA_CECTL_FSET(N,FIELD,f)\
    _PER_FSET(_EMIFA_CECTL##N##_ADDR,EMIFA,CECTL,##FIELD,f)

  #define _EMIFA_CECTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_EMIFA_CECTL##N##_ADDR,EMIFA,CECTL,##FIELD,##SYM)

  #define _EMIFA_CECTL0_FGET(FIELD) _EMIFA_CECTL_FGET(0,##FIELD)
  #define _EMIFA_CECTL1_FGET(FIELD) _EMIFA_CECTL_FGET(1,##FIELD)
  #define _EMIFA_CECTL2_FGET(FIELD) _EMIFA_CECTL_FGET(2,##FIELD)
  #define _EMIFA_CECTL3_FGET(FIELD) _EMIFA_CECTL_FGET(3,##FIELD)

  #define _EMIFA_CECTL0_FSET(FIELD,f) _EMIFA_CECTL_FSET(0,##FIELD,f)
  #define _EMIFA_CECTL1_FSET(FIELD,f) _EMIFA_CECTL_FSET(1,##FIELD,f)
  #define _EMIFA_CECTL2_FSET(FIELD,f) _EMIFA_CECTL_FSET(2,##FIELD,f)
  #define _EMIFA_CECTL3_FSET(FIELD,f) _EMIFA_CECTL_FSET(3,##FIELD,f)

  #define _EMIFA_CECTL0_FSETS(FIELD,SYM) _EMIFA_CECTL_FSETS(0,##FIELD,##SYM)
  #define _EMIFA_CECTL1_FSETS(FIELD,SYM) _EMIFA_CECTL_FSETS(1,##FIELD,##SYM)
  #define _EMIFA_CECTL2_FSETS(FIELD,SYM) _EMIFA_CECTL_FSETS(2,##FIELD,##SYM)
  #define _EMIFA_CECTL3_FSETS(FIELD,SYM) _EMIFA_CECTL_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D C T L        |
* |___________________|
*
* SDCTL   - SDRAM control regsiter
*
* FIELDS (msb -> lsb)
* (rw) SDBSZ 
* (rw) SDRSZ 
* (rw) SDCSZ 
* (rw) RFEN
* (w)  INIT
* (rw) TRCD
* (rw) TRP
* (rw) TRC
* (rw) SLFRFR
*
\******************************************************************************/
  #define _EMIFA_SDCTL_OFFSET           6

  #define _EMIFA_SDCTL_ADDR             0x01800018u

  #define _EMIFA_SDCTL_SDBSZ_MASK       0x40000000u
  #define _EMIFA_SDCTL_SDBSZ_SHIFT      0x0000001Eu
  #define  EMIFA_SDCTL_SDBSZ_DEFAULT    0x00000000u
  #define  EMIFA_SDCTL_SDBSZ_OF(x)      _VALUEOF(x)
  #define  EMIFA_SDCTL_SDBSZ_2BANKS     0x00000000u
  #define  EMIFA_SDCTL_SDBSZ_4BANKS     0x00000001u
  
  #define _EMIFA_SDCTL_SDRSZ_MASK       0x30000000u
  #define _EMIFA_SDCTL_SDRSZ_SHIFT      0x0000001Cu
  #define  EMIFA_SDCTL_SDRSZ_DEFAULT    0x00000000u
  #define  EMIFA_SDCTL_SDRSZ_OF(x)      _VALUEOF(x)
  #define  EMIFA_SDCTL_SDRSZ_11ROW      0x00000000u
  #define  EMIFA_SDCTL_SDRSZ_12ROW      0x00000001u
  #define  EMIFA_SDCTL_SDRSZ_13ROW      0x00000002u
  
  #define _EMIFA_SDCTL_SDCSZ_MASK       0x0C000000u
  #define _EMIFA_SDCTL_SDCSZ_SHIFT      0x0000001Au
  #define  EMIFA_SDCTL_SDCSZ_DEFAULT    0x00000000u
  #define  EMIFA_SDCTL_SDCSZ_OF(x)      _VALUEOF(x)
  #define  EMIFA_SDCTL_SDCSZ_9COL       0x00000000u
  #define  EMIFA_SDCTL_SDCSZ_8COL       0x00000001u
  #define  EMIFA_SDCTL_SDCSZ_10COL      0x00000002u
  
  #define _EMIFA_SDCTL_RFEN_MASK        0x02000000u
  #define _EMIFA_SDCTL_RFEN_SHIFT       0x00000019u
  #define  EMIFA_SDCTL_RFEN_DEFAULT     0x00000001u
  #define  EMIFA_SDCTL_RFEN_OF(x)       _VALUEOF(x)
  #define  EMIFA_SDCTL_RFEN_DISABLE     0x00000000u
  #define  EMIFA_SDCTL_RFEN_ENABLE      0x00000001u

  #define _EMIFA_SDCTL_INIT_MASK        0x01000000u
  #define _EMIFA_SDCTL_INIT_SHIFT       0x00000018u
  #define  EMIFA_SDCTL_INIT_DEFAULT     0x00000001u
  #define  EMIFA_SDCTL_INIT_OF(x)       _VALUEOF(x)
  #define  EMIFA_SDCTL_INIT_NO          0x00000000u
  #define  EMIFA_SDCTL_INIT_YES         0x00000001u

  #define _EMIFA_SDCTL_TRCD_MASK        0x00F00000u
  #define _EMIFA_SDCTL_TRCD_SHIFT       0x00000014u
  #define  EMIFA_SDCTL_TRCD_DEFAULT     0x00000004u
  #define  EMIFA_SDCTL_TRCD_OF(x)       _VALUEOF(x)

  #define _EMIFA_SDCTL_TRP_MASK         0x000F0000u
  #define _EMIFA_SDCTL_TRP_SHIFT        0x00000010u
  #define  EMIFA_SDCTL_TRP_DEFAULT      0x00000008u
  #define  EMIFA_SDCTL_TRP_OF(x)        _VALUEOF(x)

  #define _EMIFA_SDCTL_TRC_MASK         0x0000F000u
  #define _EMIFA_SDCTL_TRC_SHIFT        0x0000000Cu
  #define  EMIFA_SDCTL_TRC_DEFAULT      0x0000000Fu
  #define  EMIFA_SDCTL_TRC_OF(x)        _VALUEOF(x)

  #define _EMIFA_SDCTL_SLFRFR_MASK      0x00000001u
  #define _EMIFA_SDCTL_SLFRFR_SHIFT     0x00000000u
  #define  EMIFA_SDCTL_SLFRFR_DEFAULT   0x00000000u
  #define  EMIFA_SDCTL_SLFRFR_OF(x)     _VALUEOF(x)
  #define  EMIFA_SDCTL_SLFRFR_DISABLE   0x00000000u
  #define  EMIFA_SDCTL_SLFRFR_ENABLE    0x00000001u

  #define  EMIFA_SDCTL_OF(x)            _VALUEOF(x)

  #define EMIFA_SDCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFA,SDCTL,SDBSZ)\
    |_PER_FDEFAULT(EMIFA,SDCTL,SDRSZ)\
    |_PER_FDEFAULT(EMIFA,SDCTL,SDCSZ)\
    |_PER_FDEFAULT(EMIFA,SDCTL,RFEN)\
    |_PER_FDEFAULT(EMIFA,SDCTL,INIT)\
    |_PER_FDEFAULT(EMIFA,SDCTL,TRCD)\
    |_PER_FDEFAULT(EMIFA,SDCTL,TRP)\
    |_PER_FDEFAULT(EMIFA,SDCTL,TRC)\
    |_PER_FDEFAULT(EMIFA,SDCTL,SLFRFR)\
  )

  #define EMIFA_SDCTL_RMK(sdbsz,sdrsz,sdcsz,rfen,init,trcd,trp,trc,slfrfr) (Uint32)(\
     _PER_FMK(EMIFA,SDCTL,SDBSZ,sdbsz)\
    |_PER_FMK(EMIFA,SDCTL,SDRSZ,sdrsz)\
    |_PER_FMK(EMIFA,SDCTL,SDCSZ,sdcsz)\
    |_PER_FMK(EMIFA,SDCTL,RFEN,rfen)\
    |_PER_FMK(EMIFA,SDCTL,INIT,init)\
    |_PER_FMK(EMIFA,SDCTL,TRCD,trcd)\
    |_PER_FMK(EMIFA,SDCTL,TRP,trp)\
    |_PER_FMK(EMIFA,SDCTL,TRC,trc)\
    |_PER_FMK(EMIFA,SDCTL,SLFRFR,slfrfr)\
  )

  #define _EMIFA_SDCTL_FGET(FIELD)\
    _PER_FGET(_EMIFA_SDCTL_ADDR,EMIFA,SDCTL,##FIELD)

  #define _EMIFA_SDCTL_FSET(FIELD,field)\
    _PER_FSET(_EMIFA_SDCTL_ADDR,EMIFA,SDCTL,##FIELD,field)

  #define _EMIFA_SDCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFA_SDCTL_ADDR,EMIFA,SDCTL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D T I M        |
* |___________________|
*
* SDTIM   - SDRAM timing register
*
* FIELDS (msb -> lsb)
* (rw) XRFR
* (r)  CNTR
* (rw) PERIOD
*
\******************************************************************************/
  #define _EMIFA_SDTIM_OFFSET           7

  #define _EMIFA_SDTIM_ADDR             0x0180001Cu

  #define _EMIFA_SDTIM_XRFR_MASK        0x03000000u
  #define _EMIFA_SDTIM_XRFR_SHIFT       0x00000018u
  #define  EMIFA_SDTIM_XRFR_DEFAULT     0x00000000u
  #define  EMIFA_SDTIM_XRFR_OF(x)       _VALUEOF(x)

  #define _EMIFA_SDTIM_CNTR_MASK        0x00FFF000u
  #define _EMIFA_SDTIM_CNTR_SHIFT       0x0000000Cu
  #define  EMIFA_SDTIM_CNTR_DEFAULT     0x000005DCu
  #define  EMIFA_SDTIM_CNTR_OF(x)       _VALUEOF(x)
  
  #define _EMIFA_SDTIM_PERIOD_MASK      0x00000FFFu
  #define _EMIFA_SDTIM_PERIOD_SHIFT     0x00000000u
  #define  EMIFA_SDTIM_PERIOD_DEFAULT   0x000005DCu
  #define  EMIFA_SDTIM_PERIOD_OF(x)     _VALUEOF(x)

  #define  EMIFA_SDTIM_OF(x)            _VALUEOF(x)

  #define EMIFA_SDTIM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFA,SDTIM,XRFR)\
    |_PER_FDEFAULT(EMIFA,SDTIM,CNTR)\
    |_PER_FDEFAULT(EMIFA,SDTIM,PERIOD)\
  )

  #define EMIFA_SDTIM_RMK(xrfr,period) (Uint32)(\
     _PER_FMK(EMIFA,SDTIM,XRFR,xrfr)\
    |_PER_FMK(EMIFA,SDTIM,PERIOD,period)\
  )

  #define _EMIFA_SDTIM_FGET(FIELD)\
    _PER_FGET(_EMIFA_SDTIM_ADDR,EMIFA,SDTIM,##FIELD)

  #define _EMIFA_SDTIM_FSET(FIELD,field)\
    _PER_FSET(_EMIFA_SDTIM_ADDR,EMIFA,SDTIM,##FIELD,field)

  #define _EMIFA_SDTIM_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFA_SDTIM_ADDR,EMIFA,SDTIM,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D E X T        |
* |___________________|
*
* SDEXT   - SDRAM extension register
*
* FIELDS (msb -> lsb)
* (rw) WR2RD
* (rw) WR2DEAC
* (rw) WR2WR
* (rw) R2WDQM
* (rw) RD2WR
* (rw) RD2DEAC
* (rw) RD2RD
* (rw) THZP
* (rw) TWR
* (rw) TRRD
* (rw) TRAS
* (rw) TCL
*
\******************************************************************************/
  #define _EMIFA_SDEXT_OFFSET           8

  #define _EMIFA_SDEXT_ADDR             0x01800020u

  #define _EMIFA_SDEXT_WR2RD_MASK       0x00100000u
  #define _EMIFA_SDEXT_WR2RD_SHIFT      0x00000014u
  #define  EMIFA_SDEXT_WR2RD_DEFAULT    0x00000001u
  #define  EMIFA_SDEXT_WR2RD_OF(x)      _VALUEOF(x)

  #define _EMIFA_SDEXT_WR2DEAC_MASK     0x000C0000u
  #define _EMIFA_SDEXT_WR2DEAC_SHIFT    0x00000012u
  #define  EMIFA_SDEXT_WR2DEAC_DEFAULT  0x00000001u
  #define  EMIFA_SDEXT_WR2DEAC_OF(x)    _VALUEOF(x)

  #define _EMIFA_SDEXT_WR2WR_MASK       0x00020000u
  #define _EMIFA_SDEXT_WR2WR_SHIFT      0x00000011u
  #define  EMIFA_SDEXT_WR2WR_DEFAULT    0x00000001u
  #define  EMIFA_SDEXT_WR2WR_OF(x)      _VALUEOF(x)

  #define _EMIFA_SDEXT_R2WDQM_MASK      0x00018000u
  #define _EMIFA_SDEXT_R2WDQM_SHIFT     0x0000000Fu
  #define  EMIFA_SDEXT_R2WDQM_DEFAULT   0x00000002u
  #define  EMIFA_SDEXT_R2WDQM_OF(x)     _VALUEOF(x)

  #define _EMIFA_SDEXT_RD2WR_MASK       0x00007000u
  #define _EMIFA_SDEXT_RD2WR_SHIFT      0x0000000Cu
  #define  EMIFA_SDEXT_RD2WR_DEFAULT    0x00000005u
  #define  EMIFA_SDEXT_RD2WR_OF(x)      _VALUEOF(x)

  #define _EMIFA_SDEXT_RD2DEAC_MASK     0x00000C00u
  #define _EMIFA_SDEXT_RD2DEAC_SHIFT    0x0000000Au
  #define  EMIFA_SDEXT_RD2DEAC_DEFAULT  0x00000003u
  #define  EMIFA_SDEXT_RD2DEAC_OF(x)    _VALUEOF(x)

  #define _EMIFA_SDEXT_RD2RD_MASK       0x00000200u
  #define _EMIFA_SDEXT_RD2RD_SHIFT      0x00000009u
  #define  EMIFA_SDEXT_RD2RD_DEFAULT    0x00000001u
  #define  EMIFA_SDEXT_RD2RD_OF(x)      _VALUEOF(x)

  #define _EMIFA_SDEXT_THZP_MASK        0x00000180u
  #define _EMIFA_SDEXT_THZP_SHIFT       0x00000007u
  #define  EMIFA_SDEXT_THZP_DEFAULT     0x00000002u
  #define  EMIFA_SDEXT_THZP_OF(x)       _VALUEOF(x)

  #define _EMIFA_SDEXT_TWR_MASK         0x00000060u
  #define _EMIFA_SDEXT_TWR_SHIFT        0x00000005u
  #define  EMIFA_SDEXT_TWR_DEFAULT      0x00000001u
  #define  EMIFA_SDEXT_TWR_OF(x)        _VALUEOF(x)

  #define _EMIFA_SDEXT_TRRD_MASK        0x00000010u
  #define _EMIFA_SDEXT_TRRD_SHIFT       0x00000004u
  #define  EMIFA_SDEXT_TRRD_DEFAULT     0x00000001u
  #define  EMIFA_SDEXT_TRRD_OF(x)       _VALUEOF(x)

  #define _EMIFA_SDEXT_TRAS_MASK        0x0000000Eu
  #define _EMIFA_SDEXT_TRAS_SHIFT       0x00000001u
  #define  EMIFA_SDEXT_TRAS_DEFAULT     0x00000007u
  #define  EMIFA_SDEXT_TRAS_OF(x)       _VALUEOF(x)

  #define _EMIFA_SDEXT_TCL_MASK         0x00000001u
  #define _EMIFA_SDEXT_TCL_SHIFT        0x00000000u
  #define  EMIFA_SDEXT_TCL_DEFAULT      0x00000001u
  #define  EMIFA_SDEXT_TCL_OF(x)        _VALUEOF(x)

  #define  EMIFA_SDEXT_OF(x)            _VALUEOF(x)

  #define EMIFA_SDEXT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFA,SDEXT,WR2RD)\
    |_PER_FDEFAULT(EMIFA,SDEXT,WR2DEAC)\
    |_PER_FDEFAULT(EMIFA,SDEXT,WR2WR)\
    |_PER_FDEFAULT(EMIFA,SDEXT,R2WDQM)\
    |_PER_FDEFAULT(EMIFA,SDEXT,RD2WR)\
    |_PER_FDEFAULT(EMIFA,SDEXT,RD2DEAC)\
    |_PER_FDEFAULT(EMIFA,SDEXT,RD2RD)\
    |_PER_FDEFAULT(EMIFA,SDEXT,THZP)\
    |_PER_FDEFAULT(EMIFA,SDEXT,TWR)\
    |_PER_FDEFAULT(EMIFA,SDEXT,TRRD)\
    |_PER_FDEFAULT(EMIFA,SDEXT,TRAS)\
    |_PER_FDEFAULT(EMIFA,SDEXT,TCL)\
  )

  #define EMIFA_SDEXT_RMK(wr2rd,wr2deac,wr2wr,r2wdqm,rd2wr,rd2deac,\
    rd2rd,thzp,twr,trrd,tras,tcl) (Uint32)( \
     _PER_FMK(EMIFA,SDEXT,WR2RD,wr2rd)\
    |_PER_FMK(EMIFA,SDEXT,WR2DEAC,wr2deac)\
    |_PER_FMK(EMIFA,SDEXT,WR2WR,wr2wr)\
    |_PER_FMK(EMIFA,SDEXT,R2WDQM,r2wdqm)\
    |_PER_FMK(EMIFA,SDEXT,RD2WR,rd2wr)\
    |_PER_FMK(EMIFA,SDEXT,RD2DEAC,rd2deac)\
    |_PER_FMK(EMIFA,SDEXT,RD2RD,rd2rd)\
    |_PER_FMK(EMIFA,SDEXT,THZP,thzp)\
    |_PER_FMK(EMIFA,SDEXT,TWR,twr)\
    |_PER_FMK(EMIFA,SDEXT,TRRD,trrd)\
    |_PER_FMK(EMIFA,SDEXT,TRAS,tras)\
    |_PER_FMK(EMIFA,SDEXT,TCL,tcl)\
  )

  #define _EMIFA_SDEXT_FGET(FIELD)\
    _PER_FGET(_EMIFA_SDEXT_ADDR,EMIFA,SDEXT,##FIELD)

  #define _EMIFA_SDEXT_FSET(FIELD,field)\
    _PER_FSET(_EMIFA_SDEXT_ADDR,EMIFA,SDEXT,##FIELD,field)

  #define _EMIFA_SDEXT_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFA_SDEXT_ADDR,EMIFA,SDEXT,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  C E x S E C      |
* |___________________|
*
* CESEC0 - CE space secondary control register 0
* CESEC1 - CE space secondary control register 1
* CESEC2 - CE space secondary control register 2
* CESEC3 - CE space secondary control register 3
*
* FIELDS (msb -> lsb)
* (rw) SNCCLK
* (rw) RENEN
* (rw) CEEXT
* (rw) SYNCWL
* (rw) SYNCRL
*
\******************************************************************************/
  #define _EMIFA_CESEC0_OFFSET          18
  #define _EMIFA_CESEC1_OFFSET          17
  #define _EMIFA_CESEC2_OFFSET          20
  #define _EMIFA_CESEC3_OFFSET          21

  #define _EMIFA_CESEC0_ADDR            0x01800048u
  #define _EMIFA_CESEC1_ADDR            0x01800044u
  #define _EMIFA_CESEC2_ADDR            0x01800050u
  #define _EMIFA_CESEC3_ADDR            0x01800054u

  #define _EMIFA_CESEC_SNCCLK_MASK      0x00000040u
  #define _EMIFA_CESEC_SNCCLK_SHIFT     0x00000006u
  #define  EMIFA_CESEC_SNCCLK_DEFAULT   0x00000000u
  #define  EMIFA_CESEC_SNCCLK_OF(x)     _VALUEOF(x)
  #define  EMIFA_CESEC_SNCCLK_ECLKOUT1  0x00000000u
  #define  EMIFA_CESEC_SNCCLK_ECLKOUT2  0x00000001u

  #define _EMIFA_CESEC_RENEN_MASK      0x00000020u
  #define _EMIFA_CESEC_RENEN_SHIFT     0x00000005u
  #define  EMIFA_CESEC_RENEN_DEFAULT   0x00000000u
  #define  EMIFA_CESEC_RENEN_OF(x)     _VALUEOF(x)
  #define  EMIFA_CESEC_RENEN_ADS       0x00000000u
  #define  EMIFA_CESEC_RENEN_READ      0x00000001u

  #define _EMIFA_CESEC_CEEXT_MASK      0x00000010u
  #define _EMIFA_CESEC_CEEXT_SHIFT     0x00000004u
  #define  EMIFA_CESEC_CEEXT_DEFAULT   0x00000000u
  #define  EMIFA_CESEC_CEEXT_OF(x)     _VALUEOF(x)
  #define  EMIFA_CESEC_CEEXT_INACTIVE  0x00000000u
  #define  EMIFA_CESEC_CEEXT_ACTIVE    0x00000001u

  #define _EMIFA_CESEC_SYNCWL_MASK      0x0000000Cu
  #define _EMIFA_CESEC_SYNCWL_SHIFT     0x00000002u
  #define  EMIFA_CESEC_SYNCWL_DEFAULT   0x00000000u
  #define  EMIFA_CESEC_SYNCWL_OF(x)     _VALUEOF(x)
  #define  EMIFA_CESEC_SYNCWL_0CYCLE    0x00000000u
  #define  EMIFA_CESEC_SYNCWL_1CYCLE    0x00000001u
  #define  EMIFA_CESEC_SYNCWL_2CYCLE    0x00000002u
  #define  EMIFA_CESEC_SYNCWL_3CYCLE    0x00000003u

  #define _EMIFA_CESEC_SYNCRL_MASK      0x00000003u
  #define _EMIFA_CESEC_SYNCRL_SHIFT     0x00000000u
  #define  EMIFA_CESEC_SYNCRL_DEFAULT   0x00000002u
  #define  EMIFA_CESEC_SYNCRL_OF(x)     _VALUEOF(x)
  #define  EMIFA_CESEC_SYNCRL_0CYCLE    0x00000000u
  #define  EMIFA_CESEC_SYNCRL_1CYCLE    0x00000001u
  #define  EMIFA_CESEC_SYNCRL_2CYCLE    0x00000002u
  #define  EMIFA_CESEC_SYNCRL_3CYCLE    0x00000003u

  #define  EMIFA_CESEC_OF(x)            _VALUEOF(x)

  #define EMIFA_CESEC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFA,CESEC,SNCCLK)\
    |_PER_FDEFAULT(EMIFA,CESEC,RENEN)\
    |_PER_FDEFAULT(EMIFA,CESEC,CEEXT)\
    |_PER_FDEFAULT(EMIFA,CESEC,SYNCWL)\
    |_PER_FDEFAULT(EMIFA,CESEC,SYNCRL)\
  )

  #define EMIFA_CESEC_RMK(sncclk,renen,ceext,syncwl,syncrl)\
    (Uint32)( \
     _PER_FMK(EMIFA,CESEC,SNCCLK,sncclk)\
    |_PER_FMK(EMIFA,CESEC,RENEN,renen)\
    |_PER_FMK(EMIFA,CESEC,CEEXT,ceext)\
    |_PER_FMK(EMIFA,CESEC,SYNCWL,syncwl)\
    |_PER_FMK(EMIFA,CESEC,SYNCRL,syncrl)\
  )

  #define _EMIFA_CESEC_FGET(N,FIELD)\
    _PER_FGET(_EMIFA_CESEC##N##_ADDR,EMIFA,CESEC,##FIELD)

  #define _EMIFA_CESEC_FSET(N,FIELD,f)\
    _PER_FSET(_EMIFA_CESEC##N##_ADDR,EMIFA,CESEC,##FIELD,f)

  #define _EMIFA_CESEC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_EMIFA_CESEC##N##_ADDR,EMIFA,CESEC,##FIELD,##SYM)

  #define _EMIFA_CESEC0_FGET(FIELD) _EMIFA_CESEC_FGET(0,##FIELD)
  #define _EMIFA_CESEC1_FGET(FIELD) _EMIFA_CESEC_FGET(1,##FIELD)
  #define _EMIFA_CESEC2_FGET(FIELD) _EMIFA_CESEC_FGET(2,##FIELD)
  #define _EMIFA_CESEC3_FGET(FIELD) _EMIFA_CESEC_FGET(3,##FIELD)

  #define _EMIFA_CESEC0_FSET(FIELD,f) _EMIFA_CESEC_FSET(0,##FIELD,f)
  #define _EMIFA_CESEC1_FSET(FIELD,f) _EMIFA_CESEC_FSET(1,##FIELD,f)
  #define _EMIFA_CESEC2_FSET(FIELD,f) _EMIFA_CESEC_FSET(2,##FIELD,f)
  #define _EMIFA_CESEC3_FSET(FIELD,f) _EMIFA_CESEC_FSET(3,##FIELD,f)

  #define _EMIFA_CESEC0_FSETS(FIELD,SYM) _EMIFA_CESEC_FSETS(0,##FIELD,##SYM)
  #define _EMIFA_CESEC1_FSETS(FIELD,SYM) _EMIFA_CESEC_FSETS(1,##FIELD,##SYM)
  #define _EMIFA_CESEC2_FSETS(FIELD,SYM) _EMIFA_CESEC_FSETS(2,##FIELD,##SYM)
  #define _EMIFA_CESEC3_FSETS(FIELD,SYM) _EMIFA_CESEC_FSETS(3,##FIELD,##SYM)

   
/******************************************************************************\
* _____________________
* |                   |
* |  P D T C T L      |
* |___________________|
*
* PDTCTL   - Peripheral device transfer (PDT) control
*
* FIELDS (msb -> lsb)
* (rw) PDTWL
* (rw) PDTRL
*
\******************************************************************************/
  #define _EMIFA_PDTCTL_OFFSET          16 

  #define _EMIFA_PDTCTL_ADDR            0x01800040u

  #define _EMIFA_PDTCTL_PDTWL_MASK      0x0000000Cu
  #define _EMIFA_PDTCTL_PDTWL_SHIFT     0x00000002u
  #define  EMIFA_PDTCTL_PDTWL_DEFAULT   0x00000000u
  #define  EMIFA_PDTCTL_PDTWL_OF(x)     _VALUEOF(x)
  #define  EMIFA_PDTCTL_PDTWL_0CYCLE    0x00000000u
  #define  EMIFA_PDTCTL_PDTWL_1CYCLE    0x00000001u
  #define  EMIFA_PDTCTL_PDTWL_2CYCLE    0x00000002u
  #define  EMIFA_PDTCTL_PDTWL_3CYCLE    0x00000003u

  #define _EMIFA_PDTCTL_PDTRL_MASK      0x000C0003u
  #define _EMIFA_PDTCTL_PDTRL_SHIFT     0x00000000u
  #define  EMIFA_PDTCTL_PDTRL_DEFAULT   0x00000000u
  #define  EMIFA_PDTCTL_PDTRL_OF(x)     _VALUEOF(x)
  #define  EMIFA_PDTCTL_PDTRL_0CYCLE    0x00000000u
  #define  EMIFA_PDTCTL_PDTRL_1CYCLE    0x00000001u
  #define  EMIFA_PDTCTL_PDTRL_2CYCLE    0x00000002u
  #define  EMIFA_PDTCTL_PDTRL_3CYCLE    0x00000003u


  #define EMIFA_PDTCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFA,PDTCTL,PDTWL)\
    |_PER_FDEFAULT(EMIFA,PDTCTL,PDTRL)\
  )

  #define EMIFA_PDTCTL_RMK(pdtwl,pdtrl) (Uint32)( \
     _PER_FMK(EMIFA,PDTCTL,PDTWL,pdtwl)\
    |_PER_FMK(EMIFA,PDTCTL,PDTRL,pdtrl)\
  )

  #define _EMIFA_PDTCTL_FGET(FIELD)\
    _PER_FGET(_EMIFA_PDTCTL_ADDR,EMIFA,PDTCTL,##FIELD)

  #define _EMIFA_PDTCTL_FSET(FIELD,field)\
    _PER_FSET(_EMIFA_PDTCTL_ADDR,EMIFA,PDTCTL,##FIELD,field)

  #define _EMIFA_PDTCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFA_PDTCTL_ADDR,EMIFA,PDTCTL,##FIELD,##SYM)

#endif /* EMIFA_SUPPORT */

#endif /* _CSL_EMIFHAL_H_ */
/******************************************************************************\
* End of csl_emifahal.h
\******************************************************************************/


csl_emifb.h/    1044860104  0     0     0       6800      `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emifb.h
* DATE CREATED.. 03/27/2001 
* LAST MODIFIED. 01/31/2002 SDCTL reg. setting after SDEXT reg.setting
\******************************************************************************/
#ifndef _CSL_EMIFB_H_
#define _CSL_EMIFB_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_emifbhal.h>


#if (EMIFB_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _EMIFB_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* device configuration structure */
typedef struct {
  Uint32 gblctl;
  Uint32 cectl0;
  Uint32 cectl1;
  Uint32 cectl2;
  Uint32 cectl3;
  Uint32 sdctl;
  Uint32 sdtim;
  Uint32 sdext;
  Uint32 cesec0;
  Uint32 cesec1;
  Uint32 cesec2;
  Uint32 cesec3;
} EMIFB_Config;


/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/


/******************************************************************************\
* inline function declarations
\******************************************************************************/
#if (CHIP_6414 | CHIP_6415 | CHIP_6416 ) 
IDECL void EMIFB_config(EMIFB_Config *config);
IDECL void EMIFB_configArgs(Uint32 gblctl, Uint32 cectl0, Uint32 cectl1,
    Uint32 cectl2, Uint32 cectl3, Uint32 sdctl, Uint32 sdtim, Uint32 sdext, Uint32 cesec0,
    Uint32 cesec1, Uint32 cesec2, Uint32 cesec3);
IDECL void EMIFB_getConfig(EMIFB_Config *config);
#endif

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
#if (CHIP_6414 | CHIP_6415 | CHIP_6416 ) 
IDEF void EMIFB_config(EMIFB_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIFB_BASE_GLOBAL;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */
  x0  = config->gblctl;
  x1  = config->cectl0;
  x2  = config->cectl1;
  x3  = config->cectl2;
  x4  = config->cectl3;
  x5  = config->sdctl;
  x6  = config->sdtim;
  x7  = config->sdext;
  x8  = config->cesec0;
  x9  = config->cesec1;
  x10 = config->cesec2;
  x11 = config->cesec3;

  base[_EMIFB_GBLCTL_OFFSET]  = x0;
  base[_EMIFB_CECTL0_OFFSET]  = x1;
  base[_EMIFB_CECTL1_OFFSET]  = x2;
  base[_EMIFB_CECTL2_OFFSET]  = x3;
  base[_EMIFB_CECTL3_OFFSET]  = x4;
  base[_EMIFB_SDTIM_OFFSET]   = x6;
  base[_EMIFB_SDEXT_OFFSET]   = x7;
  base[_EMIFB_CESEC0_OFFSET]  = x8;
  base[_EMIFB_CESEC1_OFFSET]  = x9;
  base[_EMIFB_CESEC2_OFFSET]  = x10;
  base[_EMIFB_CESEC3_OFFSET]  = x11;

  base[_EMIFB_SDCTL_OFFSET]   = x5;


  IRQ_globalRestore(gie);
}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
#if (CHIP_6414 | CHIP_6415 | CHIP_6416 ) 
IDEF void EMIFB_configArgs(Uint32 gblctl, Uint32 cectl0, Uint32 cectl1,
  Uint32 cectl2, Uint32 cectl3, Uint32 sdctl, Uint32 sdtim, Uint32 sdext,
  Uint32 cesec0, Uint32 cesec1, Uint32 cesec2, Uint32 cesec3) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIFB_BASE_GLOBAL;

  gie = IRQ_globalDisable();

  base[_EMIFB_GBLCTL_OFFSET]  = gblctl;
  base[_EMIFB_CECTL0_OFFSET]  = cectl0;
  base[_EMIFB_CECTL1_OFFSET]  = cectl1;
  base[_EMIFB_CECTL2_OFFSET]  = cectl2;
  base[_EMIFB_CECTL3_OFFSET]  = cectl3;
  base[_EMIFB_SDTIM_OFFSET]   = sdtim;
  base[_EMIFB_SDEXT_OFFSET]   = sdext;
  base[_EMIFB_CESEC0_OFFSET]  = cesec0;
  base[_EMIFB_CESEC1_OFFSET]  = cesec1;
  base[_EMIFB_CESEC2_OFFSET]  = cesec2;
  base[_EMIFB_CESEC3_OFFSET]  = cesec3;

  base[_EMIFB_SDCTL_OFFSET]   = sdctl;

  IRQ_globalRestore(gie);
}

#endif 
/*----------------------------------------------------------------------------*/
#if (CHIP_6414 | CHIP_6415 | CHIP_6416 ) 
IDEF void EMIFB_getConfig(EMIFB_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_EMIFB_BASE_GLOBAL;
  volatile EMIFB_Config* cfg = (volatile EMIFB_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */

  x0  = base[_EMIFB_GBLCTL_OFFSET];
  x1  = base[_EMIFB_CECTL0_OFFSET];
  x2  = base[_EMIFB_CECTL1_OFFSET];
  x3  = base[_EMIFB_CECTL2_OFFSET];
  x4  = base[_EMIFB_CECTL3_OFFSET];
  x5  = base[_EMIFB_SDCTL_OFFSET];
  x6  = base[_EMIFB_SDTIM_OFFSET];
  x7  = base[_EMIFB_SDEXT_OFFSET];
  x8  = base[_EMIFB_CESEC0_OFFSET];
  x9  = base[_EMIFB_CESEC1_OFFSET];
  x10 = base[_EMIFB_CESEC2_OFFSET];
  x11 = base[_EMIFB_CESEC3_OFFSET];

  cfg->gblctl  = x0;
  cfg->cectl0  = x1;
  cfg->cectl1  = x2;
  cfg->cectl2  = x3;
  cfg->cectl3  = x4;
  cfg->sdctl   = x5;
  cfg->sdtim   = x6;
  cfg->sdext   = x7;
  cfg->cesec0  = x8;
  cfg->cesec1  = x9;
  cfg->cesec2  = x10;
  cfg->cesec3  = x11;

  IRQ_globalRestore(gie);
}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* EMIFB_SUPPORT */
#endif /* _CSL_EMIFB_H_ */
/******************************************************************************\
* End of csl_emifb.h
\******************************************************************************/

csl_emifbhal.h/ 1090821491  0     0     0       30310     `
/******************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emifhal.h
* DATE CREATED.. 03/27/2001
* LAST MODIFIED. 03/27/2001
*                04/08/2004 Added PDTCTL register support 
*------------------------------------------------------------------------------
* REGISTERS
*
* GBLCTL  - global control register
* CECTL0  - CE space control register 0
* CECTL1  - CE space control register 1
* CECTL2  - CE space control register 2
* CECTL3  - CE space control register 3
* SDCTL   - SDRAM control regsiter
* SDTIM   - SDRAM timing register
* SDEXT   - SDRAM extension register 
* CESEC0  - EMIFB CE0 secondary control 
* CESEC1  - EMIFB CE1 secondary control 
* CESEC2  - EMIFB CE2 secondary control 
* CESEC3  - EMIFB CE3 secondary control 
* PDTCTL  - Peripheral device transfer control
\******************************************************************************/
#ifndef _CSL_EMIFBHAL_H_
#define _CSL_EMIFBHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (EMIFB_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#define _EMIFB_BASE_GLOBAL   0x01A80000u


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define EMIFB_FMK(REG,FIELD,x)\
    _PER_FMK(EMIFB,##REG,##FIELD,x)

  #define EMIFB_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(EMIFB,##REG,##FIELD,##SYM)
 
 
  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define EMIFB_ADDR(REG)\
    _EMIFB_##REG##_ADDR

  #define EMIFB_RGET(REG)\
    _PER_RGET(_EMIFB_##REG##_ADDR,EMIFB,##REG)

  #define EMIFB_RSET(REG,x)\
    _PER_RSET(_EMIFB_##REG##_ADDR,EMIFB,##REG,x)

  #define EMIFB_FGET(REG,FIELD)\
    _EMIFB_##REG##_FGET(##FIELD)

  #define EMIFB_FSET(REG,FIELD,x)\
    _EMIFB_##REG##_FSET(##FIELD,##x)

  #define EMIFB_FSETS(REG,FIELD,SYM)\
    _EMIFB_##REG##_FSETS(##FIELD,##SYM)
 
 
  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define EMIFB_RGETA(addr,REG)\
    _PER_RGET(addr,EMIFB,##REG)

  #define EMIFB_RSETA(addr,REG,x)\
    _PER_RSET(addr,EMIFB,##REG,x)

  #define EMIFB_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,EMIFB,##REG,##FIELD)

  #define EMIFB_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,EMIFB,##REG,##FIELD,x)

  #define EMIFB_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,EMIFB,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  G B L C T L      |
* |___________________|
*
* GBLCTL  - global control register
*
* FIELDS (msb -> lsb)
* (rw) EK2RATE
* (rw) EK2HZ
* (rw) EK2EN
* (rw) BRMODE
* (r)  BUSREQ
* (r)  ARDY
* (r)  HOLD
* (r)  HOLDA
* (rw) NOHOLD
* (rw) EK1HZ
* (rw) EK1EN
*
\******************************************************************************/
  #define _EMIFB_GBLCTL_OFFSET          0

  #define _EMIFB_GBLCTL_ADDR            0x01A80000u

  #define _EMIFB_GBLCTL_EK2RATE_MASK     0x000C0000u
  #define _EMIFB_GBLCTL_EK2RATE_SHIFT    0x00000012u
  #define  EMIFB_GBLCTL_EK2RATE_DEFAULT  0x00000002u
  #define  EMIFB_GBLCTL_EK2RATE_OF(x)    _VALUEOF(x)
  #define  EMIFB_GBLCTL_EK2RATE_FULLCLK  0x00000000u 
  #define  EMIFB_GBLCTL_EK2RATE_HALFCLK  0x00000001u 
  #define  EMIFB_GBLCTL_EK2RATE_QUARCLK  0x00000002u 

  #define _EMIFB_GBLCTL_EK2HZ_MASK       0x00020000u
  #define _EMIFB_GBLCTL_EK2HZ_SHIFT      0x00000011u
  #define  EMIFB_GBLCTL_EK2HZ_DEFAULT    0x00000000u
  #define  EMIFB_GBLCTL_EK2HZ_OF(x)      _VALUEOF(x)
  #define  EMIFB_GBLCTL_EK2HZ_CLK        0x00000000u 
  #define  EMIFB_GBLCTL_EK2HZ_HIGHZ      0x00000001u 

  #define _EMIFB_GBLCTL_EK2EN_MASK       0x00010000u
  #define _EMIFB_GBLCTL_EK2EN_SHIFT      0x00000010u
  #define  EMIFB_GBLCTL_EK2EN_DEFAULT    0x00000001u
  #define  EMIFB_GBLCTL_EK2EN_OF(x)      _VALUEOF(x)
  #define  EMIFB_GBLCTL_EK2EN_DISABLE    0x00000000u 
  #define  EMIFB_GBLCTL_EK2EN_ENABLE     0x00000001u 

  #define _EMIFB_GBLCTL_BRMODE_MASK     0x00002000u
  #define _EMIFB_GBLCTL_BRMODE_SHIFT    0x0000000Du
  #define  EMIFB_GBLCTL_BRMODE_DEFAULT  0x00000001u
  #define  EMIFB_GBLCTL_BRMODE_OF(x)    _VALUEOF(x)
  #define  EMIFB_GBLCTL_BRMODE_MSTATUS  0x00000000u 
  #define  EMIFB_GBLCTL_BRMODE_MRSTATUS 0x00000001u 

  #define _EMIFB_GBLCTL_BUSREQ_MASK     0x00000800u
  #define _EMIFB_GBLCTL_BUSREQ_SHIFT    0x0000000Bu
  #define  EMIFB_GBLCTL_BUSREQ_DEFAULT  0x00000000u
  #define  EMIFB_GBLCTL_BUSREQ_OF(x)    _VALUEOF(x)
  #define  EMIFB_GBLCTL_BUSREQ_LOW      0x00000000u
  #define  EMIFB_GBLCTL_BUSREQ_HIGH     0x00000001u

  #define _EMIFB_GBLCTL_ARDY_MASK       0x00000400u
  #define _EMIFB_GBLCTL_ARDY_SHIFT      0x0000000Au
  #define  EMIFB_GBLCTL_ARDY_DEFAULT    0x00000000u
  #define  EMIFB_GBLCTL_ARDY_OF(x)      _VALUEOF(x)
  #define  EMIFB_GBLCTL_ARDY_LOW        0x00000000u
  #define  EMIFB_GBLCTL_ARDY_HIGH       0x00000001u

  #define _EMIFB_GBLCTL_HOLD_MASK       0x00000200u
  #define _EMIFB_GBLCTL_HOLD_SHIFT      0x00000009u
  #define  EMIFB_GBLCTL_HOLD_DEFAULT    0x00000000u
  #define  EMIFB_GBLCTL_HOLD_OF(x)      _VALUEOF(x)
  #define  EMIFB_GBLCTL_HOLD_LOW        0x00000000u
  #define  EMIFB_GBLCTL_HOLD_HIGH       0x00000001u

  #define _EMIFB_GBLCTL_HOLDA_MASK      0x00000100u
  #define _EMIFB_GBLCTL_HOLDA_SHIFT     0x00000008u
  #define  EMIFB_GBLCTL_HOLDA_DEFAULT   0x00000000u
  #define  EMIFB_GBLCTL_HOLDA_OF(x)     _VALUEOF(x)
  #define  EMIFB_GBLCTL_HOLDA_LOW       0x00000000u
  #define  EMIFB_GBLCTL_HOLDA_HIGH      0x00000001u

  #define _EMIFB_GBLCTL_NOHOLD_MASK     0x00000080u
  #define _EMIFB_GBLCTL_NOHOLD_SHIFT    0x00000007u
  #define  EMIFB_GBLCTL_NOHOLD_DEFAULT  0x00000000u
  #define  EMIFB_GBLCTL_NOHOLD_OF(x)    _VALUEOF(x)
  #define  EMIFB_GBLCTL_NOHOLD_DISABLE  0x00000000u
  #define  EMIFB_GBLCTL_NOHOLD_ENABLE   0x00000001u

  #define _EMIFB_GBLCTL_EK1HZ_MASK      0x00000040u
  #define _EMIFB_GBLCTL_EK1HZ_SHIFT     0x00000006u
  #define  EMIFB_GBLCTL_EK1HZ_DEFAULT   0x00000001u
  #define  EMIFB_GBLCTL_EK1HZ_OF(x)     _VALUEOF(x)
  #define  EMIFB_GBLCTL_EK1HZ_CLK       0x00000000u 
  #define  EMIFB_GBLCTL_EK1HZ_HIGHZ     0x00000001u 

  #define _EMIFB_GBLCTL_EK1EN_MASK      0x00000020u
  #define _EMIFB_GBLCTL_EK1EN_SHIFT     0x00000005u
  #define  EMIFB_GBLCTL_EK1EN_DEFAULT   0x00000001u
  #define  EMIFB_GBLCTL_EK1EN_OF(x)     _VALUEOF(x)
  #define  EMIFB_GBLCTL_EK1EN_DISABLE   0x00000000u 
  #define  EMIFB_GBLCTL_EK1EN_ENABLE    0x00000001u 

  #define  EMIFB_GBLCTL_OF(x)           _VALUEOF(x)

  #define EMIFB_GBLCTL_DEFAULT (Uint32)( \
    0x00000004\
    |_PER_FDEFAULT(EMIFB,GBLCTL,EK2RATE)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,EK2HZ)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,EK2EN)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,BRMODE)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,BUSREQ)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,ARDY)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,HOLD)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,HOLDA)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,NOHOLD)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,EK1HZ)\
    |_PER_FDEFAULT(EMIFB,GBLCTL,EK1EN)\
  )

  #define EMIFB_GBLCTL_RMK(ek2rate,ek2hz,ek2en,brmode,nohold,ek1hz,ek1en) \
    (Uint32)( \
     _PER_FMK(EMIFB,GBLCTL,EK2RATE,ek2rate)\
    |_PER_FMK(EMIFB,GBLCTL,EK2HZ,ek2hz)\
    |_PER_FMK(EMIFB,GBLCTL,EK2EN,ek2en)\
    |_PER_FMK(EMIFB,GBLCTL,BRMODE,brmode)\
    |_PER_FMK(EMIFB,GBLCTL,NOHOLD,nohold)\
    |_PER_FMK(EMIFB,GBLCTL,EK1HZ,ek1hz)\
    |_PER_FMK(EMIFB,GBLCTL,EK1EN,ek1en)\
  )

  #define _EMIFB_GBLCTL_FGET(FIELD)\
    _PER_FGET(_EMIFB_GBLCTL_ADDR,EMIFB,GBLCTL,##FIELD)

  #define _EMIFB_GBLCTL_FSET(FIELD,field)\
    _PER_FSET(_EMIFB_GBLCTL_ADDR,EMIFB,GBLCTL,##FIELD,field)

  #define _EMIFB_GBLCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFB_GBLCTL_ADDR,EMIFB,GBLCTL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C E C T L        |
* |___________________|
*
* CECTL0 - CE space control register 0
* CECTL1 - CE space control register 1
* CECTL2 - CE space control register 2
* CECTL3 - CE space control register 3
*
* FIELDS (msb -> lsb)
* (rw) WRSETUP
* (rw) WRSTRB
* (rw) WRHLD
* (rw) RDSETUP
* (rw) TA
* (rw) RDSTRB
* (rw) MTYPE
* (rw) RDHLD
*
\******************************************************************************/
  #define _EMIFB_CECTL0_OFFSET          2
  #define _EMIFB_CECTL1_OFFSET          1
  #define _EMIFB_CECTL2_OFFSET          4
  #define _EMIFB_CECTL3_OFFSET          5

  #define _EMIFB_CECTL0_ADDR            0x01A80008u
  #define _EMIFB_CECTL1_ADDR            0x01A80004u
  #define _EMIFB_CECTL2_ADDR            0x01A80010u
  #define _EMIFB_CECTL3_ADDR            0x01A80014u

  #define _EMIFB_CECTL_WRSETUP_MASK     0xF0000000u
  #define _EMIFB_CECTL_WRSETUP_SHIFT    0x0000001Cu
  #define  EMIFB_CECTL_WRSETUP_DEFAULT  0x0000000Fu
  #define  EMIFB_CECTL_WRSETUP_OF(x)    _VALUEOF(x)

  #define _EMIFB_CECTL_WRSTRB_MASK      0x0FC00000u
  #define _EMIFB_CECTL_WRSTRB_SHIFT     0x00000016u
  #define  EMIFB_CECTL_WRSTRB_DEFAULT   0x0000003Fu
  #define  EMIFB_CECTL_WRSTRB_OF(x)     _VALUEOF(x)

  #define _EMIFB_CECTL_WRHLD_MASK       0x00300000u
  #define _EMIFB_CECTL_WRHLD_SHIFT      0x00000014u
  #define  EMIFB_CECTL_WRHLD_DEFAULT    0x00000003u
  #define  EMIFB_CECTL_WRHLD_OF(x)      _VALUEOF(x)
  
  #define _EMIFB_CECTL_RDSETUP_MASK     0x000F0000u
  #define _EMIFB_CECTL_RDSETUP_SHIFT    0x00000010u
  #define  EMIFB_CECTL_RDSETUP_DEFAULT  0x0000000Fu
  #define  EMIFB_CECTL_RDSETUP_OF(x)    _VALUEOF(x)

  #define _EMIFB_CECTL_TA_MASK          0x0000C000u
  #define _EMIFB_CECTL_TA_SHIFT         0x0000000Eu
  #define  EMIFB_CECTL_TA_DEFAULT       0x00000003u
  #define  EMIFB_CECTL_TA_OF(x)         _VALUEOF(x)

  #define _EMIFB_CECTL_RDSTRB_MASK      0x00003F00u
  #define _EMIFB_CECTL_RDSTRB_SHIFT     0x00000008u
  #define  EMIFB_CECTL_RDSTRB_DEFAULT   0x0000003Fu
  #define  EMIFB_CECTL_RDSTRB_OF(x)     _VALUEOF(x)
  
  #define _EMIFB_CECTL_MTYPE_MASK       0x000000F0u
  #define _EMIFB_CECTL_MTYPE_SHIFT      0x00000004u
  #define  EMIFB_CECTL_MTYPE_DEFAULT    0x00000000u
  #define  EMIFB_CECTL_MTYPE_OF(x)      _VALUEOF(x)
  #define  EMIFB_CECTL_MTYPE_ASYNC8     0x00000000u 
  #define  EMIFB_CECTL_MTYPE_ASYNC16    0x00000001u 
  #define  EMIFB_CECTL_MTYPE_SDRAM8     0x00000008u 
  #define  EMIFB_CECTL_MTYPE_SDRAM16    0x00000009u 
  #define  EMIFB_CECTL_MTYPE_SYNC8      0x0000000Au 
  #define  EMIFB_CECTL_MTYPE_SYNC16     0x0000000Bu 

  #define _EMIFB_CECTL_WRHLDMSB_MASK    0x00000008u
  #define _EMIFB_CECTL_WRHLDMSB_SHIFT   0x00000003u
  #define  EMIFB_CECTL_WRHLDMSB_DEFAULT 0x00000000u
  #define  EMIFB_CECTL_WRHLDMSB_OF(x)   _VALUEOF(x)

  #define _EMIFB_CECTL_RDHLD_MASK       0x00000007u
  #define _EMIFB_CECTL_RDHLD_SHIFT      0x00000000u
  #define  EMIFB_CECTL_RDHLD_DEFAULT    0x00000003u
  #define  EMIFB_CECTL_RDHLD_OF(x)      _VALUEOF(x)

  #define  EMIFB_CECTL_OF(x)            _VALUEOF(x)

  #define EMIFB_CECTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFB,CECTL,WRSETUP)\
    |_PER_FDEFAULT(EMIFB,CECTL,WRSTRB)\
    |_PER_FDEFAULT(EMIFB,CECTL,WRHLD)\
    |_PER_FDEFAULT(EMIFB,CECTL,RDSETUP)\
    |_PER_FDEFAULT(EMIFB,CECTL,TA)\
    |_PER_FDEFAULT(EMIFB,CECTL,RDSTRB)\
    |_PER_FDEFAULT(EMIFB,CECTL,MTYPE)\
    |_PER_FDEFAULT(EMIFB,CECTL,WRHLDMSB)\
    |_PER_FDEFAULT(EMIFB,CECTL,RDHLD)\
  )

  #define EMIFB_CECTL_RMK(wrsetup,wrstrb,wrhld,rdsetup,ta,rdstrb,mtype,\
    wrhldmsb,rdhld) (Uint32)( \
     _PER_FMK(EMIFB,CECTL,WRSETUP,wrsetup)\
    |_PER_FMK(EMIFB,CECTL,WRSTRB,wrstrb)\
    |_PER_FMK(EMIFB,CECTL,WRHLD,wrhld)\
    |_PER_FMK(EMIFB,CECTL,RDSETUP,rdsetup)\
    |_PER_FMK(EMIFB,CECTL,TA,ta)\
    |_PER_FMK(EMIFB,CECTL,RDSTRB,rdstrb)\
    |_PER_FMK(EMIFB,CECTL,MTYPE,mtype)\
    |_PER_FMK(EMIFB,CECTL,WRHLDMSB,wrhldmsb)\
    |_PER_FMK(EMIFB,CECTL,RDHLD,rdhld)\
  )

  #define _EMIFB_CECTL_FGET(N,FIELD)\
    _PER_FGET(_EMIFB_CECTL##N##_ADDR,EMIFB,CECTL,##FIELD)

  #define _EMIFB_CECTL_FSET(N,FIELD,f)\
    _PER_FSET(_EMIFB_CECTL##N##_ADDR,EMIFB,CECTL,##FIELD,f)

  #define _EMIFB_CECTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_EMIFB_CECTL##N##_ADDR,EMIFB,CECTL,##FIELD,##SYM)

  #define _EMIFB_CECTL0_FGET(FIELD) _EMIFB_CECTL_FGET(0,##FIELD)
  #define _EMIFB_CECTL1_FGET(FIELD) _EMIFB_CECTL_FGET(1,##FIELD)
  #define _EMIFB_CECTL2_FGET(FIELD) _EMIFB_CECTL_FGET(2,##FIELD)
  #define _EMIFB_CECTL3_FGET(FIELD) _EMIFB_CECTL_FGET(3,##FIELD)

  #define _EMIFB_CECTL0_FSET(FIELD,f) _EMIFB_CECTL_FSET(0,##FIELD,f)
  #define _EMIFB_CECTL1_FSET(FIELD,f) _EMIFB_CECTL_FSET(1,##FIELD,f)
  #define _EMIFB_CECTL2_FSET(FIELD,f) _EMIFB_CECTL_FSET(2,##FIELD,f)
  #define _EMIFB_CECTL3_FSET(FIELD,f) _EMIFB_CECTL_FSET(3,##FIELD,f)

  #define _EMIFB_CECTL0_FSETS(FIELD,SYM) _EMIFB_CECTL_FSETS(0,##FIELD,##SYM)
  #define _EMIFB_CECTL1_FSETS(FIELD,SYM) _EMIFB_CECTL_FSETS(1,##FIELD,##SYM)
  #define _EMIFB_CECTL2_FSETS(FIELD,SYM) _EMIFB_CECTL_FSETS(2,##FIELD,##SYM)
  #define _EMIFB_CECTL3_FSETS(FIELD,SYM) _EMIFB_CECTL_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D C T L        |
* |___________________|
*
* SDCTL   - SDRAM control regsiter
*
* FIELDS (msb -> lsb)
* (rw) SDBSZ 
* (rw) SDRSZ 
* (rw) SDCSZ 
* (rw) RFEN
* (w)  INIT
* (rw) TRCD
* (rw) TRP
* (rw) TRC
*
\******************************************************************************/
  #define _EMIFB_SDCTL_OFFSET           6

  #define _EMIFB_SDCTL_ADDR             0x01A80018u

  #define _EMIFB_SDCTL_SDBSZ_MASK       0x40000000u
  #define _EMIFB_SDCTL_SDBSZ_SHIFT      0x0000001Eu
  #define  EMIFB_SDCTL_SDBSZ_DEFAULT    0x00000000u
  #define  EMIFB_SDCTL_SDBSZ_OF(x)      _VALUEOF(x)
  #define  EMIFB_SDCTL_SDBSZ_2BANKS     0x00000000u
  #define  EMIFB_SDCTL_SDBSZ_4BANKS     0x00000001u
  
  #define _EMIFB_SDCTL_SDRSZ_MASK       0x30000000u
  #define _EMIFB_SDCTL_SDRSZ_SHIFT      0x0000001Cu
  #define  EMIFB_SDCTL_SDRSZ_DEFAULT    0x00000000u
  #define  EMIFB_SDCTL_SDRSZ_OF(x)      _VALUEOF(x)
  #define  EMIFB_SDCTL_SDRSZ_11ROW      0x00000000u
  #define  EMIFB_SDCTL_SDRSZ_12ROW      0x00000001u
  #define  EMIFB_SDCTL_SDRSZ_13ROW      0x00000002u
  
  #define _EMIFB_SDCTL_SDCSZ_MASK       0x0C000000u
  #define _EMIFB_SDCTL_SDCSZ_SHIFT      0x0000001Au
  #define  EMIFB_SDCTL_SDCSZ_DEFAULT    0x00000000u
  #define  EMIFB_SDCTL_SDCSZ_OF(x)      _VALUEOF(x)
  #define  EMIFB_SDCTL_SDCSZ_9COL       0x00000000u
  #define  EMIFB_SDCTL_SDCSZ_8COL       0x00000001u
  #define  EMIFB_SDCTL_SDCSZ_10COL      0x00000002u
  
  #define _EMIFB_SDCTL_RFEN_MASK        0x02000000u
  #define _EMIFB_SDCTL_RFEN_SHIFT       0x00000019u
  #define  EMIFB_SDCTL_RFEN_DEFAULT     0x00000001u
  #define  EMIFB_SDCTL_RFEN_OF(x)       _VALUEOF(x)
  #define  EMIFB_SDCTL_RFEN_DISABLE     0x00000000u
  #define  EMIFB_SDCTL_RFEN_ENABLE      0x00000001u

  #define _EMIFB_SDCTL_INIT_MASK        0x01000000u
  #define _EMIFB_SDCTL_INIT_SHIFT       0x00000018u
  #define  EMIFB_SDCTL_INIT_DEFAULT     0x00000001u
  #define  EMIFB_SDCTL_INIT_OF(x)       _VALUEOF(x)
  #define  EMIFB_SDCTL_INIT_NO          0x00000000u
  #define  EMIFB_SDCTL_INIT_YES         0x00000001u

  #define _EMIFB_SDCTL_TRCD_MASK        0x00F00000u
  #define _EMIFB_SDCTL_TRCD_SHIFT       0x00000014u
  #define  EMIFB_SDCTL_TRCD_DEFAULT     0x00000004u
  #define  EMIFB_SDCTL_TRCD_OF(x)       _VALUEOF(x)

  #define _EMIFB_SDCTL_TRP_MASK         0x000F0000u
  #define _EMIFB_SDCTL_TRP_SHIFT        0x00000010u
  #define  EMIFB_SDCTL_TRP_DEFAULT      0x00000008u
  #define  EMIFB_SDCTL_TRP_OF(x)        _VALUEOF(x)

  #define _EMIFB_SDCTL_TRC_MASK         0x0000F000u
  #define _EMIFB_SDCTL_TRC_SHIFT        0x0000000Cu
  #define  EMIFB_SDCTL_TRC_DEFAULT      0x0000000Fu
  #define  EMIFB_SDCTL_TRC_OF(x)        _VALUEOF(x)

  #define  EMIFB_SDCTL_OF(x)            _VALUEOF(x)

  #define EMIFB_SDCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFB,SDCTL,SDBSZ)\
    |_PER_FDEFAULT(EMIFB,SDCTL,SDRSZ)\
    |_PER_FDEFAULT(EMIFB,SDCTL,SDCSZ)\
    |_PER_FDEFAULT(EMIFB,SDCTL,RFEN)\
    |_PER_FDEFAULT(EMIFB,SDCTL,INIT)\
    |_PER_FDEFAULT(EMIFB,SDCTL,TRCD)\
    |_PER_FDEFAULT(EMIFB,SDCTL,TRP)\
    |_PER_FDEFAULT(EMIFB,SDCTL,TRC)\
  )

  #define EMIFB_SDCTL_RMK(sdbsz,sdrsz,sdcsz,rfen,init,trcd,trp,trc) (Uint32)(\
     _PER_FMK(EMIFB,SDCTL,SDBSZ,sdbsz)\
    |_PER_FMK(EMIFB,SDCTL,SDRSZ,sdrsz)\
    |_PER_FMK(EMIFB,SDCTL,SDCSZ,sdcsz)\
    |_PER_FMK(EMIFB,SDCTL,RFEN,rfen)\
    |_PER_FMK(EMIFB,SDCTL,INIT,init)\
    |_PER_FMK(EMIFB,SDCTL,TRCD,trcd)\
    |_PER_FMK(EMIFB,SDCTL,TRP,trp)\
    |_PER_FMK(EMIFB,SDCTL,TRC,trc)\
  )

  #define _EMIFB_SDCTL_FGET(FIELD)\
    _PER_FGET(_EMIFB_SDCTL_ADDR,EMIFB,SDCTL,##FIELD)

  #define _EMIFB_SDCTL_FSET(FIELD,field)\
    _PER_FSET(_EMIFB_SDCTL_ADDR,EMIFB,SDCTL,##FIELD,field)

  #define _EMIFB_SDCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFB_SDCTL_ADDR,EMIFB,SDCTL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D T I M        |
* |___________________|
*
* SDTIM   - SDRAM timing register
*
* FIELDS (msb -> lsb)
* (rw) XRFR
* (r)  CNTR
* (rw) PERIOD
*
\******************************************************************************/
  #define _EMIFB_SDTIM_OFFSET           7

  #define _EMIFB_SDTIM_ADDR             0x01A8001Cu

  #define _EMIFB_SDTIM_XRFR_MASK        0x03000000u
  #define _EMIFB_SDTIM_XRFR_SHIFT       0x00000018u
  #define  EMIFB_SDTIM_XRFR_DEFAULT     0x00000000u
  #define  EMIFB_SDTIM_XRFR_OF(x)       _VALUEOF(x)

  #define _EMIFB_SDTIM_CNTR_MASK        0x00FFF000u
  #define _EMIFB_SDTIM_CNTR_SHIFT       0x0000000Cu
  #define  EMIFB_SDTIM_CNTR_DEFAULT     0x000005DCu
  #define  EMIFB_SDTIM_CNTR_OF(x)       _VALUEOF(x)
  
  #define _EMIFB_SDTIM_PERIOD_MASK      0x00000FFFu
  #define _EMIFB_SDTIM_PERIOD_SHIFT     0x00000000u
  #define  EMIFB_SDTIM_PERIOD_DEFAULT   0x000005DCu
  #define  EMIFB_SDTIM_PERIOD_OF(x)     _VALUEOF(x)

  #define  EMIFB_SDTIM_OF(x)            _VALUEOF(x)

  #define EMIFB_SDTIM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFB,SDTIM,XRFR)\
    |_PER_FDEFAULT(EMIFB,SDTIM,CNTR)\
    |_PER_FDEFAULT(EMIFB,SDTIM,PERIOD)\
  )

  #define EMIFB_SDTIM_RMK(xrfr,period) (Uint32)(\
     _PER_FMK(EMIFB,SDTIM,XRFR,xrfr)\
    |_PER_FMK(EMIFB,SDTIM,PERIOD,period)\
  )

  #define _EMIFB_SDTIM_FGET(FIELD)\
    _PER_FGET(_EMIFB_SDTIM_ADDR,EMIFB,SDTIM,##FIELD)

  #define _EMIFB_SDTIM_FSET(FIELD,field)\
    _PER_FSET(_EMIFB_SDTIM_ADDR,EMIFB,SDTIM,##FIELD,field)

  #define _EMIFB_SDTIM_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFB_SDTIM_ADDR,EMIFB,SDTIM,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D E X T        |
* |___________________|
*
* SDEXT   - SDRAM extension register
*
* FIELDS (msb -> lsb)
* (rw) WR2RD
* (rw) WR2DEAC
* (rw) WR2WR
* (rw) R2WDQM
* (rw) RD2WR
* (rw) RD2DEAC
* (rw) RD2RD
* (rw) THZP
* (rw) TWR
* (rw) TRRD
* (rw) TRAS
* (rw) TCL
*
\******************************************************************************/
  #define _EMIFB_SDEXT_OFFSET           8

  #define _EMIFB_SDEXT_ADDR             0x01A80020u

  #define _EMIFB_SDEXT_WR2RD_MASK       0x00100000u
  #define _EMIFB_SDEXT_WR2RD_SHIFT      0x00000014u
  #define  EMIFB_SDEXT_WR2RD_DEFAULT    0x00000001u
  #define  EMIFB_SDEXT_WR2RD_OF(x)      _VALUEOF(x)

  #define _EMIFB_SDEXT_WR2DEAC_MASK     0x000C0000u
  #define _EMIFB_SDEXT_WR2DEAC_SHIFT    0x00000012u
  #define  EMIFB_SDEXT_WR2DEAC_DEFAULT  0x00000001u
  #define  EMIFB_SDEXT_WR2DEAC_OF(x)    _VALUEOF(x)

  #define _EMIFB_SDEXT_WR2WR_MASK       0x00020000u
  #define _EMIFB_SDEXT_WR2WR_SHIFT      0x00000011u
  #define  EMIFB_SDEXT_WR2WR_DEFAULT    0x00000001u
  #define  EMIFB_SDEXT_WR2WR_OF(x)      _VALUEOF(x)

  #define _EMIFB_SDEXT_R2WDQM_MASK      0x00018000u
  #define _EMIFB_SDEXT_R2WDQM_SHIFT     0x0000000Fu
  #define  EMIFB_SDEXT_R2WDQM_DEFAULT   0x00000002u
  #define  EMIFB_SDEXT_R2WDQM_OF(x)     _VALUEOF(x)

  #define _EMIFB_SDEXT_RD2WR_MASK       0x00007000u
  #define _EMIFB_SDEXT_RD2WR_SHIFT      0x0000000Cu
  #define  EMIFB_SDEXT_RD2WR_DEFAULT    0x00000005u
  #define  EMIFB_SDEXT_RD2WR_OF(x)      _VALUEOF(x)

  #define _EMIFB_SDEXT_RD2DEAC_MASK     0x00000C00u
  #define _EMIFB_SDEXT_RD2DEAC_SHIFT    0x0000000Au
  #define  EMIFB_SDEXT_RD2DEAC_DEFAULT  0x00000003u
  #define  EMIFB_SDEXT_RD2DEAC_OF(x)    _VALUEOF(x)

  #define _EMIFB_SDEXT_RD2RD_MASK       0x00000200u
  #define _EMIFB_SDEXT_RD2RD_SHIFT      0x00000009u
  #define  EMIFB_SDEXT_RD2RD_DEFAULT    0x00000001u
  #define  EMIFB_SDEXT_RD2RD_OF(x)      _VALUEOF(x)

  #define _EMIFB_SDEXT_THZP_MASK        0x00000180u
  #define _EMIFB_SDEXT_THZP_SHIFT       0x00000007u
  #define  EMIFB_SDEXT_THZP_DEFAULT     0x00000002u
  #define  EMIFB_SDEXT_THZP_OF(x)       _VALUEOF(x)

  #define _EMIFB_SDEXT_TWR_MASK         0x00000060u
  #define _EMIFB_SDEXT_TWR_SHIFT        0x00000005u
  #define  EMIFB_SDEXT_TWR_DEFAULT      0x00000001u
  #define  EMIFB_SDEXT_TWR_OF(x)        _VALUEOF(x)

  #define _EMIFB_SDEXT_TRRD_MASK        0x00000010u
  #define _EMIFB_SDEXT_TRRD_SHIFT       0x00000004u
  #define  EMIFB_SDEXT_TRRD_DEFAULT     0x00000001u
  #define  EMIFB_SDEXT_TRRD_OF(x)       _VALUEOF(x)

  #define _EMIFB_SDEXT_TRAS_MASK        0x0000000Eu
  #define _EMIFB_SDEXT_TRAS_SHIFT       0x00000001u
  #define  EMIFB_SDEXT_TRAS_DEFAULT     0x00000007u
  #define  EMIFB_SDEXT_TRAS_OF(x)       _VALUEOF(x)

  #define _EMIFB_SDEXT_TCL_MASK         0x00000001u
  #define _EMIFB_SDEXT_TCL_SHIFT        0x00000000u
  #define  EMIFB_SDEXT_TCL_DEFAULT      0x00000001u
  #define  EMIFB_SDEXT_TCL_OF(x)        _VALUEOF(x)

  #define  EMIFB_SDEXT_OF(x)            _VALUEOF(x)

  #define EMIFB_SDEXT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFB,SDEXT,WR2RD)\
    |_PER_FDEFAULT(EMIFB,SDEXT,WR2DEAC)\
    |_PER_FDEFAULT(EMIFB,SDEXT,WR2WR)\
    |_PER_FDEFAULT(EMIFB,SDEXT,R2WDQM)\
    |_PER_FDEFAULT(EMIFB,SDEXT,RD2WR)\
    |_PER_FDEFAULT(EMIFB,SDEXT,RD2DEAC)\
    |_PER_FDEFAULT(EMIFB,SDEXT,RD2RD)\
    |_PER_FDEFAULT(EMIFB,SDEXT,THZP)\
    |_PER_FDEFAULT(EMIFB,SDEXT,TWR)\
    |_PER_FDEFAULT(EMIFB,SDEXT,TRRD)\
    |_PER_FDEFAULT(EMIFB,SDEXT,TRAS)\
    |_PER_FDEFAULT(EMIFB,SDEXT,TCL)\
  )

  #define EMIFB_SDEXT_RMK(wr2rd,wr2deac,wr2wr,r2wdqm,rd2wr,rd2deac,\
    rd2rd,thzp,twr,trrd,tras,tcl) (Uint32)( \
     _PER_FMK(EMIFB,SDEXT,WR2RD,wr2rd)\
    |_PER_FMK(EMIFB,SDEXT,WR2DEAC,wr2deac)\
    |_PER_FMK(EMIFB,SDEXT,WR2WR,wr2wr)\
    |_PER_FMK(EMIFB,SDEXT,R2WDQM,r2wdqm)\
    |_PER_FMK(EMIFB,SDEXT,RD2WR,rd2wr)\
    |_PER_FMK(EMIFB,SDEXT,RD2DEAC,rd2deac)\
    |_PER_FMK(EMIFB,SDEXT,RD2RD,rd2rd)\
    |_PER_FMK(EMIFB,SDEXT,THZP,thzp)\
    |_PER_FMK(EMIFB,SDEXT,TWR,twr)\
    |_PER_FMK(EMIFB,SDEXT,TRRD,trrd)\
    |_PER_FMK(EMIFB,SDEXT,TRAS,tras)\
    |_PER_FMK(EMIFB,SDEXT,TCL,tcl)\
  )

  #define _EMIFB_SDEXT_FGET(FIELD)\
    _PER_FGET(_EMIFB_SDEXT_ADDR,EMIFB,SDEXT,##FIELD)

  #define _EMIFB_SDEXT_FSET(FIELD,field)\
    _PER_FSET(_EMIFB_SDEXT_ADDR,EMIFB,SDEXT,##FIELD,field)

  #define _EMIFB_SDEXT_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFB_SDEXT_ADDR,EMIFB,SDEXT,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  C E x S E C      |
* |___________________|
*
* CESEC0 - CE space secondary control register 0
* CESEC1 - CE space secondary control register 1
* CESEC2 - CE space secondary control register 2
* CESEC3 - CE space secondary control register 3
*
* FIELDS (msb -> lsb)
* (rw) SNCCLK
* (rw) RENEN
* (rw) CEEXT
* (rw) SYNCWL
* (rw) SYNCRL
*
\******************************************************************************/
  #define _EMIFB_CESEC0_OFFSET          18
  #define _EMIFB_CESEC1_OFFSET          17
  #define _EMIFB_CESEC2_OFFSET          20
  #define _EMIFB_CESEC3_OFFSET          21

  #define _EMIFB_CESEC0_ADDR            0x01A80048u
  #define _EMIFB_CESEC1_ADDR            0x01A80044u
  #define _EMIFB_CESEC2_ADDR            0x01A80050u
  #define _EMIFB_CESEC3_ADDR            0x01A80054u

  #define _EMIFB_CESEC_SNCCLK_MASK      0x00000040u
  #define _EMIFB_CESEC_SNCCLK_SHIFT     0x00000006u
  #define  EMIFB_CESEC_SNCCLK_DEFAULT   0x00000000u
  #define  EMIFB_CESEC_SNCCLK_OF(x)     _VALUEOF(x)
  #define  EMIFB_CESEC_SNCCLK_ECLKOUT1  0x00000000u 
  #define  EMIFB_CESEC_SNCCLK_ECLKOUT2  0x00000001u 

  #define _EMIFB_CESEC_RENEN_MASK       0x00000020u
  #define _EMIFB_CESEC_RENEN_SHIFT      0x00000005u
  #define  EMIFB_CESEC_RENEN_DEFAULT    0x00000000u
  #define  EMIFB_CESEC_RENEN_OF(x)      _VALUEOF(x)
  #define  EMIFB_CESEC_RENEN_ADS        0x00000000u 
  #define  EMIFB_CESEC_RENEN_READ       0x00000001u 

  #define _EMIFB_CESEC_CEEXT_MASK       0x00000010u
  #define _EMIFB_CESEC_CEEXT_SHIFT      0x00000004u
  #define  EMIFB_CESEC_CEEXT_DEFAULT    0x00000000u
  #define  EMIFB_CESEC_CEEXT_OF(x)      _VALUEOF(x)
  #define  EMIFB_CESEC_CEEXT_INACTIVE   0x00000000u 
  #define  EMIFB_CESEC_CEEXT_ACTIVE     0x00000001u 

  #define _EMIFB_CESEC_SYNCWL_MASK      0x0000000Cu
  #define _EMIFB_CESEC_SYNCWL_SHIFT     0x00000002u
  #define  EMIFB_CESEC_SYNCWL_DEFAULT   0x00000000u
  #define  EMIFB_CESEC_SYNCWL_OF(x)     _VALUEOF(x)
  #define  EMIFB_CESEC_SYNCWL_0CYCLE    0x00000000u 
  #define  EMIFB_CESEC_SYNCWL_1CYCLE    0x00000001u 
  #define  EMIFB_CESEC_SYNCWL_2CYCLE    0x00000002u 
  #define  EMIFB_CESEC_SYNCWL_3CYCLE    0x00000003u 

  #define _EMIFB_CESEC_SYNCRL_MASK      0x00000003u
  #define _EMIFB_CESEC_SYNCRL_SHIFT     0x00000000u
  #define  EMIFB_CESEC_SYNCRL_DEFAULT   0x00000002u
  #define  EMIFB_CESEC_SYNCRL_OF(x)     _VALUEOF(x)
  #define  EMIFB_CESEC_SYNCRL_0CYCLE    0x00000000u 
  #define  EMIFB_CESEC_SYNCRL_1CYCLE    0x00000001u 
  #define  EMIFB_CESEC_SYNCRL_2CYCLE    0x00000002u 
  #define  EMIFB_CESEC_SYNCRL_3CYCLE    0x00000003u 

  #define  EMIFB_CESEC_OF(x)            _VALUEOF(x)

  #define EMIFB_CESEC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFB,CESEC,SNCCLK)\
    |_PER_FDEFAULT(EMIFB,CESEC,RENEN)\
    |_PER_FDEFAULT(EMIFB,CESEC,CEEXT)\
    |_PER_FDEFAULT(EMIFB,CESEC,SYNCWL)\
    |_PER_FDEFAULT(EMIFB,CESEC,SYNCRL)\
  )

  #define EMIFB_CESEC_RMK(sncclk,renen,ceext,syncwl,syncrl)\
    (Uint32)( \
     _PER_FMK(EMIFB,CESEC,SNCCLK,sncclk)\
    |_PER_FMK(EMIFB,CESEC,RENEN,renen)\
    |_PER_FMK(EMIFB,CESEC,CEEXT,ceext)\
    |_PER_FMK(EMIFB,CESEC,SYNCWL,syncwl)\
    |_PER_FMK(EMIFB,CESEC,SYNCRL,syncrl)\
  )

  #define _EMIFB_CESEC_FGET(N,FIELD)\
    _PER_FGET(_EMIFB_CESEC##N##_ADDR,EMIFB,CESEC,##FIELD)

  #define _EMIFB_CESEC_FSET(N,FIELD,f)\
    _PER_FSET(_EMIFB_CESEC##N##_ADDR,EMIFB,CESEC,##FIELD,f)

  #define _EMIFB_CESEC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_EMIFB_CESEC##N##_ADDR,EMIFB,CESEC,##FIELD,##SYM)

  #define _EMIFB_CESEC0_FGET(FIELD) _EMIFB_CESEC_FGET(0,##FIELD)
  #define _EMIFB_CESEC1_FGET(FIELD) _EMIFB_CESEC_FGET(1,##FIELD)
  #define _EMIFB_CESEC2_FGET(FIELD) _EMIFB_CESEC_FGET(2,##FIELD)
  #define _EMIFB_CESEC3_FGET(FIELD) _EMIFB_CESEC_FGET(3,##FIELD)

  #define _EMIFB_CESEC0_FSET(FIELD,f) _EMIFB_CESEC_FSET(0,##FIELD,f)
  #define _EMIFB_CESEC1_FSET(FIELD,f) _EMIFB_CESEC_FSET(1,##FIELD,f)
  #define _EMIFB_CESEC2_FSET(FIELD,f) _EMIFB_CESEC_FSET(2,##FIELD,f)
  #define _EMIFB_CESEC3_FSET(FIELD,f) _EMIFB_CESEC_FSET(3,##FIELD,f)

  #define _EMIFB_CESEC0_FSETS(FIELD,SYM) _EMIFB_CESEC_FSETS(0,##FIELD,##SYM)
  #define _EMIFB_CESEC1_FSETS(FIELD,SYM) _EMIFB_CESEC_FSETS(1,##FIELD,##SYM)
  #define _EMIFB_CESEC2_FSETS(FIELD,SYM) _EMIFB_CESEC_FSETS(2,##FIELD,##SYM)
  #define _EMIFB_CESEC3_FSETS(FIELD,SYM) _EMIFB_CESEC_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  P D T C T L      |
* |___________________|
*
* PDTCTL   - Peripheral device transfer (PDT) control
*
* FIELDS (msb -> lsb)
* (rw) PDTWL
* (rw) PDTRL
*
\******************************************************************************/
  #define _EMIFB_PDTCTL_OFFSET          16 

  #define _EMIFB_PDTCTL_ADDR            0x01A80040u

  #define _EMIFB_PDTCTL_PDTWL_MASK      0x0000000Cu
  #define _EMIFB_PDTCTL_PDTWL_SHIFT     0x00000002u
  #define  EMIFB_PDTCTL_PDTWL_DEFAULT   0x00000000u
  #define  EMIFB_PDTCTL_PDTWL_OF(x)     _VALUEOF(x)
  #define  EMIFB_PDTCTL_PDTWL_0CYCLE    0x00000000u
  #define  EMIFB_PDTCTL_PDTWL_1CYCLE    0x00000001u
  #define  EMIFB_PDTCTL_PDTWL_2CYCLE    0x00000002u
  #define  EMIFB_PDTCTL_PDTWL_3CYCLE    0x00000003u
   
  #define _EMIFB_PDTCTL_PDTRL_MASK      0x00000003u
  #define _EMIFB_PDTCTL_PDTRL_SHIFT     0x00000000u
  #define  EMIFB_PDTCTL_PDTRL_DEFAULT   0x00000000u
  #define  EMIFB_PDTCTL_PDTRL_OF(x)     _VALUEOF(x)
  #define  EMIFB_PDTCTL_PDTRL_0CYCLE    0x00000000u
  #define  EMIFB_PDTCTL_PDTRL_1CYCLE    0x00000001u
  #define  EMIFB_PDTCTL_PDTRL_2CYCLE    0x00000002u
  #define  EMIFB_PDTCTL_PDTRL_3CYCLE    0x00000003u


  #define EMIFB_PDTCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIFB,PDTCTL,PDTWL)\
    |_PER_FDEFAULT(EMIFB,PDTCTL,PDTRL)\
  )

  #define EMIFB_PDTCTL_RMK(pdtwl,pdtrl) (Uint32)( \
     _PER_FMK(EMIFB,PDTCTL,PDTWL,pdtwl)\
    |_PER_FMK(EMIFB,PDTCTL,PDTRL,pdtrl)\
  )

  #define _EMIFB_PDTCTL_FGET(FIELD)\
    _PER_FGET(_EMIFB_PDTCTL_ADDR,EMIFB,PDTCTL,##FIELD)

  #define _EMIFB_PDTCTL_FSET(FIELD,field)\
    _PER_FSET(_EMIFB_PDTCTL_ADDR,EMIFB,PDTCTL,##FIELD,field)

  #define _EMIFB_PDTCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIFB_PDTCTL_ADDR,EMIFB,PDTCTL,##FIELD,##SYM)


   
#endif /* EMIFB_SUPPORT */

#endif /* _CSL_EMIFBHAL_H_ */
/******************************************************************************\
* End of csl_emifhal.h
\******************************************************************************/

csl_emifhal.h/  1056024094  0     0     0       30950     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_emifhal.h
* DATE CREATED.. 06/12/1999 
* LAST MODIFIED. 06/17/2003  Added CHIP_6712C
*                05/28/2003  Added CHIP_6711C
*                10/03/2000
*------------------------------------------------------------------------------
* REGISTERS
*
* GBLCTL  - global control register
* CECTL0  - CE space control register 0
* CECTL1  - CE space control register 1
* CECTL2  - CE space control register 2
* CECTL3  - CE space control register 3
* SDCTL   - SDRAM control regsiter
* SDTIM   - SDRAM timing register
* SDEXT   - SDRAM extension register (1)
*
* (1) - only supported on 6211,6711,6712,6713,6711C,6712C
* 
\******************************************************************************/
#ifndef _CSL_EMIFHAL_H_
#define _CSL_EMIFHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (EMIF_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#define _EMIF_BASE_GLOBAL   0x01800000u


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define EMIF_FMK(REG,FIELD,x)\
    _PER_FMK(EMIF,##REG,##FIELD,x)

  #define EMIF_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(EMIF,##REG,##FIELD,##SYM)
 
 
  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define EMIF_ADDR(REG)\
    _EMIF_##REG##_ADDR

  #define EMIF_RGET(REG)\
    _PER_RGET(_EMIF_##REG##_ADDR,EMIF,##REG)

  #define EMIF_RSET(REG,x)\
    _PER_RSET(_EMIF_##REG##_ADDR,EMIF,##REG,x)

  #define EMIF_FGET(REG,FIELD)\
    _EMIF_##REG##_FGET(##FIELD)

  #define EMIF_FSET(REG,FIELD,x)\
    _EMIF_##REG##_FSET(##FIELD,##x)

  #define EMIF_FSETS(REG,FIELD,SYM)\
    _EMIF_##REG##_FSETS(##FIELD,##SYM)
 
 
  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define EMIF_RGETA(addr,REG)\
    _PER_RGET(addr,EMIF,##REG)

  #define EMIF_RSETA(addr,REG,x)\
    _PER_RSET(addr,EMIF,##REG,x)

  #define EMIF_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,EMIF,##REG,##FIELD)

  #define EMIF_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,EMIF,##REG,##FIELD,x)

  #define EMIF_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,EMIF,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  G B L C T L      |
* |___________________|
*
* GBLCTL  - global control register
*
* FIELDS (msb -> lsb)
* (r)  BUSREQ  (1)
* (r)  ARDY
* (r)  HOLD
* (r)  HOLDA
* (rw) NOHOLD
* (rw) SDCEN   (2)
* (rw) SSCEN   (2)
* (rw) EKEN    (4)
* (rw) CLK1EN
* (rw) CLK2EN  (3)
* (rw) SSCRT   (2)(3)
* (rw) RBTR8   (2)
* (r)  MAP     (2)
*
* (1) - Field only exists for C11_SUPPORT
* (2) - Field does not exist for C11_SUPPORT
* (3) - Field does not exist for 6202/6203/6204/6205 
* (4) - Field only exixts for C6713, DA610, 6711C, 6712C
*
\******************************************************************************/
  #define _EMIF_GBLCTL_OFFSET          0

  #define _EMIF_GBLCTL_ADDR            0x01800000u

#if (C11_SUPPORT)
  #define _EMIF_GBLCTL_BUSREQ_MASK     0x00000800u
  #define _EMIF_GBLCTL_BUSREQ_SHIFT    0x0000000Bu
  #define  EMIF_GBLCTL_BUSREQ_DEFAULT  0x00000000u
  #define  EMIF_GBLCTL_BUSREQ_OF(x)    _VALUEOF(x)
  #define  EMIF_GBLCTL_BUSREQ_LOW      0x00000000u
  #define  EMIF_GBLCTL_BUSREQ_HIGH     0x00000001u
#endif

  #define _EMIF_GBLCTL_ARDY_MASK       0x00000400u
  #define _EMIF_GBLCTL_ARDY_SHIFT      0x0000000Au
  #define  EMIF_GBLCTL_ARDY_DEFAULT    0x00000000u
  #define  EMIF_GBLCTL_ARDY_OF(x)      _VALUEOF(x)
  #define  EMIF_GBLCTL_ARDY_LOW        0x00000000u
  #define  EMIF_GBLCTL_ARDY_HIGH       0x00000001u

  #define _EMIF_GBLCTL_HOLD_MASK       0x00000200u
  #define _EMIF_GBLCTL_HOLD_SHIFT      0x00000009u
  #define  EMIF_GBLCTL_HOLD_DEFAULT    0x00000000u
  #define  EMIF_GBLCTL_HOLD_OF(x)      _VALUEOF(x)
  #define  EMIF_GBLCTL_HOLD_LOW        0x00000000u
  #define  EMIF_GBLCTL_HOLD_HIGH       0x00000001u

  #define _EMIF_GBLCTL_HOLDA_MASK      0x00000100u
  #define _EMIF_GBLCTL_HOLDA_SHIFT     0x00000008u
  #define  EMIF_GBLCTL_HOLDA_DEFAULT   0x00000000u
  #define  EMIF_GBLCTL_HOLDA_OF(x)     _VALUEOF(x)
  #define  EMIF_GBLCTL_HOLDA_LOW       0x00000000u
  #define  EMIF_GBLCTL_HOLDA_HIGH      0x00000001u

  #define _EMIF_GBLCTL_NOHOLD_MASK     0x00000080u
  #define _EMIF_GBLCTL_NOHOLD_SHIFT    0x00000007u
  #define  EMIF_GBLCTL_NOHOLD_DEFAULT  0x00000000u
  #define  EMIF_GBLCTL_NOHOLD_OF(x)    _VALUEOF(x)
  #define  EMIF_GBLCTL_NOHOLD_DISABLE  0x00000000u
  #define  EMIF_GBLCTL_NOHOLD_ENABLE   0x00000001u

#if (CHIP_6201 | CHIP_6202 | CHIP_6203 | CHIP_6204 | CHIP_6205 | CHIP_6701)
  #define _EMIF_GBLCTL_SDCEN_MASK      0x00000040u
  #define _EMIF_GBLCTL_SDCEN_SHIFT     0x00000006u
  #define  EMIF_GBLCTL_SDCEN_DEFAULT   0x00000001u
  #define  EMIF_GBLCTL_SDCEN_OF(x)     _VALUEOF(x)
  #define  EMIF_GBLCTL_SDCEN_DISABLE   0x00000000u
  #define  EMIF_GBLCTL_SDCEN_ENABLE    0x00000001u
#endif

#if (CHIP_6201 | CHIP_6202 | CHIP_6203 | CHIP_6204 | CHIP_6205 | CHIP_6701)
  #define _EMIF_GBLCTL_SSCEN_MASK      0x00000020u
  #define _EMIF_GBLCTL_SSCEN_SHIFT     0x00000005u
  #define  EMIF_GBLCTL_SSCEN_DEFAULT   0x00000001u
  #define  EMIF_GBLCTL_SSCEN_OF(x)     _VALUEOF(x)
  #define  EMIF_GBLCTL_SSCEN_DISABLE   0x00000000u
  #define  EMIF_GBLCTL_SSCEN_ENABLE    0x00000001u
#endif

#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
  #define _EMIF_GBLCTL_EKEN_MASK       0x00000020u
  #define _EMIF_GBLCTL_EKEN_SHIFT      0x00000005u
  #define  EMIF_GBLCTL_EKEN_DEFAULT    0x00000001u
  #define  EMIF_GBLCTL_EKEN_OF(x)      _VALUEOF(x)
  #define  EMIF_GBLCTL_EKEN_DISABLE    0x00000000u
  #define  EMIF_GBLCTL_EKEN_ENABLE     0x00000001u
#endif

  #define _EMIF_GBLCTL_CLK1EN_MASK     0x00000010u
  #define _EMIF_GBLCTL_CLK1EN_SHIFT    0x00000004u

#if (CHIP_6713 || CHIP_DA610)
  #define  EMIF_GBLCTL_CLK1EN_DEFAULT  0x00000000u
#else
  #define  EMIF_GBLCTL_CLK1EN_DEFAULT  0x00000001u
#endif

  #define  EMIF_GBLCTL_CLK1EN_OF(x)    _VALUEOF(x)
  #define  EMIF_GBLCTL_CLK1EN_DISABLE  0x00000000u
  #define  EMIF_GBLCTL_CLK1EN_ENABLE   0x00000001u

#if (!(CHIP_6202|CHIP_6203|CHIP_6204|CHIP_6205))
  #define _EMIF_GBLCTL_CLK2EN_MASK     0x00000008u
  #define _EMIF_GBLCTL_CLK2EN_SHIFT    0x00000003u
  #define  EMIF_GBLCTL_CLK2EN_DEFAULT  0x00000001u
  #define  EMIF_GBLCTL_CLK2EN_OF(x)    _VALUEOF(x)
  #define  EMIF_GBLCTL_CLK2EN_DISABLE  0x00000000u
  #define  EMIF_GBLCTL_CLK2EN_ENABLE   0x00000001u
#endif

#if (CHIP_6201|CHIP_6701)
  #define _EMIF_GBLCTL_SSCRT_MASK      0x00000004u
  #define _EMIF_GBLCTL_SSCRT_SHIFT     0x00000002u
  #define  EMIF_GBLCTL_SSCRT_DEFAULT   0x00000000u
  #define  EMIF_GBLCTL_SSCRT_OF(x)     _VALUEOF(x)
  #define  EMIF_GBLCTL_SSCRT_CPUOVR2   0x00000000u
  #define  EMIF_GBLCTL_SSCRT_CPU       0x00000001u
#endif

#if (!C11_SUPPORT)
  #define _EMIF_GBLCTL_RBTR8_MASK      0x00000002u
  #define _EMIF_GBLCTL_RBTR8_SHIFT     0x00000001u
  #define  EMIF_GBLCTL_RBTR8_DEFAULT   0x00000000u
  #define  EMIF_GBLCTL_RBTR8_OF(x)     _VALUEOF(x)
  #define  EMIF_GBLCTL_RBTR8_HPRI      0x00000000u
  #define  EMIF_GBLCTL_RBTR8_8ACC      0x00000001u
#endif

#if (!C11_SUPPORT)
  #define _EMIF_GBLCTL_MAP_MASK        0x00000001u
  #define _EMIF_GBLCTL_MAP_SHIFT       0x00000000u
  #define  EMIF_GBLCTL_MAP_MAP1        0x00000000u
  #define  EMIF_GBLCTL_MAP_MAP0        0x00000001u
  #define  EMIF_GBLCTL_MAP_DEFAULT     0x00000000u
  #define  EMIF_GBLCTL_MAP_OF(x)       _VALUEOF(x)
#endif

  #define  EMIF_GBLCTL_OF(x)           _VALUEOF(x)

#if (CHIP_6201|CHIP_6701)
  #define EMIF_GBLCTL_DEFAULT (Uint32)( \
    0x00003000\
    |_PER_FDEFAULT(EMIF,GBLCTL,ARDY)\
    |_PER_FDEFAULT(EMIF,GBLCTL,HOLD)\
    |_PER_FDEFAULT(EMIF,GBLCTL,HOLDA)\
    |_PER_FDEFAULT(EMIF,GBLCTL,NOHOLD)\
    |_PER_FDEFAULT(EMIF,GBLCTL,SDCEN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,SSCEN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,CLK1EN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,CLK2EN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,SSCRT)\
    |_PER_FDEFAULT(EMIF,GBLCTL,RBTR8)\
    |_PER_FDEFAULT(EMIF,GBLCTL,MAP)\
  )

  #define EMIF_GBLCTL_RMK(nohold,sdcen,sscen,clk1en,clk2en,sscrt,rbtr8) \
    (Uint32)( \
     _PER_FMK(EMIF,GBLCTL,NOHOLD,nohold)\
    |_PER_FMK(EMIF,GBLCTL,SDCEN,sdcen)\
    |_PER_FMK(EMIF,GBLCTL,SSCEN,sscen)\
    |_PER_FMK(EMIF,GBLCTL,CLK1EN,clk1en)\
    |_PER_FMK(EMIF,GBLCTL,CLK2EN,clk2en)\
    |_PER_FMK(EMIF,GBLCTL,SSCRT,sscrt)\
    |_PER_FMK(EMIF,GBLCTL,RBTR8,rbtr8)\
  )
#endif

#if (CHIP_6211|CHIP_6711)
  #define EMIF_GBLCTL_DEFAULT (Uint32)( \
    0x00003000\
    |_PER_FDEFAULT(EMIF,GBLCTL,BUSREQ)\
    |_PER_FDEFAULT(EMIF,GBLCTL,ARDY)\
    |_PER_FDEFAULT(EMIF,GBLCTL,HOLD)\
    |_PER_FDEFAULT(EMIF,GBLCTL,HOLDA)\
    |_PER_FDEFAULT(EMIF,GBLCTL,NOHOLD)\
    |_PER_FDEFAULT(EMIF,GBLCTL,CLK1EN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,CLK2EN)\
  )

  #define EMIF_GBLCTL_RMK(nohold,clk1en,clk2en) (Uint32)( \
     _PER_FMK(EMIF,GBLCTL,NOHOLD,nohold)\
    |_PER_FMK(EMIF,GBLCTL,CLK1EN,clk1en)\
    |_PER_FMK(EMIF,GBLCTL,CLK2EN,clk2en)\
  )
#endif

#if (CHIP_6202|CHIP_6203|CHIP_6204|CHIP_6205)
  #define EMIF_GBLCTL_DEFAULT (Uint32)( \
    0x00003008\
    |_PER_FDEFAULT(EMIF,GBLCTL,ARDY)\
    |_PER_FDEFAULT(EMIF,GBLCTL,HOLD)\
    |_PER_FDEFAULT(EMIF,GBLCTL,HOLDA)\
    |_PER_FDEFAULT(EMIF,GBLCTL,NOHOLD)\
    |_PER_FDEFAULT(EMIF,GBLCTL,SDCEN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,SSCEN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,CLK1EN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,RBTR8)\
    |_PER_FDEFAULT(EMIF,GBLCTL,MAP)\
  )

  #define EMIF_GBLCTL_RMK(nohold,sdcen,sscen,clk1en,rbtr8) (Uint32)( \
     _PER_FMK(EMIF,GBLCTL,NOHOLD,nohold)\
    |_PER_FMK(EMIF,GBLCTL,SDCEN,sdcen)\
    |_PER_FMK(EMIF,GBLCTL,SSCEN,sscen)\
    |_PER_FMK(EMIF,GBLCTL,CLK1EN,clk1en)\
    |_PER_FMK(EMIF,GBLCTL,RBTR8,rbtr8)\
  )
#endif

#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
  #define EMIF_GBLCTL_DEFAULT (Uint32)( \
    0x00003000\
    |_PER_FDEFAULT(EMIF,GBLCTL,BUSREQ)\
    |_PER_FDEFAULT(EMIF,GBLCTL,ARDY)\
    |_PER_FDEFAULT(EMIF,GBLCTL,HOLD)\
    |_PER_FDEFAULT(EMIF,GBLCTL,HOLDA)\
    |_PER_FDEFAULT(EMIF,GBLCTL,NOHOLD)\
    |_PER_FDEFAULT(EMIF,GBLCTL,EKEN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,CLK1EN)\
    |_PER_FDEFAULT(EMIF,GBLCTL,CLK2EN)\
  )

  #define EMIF_GBLCTL_RMK(nohold,eken,clk1en,clk2en) (Uint32)( \
     _PER_FMK(EMIF,GBLCTL,NOHOLD,nohold)\
    |_PER_FMK(EMIF,GBLCTL,EKEN,eken)\
    |_PER_FMK(EMIF,GBLCTL,CLK1EN,clk1en)\
    |_PER_FMK(EMIF,GBLCTL,CLK2EN,clk2en)\
  )
#endif

  #define _EMIF_GBLCTL_FGET(FIELD)\
    _PER_FGET(_EMIF_GBLCTL_ADDR,EMIF,GBLCTL,##FIELD)

  #define _EMIF_GBLCTL_FSET(FIELD,field)\
    _PER_FSET(_EMIF_GBLCTL_ADDR,EMIF,GBLCTL,##FIELD,field)

  #define _EMIF_GBLCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIF_GBLCTL_ADDR,EMIF,GBLCTL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C E C T L        |
* |___________________|
*
* CECTL0 - CE space control register 0
* CECTL1 - CE space control register 1
* CECTL2 - CE space control register 2
* CECTL3 - CE space control register 3
*
* FIELDS (msb -> lsb)
* (rw) WRSETUP
* (rw) WRSTRB
* (rw) WRHLD
* (rw) RDSETUP
* (rw) TA       (1) 
* (rw) RDSTRB
* (rw) MTYPE
* (rw) WRHLDMSB 
* (rw) RDHLD
*
* (1) - Field only exists for C11_SUPPORT
* 
*
\******************************************************************************/
  #define _EMIF_CECTL0_OFFSET          2
  #define _EMIF_CECTL1_OFFSET          1
  #define _EMIF_CECTL2_OFFSET          4
  #define _EMIF_CECTL3_OFFSET          5

  #define _EMIF_CECTL0_ADDR            0x01800008u
  #define _EMIF_CECTL1_ADDR            0x01800004u
  #define _EMIF_CECTL2_ADDR            0x01800010u
  #define _EMIF_CECTL3_ADDR            0x01800014u

  #define _EMIF_CECTL_WRSETUP_MASK     0xF0000000u
  #define _EMIF_CECTL_WRSETUP_SHIFT    0x0000001Cu
  #define  EMIF_CECTL_WRSETUP_DEFAULT  0x0000000Fu
  #define  EMIF_CECTL_WRSETUP_OF(x)    _VALUEOF(x)

  #define _EMIF_CECTL_WRSTRB_MASK      0x0FC00000u
  #define _EMIF_CECTL_WRSTRB_SHIFT     0x00000016u
  #define  EMIF_CECTL_WRSTRB_DEFAULT   0x0000003Fu
  #define  EMIF_CECTL_WRSTRB_OF(x)     _VALUEOF(x)

  #define _EMIF_CECTL_WRHLD_MASK       0x00300000u
  #define _EMIF_CECTL_WRHLD_SHIFT      0x00000014u
  #define  EMIF_CECTL_WRHLD_DEFAULT    0x00000003u
  #define  EMIF_CECTL_WRHLD_OF(x)      _VALUEOF(x)
  
  #define _EMIF_CECTL_RDSETUP_MASK     0x000F0000u
  #define _EMIF_CECTL_RDSETUP_SHIFT    0x00000010u
  #define  EMIF_CECTL_RDSETUP_DEFAULT  0x0000000Fu
  #define  EMIF_CECTL_RDSETUP_OF(x)    _VALUEOF(x)

#if (C11_SUPPORT)
  #define _EMIF_CECTL_TA_MASK          0x0000C000u
  #define _EMIF_CECTL_TA_SHIFT         0x0000000Eu
  #define  EMIF_CECTL_TA_DEFAULT       0x00000003u
  #define  EMIF_CECTL_TA_OF(x)         _VALUEOF(x)
#endif

  #define _EMIF_CECTL_RDSTRB_MASK      0x00003F00u
  #define _EMIF_CECTL_RDSTRB_SHIFT     0x00000008u
  #define  EMIF_CECTL_RDSTRB_DEFAULT   0x0000003Fu
  #define  EMIF_CECTL_RDSTRB_OF(x)     _VALUEOF(x)
  
#if (C11_SUPPORT)
  #define _EMIF_CECTL_MTYPE_MASK       0x000000F0u
  #define _EMIF_CECTL_MTYPE_SHIFT      0x00000004u
  #define  EMIF_CECTL_MTYPE_DEFAULT    0x00000002u
  #define  EMIF_CECTL_MTYPE_OF(x)      _VALUEOF(x)
  #if (CHIP_6712 || CHIP_6712C)  /* 16-bit EMIF */ 
  #define  EMIFB_CECTL_MTYPE_ASYNC8     0x00000000u 
  #define  EMIFB_CECTL_MTYPE_ASYNC16    0x00000001u 
  #define  EMIFB_CECTL_MTYPE_SDRAM8     0x00000008u 
  #define  EMIFB_CECTL_MTYPE_SDRAM16    0x00000009u 
  #define  EMIFB_CECTL_MTYPE_SYNC8      0x0000000Au 
  #define  EMIFB_CECTL_MTYPE_SYNC16     0x0000000Bu 
  #else /* CHIP_6211/C6711/6711C 32-bit EMIF */
  #define  EMIF_CECTL_MTYPE_ASYNC8     0x00000000u
  #define  EMIF_CECTL_MTYPE_ASYNC16    0x00000001u
  #define  EMIF_CECTL_MTYPE_ASYNC32    0x00000002u
  #define  EMIF_CECTL_MTYPE_SDRAM32    0x00000003u
  #define  EMIF_CECTL_MTYPE_SBSRAM32   0x00000004u
  #define  EMIF_CECTL_MTYPE_SDRAM8     0x00000008u
  #define  EMIF_CECTL_MTYPE_SDRAM16    0x00000009u
  #define  EMIF_CECTL_MTYPE_SBSRAM8    0x0000000Au
  #define  EMIF_CECTL_MTYPE_SBSRAM16   0x0000000Bu
  #endif
 
#else
  #define _EMIF_CECTL_MTYPE_MASK       0x00000070u
  #define _EMIF_CECTL_MTYPE_SHIFT      0x00000004u
  #define  EMIF_CECTL_MTYPE_DEFAULT    0x00000002u
  #define  EMIF_CECTL_MTYPE_OF(x)      _VALUEOF(x)
  #define  EMIF_CECTL_MTYPE_ASYNC8     0x00000000u
  #define  EMIF_CECTL_MTYPE_ASYNC16    0x00000001u
  #define  EMIF_CECTL_MTYPE_ASYNC32    0x00000002u
  #define  EMIF_CECTL_MTYPE_SDRAM32    0x00000003u
  #define  EMIF_CECTL_MTYPE_SBSRAM32   0x00000004u
#endif


#if (C11_SUPPORT )
  #define _EMIF_CECTL_RDHLD_MASK       0x00000007u
  #define _EMIF_CECTL_RDHLD_SHIFT      0x00000000u
  #define  EMIF_CECTL_RDHLD_DEFAULT    0x00000003u
  #define  EMIF_CECTL_RDHLD_OF(x)      _VALUEOF(x)
#else
  #define _EMIF_CECTL_RDHLD_MASK       0x00000003u
  #define _EMIF_CECTL_RDHLD_SHIFT      0x00000000u
  #define  EMIF_CECTL_RDHLD_DEFAULT    0x00000003u
  #define  EMIF_CECTL_RDHLD_OF(x)      _VALUEOF(x)
#endif

  #define  EMIF_CECTL_OF(x)            _VALUEOF(x)

#if (C11_SUPPORT)
  #define EMIF_CECTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIF,CECTL,WRSETUP)\
    |_PER_FDEFAULT(EMIF,CECTL,WRSTRB)\
    |_PER_FDEFAULT(EMIF,CECTL,WRHLD)\
    |_PER_FDEFAULT(EMIF,CECTL,RDSETUP)\
    |_PER_FDEFAULT(EMIF,CECTL,TA)\
    |_PER_FDEFAULT(EMIF,CECTL,RDSTRB)\
    |_PER_FDEFAULT(EMIF,CECTL,MTYPE)\
    |_PER_FDEFAULT(EMIF,CECTL,RDHLD)\
  )

  #define EMIF_CECTL_RMK(wrsetup,wrstrb,wrhld,rdsetup,ta,rdstrb,mtype,\
    rdhld) (Uint32)( \
     _PER_FMK(EMIF,CECTL,WRSETUP,wrsetup)\
    |_PER_FMK(EMIF,CECTL,WRSTRB,wrstrb)\
    |_PER_FMK(EMIF,CECTL,WRHLD,wrhld)\
    |_PER_FMK(EMIF,CECTL,RDSETUP,rdsetup)\
    |_PER_FMK(EMIF,CECTL,TA,ta)\
    |_PER_FMK(EMIF,CECTL,RDSTRB,rdstrb)\
    |_PER_FMK(EMIF,CECTL,MTYPE,mtype)\
    |_PER_FMK(EMIF,CECTL,RDHLD,rdhld)\
  )
#endif



#if (!C11_SUPPORT)
  #define EMIF_CECTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIF,CECTL,WRSETUP)\
    |_PER_FDEFAULT(EMIF,CECTL,WRSTRB)\
    |_PER_FDEFAULT(EMIF,CECTL,WRHLD)\
    |_PER_FDEFAULT(EMIF,CECTL,RDSETUP)\
    |_PER_FDEFAULT(EMIF,CECTL,RDSTRB)\
    |_PER_FDEFAULT(EMIF,CECTL,MTYPE)\
    |_PER_FDEFAULT(EMIF,CECTL,RDHLD)\
  )

  #define EMIF_CECTL_RMK(wrsetup,wrstrb,wrhld,rdsetup,rdstrb,mtype,\
    rdhld) (Uint32)( \
     _PER_FMK(EMIF,CECTL,WRSETUP,wrsetup)\
    |_PER_FMK(EMIF,CECTL,WRSTRB,wrstrb)\
    |_PER_FMK(EMIF,CECTL,WRHLD,wrhld)\
    |_PER_FMK(EMIF,CECTL,RDSETUP,rdsetup)\
    |_PER_FMK(EMIF,CECTL,RDSTRB,rdstrb)\
    |_PER_FMK(EMIF,CECTL,MTYPE,mtype)\
    |_PER_FMK(EMIF,CECTL,RDHLD,rdhld)\
  )
#endif

  #define _EMIF_CECTL_FGET(N,FIELD)\
    _PER_FGET(_EMIF_CECTL##N##_ADDR,EMIF,CECTL,##FIELD)

  #define _EMIF_CECTL_FSET(N,FIELD,f)\
    _PER_FSET(_EMIF_CECTL##N##_ADDR,EMIF,CECTL,##FIELD,f)

  #define _EMIF_CECTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_EMIF_CECTL##N##_ADDR,EMIF,CECTL,##FIELD,##SYM)

  #define _EMIF_CECTL0_FGET(FIELD) _EMIF_CECTL_FGET(0,##FIELD)
  #define _EMIF_CECTL1_FGET(FIELD) _EMIF_CECTL_FGET(1,##FIELD)
  #define _EMIF_CECTL2_FGET(FIELD) _EMIF_CECTL_FGET(2,##FIELD)
  #define _EMIF_CECTL3_FGET(FIELD) _EMIF_CECTL_FGET(3,##FIELD)

  #define _EMIF_CECTL0_FSET(FIELD,f) _EMIF_CECTL_FSET(0,##FIELD,f)
  #define _EMIF_CECTL1_FSET(FIELD,f) _EMIF_CECTL_FSET(1,##FIELD,f)
  #define _EMIF_CECTL2_FSET(FIELD,f) _EMIF_CECTL_FSET(2,##FIELD,f)
  #define _EMIF_CECTL3_FSET(FIELD,f) _EMIF_CECTL_FSET(3,##FIELD,f)

  #define _EMIF_CECTL0_FSETS(FIELD,SYM) _EMIF_CECTL_FSETS(0,##FIELD,##SYM)
  #define _EMIF_CECTL1_FSETS(FIELD,SYM) _EMIF_CECTL_FSETS(1,##FIELD,##SYM)
  #define _EMIF_CECTL2_FSETS(FIELD,SYM) _EMIF_CECTL_FSETS(2,##FIELD,##SYM)
  #define _EMIF_CECTL3_FSETS(FIELD,SYM) _EMIF_CECTL_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D C T L        |
* |___________________|
*
* SDCTL   - SDRAM control regsiter
*
* FIELDS (msb -> lsb)
* (rw) SDBSZ (2)
* (rw) SDRSZ (2)
* (rw) SDCSZ (2)
* (rw) SDWID (1)
* (rw) RFEN
* (r)  INIT
* (rw) TRCD
* (rw) TRP
* (rw) TRC
*
* (1) - Field only exists for C01_SUPPORT
* (2) - Field only exists for C11_SUPPORT 
*
\******************************************************************************/
  #define _EMIF_SDCTL_OFFSET           6

  #define _EMIF_SDCTL_ADDR             0x01800018u

#if (C11_SUPPORT)
  #define _EMIF_SDCTL_SDBSZ_MASK       0x40000000u
  #define _EMIF_SDCTL_SDBSZ_SHIFT      0x0000001Eu
  #define  EMIF_SDCTL_SDBSZ_DEFAULT    0x00000000u
  #define  EMIF_SDCTL_SDBSZ_OF(x)      _VALUEOF(x)
  #define  EMIF_SDCTL_SDBSZ_2BANKS     0x00000000u
  #define  EMIF_SDCTL_SDBSZ_4BANKS     0x00000001u
#endif
  
#if (C11_SUPPORT)
  #define _EMIF_SDCTL_SDRSZ_MASK       0x30000000u
  #define _EMIF_SDCTL_SDRSZ_SHIFT      0x0000001Cu
  #define  EMIF_SDCTL_SDRSZ_DEFAULT    0x00000000u
  #define  EMIF_SDCTL_SDRSZ_OF(x)      _VALUEOF(x)
  #define  EMIF_SDCTL_SDRSZ_11ROW      0x00000000u
  #define  EMIF_SDCTL_SDRSZ_12ROW      0x00000001u
  #define  EMIF_SDCTL_SDRSZ_13ROW      0x00000002u
#endif
  
#if (C11_SUPPORT)
  #define _EMIF_SDCTL_SDCSZ_MASK       0x0C000000u
  #define _EMIF_SDCTL_SDCSZ_SHIFT      0x0000001Au
  #define  EMIF_SDCTL_SDCSZ_DEFAULT    0x00000000u
  #define  EMIF_SDCTL_SDCSZ_OF(x)      _VALUEOF(x)
  #define  EMIF_SDCTL_SDCSZ_9COL       0x00000000u
  #define  EMIF_SDCTL_SDCSZ_8COL       0x00000001u
  #define  EMIF_SDCTL_SDCSZ_10COL      0x00000002u
#endif
  
#if !(C11_SUPPORT) 
  #define _EMIF_SDCTL_SDWID_MASK       0x04000000u
  #define _EMIF_SDCTL_SDWID_SHIFT      0x0000001Au
  #define  EMIF_SDCTL_SDWID_DEFAULT    0x00000000u
  #define  EMIF_SDCTL_SDWID_OF(x)      _VALUEOF(x)
  #define  EMIF_SDCTL_SDWID_4X8BIT     0x00000000u
  #define  EMIF_SDCTL_SDWID_2X16BIT    0x00000001u
#endif
  
  #define _EMIF_SDCTL_RFEN_MASK        0x02000000u
  #define _EMIF_SDCTL_RFEN_SHIFT       0x00000019u
  #define  EMIF_SDCTL_RFEN_DEFAULT     0x00000001u
  #define  EMIF_SDCTL_RFEN_OF(x)       _VALUEOF(x)
  #define  EMIF_SDCTL_RFEN_DISABLE     0x00000000u
  #define  EMIF_SDCTL_RFEN_ENABLE      0x00000001u

  #define _EMIF_SDCTL_INIT_MASK        0x01000000u
  #define _EMIF_SDCTL_INIT_SHIFT       0x00000018u
  #define  EMIF_SDCTL_INIT_DEFAULT     0x00000001u
  #define  EMIF_SDCTL_INIT_OF(x)       _VALUEOF(x)
  #define  EMIF_SDCTL_INIT_NO          0x00000000u
  #define  EMIF_SDCTL_INIT_YES         0x00000001u

#if (C11_SUPPORT)
  #define _EMIF_SDCTL_TRCD_MASK        0x00F00000u
  #define _EMIF_SDCTL_TRCD_SHIFT       0x00000014u
  #define  EMIF_SDCTL_TRCD_DEFAULT     0x00000004u
  #define  EMIF_SDCTL_TRCD_OF(x)       _VALUEOF(x)
#else
  #define _EMIF_SDCTL_TRCD_MASK        0x00F00000u
  #define _EMIF_SDCTL_TRCD_SHIFT       0x00000014u
  #define  EMIF_SDCTL_TRCD_DEFAULT     0x00000008u
  #define  EMIF_SDCTL_TRCD_OF(x)       _VALUEOF(x)
#endif

  #define _EMIF_SDCTL_TRP_MASK         0x000F0000u
  #define _EMIF_SDCTL_TRP_SHIFT        0x00000010u
  #define  EMIF_SDCTL_TRP_DEFAULT      0x00000008u
  #define  EMIF_SDCTL_TRP_OF(x)        _VALUEOF(x)

  #define _EMIF_SDCTL_TRC_MASK         0x0000F000u
  #define _EMIF_SDCTL_TRC_SHIFT        0x0000000Cu
  #define  EMIF_SDCTL_TRC_DEFAULT      0x0000000Fu
  #define  EMIF_SDCTL_TRC_OF(x)        _VALUEOF(x)

  #define  EMIF_SDCTL_OF(x)            _VALUEOF(x)

#if (C11_SUPPORT)
  #define EMIF_SDCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIF,SDCTL,SDBSZ)\
    |_PER_FDEFAULT(EMIF,SDCTL,SDRSZ)\
    |_PER_FDEFAULT(EMIF,SDCTL,SDCSZ)\
    |_PER_FDEFAULT(EMIF,SDCTL,RFEN)\
    |_PER_FDEFAULT(EMIF,SDCTL,INIT)\
    |_PER_FDEFAULT(EMIF,SDCTL,TRCD)\
    |_PER_FDEFAULT(EMIF,SDCTL,TRP)\
    |_PER_FDEFAULT(EMIF,SDCTL,TRC)\
  )

  #define EMIF_SDCTL_RMK(sdbsz,sdrsz,sdcsz,rfen,init,trcd,trp,trc) (Uint32)(\
     _PER_FMK(EMIF,SDCTL,SDBSZ,sdbsz)\
    |_PER_FMK(EMIF,SDCTL,SDRSZ,sdrsz)\
    |_PER_FMK(EMIF,SDCTL,SDCSZ,sdcsz)\
    |_PER_FMK(EMIF,SDCTL,RFEN,rfen)\
    |_PER_FMK(EMIF,SDCTL,INIT,init)\
    |_PER_FMK(EMIF,SDCTL,TRCD,trcd)\
    |_PER_FMK(EMIF,SDCTL,TRP,trp)\
    |_PER_FMK(EMIF,SDCTL,TRC,trc)\
  )
#endif

#if !(C11_SUPPORT)
  #define EMIF_SDCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIF,SDCTL,SDWID)\
    |_PER_FDEFAULT(EMIF,SDCTL,RFEN)\
    |_PER_FDEFAULT(EMIF,SDCTL,INIT)\
    |_PER_FDEFAULT(EMIF,SDCTL,TRCD)\
    |_PER_FDEFAULT(EMIF,SDCTL,TRP)\
    |_PER_FDEFAULT(EMIF,SDCTL,TRC)\
  )

  #define EMIF_SDCTL_RMK(sdwid,rfen,init,trcd,trp,trc) (Uint32)(\
     _PER_FMK(EMIF,SDCTL,SDWID,sdwid)\
    |_PER_FMK(EMIF,SDCTL,RFEN,rfen)\
    |_PER_FMK(EMIF,SDCTL,INIT,init)\
    |_PER_FMK(EMIF,SDCTL,TRCD,trcd)\
    |_PER_FMK(EMIF,SDCTL,TRP,trp)\
    |_PER_FMK(EMIF,SDCTL,TRC,trc)\
  )
#endif

  #define _EMIF_SDCTL_FGET(FIELD)\
    _PER_FGET(_EMIF_SDCTL_ADDR,EMIF,SDCTL,##FIELD)

  #define _EMIF_SDCTL_FSET(FIELD,field)\
    _PER_FSET(_EMIF_SDCTL_ADDR,EMIF,SDCTL,##FIELD,field)

  #define _EMIF_SDCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIF_SDCTL_ADDR,EMIF,SDCTL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D T I M        |
* |___________________|
*
* SDTIM   - SDRAM timing register
*
* FIELDS (msb -> lsb)
* (rw) XRFR   (1)
* (r)  CNTR
* (rw) PERIOD
*
* (1) - Field only exists for C11_SUPPORT
*
\******************************************************************************/
  #define _EMIF_SDTIM_OFFSET           7

  #define _EMIF_SDTIM_ADDR             0x0180001Cu

#if (C11_SUPPORT)
  #define _EMIF_SDTIM_XRFR_MASK        0x03000000u
  #define _EMIF_SDTIM_XRFR_SHIFT       0x00000018u
  #define  EMIF_SDTIM_XRFR_DEFAULT     0x00000000u
  #define  EMIF_SDTIM_XRFR_OF(x)       _VALUEOF(x)
#endif

#if (C11_SUPPORT)
  #define _EMIF_SDTIM_CNTR_MASK        0x00FFF000u
  #define _EMIF_SDTIM_CNTR_SHIFT       0x0000000Cu
  #define  EMIF_SDTIM_CNTR_DEFAULT     0x000005DCu
  #define  EMIF_SDTIM_CNTR_OF(x)       _VALUEOF(x)
#else
  #define _EMIF_SDTIM_CNTR_MASK        0x00FFF000u
  #define _EMIF_SDTIM_CNTR_SHIFT       0x0000000Cu
  #define  EMIF_SDTIM_CNTR_DEFAULT     0x00000040u
  #define  EMIF_SDTIM_CNTR_OF(x)       _VALUEOF(x)
#endif
  
#if (C11_SUPPORT)
  #define _EMIF_SDTIM_PERIOD_MASK      0x00000FFFu
  #define _EMIF_SDTIM_PERIOD_SHIFT     0x00000000u
  #define  EMIF_SDTIM_PERIOD_DEFAULT   0x000005DCu
  #define  EMIF_SDTIM_PERIOD_OF(x)     _VALUEOF(x)
#else
  #define _EMIF_SDTIM_PERIOD_MASK      0x00000FFFu
  #define _EMIF_SDTIM_PERIOD_SHIFT     0x00000000u
  #define  EMIF_SDTIM_PERIOD_DEFAULT   0x00000040u
  #define  EMIF_SDTIM_PERIOD_OF(x)     _VALUEOF(x)
#endif

  #define  EMIF_SDTIM_OF(x)            _VALUEOF(x)

#if (C11_SUPPORT)
  #define EMIF_SDTIM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIF,SDTIM,XRFR)\
    |_PER_FDEFAULT(EMIF,SDTIM,CNTR)\
    |_PER_FDEFAULT(EMIF,SDTIM,PERIOD)\
  )

  #define EMIF_SDTIM_RMK(xrfr,period) (Uint32)(\
     _PER_FMK(EMIF,SDTIM,XRFR,xrfr)\
    |_PER_FMK(EMIF,SDTIM,PERIOD,period)\
  )
#endif

#if !(C11_SUPPORT)
  #define EMIF_SDTIM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIF,SDTIM,CNTR)\
    |_PER_FDEFAULT(EMIF,SDTIM,PERIOD)\
  )

  #define EMIF_SDTIM_RMK(period) (Uint32)(\
     _PER_FMK(EMIF,SDTIM,PERIOD,period)\
  )
#endif


  #define _EMIF_SDTIM_FGET(FIELD)\
    _PER_FGET(_EMIF_SDTIM_ADDR,EMIF,SDTIM,##FIELD)

  #define _EMIF_SDTIM_FSET(FIELD,field)\
    _PER_FSET(_EMIF_SDTIM_ADDR,EMIF,SDTIM,##FIELD,field)

  #define _EMIF_SDTIM_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIF_SDTIM_ADDR,EMIF,SDTIM,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  S D E X T        |
* |___________________|
*
* SDEXT   - SDRAM extension register (1)
*
* (1) - only supported on 6211,6711,6713,DA610,6711C,6712C
*
* FIELDS (msb -> lsb)
* (rw) WR2RD
* (rw) WR2DEAC
* (rw) WR2WR
* (rw) R2WDQM
* (rw) RD2WR
* (rw) RD2DEAC
* (rw) RD2RD
* (rw) THZP
* (rw) TWR
* (rw) TRRD
* (rw) TRAS
* (rw) TCL
*
\******************************************************************************/
#if (C11_SUPPORT)
  #define _EMIF_SDEXT_OFFSET           8

  #define _EMIF_SDEXT_ADDR             0x01800020u

  #define _EMIF_SDEXT_WR2RD_MASK       0x00100000u
  #define _EMIF_SDEXT_WR2RD_SHIFT      0x00000014u
  #define  EMIF_SDEXT_WR2RD_DEFAULT    0x00000001u
  #define  EMIF_SDEXT_WR2RD_OF(x)      _VALUEOF(x)

  #define _EMIF_SDEXT_WR2DEAC_MASK     0x000C0000u
  #define _EMIF_SDEXT_WR2DEAC_SHIFT    0x00000012u
  #define  EMIF_SDEXT_WR2DEAC_DEFAULT  0x00000001u
  #define  EMIF_SDEXT_WR2DEAC_OF(x)    _VALUEOF(x)

  #define _EMIF_SDEXT_WR2WR_MASK       0x00020000u
  #define _EMIF_SDEXT_WR2WR_SHIFT      0x00000011u
  #define  EMIF_SDEXT_WR2WR_DEFAULT    0x00000001u
  #define  EMIF_SDEXT_WR2WR_OF(x)      _VALUEOF(x)

  #define _EMIF_SDEXT_R2WDQM_MASK      0x00018000u
  #define _EMIF_SDEXT_R2WDQM_SHIFT     0x0000000Fu
  #define  EMIF_SDEXT_R2WDQM_DEFAULT   0x00000003u
  #define  EMIF_SDEXT_R2WDQM_OF(x)     _VALUEOF(x)

  #define _EMIF_SDEXT_RD2WR_MASK       0x00007000u
  #define _EMIF_SDEXT_RD2WR_SHIFT      0x0000000Cu
  #define  EMIF_SDEXT_RD2WR_DEFAULT    0x00000005u
  #define  EMIF_SDEXT_RD2WR_OF(x)      _VALUEOF(x)

  #define _EMIF_SDEXT_RD2DEAC_MASK     0x00000C00u
  #define _EMIF_SDEXT_RD2DEAC_SHIFT    0x0000000Au
  #define  EMIF_SDEXT_RD2DEAC_DEFAULT  0x00000003u
  #define  EMIF_SDEXT_RD2DEAC_OF(x)    _VALUEOF(x)

  #define _EMIF_SDEXT_RD2RD_MASK       0x00000200u
  #define _EMIF_SDEXT_RD2RD_SHIFT      0x00000009u
  #define  EMIF_SDEXT_RD2RD_DEFAULT    0x00000001u
  #define  EMIF_SDEXT_RD2RD_OF(x)      _VALUEOF(x)

  #define _EMIF_SDEXT_THZP_MASK        0x00000180u
  #define _EMIF_SDEXT_THZP_SHIFT       0x00000007u
  #define  EMIF_SDEXT_THZP_DEFAULT     0x00000002u
  #define  EMIF_SDEXT_THZP_OF(x)       _VALUEOF(x)

  #define _EMIF_SDEXT_TWR_MASK         0x00000060u
  #define _EMIF_SDEXT_TWR_SHIFT        0x00000005u
  #define  EMIF_SDEXT_TWR_DEFAULT      0x00000001u
  #define  EMIF_SDEXT_TWR_OF(x)        _VALUEOF(x)

  #define _EMIF_SDEXT_TRRD_MASK        0x00000010u
  #define _EMIF_SDEXT_TRRD_SHIFT       0x00000004u
  #define  EMIF_SDEXT_TRRD_DEFAULT     0x00000001u
  #define  EMIF_SDEXT_TRRD_OF(x)       _VALUEOF(x)

  #define _EMIF_SDEXT_TRAS_MASK        0x0000000Eu
  #define _EMIF_SDEXT_TRAS_SHIFT       0x00000001u
  #define  EMIF_SDEXT_TRAS_DEFAULT     0x00000007u
  #define  EMIF_SDEXT_TRAS_OF(x)       _VALUEOF(x)

  #define _EMIF_SDEXT_TCL_MASK         0x00000001u
  #define _EMIF_SDEXT_TCL_SHIFT        0x00000000u
  #define  EMIF_SDEXT_TCL_DEFAULT      0x00000001u
  #define  EMIF_SDEXT_TCL_OF(x)        _VALUEOF(x)

  #define  EMIF_SDEXT_OF(x)            _VALUEOF(x)

  #define EMIF_SDEXT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(EMIF,SDEXT,WR2RD)\
    |_PER_FDEFAULT(EMIF,SDEXT,WR2DEAC)\
    |_PER_FDEFAULT(EMIF,SDEXT,WR2WR)\
    |_PER_FDEFAULT(EMIF,SDEXT,R2WDQM)\
    |_PER_FDEFAULT(EMIF,SDEXT,RD2WR)\
    |_PER_FDEFAULT(EMIF,SDEXT,RD2DEAC)\
    |_PER_FDEFAULT(EMIF,SDEXT,RD2RD)\
    |_PER_FDEFAULT(EMIF,SDEXT,THZP)\
    |_PER_FDEFAULT(EMIF,SDEXT,TWR)\
    |_PER_FDEFAULT(EMIF,SDEXT,TRRD)\
    |_PER_FDEFAULT(EMIF,SDEXT,TRAS)\
    |_PER_FDEFAULT(EMIF,SDEXT,TCL)\
  )

  #define EMIF_SDEXT_RMK(wr2rd,wr2deac,wr2wr,r2wdqm,rd2wr,rd2deac,\
    rd2rd,thzp,twr,trrd,tras,tcl) (Uint32)( \
     _PER_FMK(EMIF,SDEXT,WR2RD,wr2rd)\
    |_PER_FMK(EMIF,SDEXT,WR2DEAC,wr2deac)\
    |_PER_FMK(EMIF,SDEXT,WR2WR,wr2wr)\
    |_PER_FMK(EMIF,SDEXT,R2WDQM,r2wdqm)\
    |_PER_FMK(EMIF,SDEXT,RD2WR,rd2wr)\
    |_PER_FMK(EMIF,SDEXT,RD2DEAC,rd2deac)\
    |_PER_FMK(EMIF,SDEXT,RD2RD,rd2rd)\
    |_PER_FMK(EMIF,SDEXT,THZP,thzp)\
    |_PER_FMK(EMIF,SDEXT,TWR,twr)\
    |_PER_FMK(EMIF,SDEXT,TRRD,trrd)\
    |_PER_FMK(EMIF,SDEXT,TRAS,tras)\
    |_PER_FMK(EMIF,SDEXT,TCL,tcl)\
  )

  #define _EMIF_SDEXT_FGET(FIELD)\
    _PER_FGET(_EMIF_SDEXT_ADDR,EMIF,SDEXT,##FIELD)

  #define _EMIF_SDEXT_FSET(FIELD,field)\
    _PER_FSET(_EMIF_SDEXT_ADDR,EMIF,SDEXT,##FIELD,field)

  #define _EMIF_SDEXT_FSETS(FIELD,SYM)\
    _PER_FSETS(_EMIF_SDEXT_ADDR,EMIF,SDEXT,##FIELD,##SYM)

#endif

/*----------------------------------------------------------------------------*/

#endif /* EMIF_SUPPORT */
#endif /* _CSL_EMIFHAL_H_ */
/******************************************************************************\
* End of csl_emifhal.h
\******************************************************************************/

csl_emu.h/      1055323621  0     0     0       3261      `
/**************************************************************************\
*              Copyright (C) 2002 Texas Instruments Incorporated.
*                             All Rights Reserved
*--------------------------------------------------------------------------
* MODULE NAME... EMU
* FILENAME...... csl_emu.h
* DATE CREATED.. 05/12/2003
* LAST MODIFIED. 05/20/2003
* PROJECT....... Chip Support Library
* COMPONENT..... Service Layer
* PREREQUISITES.
\**************************************************************************/
/**************************************************************************\
* Private Macros - Include files - EMU_SUPPORT
\**************************************************************************/
#ifndef _CSL_EMU_H_
#define _CSL_EMU_H_

#include <csl_stdinc.h>
#include <csl_emuhal.h>

#if (EMU_SUPPORT)

/**************************************************************************\
* EMU scope and inline control macros
\**************************************************************************/

#ifdef __cplusplus
#   define CSLAPI extern "C" far
#else
#   define CSLAPI extern far
#endif

#undef USEDEFS
#undef IDECL
#undef IDEF

#ifdef      _EMU_MOD_
#   define  IDECL CSLAPI
#   define  USEDEFS
#   define  IDEF
#else
#   ifdef   _INLINE
#       define  IDECL           static inline
#       define  USEDEFS
#       define  IDEF            static inline
#   else
#       define  IDECL           CSLAPI
#   endif
#endif

/**************************************************************************\
* EMU global macro declarations
\**************************************************************************/

#define EMU_DEVICE_CNT            (1)        /* The number of EMU devices */

#define EMU_SUCCESS               (1)

#define EMU_FAILURE               (0)

/**************************************************************************\
* EMU global typedef declarations
\**************************************************************************/
/**************************************************************************\
* EMU global function declarations
\**************************************************************************/

CSLAPI Uint32  EMU_setDBGM(
    void
);


CSLAPI Uint32  EMU_clrDBGM(
    void
);


CSLAPI Uint32  EMU_getDBGM(
    void
);


CSLAPI void  EMU_setABORTI(
    void
);


CSLAPI void  EMU_clrABORTI(
    void
);


CSLAPI Uint32  EMU_setEALLOW(
    void
);


CSLAPI Uint32  EMU_clrEALLOW(
    void
);


CSLAPI Uint32  EMU_getEALLOW(
    void
);


CSLAPI Uint32  EMU_getDBGSTAT(
    void
);

/**************************************************************************\
* EMU inline function declarations
\**************************************************************************/
/**************************************************************************\
* EMU inline function declarations
\**************************************************************************/

#ifdef USEDEFS

#endif /*USEDEFS */



#endif      /* EMU_SUPPORT  */

#endif      /* _CSL_EMUHAL_H  */

/**************************************************************************\
*                               End of csl_emu.h
\**************************************************************************/

csl_emuhal.h/   1055323621  0     0     0       8463      `
/**************************************************************************\
*              Copyright (C) 2002 Texas Instruments Incorporated.
*                             All Rights Reserved
*--------------------------------------------------------------------------
* MODULE NAME... EMU
* FILENAME...... csl_emuhal.h
* DATE CREATED.. 05/12/2003
* LAST MODIFIED. 05/20/2003
* PROJECT....... Chip Support Library
* COMPONENT..... Hardware Abstraction Layer
* PREREQUISITES.
*
*--------------------------------------------------------------------------
* DESCRIPTION:
*        CSL Hardware Abstraction Layer interface for the EMU module
*
*--------------------------------------------------------------------------
* REGISTERS:
*
* DBGSTAT   - DBGSTAT {Debug Status Register}
* MFREG0    - MFREG0 {Miscellaneous Function Register}
\**************************************************************************/

#ifndef _CSL_EMUHAL_H_
#define _CSL_EMUHAL_H_

/**************************************************************************\
* Private Macros and Include files
\**************************************************************************/
#include <csl_stdinchal.h>
#include <csl_chiphal.h>

#if (EMU_SUPPORT)


/**************************************************************************\
* Module level register/field access macros
\**************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */
    #define EMU_FMK(REG, FIELD, x)                                        \
    _PER_FMK(EMU, ##REG, ##FIELD, x)
    #define EMU_FMKS(REG, FIELD, SYM)                                     \
    _PER_FMKS(EMU, ##REG, ##FIELD, ##SYM)

  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */
  #define EMU_ADDR(REG)             _EMU_##REG##_ADDR
    #define EMU_RGET(REG)                                                 \
    _PER_RGET(_EMU_##REG##_ADDR, EMU, ##REG)
    #define EMU_RSET(REG, x)                                              \
    _PER_RSET(_EMU_##REG##_ADDR, EMU, ##REG, x)
  #define EMU_FGET(REG, FLD)        _EMU_##REG##_FGET(##FLD)
  #define EMU_FSET(REG, FLD, x)     _EMU_##REG##_FSET(##FLD, x)
    #define EMU_FSETS(REG, FLD, SYM)                                      \
    _EMU_##REG##_FSETS(##FLD, ##SYM)

  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */
  #define EMU_RGETA(addr, REG)      _PER_RGET(addr, EMU, ##REG)
  #define EMU_RSETA(addr, REG, x)   _PER_RSET(addr, EMU, ##REG,x)
    #define EMU_FGETA(addr, REG, FLD)                                     \
    _PER_FGET(addr, EMU, ##REG,##FLD)
    #define EMU_FSETA(addr, REG, FLD, x)                                  \
    _PER_FSET(addr, EMU, ##REG, ##FLD, x)
    #define EMU_FSETSA(addr, REG, FLD, SYM)                               \
    _PER_FSETS(addr, EMU, ##REG, ##FLD, ##SYM)

  /* ----------------------------------------- */
  /* HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */
    #define EMU_ADDRH(h, REG)                                             \
    ((void *)(&(((EMU_PrivateObj *)h)->baseAddr[_EMU_##REG##_OFFSET])))
    #define EMU_RGETH(h, REG)                                             \
    EMU_RGETA(EMU_ADDRH(h, ##REG), ##REG)
    #define EMU_RSETH(h, REG, x)                                          \
    EMU_RSETA(EMU_ADDRH(h, ##REG), ##REG, x)
    #define EMU_FGETH(h, REG, FIELD)                                      \
    EMU_FGETA(EMU_ADDRH(h, ##REG), ##REG, ##FIELD)
    #define EMU_FSETH(h, REG, FIELD,x)                                    \
    EMU_FSETA(EMU_ADDRH(h, ##REG), ##REG, ##FIELD, x)
    #define EMU_FSETSH(h, REG, FIELD, SYM)                                \
    EMU_FSETSA(EMU_ADDRH(h, ##REG), ##REG, ##FIELD, ##SYM)


/**************************************************************************\
*
* _____________________
* |                   |
* |   D B G S T A T   |
* |___________________|
*
* DBGSTAT - DBGSTAT {Debug Status Register}
*
* FIELDS (msb -> lsb)
*     (r)     DBGMST          Read MFREG0:DBGM state
*     (r)     EALLOWST        Read MFREG0:EALLOW state
\**************************************************************************/

  #define _EMU_DBGSTAT_ADDR         (0x01BC0000)
  #define _EMU_DBGSTAT              (*(Uint32 *)_EMU_DBGSTAT_ADDR)

  #define _EMU_DBGSTAT_DBGMST_MASK  (0x00020000u)
  #define _EMU_DBGSTAT_DBGMST_SHIFT (0x00000011u)

  #define EMU_DBGSTAT_DBGMST_OF(x)  _VALUEOF(x)

    #define _EMU_DBGSTAT_EALLOWST_MASK                                    \
    (0x00010000u)
    #define _EMU_DBGSTAT_EALLOWST_SHIFT                                   \
    (0x00000010u)
    #define EMU_DBGSTAT_EALLOWST_OF(x)                                    \
    _VALUEOF(x)

  #define EMU_DBGSTAT_OF(x)         _VALUEOF(x)


    #define _EMU_DBGSTAT_FGET(FLD)                                        \
    _PER_FGET(_EMU_DBGSTAT_ADDR, EMU, DBGSTAT, ##FLD)
    #define _EMU_DBGSTAT_FSET(FLD, f)                                     \
    _PER_FSET(_EMU_DBGSTAT_ADDR, EMU, DBGSTAT, ##FLD,f)
    #define _EMU_DBGSTAT_FSETS(FLD, SYM)                                  \
    _PER_FSETS(_EMU_DBGSTAT_ADDR, EMU, DBGSTAT, ##FLD, ##SYM)


/**************************************************************************\
*
* _____________________
* |                   |
* |    M F R E G 0    |
* |___________________|
*
* MFREG0 - MFREG0 {Miscellaneous Function Register}
*
* FIELDS (msb -> lsb)
*     (w)     DBGMLD          Load qualifier for the DBGM bit
*     (w)     DBGM            Set a mask to inhibit debug access
*     (w)     ABRTILD         Load qualifier for the ABORTI bit
*     (w)     ABRTI           set the bit to ABORT a lost ISR
*     (w)     EALLOWLD        Load qualifier for the EALLOW bit
*     (w)     EALLOW          Set the bit to allow Emulation access
\**************************************************************************/

  #define _EMU_MFREG0_ADDR          (0x01BC0014)
  #define _EMU_MFREG0               (*(Uint32 *)_EMU_MFREG0_ADDR)

  #define _EMU_MFREG0_DBGMLD_MASK   (0x08000000u)
  #define _EMU_MFREG0_DBGMLD_SHIFT  (0x0000001Bu)
  #define EMU_MFREG0_DBGMLD_OF(x)   _VALUEOF(x)

  #define _EMU_MFREG0_DBGM_MASK     (0x04000000u)
  #define _EMU_MFREG0_DBGM_SHIFT    (0x0000001Au)
  #define EMU_MFREG0_DBGM_OF(x)     _VALUEOF(x)

  #define _EMU_MFREG0_ABRTILD_MASK  (0x00040000u)
  #define _EMU_MFREG0_ABRTILD_SHIFT (0x00000012u)
  #define EMU_MFREG0_ABRTILD_OF(x)  _VALUEOF(x)

  #define _EMU_MFREG0_ABRTI_MASK    (0x00020000u)
  #define _EMU_MFREG0_ABRTI_SHIFT   (0x00000011u)
  #define EMU_MFREG0_ABRTI_OF(x)    _VALUEOF(x)

  #define _EMU_MFREG0_EALLOWLD_MASK (0x00004000u)
    #define _EMU_MFREG0_EALLOWLD_SHIFT                                    \
    (0x0000000Eu)
  #define EMU_MFREG0_EALLOWLD_OF(x) _VALUEOF(x)

  #define _EMU_MFREG0_EALLOW_MASK   (0x00002000u)
  #define _EMU_MFREG0_EALLOW_SHIFT  (0x0000000Du)
  #define EMU_MFREG0_EALLOW_OF(x)   _VALUEOF(x)

  #define EMU_MFREG0_OF(x)          _VALUEOF(x)

  #define EMU_MFREG0_RMK(dbgmld, dbgm, abrtild, abrti, eallowld, eallow) ((Uint32)    (\
                  _PER_FMK(EMU, MFREG0, DBGMLD, dbgmld)                   \
                |_PER_FMK(EMU, MFREG0, DBGM, dbgm)                        \
                |_PER_FMK(EMU, MFREG0, ABRTILD, abrtild)                  \
                |_PER_FMK(EMU, MFREG0, ABRTI, abrti)                      \
                |_PER_FMK(EMU, MFREG0, EALLOWLD, eallowld)                \
                |_PER_FMK(EMU, MFREG0, EALLOW, eallow)                    \
        )                                                                 \
  )

    #define _EMU_MFREG0_FGET(FLD)                                         \
    _PER_FGET(_EMU_MFREG0_ADDR, EMU, MFREG0, ##FLD)
    #define _EMU_MFREG0_FSET(FLD, f)                                      \
    _PER_FSET(_EMU_MFREG0_ADDR, EMU, MFREG0, ##FLD,f)
    #define _EMU_MFREG0_FSETS(FLD, SYM)                                   \
    _PER_FSETS(_EMU_MFREG0_ADDR, EMU, MFREG0, ##FLD, ##SYM)



#endif /* (EMU_SUPPORT) */
#endif /* _CSL_EMUHAL_H_ */

/**************************************************************************\
* End of csl_emuhal.h
\**************************************************************************/

csl_gpio.h/     1076583462  0     0     0       13952     `
/******************************************************************************\
*         Copyright (C) 2000-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_gpio.h
* DATE CREATED.. 12/04/2000 
* LAST MODIFIED. 05/09/2001
\******************************************************************************/

#ifndef _CSL_GPIO_H_
#define _CSL_GPIO_H_

#include <csl_stdinc.h>
#include <csl_chip.h>
#include <csl_irq.h>
#include "csl_gpiohal.h"


#if (GPIO_SUPPORT)
/******************************************************************************\
*     scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far 
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _GPIO_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/******************************************************************************\
*       global macro declarations
\******************************************************************************/

/* Macro define devices */
#define GPIO_DEV0          0
#if CHIP_DA610
#define GPIO_DEV1          1
#endif

/* misc global settings */
#define GPIO_INT_CNT       5
#define GPIO_PIN_CNT      32
#define GPIO_OPEN_RESET    1


/* Pin id definitions */
#define GPIO_PIN0          0x00000001u
#define GPIO_PIN1          0x00000002u
#define GPIO_PIN2          0x00000004u
#define GPIO_PIN3          0x00000008u
#define GPIO_PIN4          0x00000010u
#define GPIO_PIN5          0x00000020u
#define GPIO_PIN6          0x00000040u
#define GPIO_PIN7          0x00000080u
#define GPIO_PIN8          0x00000100u
#define GPIO_PIN9          0x00000200u
#define GPIO_PIN10         0x00000400u
#define GPIO_PIN11         0x00000800u
#define GPIO_PIN12         0x00001000u
#define GPIO_PIN13         0x00002000u
#define GPIO_PIN14         0x00004000u
#define GPIO_PIN15         0x00008000u
#define GPIO_PIN16         0x00010000u
#define GPIO_PIN17         0x00020000u
#define GPIO_PIN18         0x00040000u
#define GPIO_PIN19         0x00080000u
#define GPIO_PIN20         0x00100000u
#define GPIO_PIN21         0x00200000u
#define GPIO_PIN22         0x00400000u
#define GPIO_PIN23         0x00800000u
#define GPIO_PIN24         0x01000000u
#define GPIO_PIN25         0x02000000u
#define GPIO_PIN26         0x04000000u
#define GPIO_PIN27         0x08000000u
#define GPIO_PIN28         0x10000000u
#define GPIO_PIN29         0x20000000u
#define GPIO_PIN30         0x40000000u
#define GPIO_PIN31         0x80000000u

/* CPU Interrupt Pins for GPIO0 only */

#define GPIO_GPINT0        0
#define GPIO_GPINT4        1
#define GPIO_GPINT5        2
#define GPIO_GPINT6        3
#define GPIO_GPINT7        4

/* Interrupt Polarity */
#define GPIO_RISING     0
#define GPIO_FALLING    1

/* Pin  Direction */
#define GPIO_INPUT         0
#define GPIO_OUTPUT        1

/* GPIO masks */
#define GPIO_MASK_NA       0x00000000u
#define GPIO_MASK_00       0x00000001u
#define GPIO_MASK_01       0x00000002u
#define GPIO_MASK_02       0x00000004u
#define GPIO_MASK_03       0x00000008u
#define GPIO_MASK_04       0x00000010u
#define GPIO_MASK_05       0x00000020u
#define GPIO_MASK_06       0x00000040u
#define GPIO_MASK_07       0x00000080u
#define GPIO_MASK_08       0x00000100u
#define GPIO_MASK_09       0x00000200u
#define GPIO_MASK_10       0x00000400u
#define GPIO_MASK_11       0x00000800u
#define GPIO_MASK_12       0x00001000u
#define GPIO_MASK_13       0x00002000u
#define GPIO_MASK_14       0x00004000u
#define GPIO_MASK_15       0x00008000u

/*****************************************************************************\
*       global typedef declarations
\******************************************************************************/
  typedef struct {
   Uint32 gpgc;
   Uint32 gpen;
   Uint32 gpdir;
   Uint32 gpval;
   Uint32 gphm;
   Uint32 gplm;   
   Uint32 gppol;
  } GPIO_Config;

/* device handle object */
typedef struct {
  Uint32 allocated;
  volatile Uint32 *baseAddr;
  Uint32 pinAllocMask;
} GPIO_Obj, *GPIO_Handle;


/******************************************************************************\
*       global variable declarations
\******************************************************************************/
//extern far Uint32 _GPIO_pinTable[GPIO_PIN_CNT];
extern far Uint32 _GPIO_intTable[GPIO_INT_CNT];
extern far GPIO_Handle _hGpioDev0;

/******************************************************************************\
*      global function declarations
\******************************************************************************/

/* private functions */
/* API functions (Non-Inline function : Source file) */
CSLAPI GPIO_Handle GPIO_open(int devnum, Uint32 flags);
CSLAPI void GPIO_close(GPIO_Handle hGpio);
CSLAPI void GPIO_reset(GPIO_Handle hGpio);
CSLAPI void GPIO_clear(GPIO_Handle hGpio);


/******************************************************************************\
*       inline function declarations
\******************************************************************************/
/* configuration */

IDECL void GPIO_config(GPIO_Handle hGpio, GPIO_Config *config);
IDECL void GPIO_configArgs(GPIO_Handle hGpio,Uint32 gpgc,Uint32 gpen, Uint32 gpdir,Uint32 gpval, 
                  Uint32 gphm, Uint32 gplm, Uint32 gppol);
IDECL void GPIO_getConfig(GPIO_Handle hGpio, GPIO_Config *config);


IDECL void GPIO_pinDisable(GPIO_Handle hGpio, Uint32 pinId);
IDECL void GPIO_pinEnable(GPIO_Handle hGpio,Uint32 pinId);

IDECL Uint32 GPIO_pinDirection(GPIO_Handle hGpio, Uint32 pinId, Uint32 direction);
IDECL Uint32 GPIO_pinRead(GPIO_Handle hGpio,Uint32 pinId);
IDECL Uint32 GPIO_read(GPIO_Handle hGpio, Uint32 pinMask);


/* For output Pins */
IDECL void GPIO_pinWrite(GPIO_Handle hGpio,Uint32 pinId, Uint32 val);
IDECL void GPIO_write(GPIO_Handle hGpio, Uint32 pinMask, Uint32 val);


/* For input Pins */
IDECL Uint32 GPIO_deltaHighGet(GPIO_Handle hGpio,Uint32 pinId);
IDECL void GPIO_deltaHighClear(GPIO_Handle hGpio,Uint32 pinId);
IDECL Uint32 GPIO_deltaLowGet(GPIO_Handle hGpio,Uint32 pinId);
IDECL void GPIO_deltaLowClear(GPIO_Handle hGpio,Uint32 pinId);

IDECL void GPIO_maskHighSet(GPIO_Handle hGpio,Uint32 pinId);
IDECL void GPIO_maskHighClear(GPIO_Handle hGpio,Uint32 pinId);
IDECL void GPIO_maskLowSet(GPIO_Handle hGpio,Uint32 pinId);
IDECL void GPIO_maskLowClear(GPIO_Handle hGpio,Uint32 pinId);


/* Pass Through Mode */
IDECL Uint32 GPIO_intPolarity(GPIO_Handle hGpio,Uint32 signal, Uint32 polarity);


/******************************************************************************\
*       inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void GPIO_pinEnable(GPIO_Handle hGpio,Uint32 pinId) {
  Uint32 gpen = GPIO_RGETH(hGpio,GPEN);
  gpen = gpen | (pinId & hGpio->pinAllocMask);
  GPIO_FSETH(hGpio,GPEN,GPXEN,gpen);
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_pinDisable(GPIO_Handle hGpio,Uint32 pinId) {
  Uint32 gpen = GPIO_RGETH(hGpio,GPEN);
  gpen = gpen & (~pinId & hGpio->pinAllocMask);
  GPIO_FSETH(hGpio,GPEN,GPXEN,gpen);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 GPIO_pinDirection(GPIO_Handle hGpio,Uint32 pinId, Uint32 direction) {
  Uint32 gpdir = GPIO_RGETH(hGpio,GPDIR);
  if ( direction == 0) {
       GPIO_RSETH(hGpio,GPDIR,(gpdir & (~pinId & hGpio->pinAllocMask)));
  } else {
       GPIO_RSETH(hGpio,GPDIR,(gpdir | (pinId & hGpio->pinAllocMask)));
    }
  return ( GPIO_RGETH(hGpio,GPDIR));

}
/*----------------------------------------------------------------------------*/
IDEF Uint32 GPIO_pinRead(GPIO_Handle hGpio,Uint32 pinId) {
Uint32 x = 0xFFFFFFFF;

      if ( (GPIO_RGETH(hGpio,GPVAL) & (pinId & hGpio->pinAllocMask))!= 0 ) { 
           x = 1;
      } else {
           x = 0;
        }
  
 return ( x );
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 GPIO_read(GPIO_Handle hGpio, Uint32 pinMask)
{
    return ((GPIO_RGETH(hGpio,GPVAL) & pinMask) & hGpio->pinAllocMask);
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_pinWrite(GPIO_Handle hGpio,Uint32 pinId, Uint32 val) {
 Uint32 gpval = GPIO_RGETH(hGpio,GPVAL);
 if ( val == 0) {
     GPIO_RSETH(hGpio,GPVAL,(gpval & (~pinId  & hGpio->pinAllocMask)));
  } else {
     GPIO_RSETH(hGpio,GPVAL,(gpval | (pinId  & hGpio->pinAllocMask)));
  }

}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_write(GPIO_Handle hGpio, Uint32 pinMask, Uint32 val)
{
    Uint32 gpval = GPIO_RGETH(hGpio,GPVAL);
    GPIO_RSETH(hGpio,GPVAL, ((gpval & ~pinMask) | (pinMask & val)));
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 GPIO_deltaHighGet(GPIO_Handle hGpio,Uint32 pinId) {
  return (GPIO_FGETH(hGpio,GPDH,GPXDH)& (pinId & hGpio->pinAllocMask));
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_deltaHighClear(GPIO_Handle hGpio,Uint32 pinId) {
  Uint32 gpdh= GPIO_RGETH(hGpio,GPDH); 
  GPIO_FSETH(hGpio,GPDH,GPXDH,(gpdh & (pinId & hGpio->pinAllocMask)));

}
/*----------------------------------------------------------------------------*/
 IDEF Uint32 GPIO_deltaLowGet(GPIO_Handle hGpio,Uint32 pinId) {
  return (GPIO_FGETH(hGpio,GPDL,GPXDL)& (pinId & hGpio->pinAllocMask));
}
/*----------------------------------------------------------------------------*/ 
 IDEF void GPIO_deltaLowClear(GPIO_Handle hGpio,Uint32 pinId) {
  Uint32 gpdl= GPIO_RGETH(hGpio,GPDL); 
  GPIO_FSETH(hGpio,GPDL,GPXDL,(gpdl & (pinId & hGpio->pinAllocMask)));
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_maskHighSet(GPIO_Handle hGpio,Uint32 pinId) {
  Uint32 gphm = GPIO_RGETH(hGpio,GPHM);
  GPIO_FSETH(hGpio,GPHM,GPXHM,(gphm | (pinId & hGpio->pinAllocMask)));
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_maskHighClear(GPIO_Handle hGpio,Uint32 pinId) {
  Uint32 gphm = GPIO_RGETH(hGpio,GPHM);
  GPIO_FSETH(hGpio,GPHM,GPXHM,(gphm & (~pinId & hGpio->pinAllocMask)));
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_maskLowSet(GPIO_Handle hGpio,Uint32 pinId) {
  Uint32 gplm = GPIO_RGETH(hGpio,GPLM);
  GPIO_FSETH(hGpio,GPLM,GPXLM,(gplm | (pinId & hGpio->pinAllocMask)));
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_maskLowClear(GPIO_Handle hGpio,Uint32 pinId) {
  Uint32 gplm = GPIO_RGETH(hGpio,GPLM);
  GPIO_FSETH(hGpio,GPLM,GPXLM,(gplm & (~pinId & hGpio->pinAllocMask)));
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 GPIO_intPolarity(GPIO_Handle hGpio,Uint32 signal, Uint32 polarity){
  Uint32 gppol = GPIO_RGETH(hGpio,GPPOL);
   if ( polarity == 0) {
     GPIO_FSETH(hGpio,GPPOL,GPINTXPOL,(gppol & ~_GPIO_intTable[signal]));
  } else {   
    GPIO_FSETH(hGpio,GPPOL,GPINTXPOL,(gppol | _GPIO_intTable[signal]));
    }
 return ( GPIO_RGETH(hGpio,GPPOL));
}   
/*----------------------------------------------------------------------------*/
IDEF void GPIO_config(GPIO_Handle hGpio,GPIO_Config *config) {
  Uint32 gie;
  register int x0,x1,x2,x3,x4,x5,x6;
  volatile Uint32 *base = (volatile Uint32 *)(hGpio->baseAddr);

  gie = IRQ_globalDisable();

  x0 = config->gpgc;
  x1 = config->gpen;
  x2 = config->gpdir;
  x3 = config->gpval;
  x4 = config->gphm;
  x5 = config->gplm;
  x6 = config->gppol;

  base[_GPIO_GPGC_OFFSET] = x0;
  base[_GPIO_GPEN_OFFSET] = x1;  
  base[_GPIO_GPDIR_OFFSET]= x2;
  base[_GPIO_GPVAL_OFFSET]= x3;
  base[_GPIO_GPHM_OFFSET] = x4;
  base[_GPIO_GPLM_OFFSET] = x5;
  base[_GPIO_GPPOL_OFFSET]= x6;

 IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_configArgs(GPIO_Handle hGpio, Uint32 gpgc,Uint32 gpen, Uint32 gpdir,Uint32 gpval,
                  Uint32 gphm, Uint32 gplm, Uint32 gppol) {
   Uint32 gie;
   volatile Uint32 *base = (volatile Uint32 *)(hGpio->baseAddr);

  gie = IRQ_globalDisable();

   base[_GPIO_GPGC_OFFSET] = gpgc;
   base[_GPIO_GPEN_OFFSET] = gpen;  
   base[_GPIO_GPDIR_OFFSET]= gpdir;
   base[_GPIO_GPVAL_OFFSET]= gpval;
   base[_GPIO_GPHM_OFFSET] = gphm;
   base[_GPIO_GPLM_OFFSET] = gplm;
   base[_GPIO_GPPOL_OFFSET]= gppol ;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void GPIO_getConfig(GPIO_Handle hGpio,GPIO_Config *config) {
  Uint32 gie;
  register int x0,x1,x2,x3,x4,x5,x6;
   volatile Uint32 *base = (volatile Uint32 *)(hGpio->baseAddr);

  gie = IRQ_globalDisable();
  
  x0 = base[_GPIO_GPGC_OFFSET];
  x1 = base[_GPIO_GPEN_OFFSET];  
  x2 = base[_GPIO_GPDIR_OFFSET];
  x3 = base[_GPIO_GPVAL_OFFSET];
  x4 = base[_GPIO_GPHM_OFFSET];
  x5 = base[_GPIO_GPLM_OFFSET];
  x6 = base[_GPIO_GPPOL_OFFSET];
  
  config->gpgc  = x0;
  config->gpen  = x1;
  config->gpdir = x2;
  config->gpval = x3;
  config->gphm  = x4;
  config->gplm  = x5;
  config->gppol = x6;

  IRQ_globalRestore(gie);
}
/*---------------------------------------------------------------------------*/

#endif /* USEDEFS */


#endif /* GPIO_SUPPORT */

#endif /* _CSL_GPIO_H_ */
/******************************************************************************\
* End of csl_gpio.h
\******************************************************************************/
csl_gpiohal.h/  1056024095  0     0     0       35294     `
/******************************************************************************\
*      Copyright (C) 2000-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_gpiohal.h
* DATE CREATED.. 12/04/2000 
* LAST MODIFIED. 06/17/2003   - Added support for 6712C
*                06/09/2003   - Added support for 6711C
*                10/02/2001   - GPIO1 implementation
*                      
*------------------------------------------------------------------------------
* REGISTERS
*
* GPENx    - GPIO Enable register
* GPDIRx   - GPIO Direction register 
* GPVALx   - GPIO Value register 
* GPDHx   -  GPIO Delta High register 
* GPHMx    - GPIO High Mask register 
* GPDLx    - GPIO Delta Low register 
* GPLMx    - GPIO Low Mask register 
* GPGCx    - GPIO Global Control register 
* GPPOLx   - GPIO Interrupt Polarity register 
*
* with x = {0,1} 
\******************************************************************************/
#ifndef _CSL_GPIOHAL_H_
#define _CSL_GPIOHAL_H_

#include <csl_stdinchal.h>
#include <csl_chip.h>

#if (GPIO_SUPPORT)
/******************************************************************************\
*  MISC section 
\******************************************************************************/

#define _GPIO_BASE_ADDR    0x01B00000u 
#define _GPIO_BASE_ADDR0   0x01B00000u
#if (CHIP_DA610)
#define _GPIO_BASE_ADDR1   0x01B04000u
#endif

/******************************************************************************\
*  Module level register/field access macros
\******************************************************************************/

  /* -------------------------- */
  /*  FIELD MAKE MACROS */
  /* -------------------------- */

  #define GPIO_FMK(REG,FIELD,x)\
    _PER_FMK(GPIO,##REG,##FIELD,x)

  #define GPIO_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(GPIO,##REG,##FIELD,##SYM)
 
 
  /* ----------------------------------------- */
  /*  RAW REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define GPIO_ADDR(REG)\
    _GPIO_##REG##_ADDR

  #define GPIO_RGET(REG)\
    _PER_RGET(_GPIO_##REG##_ADDR,GPIO,##REG)

  #define GPIO_RSET(REG,x)\
    _PER_RSET(_GPIO_##REG##_ADDR,GPIO,##REG,x)

  #define GPIO_FGET(REG,FIELD)\
    _GPIO_##REG##_FGET(##FIELD)

  #define GPIO_FSET(REG,FIELD,x)\
    _GPIO_##REG##_FSET(##FIELD,##x)

  #define GPIO_FSETS(REG,FIELD,SYM)\
    _GPIO_##REG##_FSETS(##FIELD,##SYM)
 
 
  /* --------------------------------------------------- */
  /*  ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* --------------------------------------------------- */

  #define GPIO_RGETA(addr,REG)\
    _PER_RGET(addr,GPIO,##REG)

  #define GPIO_RSETA(addr,REG,x)\
    _PER_RSET(addr,GPIO,##REG,x)

  #define GPIO_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,GPIO,##REG,##FIELD)

  #define GPIO_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,GPIO,##REG,##FIELD,x)

  #define GPIO_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,GPIO,##REG,##FIELD,##SYM)

  /* -------------------------------------------------- */
  /*  HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------------------------- */


  #define GPIO_ADDRH(h,REG)\
    (Uint32)(&((h)->baseAddr[_GPIO_##REG##_OFFSET]))

  #define GPIO_RGETH(h,REG)\
    GPIO_RGETA(GPIO_ADDRH(h,##REG),##REG)


  #define GPIO_RSETH(h,REG,x)\
    GPIO_RSETA(GPIO_ADDRH(h,##REG),##REG,x)


  #define GPIO_FGETH(h,REG,FIELD)\
    GPIO_FGETA(GPIO_ADDRH(h,##REG),##REG,##FIELD)


  #define GPIO_FSETH(h,REG,FIELD,x)\
    GPIO_FSETA(GPIO_ADDRH(h,##REG),##REG,##FIELD,x)


  #define GPIO_FSETSH(h,REG,FIELD,SYM)\
    GPIO_FSETSA(GPIO_ADDRH(h,##REG),##REG,##FIELD,##SYM)




/******************************************************************************\
* _____________________
* |                   |
* |     G P E N       |
* |___________________|
*
* GPEN  - GPIO Enable register
*
* FIELDS (msb -> lsb)
* (rw)  GPXEN  
*
\******************************************************************************/
  #define _GPIO_GPEN_OFFSET              0

  #define _GPIO_GPEN_ADDR                0x01B00000u

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPEN_GPXEN_MASK          0x000000F4u
#else
  #define _GPIO_GPEN_GPXEN_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPEN_GPXEN_SHIFT         0x00000000u

#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
  #define  GPIO_GPEN_GPXEN_DEFAULT       0x000000F0u
#else
  #define  GPIO_GPEN_GPXEN_DEFAULT       0x000000F9u
#endif

  #define  GPIO_GPEN_GPXEN_OF(x)         _VALUEOF(x)

  #define  GPIO_GPEN_OF(x)               _VALUEOF(x)

  #define GPIO_GPEN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPEN,GPXEN)\
  )

  #define GPIO_GPEN_RMK(gpxen) (Uint32)( \
     _PER_FMK(GPIO,GPEN,GPXEN,gpxen)\
  )

  #define _GPIO_GPEN_FGET(FIELD)\
    _PER_FGET(_GPIO_GPEN_ADDR,GPIO,GPEN,##FIELD)

  #define _GPIO_GPEN_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPEN_ADDR,GPIO,GPEN,##FIELD,field)

  #define _GPIO_GPEN_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPEN_ADDR,GPIO,GPEN,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |     G P D I R     |
* |___________________|
*
* GPDIR  - GPIO Direction register
*
* FIELDS (msb -> lsb)
* (rw)  GPXDIR  
*
\******************************************************************************/
  #define _GPIO_GPDIR_OFFSET               1

  #define _GPIO_GPDIR_ADDR                 0x01B00004u

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPDIR_GPXDIR_MASK          0x000000F4u
#else
  #define _GPIO_GPDIR_GPXDIR_MASK          0x0000FFFFu
#endif
  
  #define _GPIO_GPDIR_GPXDIR_SHIFT         0x00000000u
  #define  GPIO_GPDIR_GPXDIR_DEFAULT       0x00000000u
  #define  GPIO_GPDIR_GPXDIR_OF(x)         _VALUEOF(x)

  #define  GPIO_GPDIR_OF(x)               _VALUEOF(x)

  #define GPIO_GPDIR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPDIR,GPXDIR)\
  )

  #define GPIO_GPDIR_RMK(gpxdir) (Uint32)( \
     _PER_FMK(GPIO,GPDIR,GPXDIR,gpxdir)\
  )

  #define _GPIO_GPDIR_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDIR_ADDR,GPIO,GPDIR,##FIELD)

  #define _GPIO_GPDIR_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDIR_ADDR,GPIO,GPDIR,##FIELD,field)

  #define _GPIO_GPDIR_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDIR_ADDR,GPIO,GPDIR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |     G P V A L     |
* |___________________|
*
* GPVAL  - GPIO Value register
*
* FIELDS (msb -> lsb)
* (rw)  GPXVAL  
*
\******************************************************************************/
  #define _GPIO_GPVAL_OFFSET               2

  #define _GPIO_GPVAL_ADDR                 0x01B00008u

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPVAL_GPXVAL_MASK          0x000000F4u
#else
  #define _GPIO_GPVAL_GPXVAL_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPVAL_GPXVAL_SHIFT         0x00000000u
  #define  GPIO_GPVAL_GPXVAL_DEFAULT       0x00000000u
  #define  GPIO_GPVAL_GPXVAL_OF(x)         _VALUEOF(x)

  #define  GPIO_GPVAL_OF(x)               _VALUEOF(x)

  #define GPIO_GPVAL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPVAL,GPXVAL)\
  )

  #define GPIO_GPVAL_RMK(gpxval) (Uint32)( \
     _PER_FMK(GPIO,GPVAL,GPXVAL,gpxval)\
  )

  #define _GPIO_GPVAL_FGET(FIELD)\
    _PER_FGET(_GPIO_GPVAL_ADDR,GPIO,GPVAL,##FIELD)

  #define _GPIO_GPVAL_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPVAL_ADDR,GPIO,GPVAL,##FIELD,field)

  #define _GPIO_GPVAL_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPVAL_ADDR,GPIO,GPVAL,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |     G P D H       |
* |___________________|
*
* GPDH  - GPIO Delta High register
*
* FIELDS (msb -> lsb)
* (rw)  GPXDH  
*
\******************************************************************************/
  #define _GPIO_GPDH_OFFSET              4

  #define _GPIO_GPDH_ADDR                0x01B00010u

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPDH_GPXDH_MASK          0x000000F4u
#else
  #define _GPIO_GPDH_GPXDH_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPDH_GPXDH_SHIFT         0x00000000u
  #define  GPIO_GPDH_GPXDH_DEFAULT       0x00000000u
  #define  GPIO_GPDH_GPXDH_OF(x)         _VALUEOF(x)

  #define  GPIO_GPDH_OF(x)               _VALUEOF(x)

  #define GPIO_GPDH_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPDH,GPXDH)\
  )

  #define GPIO_GPDH_RMK(gpxdh) (Uint32)( \
     _PER_FMK(GPIO,GPDH,GPXDH,gpxdh)\
  )

  #define _GPIO_GPDH_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDH_ADDR,GPIO,GPDH,##FIELD)

  #define _GPIO_GPDH_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDH_ADDR,GPIO,GPDH,##FIELD,field)

  #define _GPIO_GPDH_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDH_ADDR,GPIO,GPDH,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |     G P H M       |
* |___________________|
*
* GPHM  - GPIO High Mask register
*
* FIELDS (msb -> lsb)
* (rw)  GPXHM  
*
\******************************************************************************/
  #define _GPIO_GPHM_OFFSET              5

  #define _GPIO_GPHM_ADDR              0x01B00014u

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPHM_GPXHM_MASK          0x000000F4u
#else
  #define _GPIO_GPHM_GPXHM_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPHM_GPXHM_SHIFT         0x00000000u
  #define  GPIO_GPHM_GPXHM_DEFAULT       0x00000000u
  #define  GPIO_GPHM_GPXHM_OF(x)         _VALUEOF(x)

  #define  GPIO_GPHM_OF(x)               _VALUEOF(x)

  #define GPIO_GPHM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPHM,GPXHM)\
  )

  #define GPIO_GPHM_RMK(gpxhm) (Uint32)( \
     _PER_FMK(GPIO,GPHM,GPXHM,gpxhm)\
  )

  #define _GPIO_GPHM_FGET(FIELD)\
    _PER_FGET(_GPIO_GPHM_ADDR,GPIO,GPHM,##FIELD)

  #define _GPIO_GPHM_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPHM_ADDR,GPIO,GPHM,##FIELD,field)

  #define _GPIO_GPHM_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPHM_ADDR,GPIO,GPHM,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |     G P D L       |
* |___________________|
*
* GPDL  - GPIO Delta Low register
*
* FIELDS (msb -> lsb)
* (rw)  GPXDL  
*
\******************************************************************************/
  #define _GPIO_GPDL_OFFSET              6

  #define _GPIO_GPDL_ADDR                0x01B00018u

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPDL_GPXDL_MASK          0x000000F4u
#else
  #define _GPIO_GPDL_GPXDL_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPDL_GPXDL_SHIFT         0x00000000u
  #define  GPIO_GPDL_GPXDL_DEFAULT       0x00000000u
  #define  GPIO_GPDL_GPXDL_OF(x)         _VALUEOF(x)

  #define  GPIO_GPDL_OF(x)               _VALUEOF(x)

  #define GPIO_GPDL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPDL,GPXDL)\
  )

  #define GPIO_GPDL_RMK(gpxdl) (Uint32)( \
     _PER_FMK(GPIO,GPDL,GPXDL,gpxdl)\
  )

  #define _GPIO_GPDL_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDL_ADDR,GPIO,GPDL,##FIELD)

  #define _GPIO_GPDL_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDL_ADDR,GPIO,GPDL,##FIELD,field)

  #define _GPIO_GPDL_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDL_ADDR,GPIO,GPDL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |     G P L M       |
* |___________________|
*
* GPLM  - GPIO Low Mask register
*
* FIELDS (msb -> lsb)
* (rw)  GPXLM  
*
\******************************************************************************/
  #define _GPIO_GPLM_OFFSET              7

  #define _GPIO_GPLM_ADDR                0x01B0001Cu

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPLM_GPXLM_MASK          0x000000F4u
#else
  #define _GPIO_GPLM_GPXLM_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPLM_GPXLM_SHIFT         0x00000000u
  #define  GPIO_GPLM_GPXLM_DEFAULT       0x00000000u
  #define  GPIO_GPLM_GPXLM_OF(x)         _VALUEOF(x)

  #define  GPIO_GPLM_OF(x)               _VALUEOF(x)

  #define GPIO_GPLM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPLM,GPXLM)\
  )

  #define GPIO_GPLM_RMK(gpxlm) (Uint32)( \
     _PER_FMK(GPIO,GPLM,GPXLM,gpxlm)\
  )

  #define _GPIO_GPLM_FGET(FIELD)\
    _PER_FGET(_GPIO_GPLM_ADDR,GPIO,GPLM,##FIELD)

  #define _GPIO_GPLM_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPLM_ADDR,GPIO,GPLM,##FIELD,field)

  #define _GPIO_GPLM_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPLM_ADDR,GPIO,GPLM,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |     G P G C       |
* |___________________|
*
* GPGC  - GPIO Global Control register
*
* FIELDS (msb -> lsb)
* (rw)  GP0M
* (rw)  GPINT0M
* (rw)  GPINTPOL
* (rw)  LOGIC
* (rw)  GPINTDV
*
\******************************************************************************/
  #define _GPIO_GPGC_OFFSET                8

  #define _GPIO_GPGC_ADDR                  0x01B00020u

  #define _GPIO_GPGC_GP0M_MASK             0x00000020u
  #define _GPIO_GPGC_GP0M_SHIFT            0x00000005u
  #define  GPIO_GPGC_GP0M_DEFAULT          0x00000000u
  #define  GPIO_GPGC_GP0M_OF(x)            _VALUEOF(x)
  #define  GPIO_GPGC_GP0M_GPIOMODE         0x00000000u
  #define  GPIO_GPGC_GP0M_LOGICMODE        0x00000001u
  
  #define _GPIO_GPGC_GPINT0M_MASK          0x00000010u
  #define _GPIO_GPGC_GPINT0M_SHIFT         0x00000004u
  #define  GPIO_GPGC_GPINT0M_DEFAULT       0x00000000u
  #define  GPIO_GPGC_GPINT0M_OF(x)         _VALUEOF(x)
  #define  GPIO_GPGC_GPINT0M_PASSMODE      0x00000000u
  #define  GPIO_GPGC_GPINT0M_LOGICMODE     0x00000001u

  #define _GPIO_GPGC_GPINTPOL_MASK         0x00000004u
  #define _GPIO_GPGC_GPINTPOL_SHIFT        0x00000002u
  #define  GPIO_GPGC_GPINTPOL_DEFAULT      0x00000000u
  #define  GPIO_GPGC_GPINTPOL_OF(x)        _VALUEOF(x)
  #define  GPIO_GPGC_GPINTPOL_LOGICTRUE    0x00000000u
  #define  GPIO_GPGC_GPINTPOL_LOGICFALSE   0x00000001u

  #define _GPIO_GPGC_LOGIC_MASK            0x00000002u
  #define _GPIO_GPGC_LOGIC_SHIFT           0x00000001u
  #define  GPIO_GPGC_LOGIC_DEFAULT         0x00000000u
  #define  GPIO_GPGC_LOGIC_OF(x)           _VALUEOF(x)
  #define  GPIO_GPGC_LOGIC_ORMODE          0x00000000u
  #define  GPIO_GPGC_LOGIC_ANDMODE         0x00000001u

  #define _GPIO_GPGC_GPINTDV_MASK          0x00000001u
  #define _GPIO_GPGC_GPINTDV_SHIFT         0x00000000u
  #define  GPIO_GPGC_GPINTDV_DEFAULT       0x00000000u
  #define  GPIO_GPGC_GPINTDV_OF(x)         _VALUEOF(x)
  #define  GPIO_GPGC_GPINTDV_DELTAMODE     0x00000000u
  #define  GPIO_GPGC_GPINTDV_VALUEMODE     0x00000001u

  #define  GPIO_GPGC_OF(x)                 _VALUEOF(x)

  #define GPIO_GPGC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPGC,GP0M)\
    |_PER_FDEFAULT(GPIO,GPGC,GPINT0M)\
    |_PER_FDEFAULT(GPIO,GPGC,GPINTPOL)\
    |_PER_FDEFAULT(GPIO,GPGC,LOGIC)\
    |_PER_FDEFAULT(GPIO,GPGC,GPINTDV)\
  )

  #define GPIO_GPGC_RMK(gp0m,gpint0m,gpintpol,logic,gpintdv) (Uint32)( \
     _PER_FMK(GPIO,GPGC,GP0M,gp0m)\
    |_PER_FMK(GPIO,GPGC,GPINT0M,gpint0m)\
    |_PER_FMK(GPIO,GPGC,GPINTPOL,gpintpol)\
    |_PER_FMK(GPIO,GPGC,LOGIC,logic)\
    |_PER_FMK(GPIO,GPGC,GPINTDV,gpintdv)\
  )

  #define _GPIO_GPGC_FGET(FIELD)\
    _PER_FGET(_GPIO_GPGC_ADDR,GPIO,GPGC,##FIELD)

  #define _GPIO_GPGC_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPGC_ADDR,GPIO,GPGC,##FIELD,field)

  #define _GPIO_GPGC_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPGC_ADDR,GPIO,GPGC,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |     G P P O L     |
* |___________________|
*
* GPPOL  - GPIO Interrupt Polarity register
*
* FIELDS (msb -> lsb)
* (rw)  GPINTXPOL  
*
\******************************************************************************/
  #define _GPIO_GPPOL_OFFSET                  9

  #define _GPIO_GPPOL_ADDR                    0x01B00024u

  #define _GPIO_GPPOL_GPINTXPOL_MASK          0x000000F9u
  #define _GPIO_GPPOL_GPINTXPOL_SHIFT         0x00000000u
  #define  GPIO_GPPOL_GPINTXPOL_DEFAULT       0x00000000u
  #define  GPIO_GPPOL_GPINTXPOL_OF(x)         _VALUEOF(x)

  #define  GPIO_GPPOL_OF(x)                   _VALUEOF(x)
  
  #define GPIO_GPPOL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPPOL,GPINTXPOL)\
  )

  #define GPIO_GPPOL_RMK(gpintxpol) (Uint32)( \
     _PER_FMK(GPIO,GPPOL,GPINTXPOL,gpintxpol)\
  )

  #define _GPIO_GPPOL_FGET(FIELD)\
    _PER_FGET(_GPIO_GPPOL_ADDR,GPIO,GPPOL,##FIELD)  /* bug fixed pn 10/02/2001 */

  #define _GPIO_GPPOL_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPPOL_ADDR,GPIO,GPPOL,##FIELD,field)

  #define _GPIO_GPPOL_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPPOL_ADDR,GPIO,GPPOL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |     G P E N       |
* |___________________|
*
* GPEN0  - GPIO0 Enable register
* GPEN1  - GPIO1 Enable register
*
* FIELDS (msb -> lsb)
* (rw)  GPXEN  
*
\******************************************************************************/
  #define _GPIO_GPEN0_OFFSET              0
#if (CHIP_DA610)
  #define _GPIO_GPEN1_OFFSET              0
#endif

  #define _GPIO_GPEN0_ADDR               0x01B00000u
#if (CHIP_DA610)
  #define _GPIO_GPEN1_ADDR               0x01B04000u
#endif

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPEN_GPXEN_MASK          0x000000F4u
#else
  #define _GPIO_GPEN_GPXEN_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPEN_GPXEN_SHIFT         0x00000000u

#if (CHIP_6713 || CHIP_DA610 || CHIP_6711C || CHIP_6712C)
  #define  GPIO_GPEN_GPXEN_DEFAULT       0x000000F0u
#else
  #define  GPIO_GPEN_GPXEN_DEFAULT       0x000000F9u
#endif

  #define  GPIO_GPEN_GPXEN_OF(x)         _VALUEOF(x)

  #define  GPIO_GPEN_OF(x)               _VALUEOF(x)

  #define GPIO_GPEN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPEN,GPXEN)\
  )

  #define GPIO_GPEN_RMK(gpxen) (Uint32)( \
     _PER_FMK(GPIO,GPEN,GPXEN,gpxen)\
  )

  #define _GPIO_GPEN0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPEN0_ADDR,GPIO,GPEN,##FIELD)

#if (CHIP_DA610)
  #define _GPIO_GPEN1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPEN1_ADDR,GPIO,GPEN,##FIELD)
#endif

  #define _GPIO_GPEN0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPEN0_ADDR,GPIO,GPEN,##FIELD,field)

#if (CHIP_DA610)
  #define _GPIO_GPEN1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPEN1_ADDR,GPIO,GPEN,##FIELD,field)
#endif

  #define _GPIO_GPEN0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPEN0_ADDR,GPIO,GPEN,##FIELD,##SYM)

#if (CHIP_DA610)
  #define _GPIO_GPEN1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPEN1_ADDR,GPIO,GPEN,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |     G P D I R     |
* |___________________|
*
* GPDIR0  - GPIO0 Direction register
* GPDIR1  - GPIO1 Direction register
* FIELDS (msb -> lsb)
* (rw)  GPXDIR  
*
\******************************************************************************/
  #define _GPIO_GPDIR0_OFFSET               1
#if (CHIP_DA610)
  #define _GPIO_GPDIR1_OFFSET               1
#endif

  #define _GPIO_GPDIR0_ADDR                 0x01B00004u
#if (CHIP_DA610)
  #define _GPIO_GPDIR1_ADDR                 0x01B04004u
#endif

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPDIR_GPXDIR_MASK          0x000000F4u
#else
  #define _GPIO_GPDIR_GPXDIR_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPDIR_GPXDIR_SHIFT         0x00000000u
  #define  GPIO_GPDIR_GPXDIR_DEFAULT       0x00000000u
  #define  GPIO_GPDIR_GPXDIR_OF(x)         _VALUEOF(x)

  #define  GPIO_GPDIR_OF(x)               _VALUEOF(x)

  #define GPIO_GPDIR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPDIR,GPXDIR)\
  )

  #define GPIO_GPDIR_RMK(gpxdir) (Uint32)( \
     _PER_FMK(GPIO,GPDIR,GPXDIR,gpxdir)\
  )


  #define _GPIO_GPDIR0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDIR0_ADDR,GPIO,GPDIR,##FIELD)

#if (CHIP_DA610)
  #define _GPIO_GPDIR1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDIR1_ADDR,GPIO,GPDIR,##FIELD)
#endif

  #define _GPIO_GPDIR0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDIR0_ADDR,GPIO,GPDIR,##FIELD,field)

#if (CHIP_DA610)
  #define _GPIO_GPDIR1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDIR1_ADDR,GPIO,GPDIR,##FIELD,field)
#endif


  #define _GPIO_GPDIR0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDIR0_ADDR,GPIO,GPDIR,##FIELD,##SYM)
#if (CHIP_DA610)
  #define _GPIO_GPDIR1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDIR1_ADDR,GPIO,GPDIR,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |     G P V A L     |
* |___________________|
*
* GPVAL0  - GPIO0 Value register
* GPVAL1  - GPIO1 Value register
* FIELDS (msb -> lsb)
* (rw)  GPXVAL  
*
\******************************************************************************/
  #define _GPIO_GPVAL0_OFFSET               2
#if (CHIP_DA610)
  #define _GPIO_GPVAL1_OFFSET               2
#endif

  #define _GPIO_GPVAL0_ADDR                 0x01B00008u
#if (CHIP_DA610)
  #define _GPIO_GPVAL1_ADDR                 0x01B04008u
#endif

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPVAL_GPXVAL_MASK          0x000000F4u
#else
  #define _GPIO_GPVAL_GPXVAL_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPVAL_GPXVAL_SHIFT         0x00000000u
  #define  GPIO_GPVAL_GPXVAL_DEFAULT       0x00000000u
  #define  GPIO_GPVAL_GPXVAL_OF(x)         _VALUEOF(x)

  #define  GPIO_GPVAL_OF(x)               _VALUEOF(x)

  #define GPIO_GPVAL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPVAL,GPXVAL)\
  )

  #define GPIO_GPVAL_RMK(gpxval) (Uint32)( \
     _PER_FMK(GPIO,GPVAL,GPXVAL,gpxval)\
  )

  #define _GPIO_GPVAL0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPVAL0_ADDR,GPIO,GPVAL,##FIELD)
#if (CHIP_DA610)
  #define _GPIO_GPVAL1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPVAL1_ADDR,GPIO,GPVAL,##FIELD)
#endif

  #define _GPIO_GPVAL0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPVAL0_ADDR,GPIO,GPVAL,##FIELD,field)
#if (CHIP_DA610)
  #define _GPIO_GPVAL1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPVAL1_ADDR,GPIO,GPVAL,##FIELD,field)
#endif

  #define _GPIO_GPVAL0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPVAL0_ADDR,GPIO,GPVAL,##FIELD,##SYM)
#if (CHIP_DA610)
  #define _GPIO_GPVAL1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPVAL1_ADDR,GPIO,GPVAL,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |     G P D H       |
* |___________________|
*
* GPDH0  - GPIO0 Delta High register
* GPDH1  - GPIO1 Delta High register
* FIELDS (msb -> lsb)
* (rw)  GPXDH  
*
\******************************************************************************/
  #define _GPIO_GPDH0_OFFSET              4
#if (CHIP_DA610)
  #define _GPIO_GPDH1_OFFSET              4
#endif

  #define _GPIO_GPDH0_ADDR                0x01B04010u
#if (CHIP_DA610)
  #define _GPIO_GPDH1_ADDR                0x01B04010u
#endif

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPDH_GPXDH_MASK          0x000000F4u
#else
  #define _GPIO_GPDH_GPXDH_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPDH_GPXDH_SHIFT         0x00000000u
  #define  GPIO_GPDH_GPXDH_DEFAULT       0x00000000u
  #define  GPIO_GPDH_GPXDH_OF(x)         _VALUEOF(x)

  #define  GPIO_GPDH_OF(x)               _VALUEOF(x)

  #define GPIO_GPDH_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPDH,GPXDH)\
  )

  #define GPIO_GPDH_RMK(gpxdh) (Uint32)( \
     _PER_FMK(GPIO,GPDH,GPXDH,gpxdh)\
  )

  #define _GPIO_GPDH0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDH0_ADDR,GPIO,GPDH,##FIELD)
#if (CHIP_DA610)
  #define _GPIO_GPDH1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDH1_ADDR,GPIO,GPDH,##FIELD)
#endif

  #define _GPIO_GPDH0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDH0_ADDR,GPIO,GPDH,##FIELD,field)
#if (CHIP_DA610)
  #define _GPIO_GPDH1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDH1_ADDR,GPIO,GPDH,##FIELD,field)
#endif


  #define _GPIO_GPDH0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDH0_ADDR,GPIO,GPDH,##FIELD,##SYM)
#if (CHIP_DA610)
  #define _GPIO_GPDH1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDH1_ADDR,GPIO,GPDH,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |     G P H M       |
* |___________________|
*
* GPHM0  - GPIO0 High Mask register
* GPHM1  - GPIO1 High Mask register
* FIELDS (msb -> lsb)
* (rw)  GPXHM  
*
\******************************************************************************/
  #define _GPIO_GPHM0_OFFSET              5
#if (CHIP_DA610)
  #define _GPIO_GPHM1_OFFSET              5
#endif
 
  #define _GPIO_GPHM0_ADDR              0x01B00014u
#if (CHIP_DA610)
  #define _GPIO_GPHM1_ADDR              0x01B04014u
#endif

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPHM_GPXHM_MASK          0x000000F4u
#else
  #define _GPIO_GPHM_GPXHM_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPHM_GPXHM_SHIFT         0x00000000u
  #define  GPIO_GPHM_GPXHM_DEFAULT       0x00000000u
  #define  GPIO_GPHM_GPXHM_OF(x)         _VALUEOF(x)

  #define  GPIO_GPHM_OF(x)               _VALUEOF(x)

  #define GPIO_GPHM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPHM,GPXHM)\
  )

  #define GPIO_GPHM_RMK(gpxhm) (Uint32)( \
     _PER_FMK(GPIO,GPHM,GPXHM,gpxhm)\
  )

  #define _GPIO_GPHM0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPHM0_ADDR,GPIO,GPHM,##FIELD)
#if (CHIP_DA610)
  #define _GPIO_GPHM1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPHM1_ADDR,GPIO,GPHM,##FIELD)
#endif

  #define _GPIO_GPHM0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPHM0_ADDR,GPIO,GPHM,##FIELD,field)
#if (CHIP_DA610)
  #define _GPIO_GPHM1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPHM1_ADDR,GPIO,GPHM,##FIELD,field)
#endif

  #define _GPIO_GPHM0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPHM0_ADDR,GPIO,GPHM,##FIELD,##SYM)
#if (CHIP_DA610)
 #define _GPIO_GPHM1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPHM1_ADDR,GPIO,GPHM,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |     G P D L       |
* |___________________|
*
* GPDL0  - GPIO0 Delta Low register
* GPDL1  - GPIO1 Delta Low register
* FIELDS (msb -> lsb)
* (rw)  GPXDL  
*
\******************************************************************************/
  #define _GPIO_GPDL0_OFFSET              6
#if (CHIP_DA610)
  #define _GPIO_GPDL1_OFFSET              6
#endif
  
  #define _GPIO_GPDL0_ADDR                0x01B00018u
#if (CHIP_DA610)
  #define _GPIO_GPDL1_ADDR                0x01B04018u
#endif

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPDL_GPXDL_MASK          0x000000F4u
#else
  #define _GPIO_GPDL_GPXDL_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPDL_GPXDL_SHIFT         0x00000000u
  #define  GPIO_GPDL_GPXDL_DEFAULT       0x00000000u
  #define  GPIO_GPDL_GPXDL_OF(x)         _VALUEOF(x)

  #define  GPIO_GPDL_OF(x)               _VALUEOF(x)

  #define GPIO_GPDL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPDL,GPXDL)\
  )

  #define GPIO_GPDL_RMK(gpxdl) (Uint32)( \
     _PER_FMK(GPIO,GPDL,GPXDL,gpxdl)\
  )

  #define _GPIO_GPDL0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDL0_ADDR,GPIO,GPDL,##FIELD)
#if (CHIP_DA610)
  #define _GPIO_GPDL1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPDL1_ADDR,GPIO,GPDL,##FIELD)
#endif

  #define _GPIO_GPDL0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDL0_ADDR,GPIO,GPDL,##FIELD,field)
#if (CHIP_DA610)
  #define _GPIO_GPDL1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPDL1_ADDR,GPIO,GPDL,##FIELD,field)
#endif

  #define _GPIO_GPDL0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDL0_ADDR,GPIO,GPDL,##FIELD,##SYM)
#if (CHIP_DA610)
  #define _GPIO_GPDL1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPDL1_ADDR,GPIO,GPDL,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |     G P L M       |
* |___________________|
*
* GPLM0  - GPIO0 Low Mask register
* GPLM1  - GPIO1 Low Mask register
* FIELDS (msb -> lsb)
* (rw)  GPXLM  
*
\******************************************************************************/
  #define _GPIO_GPLM0_OFFSET             7
#if (CHIP_DA610)
  #define _GPIO_GPLM1_OFFSET             7
#endif

  #define _GPIO_GPLM0_ADDR               0x01B0001Cu
#if (CHIP_DA610)
  #define _GPIO_GPLM1_ADDR               0x01B0401Cu
#endif

#if (CHIP_6711C || CHIP_6712C)
  #define _GPIO_GPLM_GPXLM_MASK          0x000000F4u
#else
  #define _GPIO_GPLM_GPXLM_MASK          0x0000FFFFu
#endif

  #define _GPIO_GPLM_GPXLM_SHIFT         0x00000000u
  #define  GPIO_GPLM_GPXLM_DEFAULT       0x00000000u
  #define  GPIO_GPLM_GPXLM_OF(x)         _VALUEOF(x)

  #define  GPIO_GPLM_OF(x)               _VALUEOF(x)

  #define GPIO_GPLM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPLM,GPXLM)\
  )

  #define GPIO_GPLM_RMK(gpxlm) (Uint32)( \
     _PER_FMK(GPIO,GPLM,GPXLM,gpxlm)\
  )

  #define _GPIO_GPLM0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPLM0_ADDR,GPIO,GPLM,##FIELD)
#if (CHIP_DA610)
  #define _GPIO_GPLM1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPLM1_ADDR,GPIO,GPLM,##FIELD)
#endif


  #define _GPIO_GPLM0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPLM0_ADDR,GPIO,GPLM,##FIELD,field)
#if (CHIP_DA610)
  #define _GPIO_GPLM1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPLM1_ADDR,GPIO,GPLM,##FIELD,field)
#endif

  #define _GPIO_GPLM0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPLM0_ADDR,GPIO,GPLM,##FIELD,##SYM)
#if (CHIP_DA610)
 #define _GPIO_GPLM1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPLM1_ADDR,GPIO,GPLM,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |     G P G C       |
* |___________________|
*
* GPGC0  - GPIO Global Control register
* GPGC1  - GPIO Global Control register
* FIELDS (msb -> lsb)
* (rw)  GP0M
* (rw)  GPINT0M
* (rw)  GPINTPOL
* (rw)  LOGIC
* (rw)  GPINTDV
*
\******************************************************************************/
  #define _GPIO_GPGC0_OFFSET               8
#if (CHIP_DA610)
  #define _GPIO_GPGC1_OFFSET               8
#endif

  #define _GPIO_GPGC0_ADDR                 0x01B00020u
#if (CHIP_DA610)
  #define _GPIO_GPGC1_ADDR                 0x01B04020u
#endif

  #define _GPIO_GPGC_GP0M_MASK             0x00000020u
  #define _GPIO_GPGC_GP0M_SHIFT            0x00000005u
  #define  GPIO_GPGC_GP0M_DEFAULT          0x00000000u
  #define  GPIO_GPGC_GP0M_OF(x)            _VALUEOF(x)
  #define  GPIO_GPGC_GP0M_GPIOMODE         0x00000000u
  #define  GPIO_GPGC_GP0M_LOGICMODE        0x00000001u
  
  #define _GPIO_GPGC_GPINT0M_MASK          0x00000010u
  #define _GPIO_GPGC_GPINT0M_SHIFT         0x00000004u
  #define  GPIO_GPGC_GPINT0M_DEFAULT       0x00000000u
  #define  GPIO_GPGC_GPINT0M_OF(x)         _VALUEOF(x)
  #define  GPIO_GPGC_GPINT0M_PASSMODE      0x00000000u
  #define  GPIO_GPGC_GPINT0M_LOGICMODE     0x00000001u

  #define _GPIO_GPGC_GPINTPOL_MASK         0x00000004u
  #define _GPIO_GPGC_GPINTPOL_SHIFT        0x00000002u
  #define  GPIO_GPGC_GPINTPOL_DEFAULT      0x00000000u
  #define  GPIO_GPGC_GPINTPOL_OF(x)        _VALUEOF(x)
  #define  GPIO_GPGC_GPINTPOL_LOGICTRUE    0x00000000u
  #define  GPIO_GPGC_GPINTPOL_LOGICFALSE   0x00000001u

  #define _GPIO_GPGC_LOGIC_MASK            0x00000002u
  #define _GPIO_GPGC_LOGIC_SHIFT           0x00000001u
  #define  GPIO_GPGC_LOGIC_DEFAULT         0x00000000u
  #define  GPIO_GPGC_LOGIC_OF(x)           _VALUEOF(x)
  #define  GPIO_GPGC_LOGIC_ORMODE          0x00000000u
  #define  GPIO_GPGC_LOGIC_ANDMODE         0x00000001u

  #define _GPIO_GPGC_GPINTDV_MASK          0x00000001u
  #define _GPIO_GPGC_GPINTDV_SHIFT         0x00000000u
  #define  GPIO_GPGC_GPINTDV_DEFAULT       0x00000000u
  #define  GPIO_GPGC_GPINTDV_OF(x)         _VALUEOF(x)
  #define  GPIO_GPGC_GPINTDV_DELTAMODE     0x00000000u
  #define  GPIO_GPGC_GPINTDV_VALUEMODE     0x00000001u

  #define  GPIO_GPGC_OF(x)                 _VALUEOF(x)

  #define GPIO_GPGC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPGC,GP0M)\
    |_PER_FDEFAULT(GPIO,GPGC,GPINT0M)\
    |_PER_FDEFAULT(GPIO,GPGC,GPINTPOL)\
    |_PER_FDEFAULT(GPIO,GPGC,LOGIC)\
    |_PER_FDEFAULT(GPIO,GPGC,GPINTDV)\
  )

  #define GPIO_GPGC_RMK(gp0m,gpint0m,gpintpol,logic,gpintdv) (Uint32)( \
     _PER_FMK(GPIO,GPGC,GP0M,gp0m)\
    |_PER_FMK(GPIO,GPGC,GPINT0M,gpint0m)\
    |_PER_FMK(GPIO,GPGC,GPINTPOL,gpintpol)\
    |_PER_FMK(GPIO,GPGC,LOGIC,logic)\
    |_PER_FMK(GPIO,GPGC,GPINTDV,gpintdv)\
  )

  #define _GPIO_GPGC0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPGC0_ADDR,GPIO,GPGC,##FIELD)
#if (CHIP_DA610)
  #define _GPIO_GPGC1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPGC1_ADDR,GPIO,GPGC,##FIELD)
#endif

  #define _GPIO_GPGC0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPGC0_ADDR,GPIO,GPGC,##FIELD,field)
#if (CHIP_DA610)
  #define _GPIO_GPGC1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPGC1_ADDR,GPIO,GPGC,##FIELD,field)
#endif

  #define _GPIO_GPGC0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPGC0_ADDR,GPIO,GPGC,##FIELD,##SYM)
#if (CHIP_DA610)
 #define _GPIO_GPGC1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPGC1_ADDR,GPIO,GPGC,##FIELD,##SYM)
#endif
/******************************************************************************\
* _____________________
* |                   |
* |     G P P O L     |
* |___________________|
*
* GPPOL0  - GPIO0 Interrupt Polarity register
* GPPOL1  - GPIO1 Interrupt Polarity register
* FIELDS (msb -> lsb)
* (rw)  GPINTXPOL  
*
\******************************************************************************/
  #define _GPIO_GPPOL0_OFFSET                  9
#if (CHIP_DA610)
  #define _GPIO_GPPOL1_OFFSET                  9
#endif

  #define _GPIO_GPPOL0_ADDR                    0x01B00024u
#if (CHIP_DA610)
  #define _GPIO_GPPOL1_ADDR                    0x01B04024u
#endif

  #define _GPIO_GPPOL_GPINTXPOL_MASK          0x000000F9u
  #define _GPIO_GPPOL_GPINTXPOL_SHIFT         0x00000000u
  #define  GPIO_GPPOL_GPINTXPOL_DEFAULT       0x00000000u
  #define  GPIO_GPPOL_GPINTXPOL_OF(x)         _VALUEOF(x)

  #define  GPIO_GPPOL_OF(x)                   _VALUEOF(x)
  
  #define GPIO_GPPOL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(GPIO,GPPOL,GPINTXPOL)\
  )

  #define GPIO_GPPOL_RMK(gpintxpol) (Uint32)( \
     _PER_FMK(GPIO,GPPOL,GPINTXPOL,gpintxpol)\
  )
  #define _GPIO_GPPOL0_FGET(FIELD)\
    _PER_FGET(_GPIO_GPPOL0_ADDR,GPIO,GPPOL,##FIELD)  
#if (CHIP_DA610)
  #define _GPIO_GPPOL1_FGET(FIELD)\
    _PER_FGET(_GPIO_GPPOL1_ADDR,GPIO,GPPOL,##FIELD)  
#endif

  #define _GPIO_GPPOL0_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPPOL0_ADDR,GPIO,GPPOL,##FIELD,field)
#if (CHIP_DA610)
  #define _GPIO_GPPOL1_FSET(FIELD,field)\
    _PER_FSET(_GPIO_GPPOL1_ADDR,GPIO,GPPOL,##FIELD,field)
#endif

  #define _GPIO_GPPOL0_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPPOL0_ADDR,GPIO,GPPOL,##FIELD,##SYM)
#if (CHIP_DA610)
  #define _GPIO_GPPOL1_FSETS(FIELD,SYM)\
    _PER_FSETS(_GPIO_GPPOL1_ADDR,GPIO,GPPOL,##FIELD,##SYM)
#endif

/*----------------------------------------------------------------------------*/


#endif /* GPIO_SUPPORT */
#endif /* _CSL_GPIOHAL_H_ */
/******************************************************************************\
* End of csl_gpiohal.h
\******************************************************************************/







csl_gpioleg.h/  1034805832  0     0     0       1463      `
#include  <csl_gpio.h>

#if  C64_SUPPORT
#define GPIO_config(config)    GPIO_config(_hGpioDev0,config);
#define GPIO_configArgs( gpgc, gpen,  gpdir, gpval, gphm,  gplm,  gppol)\
        GPIO_configArgs(_hGpioDev0, gpgc, gpen,  gpdir, gpval,   gphm,  gplm,  gppol)
#define GPIO_getConfig(config)  GPIO_getConfig(_hGpioDev0,config)


#define GPIO_pinEnable(pinId)  GPIO_pinEnable(_hGpioDev0,pinId)

#define GPIO_pinDisable(pinId) GPIO_pinDisable(_hGpioDev0, pinId)
#define GPIO_pinDirection(pinId,direction) GPIO_pinDirection(_hGpioDev0,pinId,direction)


#define GPIO_pinRead( pinId) GPIO_pinRead(_hGpioDev0, pinId)

/* For output Pins */
#define GPIO_pinWrite( pinId,  val) GPIO_pinWrite(_hGpioDev0, pinId,  val)


/* For input Pins */
#define GPIO_deltaHighGet( pinId) GPIO_deltaHighGet(_hGpioDev0, pinId)
#define GPIO_deltaHighClear( pinId) GPIO_deltaHighClear(_hGpioDev0, pinId)
#define GPIO_deltaLowGet( pinId) GPIO_deltaLowGet(_hGpioDev0, pinId)
#define GPIO_deltaLowClear( pinId) GPIO_deltaLowClear(_hGpioDev0, pinId)

#define GPIO_maskHighSet( pinId) GPIO_maskHighSet(_hGpioDev0, pinId)
#define GPIO_maskHighClear( pinId) GPIO_maskHighClear(_hGpioDev0, pinId)
#define GPIO_maskLowSet( pinId) GPIO_maskLowSet(_hGpioDev0, pinId)
#define GPIO_maskLowClear( pinId) GPIO_maskLowClear(_hGpioDev0, pinId)

/* Pass Through Mode */
#define GPIO_intPolarity(signal,polarity) GPIO_intPolarity(_hGpioDev0, signal,  polarity)
#endif


csl_hpi.h/      1030611964  0     0     0       5093      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_hpi.h
* DATE CREATED.. 09/01/1999 
* LAST MODIFIED. 04/20/2001 (C64x compatibility)
\******************************************************************************/
#ifndef _CSL_HPI_H_
#define _CSL_HPI_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_hpihal.h>


#if (HPI_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _HPI_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/


/******************************************************************************\
* global typedef declarations
\******************************************************************************/


/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 HPI_getEventId();
IDECL Uint32 HPI_getHwob();
IDECL Uint32 HPI_getDspint();
IDECL Uint32 HPI_getHint();
IDECL Uint32 HPI_getHrdy();
IDECL Uint32 HPI_getFetch();
IDECL void   HPI_setDspint(Uint32 val);
IDECL void   HPI_setHint(Uint32 val);

#if (C64_SUPPORT)
IDECL void   HPI_setWriteAddr(Uint32 address);
IDECL Uint32 HPI_getWriteAddr();
IDECL void   HPI_setReadAddr(Uint32 address);
IDECL Uint32 HPI_getReadAddr();
#endif /* C64_SUPPORT */

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 HPI_getEventId() {
  return (Uint32)IRQ_EVT_DSPINT;
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 HPI_getHwob() {
  return HPI_FGET(HPIC,HWOB);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 HPI_getDspint() {
  return HPI_FGET(HPIC,DSPINT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 HPI_getHint() {
  return HPI_FGET(HPIC,HINT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 HPI_getHrdy() {
  return HPI_FGET(HPIC,HRDY);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 HPI_getFetch() {
  return HPI_FGET(HPIC,FETCH);
}
/*----------------------------------------------------------------------------*/
IDEF void HPI_setDspint(Uint32 val) {
  HPI_FSET(HPIC,DSPINT,val);
}
/*----------------------------------------------------------------------------*/
IDEF void HPI_setHint(Uint32 val) {
  HPI_FSET(HPIC,HINT,val);
}
/*----------------------------------------------------------------------------*/
#if (C64_SUPPORT)

IDEF void   HPI_setWriteAddr(Uint32 address) {
  HPI_FSET(HPIAW,HPIAW,address);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 HPI_getWriteAddr(){
  return ( HPI_FGET(HPIAW,HPIAW));
}
/*----------------------------------------------------------------------------*/
IDEF void   HPI_setReadAddr(Uint32 address) {
  HPI_FSET(HPIAR,HPIAR,address);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 HPI_getReadAddr(){
  return ( HPI_FGET(HPIAR,HPIAR));
}
/*----------------------------------------------------------------------------*/
#endif /* C64_SUPPORT */

#endif /* USEDEFS */


#endif /* HPI_SUPPORT */
#endif /* _CSL_HPI_H_ */
/******************************************************************************\
* End of csl_hpi.h
\******************************************************************************/


csl_hpihal.h/   1082727948  0     0     0       9630      `
/******************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_hpihal.h
* DATE CREATED.. 06/20/1999
* LAST MODIFIED. 04/20/2001 (C64x compatibility)
*				 06/09/2003 TRCTL bug
*                04/16/2004  Fixed TRCTL bad adress
*------------------------------------------------------------------------------
* REGISTERS
*
* HPIC - HPI control register
* HPIAW - HPI Address Write register (1)
* HPIAR - HPI Address Read registrer (1)
* TRCTL - TR Control register (1)
*
* (1) supported by C64x devices only
\******************************************************************************/
#ifndef _CSL_HPIHAL_H_
#define _CSL_HPIHAL_H_

#include <csl_chip.h>

#if (HPI_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#define _HPI_BASE_ADDR         0x01880000u


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define HPI_FMK(REG,FIELD,x)\
    _PER_FMK(HPI,##REG,##FIELD,x)

  #define HPI_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(HPI,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define HPI_ADDR(REG)\
    _HPI_##REG##_ADDR

  #define HPI_RGET(REG)\
    _PER_RGET(_HPI_##REG##_ADDR,HPI,##REG)

  #define HPI_RSET(REG,x)\
    _PER_RSET(_HPI_##REG##_ADDR,HPI,##REG,x)

  #define HPI_FGET(REG,FIELD)\
    _HPI_##REG##_FGET(##FIELD)

  #define HPI_FSET(REG,FIELD,x)\
    _HPI_##REG##_FSET(##FIELD,##x)

  #define HPI_FSETS(REG,FIELD,SYM)\
    _HPI_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define HPI_RGETA(addr,REG)\
    _PER_RGET(addr,HPI,##REG)

  #define HPI_RSETA(addr,REG,x)\
    _PER_RSET(addr,HPI,##REG,x)

  #define HPI_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,HPI,##REG,##FIELD)

  #define HPI_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,HPI,##REG,##FIELD,x)

  #define HPI_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,HPI,##REG,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  H P I C          |
* |___________________|
*
* HPI - HPI control register
*
* FIELDS (msb -> lsb)
* (r)  FETCH
* (r)  HRDY
* (rw) HINT
* (rw) DSPINT
* (r)  HWOB
*
\******************************************************************************/
  #define _HPI_HPIC_OFFSET             0
  #define _HPI_HPIC_ADDR               0x01880000u

  #define _HPI_HPIC_FETCH_MASK         0x00000010u
  #define _HPI_HPIC_FETCH_SHIFT        0x00000004u
  #define  HPI_HPIC_FETCH_DEFAULT      0x00000000u
  #define  HPI_HPIC_FETCH_OF(x)        _VALUEOF(x)
  #define  HPI_HPIC_FETCH_0            0x00000000u
  #define  HPI_HPIC_FETCH_1            0x00000001u

  #define _HPI_HPIC_HRDY_MASK          0x00000008u
  #define _HPI_HPIC_HRDY_SHIFT         0x00000003u
  #define  HPI_HPIC_HRDY_DEFAULT       0x00000001u
  #define  HPI_HPIC_HRDY_OF(x)         _VALUEOF(x)
  #define  HPI_HPIC_HRDY_0             0x00000000u
  #define  HPI_HPIC_HRDY_1             0x00000001u

  #define _HPI_HPIC_HINT_MASK          0x00000004u
  #define _HPI_HPIC_HINT_SHIFT         0x00000002u
  #define  HPI_HPIC_HINT_DEFAULT       0x00000000u
  #define  HPI_HPIC_HINT_OF(x)         _VALUEOF(x)
  #define  HPI_HPIC_HINT_0             0x00000000u
  #define  HPI_HPIC_HINT_1             0x00000001u

  #define _HPI_HPIC_DSPINT_MASK        0x00000002u
  #define _HPI_HPIC_DSPINT_SHIFT       0x00000001u
  #define  HPI_HPIC_DSPINT_DEFAULT     0x00000000u
  #define  HPI_HPIC_DSPINT_OF(x)       _VALUEOF(x)
  #define  HPI_HPIC_DSPINT_0           0x00000000u
  #define  HPI_HPIC_DSPINT_1           0x00000001u

  #define _HPI_HPIC_HWOB_MASK          0x00000001u
  #define _HPI_HPIC_HWOB_SHIFT         0x00000000u
  #define  HPI_HPIC_HWOB_DEFAULT       0x00000000u
  #define  HPI_HPIC_HWOB_OF(x)         _VALUEOF(x)
  #define  HPI_HPIC_HWOB_0             0x00000000u
  #define  HPI_HPIC_HWOB_1             0x00000001u

  #define  HPI_HPIC_OF(x)              _VALUEOF(x)

  #define HPI_HPIC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(HPI,HPIC,FETCH) \
    |_PER_FDEFAULT(HPI,HPIC,HRDY) \
    |_PER_FDEFAULT(HPI,HPIC,HINT) \
    |_PER_FDEFAULT(HPI,HPIC,DSPINT) \
    |_PER_FDEFAULT(HPI,HPIC,HWOB) \
  )

  #define HPI_HPIC_RMK(hint,dspint) (Uint32)( \
     _PER_FMK(HPI,HPIC,HINT,hint) \
    |_PER_FMK(HPI,HPIC,DSPINT,dspint) \
   )

  #define _HPI_HPIC_FGET(FIELD)\
    _PER_FGET(_HPI_HPIC_ADDR,HPI,HPIC,##FIELD)

  #define _HPI_HPIC_FSET(FIELD,field)\
    _PER_FSET(_HPI_HPIC_ADDR,HPI,HPIC,##FIELD,field)

  #define _HPI_HPIC_FSETS(FIELD,SYM)\
    _PER_FSETS(_HPI_HPIC_ADDR,HPI,HPIC,##FIELD,##SYM)
/******************************************************************************\
* _____________________
* |                   |
* |  H P I A W        |
* |___________________|
*
* HPIAW - HPI Address Write register
*
* FIELDS (msb -> lsb)
* (rw)  HPIAW
*
\******************************************************************************/
 #if (C64_SUPPORT)
  #define _HPI_HPIAW_OFFSET             1
  #define _HPI_HPIAW_ADDR               0x01880004u

  #define _HPI_HPIAW_HPIAW_MASK         0xFFFFFFFCu
  #define _HPI_HPIAW_HPIAW_SHIFT        0x00000002u
  #define  HPI_HPIAW_HPIAW_DEFAULT      0x00000000u
  #define  HPI_HPIAW_HPIAW_OF(x)        _VALUEOF(x)

  #define HPI_HPIAW_DEFAULT (Uint32)( \
     _PER_FDEFAULT(HPI,HPIAW,HPIAW) \
  )

  #define HPI_HPIAW_RMK(hpiaw) (Uint32)( \
     _PER_FMK(HPI,HPIAW,HPIAW,hpiaw) \
   )

  #define _HPI_HPIAW_FGET(FIELD)\
    _PER_FGET(_HPI_HPIAW_ADDR,HPI,HPIAW,##FIELD)

  #define _HPI_HPIAW_FSET(FIELD,field)\
    _PER_FSET(_HPI_HPIAW_ADDR,HPI,HPIAW,##FIELD,field)

  #define _HPI_HPIAW_FSETS(FIELD,SYM)\
    _PER_FSETS(_HPI_HPIAW_ADDR,HPI,HPIAW,##FIELD,##SYM)

#endif /* C64_SUPPORT */
/******************************************************************************\
* _____________________
* |                   |
* |  H P I A R        |
* |___________________|
*
* HPIAR - HPI Address Read register
*
* FIELDS (msb -> lsb)
* (rw)  HPIAR
*
\******************************************************************************/
 #if (C64_SUPPORT)
  #define _HPI_HPIAR_OFFSET             2
  #define _HPI_HPIAR_ADDR               0x01880008u

  #define _HPI_HPIAR_HPIAR_MASK         0xFFFFFFFCu
  #define _HPI_HPIAR_HPIAR_SHIFT        0x00000002u
  #define  HPI_HPIAR_HPIAR_DEFAULT      0x00000000u
  #define  HPI_HPIAR_HPIAR_OF(x)        _VALUEOF(x)

  #define HPI_HPIAR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(HPI,HPIAR,HPIAR) \
  )

  #define HPI_HPIAR_RMK(hpiar) (Uint32)( \
     _PER_FMK(HPI,HPIAR,HPIAR,hpiar) \
   )

  #define _HPI_HPIAR_FGET(FIELD)\
    _PER_FGET(_HPI_HPIAR_ADDR,HPI,HPIAR,##FIELD)

  #define _HPI_HPIAR_FSET(FIELD,field)\
    _PER_FSET(_HPI_HPIAR_ADDR,HPI,HPIAR,##FIELD,field)

  #define _HPI_HPIAR_FSETS(FIELD,SYM)\
    _PER_FSETS(_HPI_HPIAR_ADDR,HPI,HPIAR,##FIELD,##SYM)

#endif /* C64_SUPPORT */

/******************************************************************************\
* _____________________
* |                   |
* |  T R C T L        |
* |___________________|
*
* TRCTL - TR Control register
*
* FIELDS (msb -> lsb)
* (rw)  TRSTALL
* (rw)  PRI
* (rw)  PALLOC
*
\******************************************************************************/
 #if (C64_SUPPORT)
  #define _HPI_TRCTL_OFFSET             16384
  #define _HPI_TRCTL_ADDR               0x018A0000u

  #define _HPI_TRCTL_TRSTALL_MASK         0x00000100u
  #define _HPI_TRCTL_TRSTALL_SHIFT        0x00000008u
  #define  HPI_TRCTL_TRSTALL_DEFAULT      0x00000000u
  #define  HPI_TRCTL_TRSTALL_OF(x)        _VALUEOF(x)

  #define _HPI_TRCTL_PRI_MASK         0x00000030u
  #define _HPI_TRCTL_PRI_SHIFT        0x00000004u
  #define  HPI_TRCTL_PRI_DEFAULT      0x00000002u
  #define  HPI_TRCTL_PRI_OF(x)        _VALUEOF(x)

  #define _HPI_TRCTL_PALLOC_MASK         0x0000000Fu
  #define _HPI_TRCTL_PALLOC_SHIFT        0x00000000u
  #define  HPI_TRCTL_PALLOC_DEFAULT      0x00000004u
  #define  HPI_TRCTL_PALLOC_OF(x)        _VALUEOF(x)

  #define HPI_TRCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(HPI,TRCTL,TRSTALL) \
    |_PER_FDEFAULT(HPI,TRCTL,PRI) \
    |_PER_FDEFAULT(HPI,TRCTL,PALLOC) \
  )

  #define HPI_TRCTL_RMK(trstall,pri,palloc) (Uint32)( \
     _PER_FMK(HPI,TRCTL,TRSTALL,trstall) \
    |_PER_FMK(HPI,TRCTL,PRI,pri) \
    |_PER_FMK(HPI,TRCTL,PALLOC,palloc) \
   )

  #define _HPI_TRCTL_FGET(FIELD)\
    _PER_FGET(_HPI_TRCTL_ADDR,HPI,TRCTL,##FIELD)

  #define _HPI_TRCTL_FSET(FIELD,field)\
    _PER_FSET(_HPI_TRCTL_ADDR,HPI,TRCTL,##FIELD,field)

  #define _HPI_TRCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_HPI_TRCTL_ADDR,HPI,TRCTL,##FIELD,##SYM)

#endif /* C64_SUPPORT */



/*----------------------------------------------------------------------------*/

#endif /* HPI_SUPPORT */
#endif /* _CSL_HPIHAL_H_ */
/******************************************************************************\
* End of csl_hpihal.h
\******************************************************************************/

csl_i2c.h/      1092218720  0     0     0       15997     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_i2c.h
* DATE CREATED.. 06/11/1999 
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                13/03/2002 - added I2C_outOfReset()
*                01/08/2003 - Removing unused variable 'I2C_isrDispatchTable[6]'
\******************************************************************************/
#ifndef _CSL_I2C_H_
#define _CSL_I2C_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_i2chal.h>


/* defining i2cimr as i2cier for backward compatibility */

#define i2cimr i2cier

#if (I2C_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _I2C_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/

/* I2C_open() flags */
#define I2C_OPEN_RESET     (0x00000001)

/* device identifiers for I2C_open() */

#if (CHIP_6713 | CHIP_DA610 | CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define I2C_DEV0           (0)
  #define I2C_DEV1           (1)
#endif

#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412)
  #define I2C_DEV0           (0)
#endif

/* device identifiers for I2C_open() */

#if (CHIP_6713 | CHIP_DA610 | CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define I2C_PORT0          I2C_DEV0
  #define I2C_PORT1          I2C_DEV1
#endif

#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412)
  #define I2C_PORT0           I2C_DEV0
#endif

/* error codes */
#define I2C_ERR_ALLOC	        (0x00000000) 
#define I2C_ERR_INVALID_HANDLE  (0x00000001) 

#define I2C_EVT_AL      0x01     // Arbitration win/lose
#define I2C_EVT_NACK    0x02     // No acknowledgement 
#define I2C_EVT_ARDY    0x03     // register access ready
#define I2C_EVT_ICRRDY  0x04     // receive data ready
#define I2C_EVT_ICXRDY  0x05     // transmit data ready

#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define I2C_EVT_SCD     0x06     // stop condition detect 
  #define I2C_EVT_AAS     0x07     // address as slave
#endif

/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* device handle object */
typedef struct {
  Uint32 allocated;
  Uint32 eventId;
  volatile Uint32 *baseAddr;
  Uint32 i2cdrrAddr;
  Uint32 i2cdxrAddr;
} I2C_Obj, *I2C_Handle;

/* device configuration structure */
typedef struct {
	Uint32 i2coar;
	Uint32 i2cier;
	Uint32 i2cclkl;
	Uint32 i2cclkh;
	Uint32 i2ccnt;
	Uint32 i2csar;
	Uint32 i2cmdr;
	Uint32 i2cpsc;
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
        Uint32 i2cemdr;
        Uint32 i2cpfunc;
        Uint32 i2cpdir;
#endif    
} I2C_Config;

typedef struct {
	Uint32 addrmode;        /* 7 or 10 bit address mode */
	Uint32 ownaddr;         /* don't care if master */
	Uint32 sysinclock;      /* clkout value (Mhz)  */
	Uint32 rate;            /* a number between 10 and 400 in kbps*/
	Uint32 bitbyte;         /* number of bits/byte to be received or transmitted */
	Uint32 dlb;             /* digital loopback mode */
	Uint32 free;	        /* free mode */
} I2C_Init;


/******************************************************************************\
* global variable declarations
\******************************************************************************/

/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void I2C_reset(I2C_Handle hI2c);
CSLAPI void I2C_resetAll();
CSLAPI I2C_Handle I2C_open(int devNum, Uint32 flags);
CSLAPI void I2C_close(I2C_Handle hI2c);
//CSLAPI void I2C_init(I2C_Init *init);

/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 I2C_getXmtAddr(I2C_Handle hI2c);
IDECL Uint32 I2C_getRcvAddr(I2C_Handle hI2c);
IDECL Uint32 I2C_getEventId(I2C_Handle hI2c);
IDECL Uint32 I2C_rfull(I2C_Handle hI2c);
IDECL Uint32 I2C_rrdy(I2C_Handle hI2c);
IDECL Uint32 I2C_xempty(I2C_Handle hI2c);
IDECL Uint32 I2C_xrdy(I2C_Handle hI2c);
IDECL Uint32 I2C_bb(I2C_Handle hI2c);

IDECL void I2C_writeByte(I2C_Handle hI2c, Uint8 val);
IDECL Uint8 I2C_readByte(I2C_Handle hI2c);

IDECL void I2C_sendStop(I2C_Handle hI2c);
IDECL void I2C_start(I2C_Handle hI2c);
IDECL void I2C_outOfReset(I2C_Handle hI2c);

IDECL Uint32 I2C_intClear(I2C_Handle hI2c);
IDECL void I2C_intClearAll(I2C_Handle hI2c);
IDECL void I2C_intEvtEnable(I2C_Handle hI2c,Uint32 maskFlag);
IDECL void I2C_intEvtDisable(I2C_Handle hI2c,Uint32 unmaskFlag);

IDECL void I2C_config(I2C_Handle hI2c,I2C_Config *config);

#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  IDECL void I2C_configArgs(I2C_Handle hI2c,Uint32 i2coar,Uint32 i2cier,Uint32 i2cclkl,
                            Uint32 i2cclkh,Uint32 i2ccnt,Uint32 i2csar,Uint32 i2cmdr,
                            Uint32 i2cpsc,Uint32 i2cemdr,Uint32 i2cpfunc,Uint32 i2cpdir);
#else
  IDECL void I2C_configArgs(I2C_Handle hI2c,Uint32 i2coar,Uint32 i2cier,Uint32 i2cclkl,
                            Uint32 i2cclkh,Uint32 i2ccnt,Uint32 i2csar,Uint32 i2cmdr,
                            Uint32 i2cpsc);

#endif
IDECL void I2C_getConfig(I2C_Handle hI2c,I2C_Config *config);


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_getPins(I2C_Handle hI2c) {
    return I2C_RGETH(hI2c,I2CPDIN);
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_setPins(I2C_Handle hI2c,Uint32 pins) {
    I2C_RSETH(hI2c,I2CPDSET,
        (
          I2C_FMK(I2CPDSET, SCLOUT, pins>>_I2C_I2CPDSET_SCLOUT_SHIFT)
         |I2C_FMK(I2CPDSET, SDAOUT, pins>>_I2C_I2CPDSET_SDAOUT_SHIFT)
        )
    );        
}
IDEF void I2C_clearPins(I2C_Handle hI2c,Uint32 pins) {
    I2C_RSETH(hI2c,I2CPDCLR,
        (
          I2C_FMK(I2CPDCLR, SCLOUT, pins>>_I2C_I2CPDCLR_SCLOUT_SHIFT)
         |I2C_FMK(I2CPDCLR, SDAOUT, pins>>_I2C_I2CPDCLR_SDAOUT_SHIFT)
        )
    );        
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_getExtMode(I2C_Handle hI2C) {
    return I2C_FGETH(hI2C,I2CEMDR,XRDYM);
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_setMstAck(I2C_Handle hI2C) {
    I2C_FSETSH(hI2C,I2CEMDR,XRDYM,MSTACK);
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_setDxrCpy(I2C_Handle hI2C) {
    I2C_FSETSH(hI2C,I2CEMDR,XRDYM,DXRCPY);
}
#endif
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_getXmtAddr(I2C_Handle hI2c) {
  return (Uint32)(hI2c->i2cdxrAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_getRcvAddr(I2C_Handle hI2c) {
  return (Uint32)(hI2c->i2cdrrAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_getEventId(I2C_Handle hI2c) {
  return (Uint32)(hI2c->eventId);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_rfull(I2C_Handle hI2c){
 return	I2C_FGETH(hI2c,I2CSTR,RSFULL);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_rrdy(I2C_Handle hI2c){
 return	I2C_FGETH(hI2c,I2CSTR,ICRRDY);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_xempty(I2C_Handle hI2c){
 return I2C_FGETH(hI2c,I2CSTR,XSMT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_xrdy(I2C_Handle hI2c){
 return	I2C_FGETH(hI2c,I2CSTR,ICXRDY);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_bb(I2C_Handle hI2c){
 return	I2C_FGETH(hI2c,I2CSTR,BB);
}
/*----------------------------------------------------------------------------*/
IDEF Uint8 I2C_readByte(I2C_Handle hI2c) {
  return (*(volatile Uint8 *)(hI2c->i2cdrrAddr));
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_writeByte(I2C_Handle hI2c, Uint8 val) {
  (*(volatile Uint8 *)(hI2c->i2cdxrAddr)) = val;
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_sendStop(I2C_Handle hI2c){
 	I2C_FSETSH(hI2c,I2CMDR,STP,STOP);
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_start(I2C_Handle hI2c){
	I2C_FSETSH(hI2c,I2CMDR,STT,START);
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_outOfReset(I2C_Handle hI2c){
	I2C_FSETSH(hI2c,I2CMDR,IRS,NRST);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 I2C_intClear(I2C_Handle hI2c){
    return I2C_RGETH(hI2c,I2CISRC);
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_intClearAll(I2C_Handle hI2c){
   Uint32 x=I2C_RGETH(hI2c,I2CISRC);
    while(x != 0) { x=I2C_RGETH(hI2c,I2CISRC); }
}
/*----------------------------------------------------------------------------*/
IDEF void I2C_intEvtEnable(I2C_Handle hI2c,Uint32 maskFlag){

    Uint32 newMask;

	newMask = I2C_RGETH(hI2c,I2CIER) | maskFlag;
	I2C_RSETH(hI2c,I2CIER,newMask);
	IRQ_enable(hI2c->eventId);

}
/*----------------------------------------------------------------------------*/
IDEF void I2C_intEvtDisable(I2C_Handle hI2c,Uint32 unmaskFlag){

	Uint32 newMask;

	newMask = I2C_RGETH(hI2c,I2CIER) & unmaskFlag;
	I2C_RSETH(hI2c,I2CIER,newMask);

    #if (CHIP_6410 | CHIP_6413| CHIP_6418 )
	if(!(I2C_RGETH(hI2c,I2CIER) & 0x0000007F))
    #else
	if(!(I2C_RGETH(hI2c,I2CIER) & 0x0000001F))
    #endif
		IRQ_disable(hI2c->eventId);
}
/*----------------------------------------------------------------------------*/

IDEF void I2C_config(I2C_Handle hI2c, I2C_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hI2c->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7;
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  register int x8,x9,x10;
#endif

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0 = config->i2coar;
  x1 = config->i2cier;
  x2 = config->i2cclkl;
  x3 = config->i2cclkh;
  x4 = config->i2ccnt;
  x5 = config->i2csar;
  x6 = config->i2cpsc;
  x7 = config->i2cmdr;
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  x8 = config->i2cemdr;
  x9 = config->i2cpfunc;
  x10 = config->i2cpdir;
#endif  

  base[_I2C_I2COAR_OFFSET]   = x0;
  base[_I2C_I2CIER_OFFSET]   = x1;
  base[_I2C_I2CCLKL_OFFSET]  = x2;
  base[_I2C_I2CCLKH_OFFSET]  = x3;
  base[_I2C_I2CCNT_OFFSET]   = x4;
  base[_I2C_I2CSAR_OFFSET]   = x5;
  base[_I2C_I2CPSC_OFFSET]   = x6;
  base[_I2C_I2CMDR_OFFSET]   = x7;
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  base[_I2C_I2CEMDR_OFFSET]  = x8;
  base[_I2C_I2CPFUNC_OFFSET] = x9;
  base[_I2C_I2CPDIR_OFFSET]  = x10;
#endif

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
IDEF void I2C_configArgs(I2C_Handle hI2c,Uint32 i2coar,Uint32 i2cier,Uint32 i2cclkl,
                         Uint32 i2cclkh,Uint32 i2ccnt,Uint32 i2csar,Uint32 i2cmdr,
                         Uint32 i2cpsc,Uint32 i2cemdr,Uint32 i2cpfunc,Uint32 i2cpdir){

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hI2c->baseAddr);

  gie = IRQ_globalDisable();

  base[_I2C_I2COAR_OFFSET]   = i2coar;
  base[_I2C_I2CIER_OFFSET]   = i2cier;
  base[_I2C_I2CCLKL_OFFSET]  = i2cclkl;
  base[_I2C_I2CCLKH_OFFSET]  = i2cclkh;
  base[_I2C_I2CCNT_OFFSET]   = i2ccnt;
  base[_I2C_I2CSAR_OFFSET]   = i2csar;
  base[_I2C_I2CPSC_OFFSET]   = i2cpsc;
  base[_I2C_I2CMDR_OFFSET]   = i2cmdr;
  base[_I2C_I2CEMDR_OFFSET]  = i2cemdr;
  base[_I2C_I2CPFUNC_OFFSET] = i2cpfunc;
  base[_I2C_I2CPDIR_OFFSET]  = i2cpdir;

  IRQ_globalRestore(gie);
}
#else
IDEF void I2C_configArgs(I2C_Handle hI2c,Uint32 i2coar,Uint32 i2cier,
Uint32 i2cclkl,Uint32 i2cclkh,Uint32 i2ccnt,Uint32 i2csar,
Uint32 i2cmdr,Uint32 i2cpsc){

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hI2c->baseAddr);

  gie = IRQ_globalDisable();

  base[_I2C_I2COAR_OFFSET]  = i2coar;
  base[_I2C_I2CIER_OFFSET]  = i2cier;
  base[_I2C_I2CCLKL_OFFSET] = i2cclkl;
  base[_I2C_I2CCLKH_OFFSET] = i2cclkh;
  base[_I2C_I2CCNT_OFFSET]  = i2ccnt;
  base[_I2C_I2CSAR_OFFSET]  = i2csar;
  base[_I2C_I2CPSC_OFFSET]  = i2cpsc;
  base[_I2C_I2CMDR_OFFSET]  = i2cmdr;

  IRQ_globalRestore(gie);
}
#endif
/*----------------------------------------------------------------------------*/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
IDEF void I2C_getConfig(I2C_Handle hI2c, I2C_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hI2c->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */

  x0 = base[_I2C_I2COAR_OFFSET];
  x1 = base[_I2C_I2CIER_OFFSET];
  x2 = base[_I2C_I2CCLKL_OFFSET];
  x3 = base[_I2C_I2CCLKH_OFFSET];
  x4 = base[_I2C_I2CCNT_OFFSET];
  x5 = base[_I2C_I2CSAR_OFFSET];
  x6 = base[_I2C_I2CMDR_OFFSET];
  x7 = base[_I2C_I2CPSC_OFFSET];
  x8 = base[_I2C_I2CEMDR_OFFSET];
  x9 = base[_I2C_I2CPFUNC_OFFSET];
  x10 = base[_I2C_I2CPDIR_OFFSET];

  config->i2coar   = x0;
  config->i2cier   = x1;
  config->i2cclkl  = x2;
  config->i2cclkh  = x3;
  config->i2ccnt   = x4;
  config->i2csar   = x5;
  config->i2cmdr   = x6;
  config->i2cpsc   = x7;
  config->i2cemdr  = x8;
  config->i2cpfunc = x9;
  config->i2cpdir  = x10;

  IRQ_globalRestore(gie);
}
#else
IDEF void I2C_getConfig(I2C_Handle hI2c, I2C_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hI2c->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */

  x0 = base[_I2C_I2COAR_OFFSET];
  x1 = base[_I2C_I2CIER_OFFSET];
  x2 = base[_I2C_I2CCLKL_OFFSET];
  x3 = base[_I2C_I2CCLKH_OFFSET];
  x4 = base[_I2C_I2CCNT_OFFSET];
  x5 = base[_I2C_I2CSAR_OFFSET];
  x6 = base[_I2C_I2CMDR_OFFSET];
  x7 = base[_I2C_I2CPSC_OFFSET];

  config->i2coar  = x0;
  config->i2cier  = x1;
  config->i2cclkl = x2;
  config->i2cclkh = x3;
  config->i2ccnt  = x4;
  config->i2csar  = x5;
  config->i2cmdr  = x6;
  config->i2cpsc  = x7;

  IRQ_globalRestore(gie);
}
#endif
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* I2C_SUPPORT */
#endif /* _CSL_I2C_H_ */
/******************************************************************************\
* End of csl_i2c.h
\******************************************************************************/


csl_i2chal.h/   1092218721  0     0     0       65573     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_i2chal.h
* DATE CREATED.. 10/02/2001 
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                11/19/2001    register renaming 
*                11/09/2001    update bit field names 
*                07/02/2003    update to latest spec.
*------------------------------------------------------------------------------
* REGISTERS
*
* I2COAR0    - I2C0 Own Address register
* I2COAR1    - I2C1 Own Address register
* I2CIER0    - I2C0 Interrupt Mask/Status register
* I2CIER1    - I2C1 Interrupt Mask/Status register
* I2CSTR0    - I2C0 Interrupt Status register
* I2CSTR1    - I2C1 Interrupt Status register
* I2CCLKL0   - I2C0 Clock Divider Low register
* I2CCLKL1   - I2C1 Clock Divider Low register
* I2CCLKH0   - I2C0 Clock Divider High register
* I2CCLKH1   - I2C1 Clock Divider High register
* I2CCNT0    - I2C0 Data Count register
* I2CCNT1    - I2C1 Data Count register
* I2CDRR0    - I2C0 Data Receive register
* I2CDRR1    - I2C1 Data Receive register
* I2CSAR0    - I2C0 Slave Address register
* I2CSAR1    - I2C1 Slave Address register
* I2CDXR0    - I2C0 Data Transmit register
* I2CDXR1    - I2C1 Data Transmit register
* I2CMDR0    - I2C0 Mode register
* I2CMDR1    - I2C1 Mode register
* I2CISRC0    - I2C0 Interrupt Vector register
* I2CISRC1    - I2C1 Interrupt Vector register
* I2CEMDR0   - I2C0 Extended Mode register(1)
* I2CEMDR1   - I2C1 Extended Mode register(1)
* I2CPSC0    - I2C0 Prescaler register
* I2CPSC1    - I2C1 Prescaler register
* I2CPID10   - I2C0 Peripheral ID register 1(1)
* I2CPID11   - I2C1 Peripheral ID register 1(1)
* I2CPID20   - I2C0 Peripheral ID register 2(1)
* I2CPID21   - I2C1 Peripheral ID register 2(1)
* I2CPFUNC0  - I2C0 Peripheral Functional register(1)
* I2CPFUNC1  - I2C1 Peripheral Functional register(1)
* I2CPDIR0   - I2C0 Pin Direction register(1)
* I2CPDIR1   - I2C1 Pin Direction register(1)
* I2CPDIN0   - I2C0 Pin Data In register(1)
* I2CPDIN1   - I2C1 Pin Data In register(1)
* I2CPDOUT0  - I2C0 Pin Data Out register(1)
* I2CPDOUT1  - I2C1 Pin Data Out register(1)
* I2CPDSET0  - I2C0 Pin Data Set register(1)
* I2CPDSET1  - I2C1 Pin Data Set register(1)
* I2CPDCLR0  - I2C0 Pin Data Clear register(1)
* I2CPDCLR1  - I2C1 Pin Data Clear register(1)
*
* (1) For C6418/C6413/C6410 only
\******************************************************************************/
#ifndef _CSL_I2CHAL_H_
#define _CSL_I2CHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>
#if (I2C_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#if (CHIP_6713 | CHIP_DA610 | CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_PORT_CNT        2
  #define _I2C_BASE_PORT0      0x01B40000u
  #define _I2C_BASE_PORT1      0x01B44000u
#endif

#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412)
  #define _I2C_PORT_CNT        1
  #define _I2C_BASE_PORT0      0x01B40000u
#endif
 

/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define I2C_FMK(REG,FIELD,x)\
    _PER_FMK(I2C,##REG,##FIELD,x)

  #define I2C_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(I2C,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define I2C_ADDR(REG)\
    _I2C_##REG##_ADDR

  #define I2C_RGET(REG)\
    _PER_RGET(_I2C_##REG##_ADDR,I2C,##REG)

  #define I2C_RSET(REG,x)\
    _PER_RSET(_I2C_##REG##_ADDR,I2C,##REG,x)

  #define I2C_FGET(REG,FIELD)\
    _I2C_##REG##_FGET(##FIELD)

  #define I2C_FSET(REG,FIELD,x)\
    _I2C_##REG##_FSET(##FIELD,##x)

  #define I2C_FSETS(REG,FIELD,SYM)\
    _I2C_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define I2C_RGETA(addr,REG)\
    _PER_RGET(addr,I2C,##REG)

  #define I2C_RSETA(addr,REG,x)\
    _PER_RSET(addr,I2C,##REG,x)

  #define I2C_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,I2C,##REG,##FIELD)

  #define I2C_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,I2C,##REG,##FIELD,x)

  #define I2C_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,I2C,##REG,##FIELD,##SYM)


  /* ----------------------------------------- */
  /* HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define I2C_ADDRH(h,REG)\
    (Uint32)(&((h)->baseAddr[_I2C_##REG##_OFFSET]))

  #define I2C_RGETH(h,REG)\
    I2C_RGETA(I2C_ADDRH(h,##REG),##REG)


  #define I2C_RSETH(h,REG,x)\
    I2C_RSETA(I2C_ADDRH(h,##REG),##REG,x)


  #define I2C_FGETH(h,REG,FIELD)\
    I2C_FGETA(I2C_ADDRH(h,##REG),##REG,##FIELD)


  #define I2C_FSETH(h,REG,FIELD,x)\
    I2C_FSETA(I2C_ADDRH(h,##REG),##REG,##FIELD,x)


  #define I2C_FSETSH(h,REG,FIELD,SYM)\
    I2C_FSETSA(I2C_ADDRH(h,##REG),##REG,##FIELD,##SYM)



/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C O A R      |
* |___________________|
*
* I2COAR0    - I2C0 Own Address register
* I2COAR1    - I2C1 Own Address register
*
* FIELDS (msb -> lsb)
* (rw) A
*
\******************************************************************************/
  #define _I2C_I2COAR_OFFSET           0

  #define _I2C_I2COAR0_ADDR            0x01B40000
  #define _I2C_I2COAR1_ADDR            0x01B44000

  #define _I2C_I2COAR_A_MASK          0x000003FFu 
  #define _I2C_I2COAR_A_SHIFT         0x00000000u
  #define  I2C_I2COAR_A_DEFAULT       0x00000000u
  #define  I2C_I2COAR_A_OF(x)         _VALUEOF(x)

  #define  I2C_I2COAR_OF(x)             _VALUEOF(x)

  #define I2C_I2COAR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2COAR,A)\
  )

  #define I2C_I2COAR_RMK(a) (Uint32)(\
     _PER_FMK(I2C,I2COAR,A,a)\
  )
   
  #define _I2C_I2COAR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2COAR##N##_ADDR,I2C,I2COAR,##FIELD)

  #define _I2C_I2COAR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2COAR##N##_ADDR,I2C,I2COAR,##FIELD,field)

  #define _I2C_I2COAR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2COAR##N##_ADDR,I2C,I2COAR,##FIELD,##SYM)

  #define _I2C_I2COAR0_FGET(FIELD) _I2C_I2COAR_FGET(0,##FIELD)
  #define _I2C_I2COAR1_FGET(FIELD) _I2C_I2COAR_FGET(1,##FIELD)

  #define _I2C_I2COAR0_FSET(FIELD,f) _I2C_I2COAR_FSET(0,##FIELD,f)
  #define _I2C_I2COAR1_FSET(FIELD,f) _I2C_I2COAR_FSET(1,##FIELD,f)

  #define _I2C_I2COAR0_FSETS(FIELD,SYM) _I2C_I2COAR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2COAR1_FSETS(FIELD,SYM) _I2C_I2COAR_FSETS(1,##FIELD,##SYM)

/******************************************************************************\
*  (Keeping the old definitions for backward compatibility)
*  ___________________
* |                   |
* |  I 2 C I M R      |
* |___________________|
*
* I2CIMR0    - I2C0 Interrupt Mask/Status register
* I2CIMR1    - I2C1 Interrupt Mask/Status register
*
* FIELDS (msb -> lsb)
* (rw) ICXRDY
* (rw) ICRRDY
* (rw) ARDY
* (rw) NACK
* (rw) AL
\******************************************************************************/
#if (!(CHIP_6410 | CHIP_6413| CHIP_6418 ))

  #define _I2C_I2CIMR_OFFSET           1

  #define _I2C_I2CIMR0_ADDR            0x01B40004
  #define _I2C_I2CIMR1_ADDR            0x01B44004

  #define _I2C_I2CIMR_ICXRDY_MASK          0x00000010u
  #define _I2C_I2CIMR_ICXRDY_SHIFT         0x00000004u
  #define  I2C_I2CIMR_ICXRDY_DEFAULT       0x00000000u
  #define  I2C_I2CIMR_ICXRDY_OF(x)         _VALUEOF(x)
  #define  I2C_I2CIMR_ICXRDY_MSK           0x00000000u
  #define  I2C_I2CIMR_ICXRDY_UNMSK         0x00000001u

  #define _I2C_I2CIMR_ICRRDY_MASK          0x00000008u
  #define _I2C_I2CIMR_ICRRDY_SHIFT         0x00000003u
  #define  I2C_I2CIMR_ICRRDY_DEFAULT       0x00000000u
  #define  I2C_I2CIMR_ICRRDY_OF(x)         _VALUEOF(x)
  #define  I2C_I2CIMR_ICRRDY_MSK           0x00000000u
  #define  I2C_I2CIMR_ICRRDY_UNMSK         0x00000001u

  #define _I2C_I2CIMR_ARDY_MASK            0x00000004u
  #define _I2C_I2CIMR_ARDY_SHIFT           0x00000002u
  #define  I2C_I2CIMR_ARDY_DEFAULT         0x00000000u
  #define  I2C_I2CIMR_ARDY_OF(x)           _VALUEOF(x)
  #define  I2C_I2CIMR_ARDY_MSK             0x00000000u
  #define  I2C_I2CIMR_ARDY_UNMSK           0x00000001u

  #define _I2C_I2CIMR_NACK_MASK            0x00000002u
  #define _I2C_I2CIMR_NACK_SHIFT           0x00000001u
  #define  I2C_I2CIMR_NACK_DEFAULT         0x00000000u
  #define  I2C_I2CIMR_NACK_OF(x)           _VALUEOF(x)
  #define  I2C_I2CIMR_NACK_MSK             0x00000000u
  #define  I2C_I2CIMR_NACK_UNMSK           0x00000001u

  #define _I2C_I2CIMR_AL_MASK              0x00000001u
  #define _I2C_I2CIMR_AL_SHIFT             0x00000000u
  #define  I2C_I2CIMR_AL_DEFAULT           0x00000000u
  #define  I2C_I2CIMR_AL_OF(x)             _VALUEOF(x)
  #define  I2C_I2CIMR_AL_MSK               0x00000000u
  #define  I2C_I2CIMR_AL_UNMSK             0x00000001u


  #define  I2C_I2CIMR_OF(x)                _VALUEOF(x)

  #define I2C_I2CIMR_DEFAULT (Uint32)(\
      _PER_FDEFAULT(I2C,I2CIMR,ICXRDY)\
     |_PER_FDEFAULT(I2C,I2CIMR,ICRRDY)\
     |_PER_FDEFAULT(I2C,I2CIMR,ARDY)\
     |_PER_FDEFAULT(I2C,I2CIMR,NACK)\
     |_PER_FDEFAULT(I2C,I2CIMR,AL)\
  )

  #define I2C_I2CIMR_RMK(icxrdy,icrrdy,ardy,nack,al) (Uint32)(\
      _PER_FMK(I2C,I2CIMR,ICXRDY,icxrdy)\
     |_PER_FMK(I2C,I2CIMR,ICRRDY,icrrdy)\
     |_PER_FMK(I2C,I2CIMR,ARDY,ardy)\
     |_PER_FMK(I2C,I2CIMR,NACK,nack)\
     |_PER_FMK(I2C,I2CIMR,AL,al)\
  )
  
   
  #define _I2C_I2CIMR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CIMR##N##_ADDR,I2C,I2CIMR,##FIELD)

  #define _I2C_I2CIMR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CIMR##N##_ADDR,I2C,I2CIMR,##FIELD,field)

  #define _I2C_I2CIMR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CIMR##N##_ADDR,I2C,I2CIMR,##FIELD,##SYM)

  #define _I2C_I2CIMR0_FGET(FIELD) _I2C_I2CIMR_FGET(0,##FIELD)
  #define _I2C_I2CIMR1_FGET(FIELD) _I2C_I2CIMR_FGET(1,##FIELD)

  #define _I2C_I2CIMR0_FSET(FIELD,f) _I2C_I2CIMR_FSET(0,##FIELD,f)
  #define _I2C_I2CIMR1_FSET(FIELD,f) _I2C_I2CIMR_FSET(1,##FIELD,f)

  #define _I2C_I2CIMR0_FSETS(FIELD,SYM) _I2C_I2CIMR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CIMR1_FSETS(FIELD,SYM) _I2C_I2CIMR_FSETS(1,##FIELD,##SYM)
#endif

/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C I E R      |
* |___________________|
*
* I2CIER0    - I2C0 Interrupt Mask/Status register
* I2CIER1    - I2C1 Interrupt Mask/Status register
*
* FIELDS (msb -> lsb)
* (rw) AAS(1)
* (rw) SCD(1)
* (rw) ICXRDY
* (rw) ICRRDY
* (rw) ARDY
* (rw) NACK
* (rw) AL
*
*  (1) For  C6418/C6413/C6410 only
\******************************************************************************/
  #define _I2C_I2CIER_OFFSET           1

  #define _I2C_I2CIER0_ADDR            0x01B40004
  #define _I2C_I2CIER1_ADDR            0x01B44004

#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CIER_AAS_MASK             0x00000040u
  #define _I2C_I2CIER_AAS_SHIFT            0x00000006u
  #define  I2C_I2CIER_AAS_DEFAULT          0x00000000u
  #define  I2C_I2CIER_AAS_OF(x)            _VALUEOF(x)
  #define  I2C_I2CIER_AAS_MSK              0x00000000u
  #define  I2C_I2CIER_AAS_UNMSK            0x00000001u

  #define _I2C_I2CIER_SCD_MASK             0x00000020u
  #define _I2C_I2CIER_SCD_SHIFT            0x00000005u
  #define  I2C_I2CIER_SCD_DEFAULT          0x00000000u
  #define  I2C_I2CIER_SCD_OF(x)            _VALUEOF(x)
  #define  I2C_I2CIER_SCD_MSK              0x00000000u
  #define  I2C_I2CIER_SCD_UNMSK            0x00000001u
#endif

  #define _I2C_I2CIER_ICXRDY_MASK          0x00000010u
  #define _I2C_I2CIER_ICXRDY_SHIFT         0x00000004u
  #define  I2C_I2CIER_ICXRDY_DEFAULT       0x00000000u
  #define  I2C_I2CIER_ICXRDY_OF(x)         _VALUEOF(x)
  #define  I2C_I2CIER_ICXRDY_MSK           0x00000000u
  #define  I2C_I2CIER_ICXRDY_UNMSK         0x00000001u

  #define _I2C_I2CIER_ICRRDY_MASK          0x00000008u
  #define _I2C_I2CIER_ICRRDY_SHIFT         0x00000003u
  #define  I2C_I2CIER_ICRRDY_DEFAULT       0x00000000u
  #define  I2C_I2CIER_ICRRDY_OF(x)         _VALUEOF(x)
  #define  I2C_I2CIER_ICRRDY_MSK           0x00000000u
  #define  I2C_I2CIER_ICRRDY_UNMSK         0x00000001u

  #define _I2C_I2CIER_ARDY_MASK            0x00000004u
  #define _I2C_I2CIER_ARDY_SHIFT           0x00000002u
  #define  I2C_I2CIER_ARDY_DEFAULT         0x00000000u
  #define  I2C_I2CIER_ARDY_OF(x)           _VALUEOF(x)
  #define  I2C_I2CIER_ARDY_MSK             0x00000000u
  #define  I2C_I2CIER_ARDY_UNMSK           0x00000001u

  #define _I2C_I2CIER_NACK_MASK            0x00000002u
  #define _I2C_I2CIER_NACK_SHIFT           0x00000001u
  #define  I2C_I2CIER_NACK_DEFAULT         0x00000000u
  #define  I2C_I2CIER_NACK_OF(x)           _VALUEOF(x)
  #define  I2C_I2CIER_NACK_MSK             0x00000000u
  #define  I2C_I2CIER_NACK_UNMSK           0x00000001u

  #define _I2C_I2CIER_AL_MASK              0x00000001u
  #define _I2C_I2CIER_AL_SHIFT             0x00000000u
  #define  I2C_I2CIER_AL_DEFAULT           0x00000000u
  #define  I2C_I2CIER_AL_OF(x)             _VALUEOF(x)
  #define  I2C_I2CIER_AL_MSK               0x00000000u
  #define  I2C_I2CIER_AL_UNMSK             0x00000001u


  #define  I2C_I2CIER_OF(x)                _VALUEOF(x)

#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define I2C_I2CIER_DEFAULT (Uint32)(\
      _PER_FDEFAULT(I2C,I2CIER,ICXRDY)\
     |_PER_FDEFAULT(I2C,I2CIER,ICRRDY)\
     |_PER_FDEFAULT(I2C,I2CIER,ARDY)\
     |_PER_FDEFAULT(I2C,I2CIER,NACK)\
     |_PER_FDEFAULT(I2C,I2CIER,AL)\
  )

  #define I2C_I2CIER_RMK(icxrdy,icrrdy,ardy,nack,al) (Uint32)(\
      _PER_FMK(I2C,I2CIER,ICXRDY,icxrdy)\
     |_PER_FMK(I2C,I2CIER,ICRRDY,icrrdy)\
     |_PER_FMK(I2C,I2CIER,ARDY,ardy)\
     |_PER_FMK(I2C,I2CIER,NACK,nack)\
     |_PER_FMK(I2C,I2CIER,AL,al)\
  )
#else
  #define I2C_I2CIER_DEFAULT (Uint32)(\
      _PER_FDEFAULT(I2C,I2CIER,AAS)\
     |_PER_FDEFAULT(I2C,I2CIER,SCD)\
     |_PER_FDEFAULT(I2C,I2CIER,ICXRDY)\
     |_PER_FDEFAULT(I2C,I2CIER,ICRRDY)\
     |_PER_FDEFAULT(I2C,I2CIER,ARDY)\
     |_PER_FDEFAULT(I2C,I2CIER,NACK)\
     |_PER_FDEFAULT(I2C,I2CIER,AL)\
  )

  #define I2C_I2CIER_RMK(aas,scd,icxrdy,icrrdy,ardy,nack,al) (Uint32)(\
      _PER_FMK(I2C,I2CIER,AAS,aas)\
     |_PER_FMK(I2C,I2CIER,SCD,scd)\
     |_PER_FMK(I2C,I2CIER,ICXRDY,icxrdy)\
     |_PER_FMK(I2C,I2CIER,ICRRDY,icrrdy)\
     |_PER_FMK(I2C,I2CIER,ARDY,ardy)\
     |_PER_FMK(I2C,I2CIER,NACK,nack)\
     |_PER_FMK(I2C,I2CIER,AL,al)\
  )
#endif  
   
  #define _I2C_I2CIER_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CIER##N##_ADDR,I2C,I2CIER,##FIELD)

  #define _I2C_I2CIER_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CIER##N##_ADDR,I2C,I2CIER,##FIELD,field)

  #define _I2C_I2CIER_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CIER##N##_ADDR,I2C,I2CIER,##FIELD,##SYM)

  #define _I2C_I2CIER0_FGET(FIELD) _I2C_I2CIER_FGET(0,##FIELD)
  #define _I2C_I2CIER1_FGET(FIELD) _I2C_I2CIER_FGET(1,##FIELD)

  #define _I2C_I2CIER0_FSET(FIELD,f) _I2C_I2CIER_FSET(0,##FIELD,f)
  #define _I2C_I2CIER1_FSET(FIELD,f) _I2C_I2CIER_FSET(1,##FIELD,f)

  #define _I2C_I2CIER0_FSETS(FIELD,SYM) _I2C_I2CIER_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CIER1_FSETS(FIELD,SYM) _I2C_I2CIER_FSETS(1,##FIELD,##SYM)

/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C S T R      |
* |___________________|
*
* I2CSTR0    - I2C0 Interrupt Status register
* I2CSTR1    - I2C1 Interrupt Status register
*
* FIELDS (msb -> lsb)
* (rc)  SDIR(1)
* (rc)  NACKSNT
* (rc)  BB
* (r)   RSFULL
* (r)   XSMT
* (r)   AAS
* (r)   AD0
* (rc)  SCD(1)
* (rc)  ICXRDY
* (rc)  ICRRDY
* (rc)  ARDY
* (rc)  NACK
* (rc)  AL
*
* (1) For  C6418/C6413/C6410 only
\******************************************************************************/
  #define _I2C_I2CSTR_OFFSET                2

  #define _I2C_I2CSTR0_ADDR                 0x01B40008
  #define _I2C_I2CSTR1_ADDR                 0x01B44008

#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CSTR_SDIR_MASK             0x00004000u
  #define _I2C_I2CSTR_SDIR_SHIFT            0x0000000Eu
  #define  I2C_I2CSTR_SDIR_DEFAULT          0x00000000u
  #define  I2C_I2CSTR_SDIR_OF(x)            _VALUEOF(x)
  #define  I2C_I2CSTR_SDIR_NONE             0x00000000u
  #define  I2C_I2CSTR_SDIR_INT              0x00000001u
  #define  I2C_I2CSTR_SDIR_CLR              0x00000001u
#endif

  #define _I2C_I2CSTR_NACKSNT_MASK          0x00002000u
  #define _I2C_I2CSTR_NACKSNT_SHIFT         0x0000000Du
  #define  I2C_I2CSTR_NACKSNT_DEFAULT       0x00000000u
  #define  I2C_I2CSTR_NACKSNT_OF(x)         _VALUEOF(x)
  #define  I2C_I2CSTR_NACKSNT_NONE          0x00000000u
  #define  I2C_I2CSTR_NACKSNT_INT           0x00000001u
  #define  I2C_I2CSTR_NACKSNT_CLR           0x00000001u

  #define _I2C_I2CSTR_BB_MASK               0x00001000u
  #define _I2C_I2CSTR_BB_SHIFT              0x0000000Cu
  #define  I2C_I2CSTR_BB_DEFAULT            0x00000000u
  #define  I2C_I2CSTR_BB_OF(x)              _VALUEOF(x)
  #define  I2C_I2CSTR_BB_NONE               0x00000000u
  #define  I2C_I2CSTR_BB_INT                0x00000001u
  #define  I2C_I2CSTR_BB_CLR                0x00000001u

  #define _I2C_I2CSTR_RSFULL_MASK           0x00000800u
  #define _I2C_I2CSTR_RSFULL_SHIFT          0x0000000Bu
  #define  I2C_I2CSTR_RSFULL_DEFAULT        0x00000000u
  #define  I2C_I2CSTR_RSFULL_OF(x)          _VALUEOF(x)
  #define  I2C_I2CSTR_RSFULL_NONE           0x00000000u
  #define  I2C_I2CSTR_RSFULL_INT            0x00000001u

  #define _I2C_I2CSTR_XSMT_MASK             0x00000400u
  #define _I2C_I2CSTR_XSMT_SHIFT            0x0000000Au
  #define  I2C_I2CSTR_XSMT_DEFAULT          0x00000001u
  #define  I2C_I2CSTR_XSMT_OF(x)            _VALUEOF(x)
  #define  I2C_I2CSTR_XSMT_NONE             0x00000000u
  #define  I2C_I2CSTR_XSMT_INT              0x00000001u

  #define _I2C_I2CSTR_AAS_MASK              0x00000200u
  #define _I2C_I2CSTR_AAS_SHIFT             0x00000009u
  #define  I2C_I2CSTR_AAS_DEFAULT           0x00000000u
  #define  I2C_I2CSTR_AAS_OF(x)             _VALUEOF(x)
  #define  I2C_I2CSTR_AAS_NONE              0x00000000u
  #define  I2C_I2CSTR_AAS_INT               0x00000001u

  #define _I2C_I2CSTR_AD0_MASK              0x00000100u
  #define _I2C_I2CSTR_AD0_SHIFT             0x00000008u
  #define  I2C_I2CSTR_AD0_DEFAULT           0x00000000u
  #define  I2C_I2CSTR_AD0_OF(x)             _VALUEOF(x)
  #define  I2C_I2CSTR_AD0_NONE              0x00000000u
  #define  I2C_I2CSTR_AD0_INT               0x00000001u

#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CSTR_SCD_MASK              0x00000020u
  #define _I2C_I2CSTR_SCD_SHIFT             0x00000005u
  #define  I2C_I2CSTR_SCD_DEFAULT           0x00000000u
  #define  I2C_I2CSTR_SCD_OF(x)             _VALUEOF(x)
  #define  I2C_I2CSTR_SCD_NONE              0x00000000u
  #define  I2C_I2CSTR_SCD_INT               0x00000001u
  #define  I2C_I2CSTR_SCD_CLR               0x00000001u
#endif

  #define _I2C_I2CSTR_ICXRDY_MASK           0x00000010u
  #define _I2C_I2CSTR_ICXRDY_SHIFT          0x00000004u
  #define  I2C_I2CSTR_ICXRDY_DEFAULT        0x00000001u
  #define  I2C_I2CSTR_ICXRDY_OF(x)          _VALUEOF(x)
  #define  I2C_I2CSTR_ICXRDY_NONE           0x00000000u
  #define  I2C_I2CSTR_ICXRDY_INT            0x00000001u
  #define  I2C_I2CSTR_ICXRDY_CLR            0x00000001u

  #define _I2C_I2CSTR_ICRRDY_MASK           0x00000008u
  #define _I2C_I2CSTR_ICRRDY_SHIFT          0x00000003u
  #define  I2C_I2CSTR_ICRRDY_DEFAULT        0x00000000u
  #define  I2C_I2CSTR_ICRRDY_OF(x)          _VALUEOF(x)
  #define  I2C_I2CSTR_ICRRDY_NONE           0x00000000u
  #define  I2C_I2CSTR_ICRRDY_INT            0x00000001u
  #define  I2C_I2CSTR_ICRRDY_CLR            0x00000001u

  #define _I2C_I2CSTR_ARDY_MASK             0x00000004u
  #define _I2C_I2CSTR_ARDY_SHIFT            0x00000002u
  #define  I2C_I2CSTR_ARDY_DEFAULT          0x00000000u
  #define  I2C_I2CSTR_ARDY_OF(x)            _VALUEOF(x)
  #define  I2C_I2CSTR_ARDY_NONE             0x00000000u
  #define  I2C_I2CSTR_ARDY_INT              0x00000001u
  #define  I2C_I2CSTR_ARDY_CLR              0x00000001u

  #define _I2C_I2CSTR_NACK_MASK             0x00000002u
  #define _I2C_I2CSTR_NACK_SHIFT            0x00000001u
  #define  I2C_I2CSTR_NACK_DEFAULT          0x00000000u
  #define  I2C_I2CSTR_NACK_OF(x)            _VALUEOF(x)
  #define  I2C_I2CSTR_NACK_NONE             0x00000000u
  #define  I2C_I2CSTR_NACK_INT              0x00000001u
  #define  I2C_I2CSTR_NACK_CLR              0x00000001u

  #define _I2C_I2CSTR_AL_MASK               0x00000001u
  #define _I2C_I2CSTR_AL_SHIFT              0x00000000u
  #define  I2C_I2CSTR_AL_DEFAULT            0x00000000u
  #define  I2C_I2CSTR_AL_OF(x)              _VALUEOF(x)
  #define  I2C_I2CSTR_AL_NONE               0x00000000u
  #define  I2C_I2CSTR_AL_INT                0x00000001u
  #define  I2C_I2CSTR_AL_CLR                0x00000001u


  #define  I2C_I2CSTR_OF(x)                _VALUEOF(x)

#if !(CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define I2C_I2CSTR_DEFAULT (Uint32)(\
      _PER_FDEFAULT(I2C,I2CSTR,NACKSNT)\
     |_PER_FDEFAULT(I2C,I2CSTR,BB)\
     |_PER_FDEFAULT(I2C,I2CSTR,RSFULL)\
     |_PER_FDEFAULT(I2C,I2CSTR,XSMT)\
     |_PER_FDEFAULT(I2C,I2CSTR,AAS)\
     |_PER_FDEFAULT(I2C,I2CSTR,AD0)\
     |_PER_FDEFAULT(I2C,I2CSTR,ICXRDY)\
     |_PER_FDEFAULT(I2C,I2CSTR,ICRRDY)\
     |_PER_FDEFAULT(I2C,I2CSTR,ARDY)\
     |_PER_FDEFAULT(I2C,I2CSTR,NACK)\
     |_PER_FDEFAULT(I2C,I2CSTR,AL)\
  )
#else
  #define I2C_I2CSTR_DEFAULT (Uint32)(\
      _PER_FDEFAULT(I2C,I2CSTR,SDIR)\
     |_PER_FDEFAULT(I2C,I2CSTR,NACKSNT)\
     |_PER_FDEFAULT(I2C,I2CSTR,BB)\
     |_PER_FDEFAULT(I2C,I2CSTR,RSFULL)\
     |_PER_FDEFAULT(I2C,I2CSTR,XSMT)\
     |_PER_FDEFAULT(I2C,I2CSTR,AAS)\
     |_PER_FDEFAULT(I2C,I2CSTR,AD0)\
     |_PER_FDEFAULT(I2C,I2CSTR,SCD)\
     |_PER_FDEFAULT(I2C,I2CSTR,ICXRDY)\
     |_PER_FDEFAULT(I2C,I2CSTR,ICRRDY)\
     |_PER_FDEFAULT(I2C,I2CSTR,ARDY)\
     |_PER_FDEFAULT(I2C,I2CSTR,NACK)\
     |_PER_FDEFAULT(I2C,I2CSTR,AL)\
  )
#endif
#if !(CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define I2C_I2CSTR_RMK(nacksnt,bb,icxrdy,icrrdy,ardy,nack,al) (Uint32)(\
      _PER_FMK(I2C,I2CSTR,NACKSNT,nacksnt)\
     |_PER_FMK(I2C,I2CSTR,BB,bb)\
     |_PER_FMK(I2C,I2CSTR,ICXRDY,icxrdy)\
     |_PER_FMK(I2C,I2CSTR,ICRRDY,icrrdy)\
     |_PER_FMK(I2C,I2CSTR,ARDY,ardy)\
     |_PER_FMK(I2C,I2CSTR,NACK,nack)\
     |_PER_FMK(I2C,I2CSTR,AL,al)\
  )
#else
  #define I2C_I2CSTR_RMK(sdir,nacksnt,bb,scd,icxrdy,icrrdy,ardy,nack,al) (Uint32)(\
      _PER_FMK(I2C,I2CSTR,SDIR,sdir)\
      _PER_FMK(I2C,I2CSTR,NACKSNT,nacksnt)\
     |_PER_FMK(I2C,I2CSTR,BB,bb)\
     |_PER_FMK(I2C,I2CSTR,SCD,scd)\
     |_PER_FMK(I2C,I2CSTR,ICXRDY,icxrdy)\
     |_PER_FMK(I2C,I2CSTR,ICRRDY,icrrdy)\
     |_PER_FMK(I2C,I2CSTR,ARDY,ardy)\
     |_PER_FMK(I2C,I2CSTR,NACK,nack)\
     |_PER_FMK(I2C,I2CSTR,AL,al)\
  )
#endif
  #define _I2C_I2CSTR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CSTR##N##_ADDR,I2C,I2CSTR,##FIELD)

  #define _I2C_I2CSTR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CSTR##N##_ADDR,I2C,I2CSTR,##FIELD,field)

  #define _I2C_I2CSTR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CSTR##N##_ADDR,I2C,I2CSTR,##FIELD,##SYM)

  #define _I2C_I2CSTR0_FGET(FIELD) _I2C_I2CSTR_FGET(0,##FIELD)
  #define _I2C_I2CSTR1_FGET(FIELD) _I2C_I2CSTR_FGET(1,##FIELD)

  #define _I2C_I2CSTR0_FSET(FIELD,f) _I2C_I2CSTR_FSET(0,##FIELD,f)
  #define _I2C_I2CSTR1_FSET(FIELD,f) _I2C_I2CSTR_FSET(1,##FIELD,f)

  #define _I2C_I2CSTR0_FSETS(FIELD,SYM) _I2C_I2CSTR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CSTR1_FSETS(FIELD,SYM) _I2C_I2CSTR_FSETS(1,##FIELD,##SYM)


/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C C L K L    |
* |___________________|
*
* I2CCLKL0   - I2C0 Clock Divider Low register
* I2CCLKL1   - I2C1 Clock Divider Low register
*
* FIELDS (msb -> lsb)
* (rw) ICCL
*
\******************************************************************************/
  #define _I2C_I2CCLKL_OFFSET           3

  #define _I2C_I2CCLKL0_ADDR            0x01B4000C
  #define _I2C_I2CCLKL1_ADDR            0x01B4400C

  #define _I2C_I2CCLKL_ICCL_MASK           0x0000FFFFu
  #define _I2C_I2CCLKL_ICCL_SHIFT          0x00000000u
  #define  I2C_I2CCLKL_ICCL_DEFAULT        0x00000000u
  #define  I2C_I2CCLKL_ICCL_OF(x)          _VALUEOF(x)

  #define  I2C_I2CCLKL_OF(x)             _VALUEOF(x)

  #define I2C_I2CCLKL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CCLKL,ICCL)\
  )

  #define I2C_I2CCLKL_RMK(iccl) (Uint32)(\
     _PER_FMK(I2C,I2CCLKL,ICCL,iccl)\
  )
   
  #define _I2C_I2CCLKL_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CCLKL##N##_ADDR,I2C,I2CCLKL,##FIELD)

  #define _I2C_I2CCLKL_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CCLKL##N##_ADDR,I2C,I2CCLKL,##FIELD,field)

  #define _I2C_I2CCLKL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CCLKL##N##_ADDR,I2C,I2CCLKL,##FIELD,##SYM)

  #define _I2C_I2CCLKL0_FGET(FIELD) _I2C_I2CCLKL_FGET(0,##FIELD)
  #define _I2C_I2CCLKL1_FGET(FIELD) _I2C_I2CCLKL_FGET(1,##FIELD)

  #define _I2C_I2CCLKL0_FSET(FIELD,f) _I2C_I2CCLKL_FSET(0,##FIELD,f)
  #define _I2C_I2CCLKL1_FSET(FIELD,f) _I2C_I2CCLKL_FSET(1,##FIELD,f)

  #define _I2C_I2CCLKL0_FSETS(FIELD,SYM) _I2C_I2CCLKL_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CCLKL1_FSETS(FIELD,SYM) _I2C_I2CCLKL_FSETS(1,##FIELD,##SYM)


/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C C L K H    |
* |___________________|
*
* I2CCLKH0   - I2C0 Clock Divider High register
* I2CCLKH1   - I2C1 Clock Divider High register
*
* FIELDS (msb -> lsb)
* (rw) ICCH
*
\******************************************************************************/
  #define _I2C_I2CCLKH_OFFSET           4

  #define _I2C_I2CCLKH0_ADDR            0x01B40010
  #define _I2C_I2CCLKH1_ADDR            0x01B44010

  #define _I2C_I2CCLKH_ICCH_MASK        0x0000FFFFu
  #define _I2C_I2CCLKH_ICCH_SHIFT       0x00000000u
  #define  I2C_I2CCLKH_ICCH_DEFAULT     0x00000000u
  #define  I2C_I2CCLKH_ICCH_OF(x)       _VALUEOF(x)

  #define  I2C_I2CCLKH_OF(x)             _VALUEOF(x)

  #define I2C_I2CCLKH_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CCLKH,ICCH)\
  )

  #define I2C_I2CCLKH_RMK(icch) (Uint32)(\
     _PER_FMK(I2C,I2CCLKH,ICCH,icch)\
  )
   
  #define _I2C_I2CCLKH_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CCLKH##N##_ADDR,I2C,I2CCLKH,##FIELD)

  #define _I2C_I2CCLKH_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CCLKH##N##_ADDR,I2C,I2CCLKH,##FIELD,field)

  #define _I2C_I2CCLKH_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CCLKH##N##_ADDR,I2C,I2CCLKH,##FIELD,##SYM)

  #define _I2C_I2CCLKH0_FGET(FIELD) _I2C_I2CCLKH_FGET(0,##FIELD)
  #define _I2C_I2CCLKH1_FGET(FIELD) _I2C_I2CCLKH_FGET(1,##FIELD)

  #define _I2C_I2CCLKH0_FSET(FIELD,f) _I2C_I2CCLKH_FSET(0,##FIELD,f)
  #define _I2C_I2CCLKH1_FSET(FIELD,f) _I2C_I2CCLKH_FSET(1,##FIELD,f)

  #define _I2C_I2CCLKH0_FSETS(FIELD,SYM) _I2C_I2CCLKH_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CCLKH1_FSETS(FIELD,SYM) _I2C_I2CCLKH_FSETS(1,##FIELD,##SYM)


/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C C N T      |
* |___________________|
*
* I2CCNT0    - I2C0 Data Count register
* I2CCNT1    - I2C1 Data Count register
*
* FIELDS (msb -> lsb)
* (rw) ICDC
\******************************************************************************/
  #define _I2C_I2CCNT_OFFSET           5

  #define _I2C_I2CCNT0_ADDR            0x01B40014
  #define _I2C_I2CCNT1_ADDR            0x01B44014

  #define _I2C_I2CCNT_ICDC_MASK        0x0000FFFFu
  #define _I2C_I2CCNT_ICDC_SHIFT       0x00000000u
  #define  I2C_I2CCNT_ICDC_DEFAULT     0x00000000u
  #define  I2C_I2CCNT_ICDC_OF(x)       _VALUEOF(x)

  #define  I2C_I2CCNT_OF(x)             _VALUEOF(x)

  #define I2C_I2CCNT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CCNT,ICDC)\
  )

  #define I2C_I2CCNT_RMK(icdc) (Uint32)(\
     _PER_FMK(I2C,I2CCNT,ICDC,icdc)\
  )
   
  #define _I2C_I2CCNT_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CCNT##N##_ADDR,I2C,I2CCNT,##FIELD)

  #define _I2C_I2CCNT_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CCNT##N##_ADDR,I2C,I2CCNT,##FIELD,field)

  #define _I2C_I2CCNT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CCNT##N##_ADDR,I2C,I2CCNT,##FIELD,##SYM)

  #define _I2C_I2CCNT0_FGET(FIELD) _I2C_I2CCNT_FGET(0,##FIELD)
  #define _I2C_I2CCNT1_FGET(FIELD) _I2C_I2CCNT_FGET(1,##FIELD)

  #define _I2C_I2CCNT0_FSET(FIELD,f) _I2C_I2CCNT_FSET(0,##FIELD,f)
  #define _I2C_I2CCNT1_FSET(FIELD,f) _I2C_I2CCNT_FSET(1,##FIELD,f)

  #define _I2C_I2CCNT0_FSETS(FIELD,SYM) _I2C_I2CCNT_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CCNT1_FSETS(FIELD,SYM) _I2C_I2CCNT_FSETS(1,##FIELD,##SYM)


/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C D R R      |
* |___________________|
*
* I2CDRR0    - I2C0 Data Receive register
* I2CDRR1    - I2C1 Data Receive register
*
* FIELDS (msb -> lsb)
* (r) D
\******************************************************************************/
  #define _I2C_I2CDRR_OFFSET           6

  #define _I2C_I2CDRR0_ADDR            0x01B40018
  #define _I2C_I2CDRR1_ADDR            0x01B44018

  #define _I2C_I2CDRR_D_MASK        0x000000FFu
  #define _I2C_I2CDRR_D_SHIFT       0x00000000u
  #define  I2C_I2CDRR_D_DEFAULT     0x00000000u
  #define  I2C_I2CDRR_D_OF(x)       _VALUEOF(x)

  #define  I2C_I2CDRR_OF(x)             _VALUEOF(x)

  #define I2C_I2CDRR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CDRR,D)\
  )

  #define I2C_I2CDRR_RMK(d) (Uint32)(\
     _PER_FMK(I2C,I2CDRR,D,d)\
  )
   
  #define _I2C_I2CDRR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CDRR##N##_ADDR,I2C,I2CDRR,##FIELD)

  #define _I2C_I2CDRR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CDRR##N##_ADDR,I2C,I2CDRR,##FIELD,field)

  #define _I2C_I2CDRR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CDRR##N##_ADDR,I2C,I2CDRR,##FIELD,##SYM)

  #define _I2C_I2CDRR0_FGET(FIELD) _I2C_I2CDRR_FGET(0,##FIELD)
  #define _I2C_I2CDRR1_FGET(FIELD) _I2C_I2CDRR_FGET(1,##FIELD)

  #define _I2C_I2CDRR0_FSET(FIELD,f) _I2C_I2CDRR_FSET(0,##FIELD,f)
  #define _I2C_I2CDRR1_FSET(FIELD,f) _I2C_I2CDRR_FSET(1,##FIELD,f)

  #define _I2C_I2CDRR0_FSETS(FIELD,SYM) _I2C_I2CDRR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CDRR1_FSETS(FIELD,SYM) _I2C_I2CDRR_FSETS(1,##FIELD,##SYM)


/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C S A R      |
* |___________________|
*
* I2CSAR0    - I2C0 Slave Address register
* I2CSAR1    - I2C1 Slave Address register
*
* FIELDS (msb -> lsb)
* (rw) A
\******************************************************************************/
  #define _I2C_I2CSAR_OFFSET           7

  #define _I2C_I2CSAR0_ADDR            0x01B4001C
  #define _I2C_I2CSAR1_ADDR            0x01B4401C

  #define _I2C_I2CSAR_A_MASK           0x000003FFu
  #define _I2C_I2CSAR_A_SHIFT          0x00000000u
  #define  I2C_I2CSAR_A_DEFAULT        0x000003FFu /*???*/
  #define  I2C_I2CSAR_A_OF(x)          _VALUEOF(x)

  #define  I2C_I2CSAR_OF(x)             _VALUEOF(x)

  #define I2C_I2CSAR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CSAR,A)\
  )

  #define I2C_I2CSAR_RMK(a) (Uint32)(\
     _PER_FMK(I2C,I2CSAR,A,a)\
  )
   
  #define _I2C_I2CSAR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CSAR##N##_ADDR,I2C,I2CSAR,##FIELD)

  #define _I2C_I2CSAR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CSAR##N##_ADDR,I2C,I2CSAR,##FIELD,field)

  #define _I2C_I2CSAR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CSAR##N##_ADDR,I2C,I2CSAR,##FIELD,##SYM)

  #define _I2C_I2CSAR0_FGET(FIELD) _I2C_I2CSAR_FGET(0,##FIELD)
  #define _I2C_I2CSAR1_FGET(FIELD) _I2C_I2CSAR_FGET(1,##FIELD)

  #define _I2C_I2CSAR0_FSET(FIELD,f) _I2C_I2CSAR_FSET(0,##FIELD,f)
  #define _I2C_I2CSAR1_FSET(FIELD,f) _I2C_I2CSAR_FSET(1,##FIELD,f)

  #define _I2C_I2CSAR0_FSETS(FIELD,SYM) _I2C_I2CSAR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CSAR1_FSETS(FIELD,SYM) _I2C_I2CSAR_FSETS(1,##FIELD,##SYM)


/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C D X R      |
* |___________________|
*
* I2CDXR0    - I2C0 Data Transmit register
* I2CDXR1    - I2C1 Data Transmit register
*
* FIELDS (msb -> lsb)
* (rw) D
\******************************************************************************/
  #define _I2C_I2CDXR_OFFSET           8

  #define _I2C_I2CDXR0_ADDR            0x01B40020
  #define _I2C_I2CDXR1_ADDR            0x01B44020

  #define _I2C_I2CDXR_D_MASK           0x000000FFu
  #define _I2C_I2CDXR_D_SHIFT          0x00000000u
  #define  I2C_I2CDXR_D_DEFAULT        0x00000000u
  #define  I2C_I2CDXR_D_OF(x)          _VALUEOF(x)

  #define  I2C_I2CDXR_OF(x)             _VALUEOF(x)

  #define I2C_I2CDXR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CDXR,D)\
  )

  #define I2C_I2CDXR_RMK(d) (Uint32)(\
     _PER_FMK(I2C,I2CDXR,D,d)\
  )
   
  #define _I2C_I2CDXR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CDXR##N##_ADDR,I2C,I2CDXR,##FIELD)

  #define _I2C_I2CDXR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CDXR##N##_ADDR,I2C,I2CDXR,##FIELD,field)

  #define _I2C_I2CDXR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CDXR##N##_ADDR,I2C,I2CDXR,##FIELD,##SYM)

  #define _I2C_I2CDXR0_FGET(FIELD) _I2C_I2CDXR_FGET(0,##FIELD)
  #define _I2C_I2CDXR1_FGET(FIELD) _I2C_I2CDXR_FGET(1,##FIELD)

  #define _I2C_I2CDXR0_FSET(FIELD,f) _I2C_I2CDXR_FSET(0,##FIELD,f)
  #define _I2C_I2CDXR1_FSET(FIELD,f) _I2C_I2CDXR_FSET(1,##FIELD,f)

  #define _I2C_I2CDXR0_FSETS(FIELD,SYM) _I2C_I2CDXR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CDXR1_FSETS(FIELD,SYM) _I2C_I2CDXR_FSETS(1,##FIELD,##SYM)

/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C M D R      |
* |___________________|
*
* I2CMDR0    - I2C0 Mode register
* I2CMDR1    - I2C1 Mode register
*
* FIELDS (msb -> lsb)
* (rw) NACKMOD
* (rw) FREE
* (rw) STT
* (rw) STP
* (rw) MST
* (rw) TRX
* (rw) XA
* (rw) RM
* (rw) DLB
* (rw) IRS
* (rw) STB
* (rw) FDF
* (rw) BC
\******************************************************************************/
  #define _I2C_I2CMDR_OFFSET           9

  #define _I2C_I2CMDR0_ADDR            0x01B40024
  #define _I2C_I2CMDR1_ADDR            0x01B44024

  #define _I2C_I2CMDR_NACKMOD_MASK     0x00008000u
  #define _I2C_I2CMDR_NACKMOD_SHIFT    0x0000000Fu
  #define  I2C_I2CMDR_NACKMOD_DEFAULT  0x00000000u
  #define  I2C_I2CMDR_NACKMOD_OF(x)    _VALUEOF(x)
  #define  I2C_I2CMDR_NACKMOD_ACK      0x00000000u
  #define  I2C_I2CMDR_NACKMOD_NACK     0x00000001u

  #define _I2C_I2CMDR_FREE_MASK        0x00004000u
  #define _I2C_I2CMDR_FREE_SHIFT       0x0000000Eu
  #define  I2C_I2CMDR_FREE_DEFAULT     0x00000000u
  #define  I2C_I2CMDR_FREE_OF(x)       _VALUEOF(x)
  #define  I2C_I2CMDR_FREE_BSTOP       0x00000000u
  #define  I2C_I2CMDR_FREE_RFREE       0x00000001u

  #define _I2C_I2CMDR_STT_MASK         0x00002000u
  #define _I2C_I2CMDR_STT_SHIFT        0x0000000Du
  #define  I2C_I2CMDR_STT_DEFAULT      0x00000000u
  #define  I2C_I2CMDR_STT_OF(x)        _VALUEOF(x)
  #define  I2C_I2CMDR_STT_NONE         0x00000000u
  #define  I2C_I2CMDR_STT_START        0x00000001u

  #define _I2C_I2CMDR_STP_MASK         0x00000800u
  #define _I2C_I2CMDR_STP_SHIFT        0x0000000Bu
  #define  I2C_I2CMDR_STP_DEFAULT      0x00000000u
  #define  I2C_I2CMDR_STP_OF(x)        _VALUEOF(x)
  #define  I2C_I2CMDR_STP_NONE         0x00000000u
  #define  I2C_I2CMDR_STP_STOP         0x00000001u

  #define _I2C_I2CMDR_MST_MASK         0x00000400u
  #define _I2C_I2CMDR_MST_SHIFT        0x0000000Au
  #define  I2C_I2CMDR_MST_DEFAULT      0x00000000u
  #define  I2C_I2CMDR_MST_OF(x)        _VALUEOF(x)
  #define  I2C_I2CMDR_MST_SLAVE        0x00000000u
  #define  I2C_I2CMDR_MST_MASTER       0x00000001u

  #define _I2C_I2CMDR_TRX_MASK         0x00000200u
  #define _I2C_I2CMDR_TRX_SHIFT        0x00000009u
  #define  I2C_I2CMDR_TRX_DEFAULT      0x00000000u
  #define  I2C_I2CMDR_TRX_OF(x)        _VALUEOF(x)
  #define  I2C_I2CMDR_TRX_RCV          0x00000000u
  #define  I2C_I2CMDR_TRX_XMT          0x00000001u

  #define _I2C_I2CMDR_XA_MASK          0x00000100u
  #define _I2C_I2CMDR_XA_SHIFT         0x00000008u
  #define  I2C_I2CMDR_XA_DEFAULT       0x00000000u
  #define  I2C_I2CMDR_XA_OF(x)         _VALUEOF(x)
  #define  I2C_I2CMDR_XA_7BIT          0x00000000u
  #define  I2C_I2CMDR_XA_10BIT         0x00000001u

  #define _I2C_I2CMDR_RM_MASK          0x00000080u
  #define _I2C_I2CMDR_RM_SHIFT         0x00000007u
  #define  I2C_I2CMDR_RM_DEFAULT       0x00000000u
  #define  I2C_I2CMDR_RM_OF(x)         _VALUEOF(x)
  #define  I2C_I2CMDR_RM_NONE          0x00000000u
  #define  I2C_I2CMDR_RM_REPEAD        0x00000001u

  #define _I2C_I2CMDR_DLB_MASK         0x00000040u
  #define _I2C_I2CMDR_DLB_SHIFT        0x00000006u
  #define  I2C_I2CMDR_DLB_DEFAULT      0x00000000u
  #define  I2C_I2CMDR_DLB_OF(x)        _VALUEOF(x)
  #define  I2C_I2CMDR_DLB_NONE         0x00000000u
  #define  I2C_I2CMDR_DLB_LOOPBACK     0x00000001u

  #define _I2C_I2CMDR_IRS_MASK         0x00000020u
  #define _I2C_I2CMDR_IRS_SHIFT        0x00000005u
  #define  I2C_I2CMDR_IRS_DEFAULT      0x00000000u
  #define  I2C_I2CMDR_IRS_OF(x)        _VALUEOF(x)
  #define  I2C_I2CMDR_IRS_RST          0x00000000u
  #define  I2C_I2CMDR_IRS_NRST         0x00000001u

  #define _I2C_I2CMDR_STB_MASK         0x00000010u
  #define _I2C_I2CMDR_STB_SHIFT        0x00000004u
  #define  I2C_I2CMDR_STB_DEFAULT      0x00000000u
  #define  I2C_I2CMDR_STB_OF(x)        _VALUEOF(x)
  #define  I2C_I2CMDR_STB_NONE         0x00000000u
  #define  I2C_I2CMDR_STB_SET          0x00000001u

  #define _I2C_I2CMDR_FDF_MASK         0x00000008u
  #define _I2C_I2CMDR_FDF_SHIFT        0x00000003u
  #define  I2C_I2CMDR_FDF_DEFAULT      0x00000000u
  #define  I2C_I2CMDR_FDF_OF(x)        _VFDFUEOF(x)
  #define  I2C_I2CMDR_FDF_NONE         0x00000000u
  #define  I2C_I2CMDR_FDF_SET          0x00000001u

  #define _I2C_I2CMDR_BC_MASK          0x00000007u
  #define _I2C_I2CMDR_BC_SHIFT         0x00000000u
  #define  I2C_I2CMDR_BC_DEFAULT       0x00000000u
  #define  I2C_I2CMDR_BC_OF(x)         _VALUEOF(x)
  #define  I2C_I2CMDR_BC_BIT8FDF       0x00000000u
  #define  I2C_I2CMDR_BC_BIT7FDF       0x00000007u
  #define  I2C_I2CMDR_BC_BIT6FDF       0x00000006u
  #define  I2C_I2CMDR_BC_BIT5FDF       0x00000005u
  #define  I2C_I2CMDR_BC_BIT4FDF       0x00000004u
  #define  I2C_I2CMDR_BC_BIT3FDF       0x00000003u
  #define  I2C_I2CMDR_BC_BIT2FDF       0x00000002u
  #define  I2C_I2CMDR_BC_BIT1FDF       0x00000001u

  #define  I2C_I2CMDR_OF(x)                _VALUEOF(x)

  #define I2C_I2CMDR_DEFAULT (Uint32)(\
      _PER_FDEFAULT(I2C,I2CMDR,NACKMOD)\
     |_PER_FDEFAULT(I2C,I2CMDR,FREE)\
     |_PER_FDEFAULT(I2C,I2CMDR,STT)\
     |_PER_FDEFAULT(I2C,I2CMDR,STP)\
     |_PER_FDEFAULT(I2C,I2CMDR,MST)\
     |_PER_FDEFAULT(I2C,I2CMDR,TRX)\
     |_PER_FDEFAULT(I2C,I2CMDR,XA)\
     |_PER_FDEFAULT(I2C,I2CMDR,RM)\
     |_PER_FDEFAULT(I2C,I2CMDR,DLB)\
     |_PER_FDEFAULT(I2C,I2CMDR,IRS)\
     |_PER_FDEFAULT(I2C,I2CMDR,STB)\
     |_PER_FDEFAULT(I2C,I2CMDR,FDF)\
     |_PER_FDEFAULT(I2C,I2CMDR,BC)\
  )

  #define I2C_I2CMDR_RMK(nackmod,free,stt,stp,mst,trx,xa,rm,dlb,irs,stb,fdf,bc) (Uint32)(\
      _PER_FMK(I2C,I2CMDR,NACKMOD,nackmod)\
     |_PER_FMK(I2C,I2CMDR,FREE,free)\
     |_PER_FMK(I2C,I2CMDR,STT,stt)\
     |_PER_FMK(I2C,I2CMDR,STP,stp)\
     |_PER_FMK(I2C,I2CMDR,MST,mst)\
     |_PER_FMK(I2C,I2CMDR,TRX,trx)\
     |_PER_FMK(I2C,I2CMDR,XA,xa)\
     |_PER_FMK(I2C,I2CMDR,RM,rm)\
     |_PER_FMK(I2C,I2CMDR,DLB,dlb)\
     |_PER_FMK(I2C,I2CMDR,IRS,irs)\
     |_PER_FMK(I2C,I2CMDR,STB,stb)\
     |_PER_FMK(I2C,I2CMDR,FDF,fdf)\
     |_PER_FMK(I2C,I2CMDR,BC,bc)\
  )
   
  #define _I2C_I2CMDR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CMDR##N##_ADDR,I2C,I2CMDR,##FIELD)

  #define _I2C_I2CMDR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CMDR##N##_ADDR,I2C,I2CMDR,##FIELD,field)

  #define _I2C_I2CMDR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CMDR##N##_ADDR,I2C,I2CMDR,##FIELD,##SYM)

  #define _I2C_I2CMDR0_FGET(FIELD) _I2C_I2CMDR_FGET(0,##FIELD)
  #define _I2C_I2CMDR1_FGET(FIELD) _I2C_I2CMDR_FGET(1,##FIELD)

  #define _I2C_I2CMDR0_FSET(FIELD,f) _I2C_I2CMDR_FSET(0,##FIELD,f)
  #define _I2C_I2CMDR1_FSET(FIELD,f) _I2C_I2CMDR_FSET(1,##FIELD,f)

  #define _I2C_I2CMDR0_FSETS(FIELD,SYM) _I2C_I2CMDR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CMDR1_FSETS(FIELD,SYM) _I2C_I2CMDR_FSETS(1,##FIELD,##SYM)

/******************************************************************************\
*  (Keeping the old definitions for backward compatibility)
*  ___________________
* |                   |
* |  I 2 C I V R      |
* |___________________|
*
* I2CIVR0    - I2C0 Interrupt Vector register
* I2CIVR1    - I2C1 Interrupt Vector register
*
* FIELDS (msb -> lsb)
* (r) INTCODE
\******************************************************************************/

#if (!(CHIP_6410 | CHIP_6413 | CHIP_6418))
  #define _I2C_I2CIVR_OFFSET           10

  #define _I2C_I2CIVR0_ADDR            0x01B40028
  #define _I2C_I2CIVR1_ADDR            0x01B44028

  /*** old names ***/
  #define _I2C_I2CISR0_ADDR        _I2C_I2CIVR0_ADDR            
  #define _I2C_I2CISR1_ADDR        _I2C_I2CIVR1_ADDR            

  #define _I2C_I2CIVR_INTCODE_MASK     0x00000007u
  #define _I2C_I2CIVR_INTCODE_SHIFT    0x00000000u
  #define  I2C_I2CIVR_INTCODE_DEFAULT  0x00000000u
  #define  I2C_I2CIVR_INTCODE_OF(x)    _VALUEOF(x)
  #define  I2C_I2CIVR_INTCODE_NONE     0x00000000u
  #define  I2C_I2CIVR_INTCODE_AL       0x00000001u
  #define  I2C_I2CIVR_INTCODE_NACK     0x00000002u
  #define  I2C_I2CIVR_INTCODE_RAR      0x00000003u
  #define  I2C_I2CIVR_INTCODE_RDR      0x00000004u
  #define  I2C_I2CIVR_INTCODE_XDR      0x00000005u

  #define  I2C_I2CIVR_OF(x)             _VALUEOF(x)

  #define I2C_I2CIVR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CIVR,INTCODE)\
  )

  #define I2C_I2CIVR_RMK(intcode) (Uint32)(\
     _PER_FMK(I2C,I2CIVR,INTCODE,intcode)\
  )
   
  #define _I2C_I2CIVR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CIVR##N##_ADDR,I2C,I2CIVR,##FIELD)

  #define _I2C_I2CIVR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CIVR##N##_ADDR,I2C,I2CIVR,##FIELD,field)

  #define _I2C_I2CIVR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CIVR##N##_ADDR,I2C,I2CIVR,##FIELD,##SYM)

  #define _I2C_I2CIVR0_FGET(FIELD) _I2C_I2CIVR_FGET(0,##FIELD)
  #define _I2C_I2CIVR1_FGET(FIELD) _I2C_I2CIVR_FGET(1,##FIELD)

  #define _I2C_I2CIVR0_FSET(FIELD,f) _I2C_I2CIVR_FSET(0,##FIELD,f)
  #define _I2C_I2CIVR1_FSET(FIELD,f) _I2C_I2CIVR_FSET(1,##FIELD,f)

  #define _I2C_I2CIVR0_FSETS(FIELD,SYM) _I2C_I2CIVR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CIVR1_FSETS(FIELD,SYM) _I2C_I2CIVR_FSETS(1,##FIELD,##SYM)
#endif

/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C I S R C    |
* |___________________|
*
* I2CISRC0    - I2C0 Interrupt Vector register
* I2CISRC1    - I2C1 Interrupt Vector register
*
* FIELDS (msb -> lsb)
* (r) INTCODE
\******************************************************************************/

  #define _I2C_I2CISRC_OFFSET           10

  #define _I2C_I2CISRC0_ADDR            0x01B40028
  #define _I2C_I2CISRC1_ADDR            0x01B44028

  #define _I2C_I2CISRC_INTCODE_MASK     0x00000007u
  #define _I2C_I2CISRC_INTCODE_SHIFT    0x00000000u
  #define  I2C_I2CISRC_INTCODE_DEFAULT  0x00000000u
  #define  I2C_I2CISRC_INTCODE_OF(x)    _VALUEOF(x)
  #define  I2C_I2CISRC_INTCODE_NONE     0x00000000u
  #define  I2C_I2CISRC_INTCODE_AL       0x00000001u
  #define  I2C_I2CISRC_INTCODE_NACK     0x00000002u
  #define  I2C_I2CISRC_INTCODE_RAR      0x00000003u
  #define  I2C_I2CISRC_INTCODE_RDR      0x00000004u
  #define  I2C_I2CISRC_INTCODE_XDR      0x00000005u
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define  I2C_I2CISRC_INTCODE_SCD      0x00000006u
  #define  I2C_I2CISRC_INTCODE_AAS      0x00000007u
#endif

  #define  I2C_I2CISRC_OF(x)             _VALUEOF(x)

  #define I2C_I2CISRC_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CISRC,INTCODE)\
  )

  #define I2C_I2CISRC_RMK(intcode) (Uint32)(\
     _PER_FMK(I2C,I2CISRC,INTCODE,intcode)\
  )
   
  #define _I2C_I2CISRC_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CISRC##N##_ADDR,I2C,I2CISRC,##FIELD)

  #define _I2C_I2CISRC_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CISRC##N##_ADDR,I2C,I2CISRC,##FIELD,field)

  #define _I2C_I2CISRC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CISRC##N##_ADDR,I2C,I2CISRC,##FIELD,##SYM)

  #define _I2C_I2CISRC0_FGET(FIELD) _I2C_I2CISRC_FGET(0,##FIELD)
  #define _I2C_I2CISRC1_FGET(FIELD) _I2C_I2CISRC_FGET(1,##FIELD)

  #define _I2C_I2CISRC0_FSET(FIELD,f) _I2C_I2CISRC_FSET(0,##FIELD,f)
  #define _I2C_I2CISRC1_FSET(FIELD,f) _I2C_I2CISRC_FSET(1,##FIELD,f)

  #define _I2C_I2CISRC0_FSETS(FIELD,SYM) _I2C_I2CISRC_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CISRC1_FSETS(FIELD,SYM) _I2C_I2CISRC_FSETS(1,##FIELD,##SYM)

/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C E M D R    |
* |___________________|
*
* I2CEMDR0    - I2C0 Extended Mode register(1)
* I2CEMDR1    - I2C1 Extended Mode register(1)
*
* FIELDS (msb -> lsb)
* (rw) XRDYM
*
* (1) For C6418/C6413/C6410 only
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CEMDR_OFFSET           11

  #define _I2C_I2CEMDR0_ADDR            0x01B4002C
  #define _I2C_I2CEMDR1_ADDR            0x01B4402C

  #define _I2C_I2CEMDR_XRDYM_MASK         0x00000001u
  #define _I2C_I2CEMDR_XRDYM_SHIFT        0x00000000u
  #define  I2C_I2CEMDR_XRDYM_DEFAULT      0x00000001u
  #define  I2C_I2CEMDR_XRDYM_OF(x)        _VALUEOF(x)
  #define  I2C_I2CEMDR_XRDYM_MSTACK       0x00000000u
  #define  I2C_I2CEMDR_XRDYM_DXRCPY       0x00000001u

  #define  I2C_I2CEMDR_OF(x)             _VALUEOF(x)

  #define I2C_I2CEMDR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CEMDR,XRDYM)\
  )

  #define I2C_I2CEMDR_RMK(xrdym) (Uint32)(\
     _PER_FMK(I2C,I2CEMDR,XRDYM,xrdym)\
  )
   
  #define _I2C_I2CEMDR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CEMDR##N##_ADDR,I2C,I2CEMDR,##FIELD)

  #define _I2C_I2CEMDR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CEMDR##N##_ADDR,I2C,I2CEMDR,##FIELD,field)

  #define _I2C_I2CEMDR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CEMDR##N##_ADDR,I2C,I2CEMDR,##FIELD,##SYM)

  #define _I2C_I2CEMDR0_FGET(FIELD) _I2C_I2CEMDR_FGET(0,##FIELD)
  #define _I2C_I2CEMDR1_FGET(FIELD) _I2C_I2CEMDR_FGET(1,##FIELD)

  #define _I2C_I2CEMDR0_FSET(FIELD,f) _I2C_I2CEMDR_FSET(0,##FIELD,f)
  #define _I2C_I2CEMDR1_FSET(FIELD,f) _I2C_I2CEMDR_FSET(1,##FIELD,f)

  #define _I2C_I2CEMDR0_FSETS(FIELD,SYM) _I2C_I2CEMDR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CEMDR1_FSETS(FIELD,SYM) _I2C_I2CEMDR_FSETS(1,##FIELD,##SYM)
#endif

/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C P S C      |
* |___________________|
*
* I2CPSC0    - I2C0 Prescaler register
* I2CPSC1    - I2C1 Prescaler register
*
* FIELDS (msb -> lsb)
* (rw) IPSC
\******************************************************************************/
  #define _I2C_I2CPSC_OFFSET           12

  #define _I2C_I2CPSC0_ADDR            0x01B40030
  #define _I2C_I2CPSC1_ADDR            0x01B44030

  #define _I2C_I2CPSC_IPSC_MASK     0x000000FFu
  #define _I2C_I2CPSC_IPSC_SHIFT    0x00000000u
  #define  I2C_I2CPSC_IPSC_DEFAULT  0x00000000u
  #define  I2C_I2CPSC_IPSC_OF(x)    _VALUEOF(x)

  #define  I2C_I2CPSC_OF(x)             _VALUEOF(x)

  #define I2C_I2CPSC_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CPSC,IPSC)\
  )

  #define I2C_I2CPSC_RMK(ipsc) (Uint32)(\
     _PER_FMK(I2C,I2CPSC,IPSC,ipsc)\
  )
   
  #define _I2C_I2CPSC_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPSC##N##_ADDR,I2C,I2CPSC,##FIELD)

  #define _I2C_I2CPSC_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CPSC##N##_ADDR,I2C,I2CPSC,##FIELD,field)

  #define _I2C_I2CPSC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CPSC##N##_ADDR,I2C,I2CPSC,##FIELD,##SYM)

  #define _I2C_I2CPSC0_FGET(FIELD) _I2C_I2CPSC_FGET(0,##FIELD)
  #define _I2C_I2CPSC1_FGET(FIELD) _I2C_I2CPSC_FGET(1,##FIELD)

  #define _I2C_I2CPSC0_FSET(FIELD,f) _I2C_I2CPSC_FSET(0,##FIELD,f)
  #define _I2C_I2CPSC1_FSET(FIELD,f) _I2C_I2CPSC_FSET(1,##FIELD,f)

  #define _I2C_I2CPSC0_FSETS(FIELD,SYM) _I2C_I2CPSC_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CPSC1_FSETS(FIELD,SYM) _I2C_I2CPSC_FSETS(1,##FIELD,##SYM)

/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C P I D 1    |
* |___________________|
*
* I2CPID10    - I2C0 Peripheral ID Register 1(1)
* I2CPID11    - I2C1 Peripheral ID Register 1(1)
*
* FIELDS (msb -> lsb)
* (r) CLASS
* (r) REVISION
*
* (1) For C6418/C6413/C6410 only
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CPID1_OFFSET           13

  #define _I2C_I2CPID10_ADDR            0x01B40034
  #define _I2C_I2CPID11_ADDR            0x01B44034

  #define _I2C_I2CPID1_CLASS_MASK     0x0000FF00u
  #define _I2C_I2CPID1_CLASS_SHIFT    0x00000008u
  #define  I2C_I2CPID1_CLASS_DEFAULT  0x00000001u
  #define  I2C_I2CPID1_CLASS_OF(x)    _VALUEOF(x)

  #define _I2C_I2CPID1_REVISION_MASK     0x000000FFu
  #define _I2C_I2CPID1_REVISION_SHIFT    0x00000000u
  #define  I2C_I2CPID1_REVISION_DEFAULT  0x00000025u
  #define  I2C_I2CPID1_REVISION_OF(x)    _VALUEOF(x)

  #define  I2C_I2CPID1_OF(x)             _VALUEOF(x)
  
  #define I2C_I2CPID1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CPID1,CLASS)\
    |_PER_FDEFAULT(I2C,I2CPID1,REVISION)\
  )

  #define _I2C_I2CPID1_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPID1##N##_ADDR,I2C,I2CPID1,##FIELD)

  #define _I2C_I2CPID10_FGET(FIELD) _I2C_I2CPID1_FGET(0,##FIELD)
  #define _I2C_I2CPID11_FGET(FIELD) _I2C_I2CPID1_FGET(1,##FIELD)
#endif /* CHIP_6413 | CHIP_6418 | CHIP_6410 */

/******************************************************************************\
*  ___________________
* |                   |
* |  I 2 C P I D 2    |
* |___________________|
*
* I2CPID20    - I2C0 Peripheral ID Register 2(1)
* I2CPID21    - I2C1 Peripheral ID Register 2(1)
*
* FIELDS (msb -> lsb)
* (r) TYPE
*
* (1) For C6418/C6413/C6410 only
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CPID2_OFFSET           14

  #define _I2C_I2CPID20_ADDR            0x01B40038
  #define _I2C_I2CPID21_ADDR            0x01B44038

  #define _I2C_I2CPID2_TYPE_MASK     0x000000FFu
  #define _I2C_I2CPID2_TYPE_SHIFT    0x00000000u
  #define  I2C_I2CPID2_TYPE_DEFAULT  0x00000005u
  #define  I2C_I2CPID2_TYPE_OF(x)    _VALUEOF(x)

  #define  I2C_I2CPID2_OF(x)             _VALUEOF(x)
  
  #define I2C_I2CPID2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(I2C,I2CPID2,TYPE)\
  )

  #define _I2C_I2CPID2_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPID2##N##_ADDR,I2C,I2CPID2,##FIELD)

  #define _I2C_I2CPID20_FGET(FIELD) _I2C_I2CPID2_FGET(0,##FIELD)
  #define _I2C_I2CPID21_FGET(FIELD) _I2C_I2CPID2_FGET(1,##FIELD)

#endif /* CHIP_6413 | CHIP_6418 | CHIP_6410) */

/******************************************************************************\
* _____________________
* |                   |
* |  I 2 C P F U N C  |
* |___________________|
*
* I2CPFUNC0  - I2C 0 Pin Function Register(1)
* I2CPFUNC1  - I2C 1 Pin Function Register(1)
*
* FIELDS (msb -> lsb)
* (rw) GPMODE 
*
* (1) For C6418/C6413/C6410 only
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CPFUNC_OFFSET            18

  #define _I2C_I2CPFUNC0_ADDR              0x01B40048
  #define _I2C_I2CPFUNC1_ADDR              0x01B44048

  #define _I2C_I2CPFUNC_GPMODE_MASK            0x00000001u
  #define _I2C_I2CPFUNC_GPMODE_SHIFT           0x00000000u
  #define  I2C_I2CPFUNC_GPMODE_DEFAULT         0x00000000u
  #define  I2C_I2CPFUNC_GPMODE_OF(x)           _VALUEOF(x)
  #define  I2C_I2CPFUNC_GPMODE_ENABLE          0x00000001u
  #define  I2C_I2CPFUNC_GPMODE_DISABLE         0x00000000u
  
  #define  I2C_I2CPFUNC_OF(x)             _VALUEOF(x)

  #define I2C_I2CPFUNC_DEFAULT (Uint32)(\
    _PER_FDEFAULT(I2C,I2CPFUNC,GPMODE)\
  )

  #define I2C_I2CPFUNC_RMK(gpmode) (Uint32)(\
    _PER_FMK(I2C,I2CPFUNC,GPMODE,gpmode)\
  )

  #define _I2C_I2CPFUNC_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPFUNC##N##_ADDR,I2C,I2CPFUNC,##FIELD)

  #define _I2C_I2CPFUNC_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CPFUNC##N##_ADDR,I2C,I2CPFUNC,##FIELD,field)

  #define _I2C_I2CPFUNC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CPFUNC##N##_ADDR,I2C,I2CPFUNC,##FIELD,##SYM)

  #define _I2C_I2CPFUNC0_FGET(FIELD) _I2C_I2CPFUNC_FGET(0,##FIELD)
  #define _I2C_I2CPFUNC1_FGET(FIELD) _I2C_I2CPFUNC_FGET(1,##FIELD)

  #define _I2C_I2CPFUNC0_FSET(FIELD,f) _I2C_I2CPFUNC_FSET(0,##FIELD,f)
  #define _I2C_I2CPFUNC1_FSET(FIELD,f) _I2C_I2CPFUNC_FSET(1,##FIELD,f)

  #define _I2C_I2CPFUNC0_FSETS(FIELD,SYM) _I2C_I2CPFUNC_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CPFUNC1_FSETS(FIELD,SYM) _I2C_I2CPFUNC_FSETS(1,##FIELD,##SYM)
#endif /* CHIP_6413 | CHIP_6418 | CHIP_6410) */
  
/******************************************************************************\
* ___________________
* |                 |
* |  I 2 C P D I R  |
* |_________________|
*
* I2CPDIR0  - I2C 0 Pin Direction Register(1)
* I2CPDIR1  - I2C 1 Pin Direction Register(1)
*
* FIELDS (msb -> lsb)
* (rw) SDADIR
* (rw) SCLDIR
*
* (1) For C6418/C6413/C6410 only
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CPDIR_OFFSET             19

  #define _I2C_I2CPDIR0_ADDR              0x01B4004C
  #define _I2C_I2CPDIR1_ADDR              0x01B4404C

  #define _I2C_I2CPDIR_SDADIR_MASK         0x00000002u
  #define _I2C_I2CPDIR_SDADIR_SHIFT        0x00000001u
  #define  I2C_I2CPDIR_SDADIR_DEFAULT      0x00000000u
  #define  I2C_I2CPDIR_SDADIR_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDIR_SDADIR_INPUT        0x00000000u
  #define  I2C_I2CPDIR_SDADIR_OUTPUT       0x00000001u
  
  #define _I2C_I2CPDIR_SCLDIR_MASK         0x00000001u
  #define _I2C_I2CPDIR_SCLDIR_SHIFT        0x00000000u
  #define  I2C_I2CPDIR_SCLDIR_DEFAULT      0x00000000u
  #define  I2C_I2CPDIR_SCLDIR_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDIR_SCLDIR_INPUT        0x00000000u
  #define  I2C_I2CPDIR_SCLDIR_OUTPUT       0x00000001u
  
  #define  I2C_I2CPDIR_OF(x)              _VALUEOF(x)

  #define I2C_I2CPDIR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(I2C,I2CPDIR,SDADIR)\
   |_PER_FDEFAULT(I2C,I2CPDIR,SCLDIR)\
  )

  #define I2C_I2CPDIR_RMK(sdadir,scldir) (Uint32)(\
    _PER_FMK(I2C,I2CPDIR,SDADIR,sdadir)\
   |_PER_FMK(I2C,I2CPDIR,SCLDIR,scldir)\
  )

  #define _I2C_I2CPDIR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPDIR##N##_ADDR,I2C,I2CPDIR,##FIELD)

  #define _I2C_I2CPDIR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CPDIR##N##_ADDR,I2C,I2CPDIR,##FIELD,field)

  #define _I2C_I2CPDIR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CPDIR##N##_ADDR,I2C,I2CPDIR,##FIELD,##SYM)

  #define _I2C_I2CPDIR0_FGET(FIELD) _I2C_I2CPDIR_FGET(0,##FIELD)
  #define _I2C_I2CPDIR1_FGET(FIELD) _I2C_I2CPDIR_FGET(1,##FIELD)

  #define _I2C_I2CPDIR0_FSET(FIELD,f) _I2C_I2CPDIR_FSET(0,##FIELD,f)
  #define _I2C_I2CPDIR1_FSET(FIELD,f) _I2C_I2CPDIR_FSET(1,##FIELD,f)

  #define _I2C_I2CPDIR0_FSETS(FIELD,SYM) _I2C_I2CPDIR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CPDIR1_FSETS(FIELD,SYM) _I2C_I2CPDIR_FSETS(1,##FIELD,##SYM)
#endif /* CHIP_6413 | CHIP_6418 | CHIP_6410) */

/******************************************************************************\
* ___________________
* |                 |
* |  I 2 C P D I N  |
* |_________________|
*
* I2CPDIN0  - I2C 0 Pin Data In Register(1)
* I2CPDIN1  - I2C 1 Pin Data In Register(1)
*
* FIELDS (msb -> lsb)
* (r) SDAIN
* (r) SCLIN
*
* (1) For C6418/C6413/C6410 only
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CPDIN_OFFSET             20

  #define _I2C_I2CPDIN0_ADDR              0x01B40050
  #define _I2C_I2CPDIN1_ADDR              0x01B44050

  #define _I2C_I2CPDIN_SDAIN_MASK         0x00000002u
  #define _I2C_I2CPDIN_SDAIN_SHIFT        0x00000001u
  #define  I2C_I2CPDIN_SDAIN_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDIN_SDAIN_LOW          0x00000000u
  #define  I2C_I2CPDIN_SDAIN_HIGH         0x00000001u
  
  #define _I2C_I2CPDIN_SCLIN_MASK         0x00000001u
  #define _I2C_I2CPDIN_SCLIN_SHIFT        0x00000000u
  #define  I2C_I2CPDIN_SCLIN_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDIN_SCLIN_LOW          0x00000000u
  #define  I2C_I2CPDIN_SCLIN_HIGH         0x00000001u
  
  #define  I2C_I2CPDIN_OF(x)              _VALUEOF(x)

  #define I2C_I2CPDIN_DEFAULT (Uint32)(\
    _PER_FDEFAULT(I2C,I2CPDIN,SDAIN)\
   |_PER_FDEFAULT(I2C,I2CPDIN,SCLIN)\
  )

  #define I2C_I2CPDIN_RMK(sdain,sclin) (Uint32)(\
    _PER_FMK(I2C,I2CPDIN,SDAIN,sdain)\
   |_PER_FMK(I2C,I2CPDIN,SCLIN,sclin)\
  )

  #define _I2C_I2CPDIN_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPDIN##N##_ADDR,I2C,I2CPDIN,##FIELD)

  #define _I2C_I2CPDIN0_FGET(FIELD) _I2C_I2CPDIN_FGET(0,##FIELD)
  #define _I2C_I2CPDIN1_FGET(FIELD) _I2C_I2CPDIN_FGET(1,##FIELD)

#endif /* CHIP_6413 | CHIP_6418 | CHIP_6410) */

/******************************************************************************\
* _____________________
* |                   |
* |  I 2 C P D O U T  |
* |___________________|
*
* I2CPDOUT0  - I2C 0 Pin Data Out Register(1)
* I2CPDOUT1  - I2C 1 Pin Data Out Register(1)
*
* FIELDS (msb -> lsb)
* (rw) SDAOUT
* (rw) SCLOUT
*
* (1) For C6418/C6413/C6410 only
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CPDOUT_OFFSET              21

  #define _I2C_I2CPDOUT0_ADDR               0x01B40054
  #define _I2C_I2CPDOUT1_ADDR               0x01B44054

  #define _I2C_I2CPDOUT_SDAOUT_MASK         0x00000002u
  #define _I2C_I2CPDOUT_SDAOUT_SHIFT        0x00000001u
  #define  I2C_I2CPDOUT_SDAOUT_DEFAULT      0x00000000u
  #define  I2C_I2CPDOUT_SDAOUT_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDOUT_SDAOUT_LOW          0x00000000u
  #define  I2C_I2CPDOUT_SDAOUT_HIGH         0x00000001u
  
  #define _I2C_I2CPDOUT_SCLOUT_MASK         0x00000001u
  #define _I2C_I2CPDOUT_SCLOUT_SHIFT        0x00000000u
  #define  I2C_I2CPDOUT_SCLOUT_DEFAULT      0x00000000u
  #define  I2C_I2CPDOUT_SCLOUT_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDOUT_SCLOUT_LOW          0x00000000u
  #define  I2C_I2CPDOUT_SCLOUT_HIGH         0x00000001u
  
  #define  I2C_I2CPDOUT_OF(x)              _VALUEOF(x)

  #define I2C_I2CPDOUT_DEFAULT (Uint32)(\
    _PER_FDEFAULT(I2C,I2CPDOUT,SDAOUT)\
   |_PER_FDEFAULT(I2C,I2CPDOUT,SCLOUT)\
  )

  #define I2C_I2CPDOUT_RMK(sdaout,sclout) (Uint32)(\
    _PER_FMK(I2C,I2CPDOUT,SDAOUT,sdaout)\
   |_PER_FMK(I2C,I2CPDOUT,SCLOUT,sclout)\
  )

  #define _I2C_I2CPDOUT_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPDOUT##N##_ADDR,I2C,I2CPDOUT,##FIELD)

  #define _I2C_I2CPDOUT_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CPDOUT##N##_ADDR,I2C,I2CPDOUT,##FIELD,field)

  #define _I2C_I2CPDOUT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CPDOUT##N##_ADDR,I2C,I2CPDOUT,##FIELD,##SYM)

  #define _I2C_I2CPDOUT0_FGET(FIELD) _I2C_I2CPDOUT_FGET(0,##FIELD)
  #define _I2C_I2CPDOUT1_FGET(FIELD) _I2C_I2CPDOUT_FGET(1,##FIELD)

  #define _I2C_I2CPDOUT0_FSET(FIELD,f) _I2C_I2CPDOUT_FSET(0,##FIELD,f)
  #define _I2C_I2CPDOUT1_FSET(FIELD,f) _I2C_I2CPDOUT_FSET(1,##FIELD,f)

  #define _I2C_I2CPDOUT0_FSETS(FIELD,SYM) _I2C_I2CPDOUT_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CPDOUT1_FSETS(FIELD,SYM) _I2C_I2CPDOUT_FSETS(1,##FIELD,##SYM)
#endif /* CHIP_6413 | CHIP_6418 | CHIP_6410) */

/******************************************************************************\
* _____________________
* |                   |
* |  I 2 C P D S E T  |
* |___________________|
*
* I2CPDSET0  - I2C 0 Pin Data Set Register(1)
* I2CPDSET1  - I2C 1 Pin Data Set Register(1)
*
* FIELDS (msb -> lsb)
* (rw) PDSET1
* (rw) PDSET0
*
* (1) For C6418/C6413/C6410 only
*
* Note: Read of these two bits is indeterminate
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CPDSET_OFFSET              22

  #define _I2C_I2CPDSET0_ADDR               0x01B40058
  #define _I2C_I2CPDSET1_ADDR               0x01B44058

  #define _I2C_I2CPDSET_SDAOUT_MASK         0x00000002u
  #define _I2C_I2CPDSET_SDAOUT_SHIFT        0x00000001u
  #define  I2C_I2CPDSET_SDAOUT_DEFAULT      0x00000000u
  #define  I2C_I2CPDSET_SDAOUT_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDSET_SDAOUT_UNCHGN       0x00000000u
  #define  I2C_I2CPDSET_SDAOUT_SET          0x00000001u
  
  #define _I2C_I2CPDSET_SCLOUT_MASK         0x00000001u
  #define _I2C_I2CPDSET_SCLOUT_SHIFT        0x00000000u
  #define  I2C_I2CPDSET_SCLOUT_DEFAULT      0x00000000u
  #define  I2C_I2CPDSET_SCLOUT_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDSET_SCLOUT_UNCHGN       0x00000000u
  #define  I2C_I2CPDSET_SCLOUT_SET          0x00000001u
  
  #define  I2C_I2CPDSET_OF(x)              _VALUEOF(x)

  #define I2C_I2CPDSET_DEFAULT (Uint32)(\
    _PER_FDEFAULT(I2C,I2CPDSET,SDAOUT)\
   |_PER_FDEFAULT(I2C,I2CPDSET,SCLOUT)\
  )

  #define I2C_I2CPDSET_RMK(sdaout,sclout) (Uint32)(\
    _PER_FMK(I2C,I2CPDSET,SDAOUT,sdaout)\
   |_PER_FMK(I2C,I2CPDSET,SCLOUT,sclout)\
  )

  #define _I2C_I2CPDSET_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPDSET##N##_ADDR,I2C,I2CPDSET,##FIELD)

  #define _I2C_I2CPDSET_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CPDSET##N##_ADDR,I2C,I2CPDSET,##FIELD,field)

  #define _I2C_I2CPDSET_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CPDSET##N##_ADDR,I2C,I2CPDSET,##FIELD,##SYM)

  #define _I2C_I2CPDSET0_FGET(FIELD) _I2C_I2CPDSET_FGET(0,##FIELD)
  #define _I2C_I2CPDSET1_FGET(FIELD) _I2C_I2CPDSET_FGET(1,##FIELD)

  #define _I2C_I2CPDSET0_FSET(FIELD,f) _I2C_I2CPDSET_FSET(0,##FIELD,f)
  #define _I2C_I2CPDSET1_FSET(FIELD,f) _I2C_I2CPDSET_FSET(1,##FIELD,f)

  #define _I2C_I2CPDSET0_FSETS(FIELD,SYM) _I2C_I2CPDSET_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CPDSET1_FSETS(FIELD,SYM) _I2C_I2CPDSET_FSETS(1,##FIELD,##SYM)
#endif /* CHIP_6413 | CHIP_6418 | CHIP_6410) */

/******************************************************************************\
* _____________________
* |                   |
* |  I 2 C P D C L R  |
* |___________________|
*
* I2CPDCLR0  - I2C 0 Pin Data Clear Register(1)
* I2CPDCLR1  - I2C 1 Pin Data Clear Register(1)
*
* FIELDS (msb -> lsb)
* (rw) PDCLR1
* (rw) PDCLR0
*
* (1) For C6418/C6413/C6410 only
*
* Note: Read of these two bits is indeterminate
\******************************************************************************/
#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define _I2C_I2CPDCLR_OFFSET              23

  #define _I2C_I2CPDCLR0_ADDR               0x01B4005C
  #define _I2C_I2CPDCLR1_ADDR               0x01B4405C

  #define _I2C_I2CPDCLR_SDAOUT_MASK         0x00000002u
  #define _I2C_I2CPDCLR_SDAOUT_SHIFT        0x00000001u
  #define  I2C_I2CPDCLR_SDAOUT_DEFAULT      0x00000000u
  #define  I2C_I2CPDCLR_SDAOUT_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDCLR_SDAOUT_UNCHGN       0x00000000u
  #define  I2C_I2CPDCLR_SDAOUT_CLR          0x00000001u
  
  #define _I2C_I2CPDCLR_SCLOUT_MASK         0x00000001u
  #define _I2C_I2CPDCLR_SCLOUT_SHIFT        0x00000000u
  #define  I2C_I2CPDCLR_SCLOUT_DEFAULT      0x00000000u
  #define  I2C_I2CPDCLR_SCLOUT_OF(x)        _VALUEOF(x)
  #define  I2C_I2CPDCLR_SCLOUT_UNCHGN       0x00000000u
  #define  I2C_I2CPDCLR_SCLOUT_CLR          0x00000001u
  
  #define  I2C_I2CPDCLR_OF(x)              _VALUEOF(x)

  #define I2C_I2CPDCLR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(I2C,I2CPDCLR,SDAOUT)\
   |_PER_FDEFAULT(I2C,I2CPDCLR,SCLOUT)\
  )

  #define I2C_I2CPDCLR_RMK(sdaout,sclout) (Uint32)(\
    _PER_FMK(I2C,I2CPDCLR,SDAOUT,sdaout)\
   |_PER_FMK(I2C,I2CPDCLR,SCLOUT,sclout)\
  )

  #define _I2C_I2CPDCLR_FGET(N,FIELD)\
    _PER_FGET(_I2C_I2CPDCLR##N##_ADDR,I2C,I2CPDCLR,##FIELD)

  #define _I2C_I2CPDCLR_FSET(N,FIELD,field)\
    _PER_FSET(_I2C_I2CPDCLR##N##_ADDR,I2C,I2CPDCLR,##FIELD,field)

  #define _I2C_I2CPDCLR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_I2C_I2CPDCLR##N##_ADDR,I2C,I2CPDCLR,##FIELD,##SYM)

  #define _I2C_I2CPDCLR0_FGET(FIELD) _I2C_I2CPDCLR_FGET(0,##FIELD)
  #define _I2C_I2CPDCLR1_FGET(FIELD) _I2C_I2CPDCLR_FGET(1,##FIELD)

  #define _I2C_I2CPDCLR0_FSET(FIELD,f) _I2C_I2CPDCLR_FSET(0,##FIELD,f)
  #define _I2C_I2CPDCLR1_FSET(FIELD,f) _I2C_I2CPDCLR_FSET(1,##FIELD,f)

  #define _I2C_I2CPDCLR0_FSETS(FIELD,SYM) _I2C_I2CPDCLR_FSETS(0,##FIELD,##SYM)
  #define _I2C_I2CPDCLR1_FSETS(FIELD,SYM) _I2C_I2CPDCLR_FSETS(1,##FIELD,##SYM)
#endif /* CHIP_6413 | CHIP_6418 | CHIP_6410 */

#endif /* I2C_SUPPORT */
#endif /* _CSL_I2CHAL_H_ */
/******************************************************************************\
* End of csl_i2chal.h
\******************************************************************************/

csl_irq.h/      1092218722  0     0     0       12561     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_irq.h
* DATE CREATED.. 06/09/1999 
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                07/24/2004 - Re-introducing BIOS components from CSL due to compatibility issues.
*                02/05/2004 Removed bios related components 
*                10/03/2001
*                - CHIP_RSET()/CHIP_RGET() replaced by CHIP_CRSET()/CHIP_CRGET()
\******************************************************************************/
#ifndef _CSL_IRQ_H_
#define _CSL_IRQ_H_

#include <csl_stdinc.h>
#include <csl_chip.h>
#include <csl_irqhal.h>


#if (IRQ_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far 
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _IRQ_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/

/* misc global settings */
#define IRQ_INT_CNT     16
#define IRQ_EVENT_CNT   32

#define IRQ_EVT_NA         IRQ_EVENT_CNT

/* event id definitions */
#if (CHIP_6410 | CHIP_6413 | CHIP_6418)
  
    #define IRQ_EVT_DSPINT     0
    #define IRQ_EVT_TINT0      1
    #define IRQ_EVT_TINT1      2
    #define IRQ_EVT_SDINTA     3
    #define IRQ_EVT_EXTINT4    4
    #define IRQ_EVT_GPINT4     4
    #define IRQ_EVT_EXTINT5    5
    #define IRQ_EVT_GPINT5     5
    #define IRQ_EVT_EXTINT6    6
    #define IRQ_EVT_GPINT6     6
    #define IRQ_EVT_EXTINT7    7
    #define IRQ_EVT_GPINT7     7
    #define IRQ_EVT_EDMAINT    8
    #define IRQ_EVT_EMUDTDMA   9
    #define IRQ_EVT_EMURTDXRX  10
    #define IRQ_EVT_EMURTDXTX  11
    #define IRQ_EVT_XINT0      12
    #define IRQ_EVT_RINT0      13
    #define IRQ_EVT_XINT1      14
    #define IRQ_EVT_RINT1      15
    #define IRQ_EVT_GPINT0     16
    #define IRQ_EVT_TINT2      19
    #define IRQ_EVT_I2CINT0    22
    #define IRQ_EVT_I2CINT1    23
    #define IRQ_EVT_AXINT1     24
    #define IRQ_EVT_ARINT1     25
    #define IRQ_EVT_AXINT0     28
    #define IRQ_EVT_ARINT0     29

  #if (CHIP_6418)
    #define IRQ_EVT_VCPINT     30
  #endif

#else 

  #if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412)

    #define IRQ_EVT_DSPINT     0
    #define IRQ_EVT_TINT0      1
    #define IRQ_EVT_TINT1      2
    #define IRQ_EVT_SDINTA     3
    #define IRQ_EVT_EXTINT4    4
    #define IRQ_EVT_GPINT4     4
    #define IRQ_EVT_EXTINT5    5
    #define IRQ_EVT_GPINT5     5
    #define IRQ_EVT_EXTINT6    6
    #define IRQ_EVT_GPINT6     6
    #define IRQ_EVT_EXTINT7    7
    #define IRQ_EVT_GPINT7     7
    #define IRQ_EVT_EDMAINT    8
    #define IRQ_EVT_EMUDTDMA   9
    #define IRQ_EVT_EMURTDXRX  10
    #define IRQ_EVT_EMURTDXTX  11
    #define IRQ_EVT_XINT0      12
    #define IRQ_EVT_RINT0      13
    #define IRQ_EVT_XINT1      14
    #define IRQ_EVT_RINT1      15
    #define IRQ_EVT_GPINT0     16
    #define IRQ_EVT_TINT2      19
    #define IRQ_EVT_I2CINT0    22
    #define IRQ_EVT_MACINT     24

   #if !(CHIP_6412)
    #define IRQ_EVT_VINT0      25
    #define IRQ_EVT_VINT1      26
   #endif

   #if (CHIP_DM642)
    #define IRQ_EVT_VINT2      27
   #endif

   #if !(CHIP_6412)
    #define IRQ_EVT_AXINT0     28
    #define IRQ_EVT_ARINT0     29
   #endif

  #else

    #define IRQ_EVT_DSPINT     0
    #define IRQ_EVT_TINT0      1
    #define IRQ_EVT_TINT1      2
    #define IRQ_EVT_SDINT      3
    #define IRQ_EVT_SDINTA     3
    #define IRQ_EVT_EXTINT4    4
    #define IRQ_EVT_GPINT4     4
    #define IRQ_EVT_EXTINT5    5
    #define IRQ_EVT_GPINT5     5
    #define IRQ_EVT_EXTINT6    6
    #define IRQ_EVT_GPINT6     6
    #define IRQ_EVT_EXTINT7    7
    #define IRQ_EVT_GPINT7     7
    #define IRQ_EVT_EDMAINT    8
    #define IRQ_EVT_DMAINT0    8
    #define IRQ_EVT_EMUDTDMA   9
    #define IRQ_EVT_DMAINT1    9
    #define IRQ_EVT_EMURTDXRX  10
    #define IRQ_EVT_DMAINT2    10
    #define IRQ_EVT_EMURTDXTX  11
    #define IRQ_EVT_DMAINT3    11
    #define IRQ_EVT_XINT0      12
    #define IRQ_EVT_RINT0      13
    #define IRQ_EVT_XINT1      14
    #define IRQ_EVT_RINT1      15
    #define IRQ_EVT_GPINT0     16
    #define IRQ_EVT_XINT2      17
    #define IRQ_EVT_RINT2      18
    #define IRQ_EVT_TINT2      19
    #define IRQ_EVT_SDINTB     20
    #define IRQ_EVT_PCIWAKE    21
    #define IRQ_EVT_MDIO       21
    #define IRQ_EVT_QDMAERR    22
    #define IRQ_EVT_I2CINT0    22 /* 6713 */
    #define IRQ_EVT_UINT       23
    #define IRQ_EVT_I2CINT1    23 /* 6713 */
    #define IRQ_EVT_I2CINT2    23 
    #define IRQ_EVT_I2CINT3    22 
    #define IRQ_EVT_I2CINT4    23 

    #define IRQ_EVT_MACINT     24 /* DM642 */
    #define IRQ_EVT_VINT0      25 /* DM642 */
    #define IRQ_EVT_VINT1      26 /* DM642 */
    #define IRQ_EVT_VINT2      27 /* DM642 */
    #define IRQ_EVT_AXINT0     28 /* 6713 / DM642 */
    #define IRQ_EVT_ARINT0     29 /* 6713 / DM642 */
    #define IRQ_EVT_AXINT3     IRQ_EVT_EXTINT4 /* 6713 */
    #define IRQ_EVT_ARINT3     IRQ_EVT_EXTINT5 /* 6713 */
    #define IRQ_EVT_VCPINT     30
    #define IRQ_EVT_AXINT1     30 /* 6713 */

    #define IRQ_EVT_AXINT2     30 /* 6713 */
    #define IRQ_EVT_AXINT4     IRQ_EVT_EXTINT6
    #define IRQ_EVT_TCPINT     31
    #define IRQ_EVT_ARINT1     31 /* 6713 */

    #define IRQ_EVT_ARINT2     31 /* 6713 */
    #define IRQ_EVT_ARINT4     IRQ_EVT_EXTINT7

  #endif

#endif
/* interrupt masks */
#define IRQ_MASK_NA 0x00000000
#define IRQ_MASK_00 0x00000001
#define IRQ_MASK_01 0x00000002
#define IRQ_MASK_02 0x00000004
#define IRQ_MASK_03 0x00000008
#define IRQ_MASK_04 0x00000010
#define IRQ_MASK_05 0x00000020
#define IRQ_MASK_06 0x00000040
#define IRQ_MASK_07 0x00000080
#define IRQ_MASK_08 0x00000100
#define IRQ_MASK_09 0x00000200
#define IRQ_MASK_10 0x00000400
#define IRQ_MASK_11 0x00000800
#define IRQ_MASK_12 0x00001000
#define IRQ_MASK_13 0x00002000
#define IRQ_MASK_14 0x00004000
#define IRQ_MASK_15 0x00008000

/* defines used with the dispatcher functions */
#define IRQ_CCMASK_NONE        0x00000001u
#define IRQ_CCMASK_PCC_MAPPED  0x00000000u
#define IRQ_CCMASK_PCC_ENABLE  0x00000040u
#define IRQ_CCMASK_PCC_FREEZE  0x00000060u
#define IRQ_CCMASK_PCC_BYPASS  0x00000080u
#define IRQ_CCMASK_DCC_MAPPED  0x00000000u
#define IRQ_CCMASK_DCC_ENABLE  0x00000008u
#define IRQ_CCMASK_DCC_FREEZE  0x0000000Cu
#define IRQ_CCMASK_DCC_BYPASS  0x00000010u
#define IRQ_CCMASK_DEFAULT     IRQ_CCMASK_NONE
#define IRQ_IEMASK_SELF        0x80000000u
#define IRQ_IEMASK_ALL         0x0000FFFFu
#define IRQ_IEMASK_DEFAULT     IRQ_IEMASK_SELF


/* private stuff */
#define _IRQ_DISPATCHTABLE_CNT   (IRQ_INT_CNT)
#define _IRQ_EVENT2INTTABLE_CNT  (IRQ_EVENT_CNT+1)
#define _IRQ_INT2EVENTTABLE_CNT  (IRQ_INT_CNT)


/******************************************************************************\
* global typedef declarations
\******************************************************************************/
typedef struct {
  void   *funcAddr;
  Uint32 ieMask;
  Uint32 ccMask;
  Uint32 funcArg;
} _IRQ_Dispatch;

typedef struct {
  void   *funcAddr;
  Uint32 funcArg;
  Uint32 ccMask;
  Uint32 ieMask;
} IRQ_Config;


/******************************************************************************\
* global variable declarations
\******************************************************************************/

/* private vars */
extern far Uint32 _IRQ_eventTable[IRQ_EVENT_CNT+1];
extern far Uint32 _IRQ_intTable[IRQ_INT_CNT];
extern far _IRQ_Dispatch _IRQ_internalDispatchTable[_IRQ_DISPATCHTABLE_CNT];
extern far _IRQ_Dispatch *_IRQ_dispatchTable;

/******************************************************************************\
* global function declarations
\******************************************************************************/

/* private functions */
CSLAPI void _IRQ_init(Uint32 biosPresent, _IRQ_Dispatch *dispatchTable);

/* API functions */
CSLAPI void IRQ_map(Uint32 eventId, Uint32 intNumber);
CSLAPI void *IRQ_setVecs(void *vecs);
CSLAPI Uint32 IRQ_biosPresent();
CSLAPI void IRQ_hook(int intNum, void *func);

/* These functions only work with the DSP/BIOS HWI dispatcher */
CSLAPI void IRQ_config(Uint32 eventId, IRQ_Config *config);
CSLAPI void IRQ_configArgs(Uint32 eventId, void *funcAddr, Uint32 funcArg,
  Uint32 ccMask, Uint32 ieMask);
CSLAPI void IRQ_getConfig(Uint32 eventId, IRQ_Config *config);
CSLAPI Uint32 IRQ_getArg(Uint32 eventId);
CSLAPI void IRQ_setArg(Uint32 eventId, Uint32 arg);


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL void IRQ_enable(Uint32 eventId);
IDECL Uint32 IRQ_disable(Uint32 eventId);
IDECL void IRQ_restore(Uint32 eventId, Uint32 ie);
IDECL void IRQ_set(Uint32 eventId);
IDECL void IRQ_clear(Uint32 eventId);
IDECL Uint32 IRQ_test(Uint32 eventId);
IDECL void IRQ_reset(Uint32 eventId);
IDECL void IRQ_resetAll();

IDECL void IRQ_globalEnable();
IDECL Uint32 IRQ_globalDisable();
IDECL void IRQ_globalRestore(Uint32 gie);

IDECL void IRQ_nmiEnable();
IDECL void IRQ_nmiDisable();


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void IRQ_enable(Uint32 eventId) {
  IER |= _IRQ_eventTable[eventId];
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 IRQ_disable(Uint32 eventId) {
  Uint32 ie = IER & _IRQ_eventTable[eventId];
  IER &= ~_IRQ_eventTable[eventId];
  return ie;
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_restore(Uint32 eventId, Uint32 ie) {
  if (ie) {
    IER |= _IRQ_eventTable[eventId];
  } else {
    IER &= ~_IRQ_eventTable[eventId];
  }
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_set(Uint32 eventId) {
  ISR = _IRQ_eventTable[eventId];
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_clear(Uint32 eventId) {
  ICR = _IRQ_eventTable[eventId];
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 IRQ_test(Uint32 eventId) {
  return (Uint32)((IFR & _IRQ_eventTable[eventId]) ? 1 : 0);
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_globalEnable() {
  CHIP_FSET(CSR,GIE,1);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 IRQ_globalDisable() {
  Uint32 gie = CHIP_FGET(CSR,GIE);
  CHIP_FSET(CSR,GIE,0);
  return gie;
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_globalRestore(Uint32 gie) {
  CHIP_FSET(CSR,GIE,gie);
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_reset(Uint32 eventId) {
  IER &= ~_IRQ_eventTable[eventId];
  ICR = _IRQ_eventTable[eventId];
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_resetAll() {
  CHIP_FSET(CSR,GIE,0);
  CHIP_CRSET(IER,0x00000000);
  CHIP_CRSET(ICR,0xFFFFFFFF);
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_nmiEnable() {
  IER |= 0x00000002;
}
/*----------------------------------------------------------------------------*/
IDEF void IRQ_nmiDisable() {
  IER &= ~0x00000002;
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* IRQ_SUPPORT */
#endif /* _CSL_IRQ_H_ */
/******************************************************************************\
* End of csl_irq.h
\******************************************************************************/


csl_irqhal.h/   1030611967  0     0     0       9497      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_irqhal.h
* DATE CREATED.. 06/20/1999 
* LAST MODIFIED. 10/03/2000
*------------------------------------------------------------------------------
* REGISTERS
*
* MUXH   - interrupt multiplexer high register
* MUXL   - interrupt multiplexer low register
* EXTPOL - external interrupt polarity register
*
\******************************************************************************/
#ifndef _CSL_IRQHAL_H_
#define _CSL_IRQHAL_H_

#include <csl_stdinchal.h>
#include <csl_chip.h>

#if (IRQ_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define IRQ_FMK(REG,FIELD,x)\
    _PER_FMK(IRQ,##REG,##FIELD,x)

  #define IRQ_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(IRQ,##REG,##FIELD,##SYM)
 
 
  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define IRQ_ADDR(REG)\
    _IRQ_##REG##_ADDR

  #define IRQ_RGET(REG)\
    _PER_RGET(_IRQ_##REG##_ADDR,IRQ,##REG)

  #define IRQ_RSET(REG,x)\
    _PER_RSET(_IRQ_##REG##_ADDR,IRQ,##REG,x)

  #define IRQ_FGET(REG,FIELD)\
    _IRQ_##REG##_FGET(##FIELD)

  #define IRQ_FSET(REG,FIELD,x)\
    _IRQ_##REG##_FSET(##FIELD,##x)

  #define IRQ_FSETS(REG,FIELD,SYM)\
    _IRQ_##REG##_FSETS(##FIELD,##SYM)
 
 
  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define IRQ_RGETA(addr,REG)\
    _PER_RGET(addr,IRQ,##REG)

  #define IRQ_RSETA(addr,REG,x)\
    _PER_RSET(addr,IRQ,##REG,x)

  #define IRQ_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,IRQ,##REG,##FIELD)

  #define IRQ_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,IRQ,##REG,##FIELD,x)

  #define IRQ_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,IRQ,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  M U X H          |
* |___________________|
*
* MUXH - interrupt multiplexer high register
*
* FIELDS (msb -> lsb)
* (rw) INTSEL15
* (rw) INTSEL14
* (rw) INTSEL13
* (rw) INTSEL12
* (rw) INTSEL11
* (rw) INTSEL10
*
\******************************************************************************/
  #define _IRQ_MUXH_ADDR               0x019C0000u

  #define _IRQ_MUXH_INTSEL15_MASK      0x7C000000u
  #define _IRQ_MUXH_INTSEL15_SHIFT     0x0000001Au
  #define  IRQ_MUXH_INTSEL15_DEFAULT   0x00000002u
  #define  IRQ_MUXH_INTSEL15_OF(x)     _VALUEOF(x)

  #define _IRQ_MUXH_INTSEL14_MASK      0x03E00000u
  #define _IRQ_MUXH_INTSEL14_SHIFT     0x00000015u
  #define  IRQ_MUXH_INTSEL14_DEFAULT   0x00000001u
  #define  IRQ_MUXH_INTSEL14_OF(x)     _VALUEOF(x)

  #define _IRQ_MUXH_INTSEL13_MASK      0x001F0000u
  #define _IRQ_MUXH_INTSEL13_SHIFT     0x00000010u
  #define  IRQ_MUXH_INTSEL13_DEFAULT   0x00000000u
  #define  IRQ_MUXH_INTSEL13_OF(x)     _VALUEOF(x)

  #define _IRQ_MUXH_INTSEL12_MASK      0x00007C00u
  #define _IRQ_MUXH_INTSEL12_SHIFT     0x0000000Au
  #define  IRQ_MUXH_INTSEL12_DEFAULT   0x0000000Bu
  #define  IRQ_MUXH_INTSEL12_OF(x)     _VALUEOF(x)

  #define _IRQ_MUXH_INTSEL11_MASK      0x000003E0u
  #define _IRQ_MUXH_INTSEL11_SHIFT     0x00000005u
  #define  IRQ_MUXH_INTSEL11_DEFAULT   0x0000000Au
  #define  IRQ_MUXH_INTSEL11_OF(x)     _VALUEOF(x)

  #define _IRQ_MUXH_INTSEL10_MASK      0x0000001Fu
  #define _IRQ_MUXH_INTSEL10_SHIFT     0x00000000u
  #define  IRQ_MUXH_INTSEL10_DEFAULT   0x00000003u
  #define  IRQ_MUXH_INTSEL10_OF(x)     _VALUEOF(x)

  #define  IRQ_MUXH_OF(x)              _VALUEOF(x)

  #define IRQ_MUXH_DEFAULT (Uint32)( \
     _PER_FDEFAULT(IRQ,MUXH,INTSEL15) \
    |_PER_FDEFAULT(IRQ,MUXH,INTSEL14) \
    |_PER_FDEFAULT(IRQ,MUXH,INTSEL13) \
    |_PER_FDEFAULT(IRQ,MUXH,INTSEL12) \
    |_PER_FDEFAULT(IRQ,MUXH,INTSEL11) \
    |_PER_FDEFAULT(IRQ,MUXH,INTSEL10) \
  )

  #define IRQ_MUXH_RMK(intsel15,intsel14,intsel13,intsel12,intsel11,intsel10) \
    (Uint32)( \
     _PER_FMK(IRQ,MUXH,INTSEL15,intsel15) \
    |_PER_FMK(IRQ,MUXH,INTSEL14,intsel14) \
    |_PER_FMK(IRQ,MUXH,INTSEL13,intsel13) \
    |_PER_FMK(IRQ,MUXH,INTSEL12,intsel12) \
    |_PER_FMK(IRQ,MUXH,INTSEL11,intsel11) \
    |_PER_FMK(IRQ,MUXH,INTSEL10,intsel10) \
   )

  #define _IRQ_MUXH_FGET(FIELD)\
    _PER_FGET(_IRQ_MUXH_ADDR,IRQ,MUXH,##FIELD)

  #define _IRQ_MUXH_FSET(FIELD,field)\
    _PER_FSET(_IRQ_MUXH_ADDR,IRQ,MUXH,##FIELD,field)

  #define _IRQ_MUXH_FSETS(FIELD,SYM)\
    _PER_FSETS(_IRQ_MUXH_ADDR,IRQ,MUXH,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  M U X L          |
* |___________________|
*
* MUXL - interrupt multiplexer low register
*
* FIELDS (msb -> lsb)
* (rw) INTSEL9
* (rw) INTSEL8
* (rw) INTSEL7
* (rw) INTSEL6
* (rw) INTSEL5
* (rw) INTSEL4
*
\******************************************************************************/
  #define _IRQ_MUXL_ADDR               0x019C0004u

  #define _IRQ_MUXL_INTSEL9_MASK       0x7C000000u
  #define _IRQ_MUXL_INTSEL9_SHIFT      0x0000001Au
  #define  IRQ_MUXL_INTSEL9_DEFAULT    0x00000009u
  #define  IRQ_MUXL_INTSEL9_OF(x)      _VALUEOF(x)

  #define _IRQ_MUXL_INTSEL8_MASK       0x03E00000u
  #define _IRQ_MUXL_INTSEL8_SHIFT      0x00000015u
  #define  IRQ_MUXL_INTSEL8_DEFAULT    0x00000008u
  #define  IRQ_MUXL_INTSEL8_OF(x)      _VALUEOF(x)

  #define _IRQ_MUXL_INTSEL7_MASK       0x001F0000u
  #define _IRQ_MUXL_INTSEL7_SHIFT      0x00000010u
  #define  IRQ_MUXL_INTSEL7_DEFAULT    0x00000007u
  #define  IRQ_MUXL_INTSEL7_OF(x)      _VALUEOF(x)

  #define _IRQ_MUXL_INTSEL6_MASK       0x00007C00u
  #define _IRQ_MUXL_INTSEL6_SHIFT      0x0000000Au
  #define  IRQ_MUXL_INTSEL6_DEFAULT    0x00000006u
  #define  IRQ_MUXL_INTSEL6_OF(x)      _VALUEOF(x)

  #define _IRQ_MUXL_INTSEL5_MASK       0x000003E0u
  #define _IRQ_MUXL_INTSEL5_SHIFT      0x00000005u
  #define  IRQ_MUXL_INTSEL5_DEFAULT    0x00000005u
  #define  IRQ_MUXL_INTSEL5_OF(x)      _VALUEOF(x)

  #define _IRQ_MUXL_INTSEL4_MASK       0x0000001Fu
  #define _IRQ_MUXL_INTSEL4_SHIFT      0x00000000u
  #define  IRQ_MUXL_INTSEL4_DEFAULT    0x00000004u
  #define  IRQ_MUXL_INTSEL4_OF(x)      _VALUEOF(x)

  #define  IRQ_MUXL_OF(x)              _VALUEOF(x)

  #define IRQ_MUXL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(IRQ,MUXL,INTSEL9) \
    |_PER_FDEFAULT(IRQ,MUXL,INTSEL8) \
    |_PER_FDEFAULT(IRQ,MUXL,INTSEL7) \
    |_PER_FDEFAULT(IRQ,MUXL,INTSEL6) \
    |_PER_FDEFAULT(IRQ,MUXL,INTSEL5) \
    |_PER_FDEFAULT(IRQ,MUXL,INTSEL4) \
  )

  #define IRQ_MUXL_RMK(intsel9,intsel8,intsel7,intsel6,intsel5,intsel4) \
    (Uint32)( \
     _PER_FMK(IRQ,MUXL,INTSEL9,intsel9) \
    |_PER_FMK(IRQ,MUXL,INTSEL8,intsel8) \
    |_PER_FMK(IRQ,MUXL,INTSEL7,intsel7) \
    |_PER_FMK(IRQ,MUXL,INTSEL6,intsel6) \
    |_PER_FMK(IRQ,MUXL,INTSEL5,intsel5) \
    |_PER_FMK(IRQ,MUXL,INTSEL4,intsel4) \
   )

  #define _IRQ_MUXL_FGET(FIELD)\
    _PER_FGET(_IRQ_MUXL_ADDR,IRQ,MUXL,##FIELD)

  #define _IRQ_MUXL_FSET(FIELD,field)\
    _PER_FSET(_IRQ_MUXL_ADDR,IRQ,MUXL,##FIELD,field)

  #define _IRQ_MUXL_FSETS(FIELD,SYM)\
    _PER_FSETS(_IRQ_MUXL_ADDR,IRQ,MUXL,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  E X T P O L      |
* |___________________|
*
* EXTPOL - external interrupt polarity register
*
* FIELDS (msb -> lsb)
* (rw) XIP
*
\******************************************************************************/
  #define _IRQ_EXTPOL_ADDR            0x019C0008u

  #define _IRQ_EXTPOL_XIP_MASK        0x0000000Fu
  #define _IRQ_EXTPOL_XIP_SHIFT       0x00000000u
  #define  IRQ_EXTPOL_XIP_DEFAULT     0x00000000u
  #define  IRQ_EXTPOL_XIP_OF(x)       _VALUEOF(x)

  #define  IRQ_EXTPOL_OF(x)           _VALUEOF(x)

  #define IRQ_EXTPOL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(IRQ,EXTPOL,XIP) \
  )

  #define IRQ_EXTPOL_RMK(xip) (Uint32)( \
     _PER_FMK(IRQ,EXTPOL,XIP,xip) \
  )

  #define _IRQ_EXTPOL_FGET(FIELD)\
    _PER_FGET(_IRQ_EXTPOL_ADDR,IRQ,EXTPOL,##FIELD)

  #define _IRQ_EXTPOL_FSET(FIELD,field)\
    _PER_FSET(_IRQ_EXTPOL_ADDR,IRQ,EXTPOL,##FIELD,field)

  #define _IRQ_EXTPOL_FSETS(FIELD,SYM)\
    _PER_FSETS(_IRQ_EXTPOL_ADDR,IRQ,EXTPOL,##FIELD,##SYM)


/*----------------------------------------------------------------------------*/

#endif /* IRQ_SUPPORT */
#endif /* _CSL_IRQHAL_H_ */
/******************************************************************************\
* End of csl_irqhal.h
\******************************************************************************/


csl_legacy.h/   1037695790  0     0     0       30771     `
/*
 *  Copyright 2001 by Texas Instruments Incorporated.
 *  All rights reserved. Property of Texas Instruments Incorporated.
 *  Restricted rights to use, duplicate or disclose this code are
 *  granted through contract.
 *  U.S. Patent Nos. 5,283,900  5,392,448
 */
/* "@(#) DSP/BIOS 4.50.2 03-27-01 (barracuda-i02)" */
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_legacy.h
* DATE CREATED.. 04/24/2000 
* LAST MODIFIED. 10/30/2001 - 
                           EMIF_GBLCTL_NOHOLD_0 => EMIF_GBLCTL_NOHOLD_DISABLE
                           EMIF_GBLCTL_NOHOLD_1 => EMIF_GBLCTL_NOHOLD_ENABLE
                           MCBSP : Baseaddr => baseaddr
\******************************************************************************/
#ifndef _CSL_LEGACY_H_
#define _CSL_LEGACY_H_

#include <csl_legacyhal.h>

/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _LEGACY_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/

#if (CACHE_SUPPORT)
  #define CACHE_64KSRAM        CACHE_64KSRAM 
  #define CACHE_0KCACHE        CACHE_0KCACHE 
  #define CACHE_48KSRAM        CACHE_48KSRAM 
  #define CACHE_16KCACHE       CACHE_16KCACHE
  #define CACHE_32KSRAM        CACHE_32KSRAM 
  #define CACHE_32KCACHE       CACHE_32KCACHE
  #define CACHE_16KSRAM        CACHE_16KSRAM 
  #define CACHE_48KCACHE       CACHE_48KCACHE
  #define CACHE_0KSRAM         CACHE_0KSRAM  
  #define CACHE_64KCACHE       CACHE_64KCACHE
  #define CACHE_L2MODE         CACHE_L2Mode 
  #define CACHE_L2ALL          CACHE_L2ALL
  #define CACHE_L1PALL         CACHE_L1PALL
  #define CACHE_L1DALL         CACHE_L1DALL
  #define CACHE_REGION         CACHE_Region
  #define CACHE_PCCMAPPED      CACHE_PCC_MAPPED
  #define CACHE_PCCENABLE      CACHE_PCC_ENABLE
  #define CACHE_PCCFREEZE      CACHE_PCC_FREEZE
  #define CACHE_PCCBYPASS      CACHE_PCC_BYPASS 
  #define CACHE_PCC            CACHE_Pcc 
  #define CACHE_Reset          CACHE_reset
  #define CACHE_SetL2Mode      CACHE_setL2Mode
  #define CACHE_GetL2Mode      CACHE_getL2Mode
  #define CACHE_SetPccMode     CACHE_setPccMode
  #define CACHE_GetL2SramSize  CACHE_getL2SramSize
  //#define CACHE_Init           CACHE_init
  #define CACHE_Init()
  #define CACHE_EnableCaching  CACHE_enableCaching

  #define CACHE_Flush(r,a,w)      CACHE_flush(r,(void*)(a),w)
  #define CACHE_Clean(r,a,w)      CACHE_clean(r,(void*)(a),w)
  #define CACHE_Invalidate(r,a,w) CACHE_invalidate(r,(void*)(a),w)

#endif /* CACHE_SUPPORT */

#if (1)
  //#define CHIP_Init            CHIP_init 
  #define CHIP_Init()              
  #define CHIP_GetCpuId        CHIP_getCpuId
  #define CHIP_GetRevId        CHIP_getRevId
  #define CHIP_GetEndian       CHIP_getEndian
  #define CHIP_GetMapMode      CHIP_getMapMode 
#endif

#if (1)
  #define CSL_Init             CSL_init      
  #define CSLINIT_Init         CSLINIT_init      
  #define CSLLIB_Init          CSLLIB_init
#endif

#if (DAT_SUPPORT)
  #define DAT_Open             DAT_open  
  #define DAT_Close            DAT_close     
  #define DAT_Copy             DAT_copy   
  #define DAT_Fill             DAT_fill    
  #define DAT_Wait             DAT_wait  
  #define DAT_Copy2D           DAT_copy2d   
  //#define DAT_Init             DAT_init 
  #define DAT_Init()
  #define _DAT_Open            _DAT_open  
  #define _DAT_Close           _DAT_close     
  #define _DAT_Copy            _DAT_copy   
  #define _DAT_Fill            _DAT_fill    
  #define _DAT_Wait            _DAT_wait  
  #define _DAT_Copy2D          _DAT_copy2d   
  #define _DAT_Init            _DAT_init 
#endif /* DAT_SUPPORT */

#if (DMA_SUPPORT)
  #define DMA_PRIVATE_OBJ      DMA_PrivateObj
  #define DMA_HANDLE           DMA_Handle
  #define DMA_CONFIG           DMA_Config
  #define DMA_GBL              DMA_Gbl
  #define DMA_HCHA0            _DMA_hCha0
  #define DMA_HCHA1            _DMA_hCha1
  #define DMA_HCHA2            _DMA_hCha2
  #define DMA_HCHA3            _DMA_hCha3
  #define DMA_GBL_PRIVATE      DMA_gblPrivate 
  #define DMA_Reset            DMA_reset           
  #define DMA_Open             DMA_open            
  #define DMA_Close            DMA_close           
  #define DMA_ConfigA          DMA_config           
  #define DMA_ConfigB          DMA_configArgs           
  #define DMA_AllocGlobalReg   DMA_allocGlobalReg           
  #define DMA_FreeGlobalReg    DMA_freeGlobalReg           
  //#define DMA_Init             DMA_init           
  #define DMA_Init()
  #define DMA_GetEventId       DMA_getEventId           
  #define DMA_GetStatus        DMA_getStatus           
  #define DMA_Start            DMA_start           
  #define DMA_Stop             DMA_stop           
  #define DMA_Pause            DMA_pause           
  #define DMA_AutoStart        DMA_autoStart           
  #define DMA_Wait             DMA_wait           
  #define DMA_SetAuxCtl        DMA_setAuxCtl           
  #define DMA_GetGlobalReg     DMA_getGlobalReg           
  #define DMA_SetGlobalReg     DMA_setGlobalReg           

#if (0)
  #define DMA_GBL_ADDRRLDB    0x00000001u
  #define DMA_GBL_ADDRRLDC    0x00000002u
  #define DMA_GBL_ADDRRLDD    0x00000003u
  #define DMA_GBL_INDEXA      0x00000004u
  #define DMA_GBL_INDEXB      0x00000005u
  #define DMA_GBL_CNTRLDA     0x00000008u
  #define DMA_GBL_CNTRLDB     0x00000009u
  #define DMA_GBL_SPLITA      0x0000000Du
  #define DMA_GBL_SPLITB      0x0000000Eu
  #define DMA_GBL_SPLITC      0x0000000Fu

  #define _DMA_GBLREG_CNT     16
  #define _DMA_GBLREG_MASK    (_DMA_GBLREG_CNT-1)
#endif

  #define DMA_MK_AUXCTL(chpri,auxpri) ((Uint32)(\
      HFIELD_SHIFT(HDMA_AUXCTL_CHPRI,chpri)|\
      HFIELD_SHIFT(HDMA_AUXCTL_AUXPRI,auxpri)\
    )\
  )

  #define DMA_MK_PRICTL(start,srcdir,dstdir,esize,split,cntrld,\
    index,rsync,wsync,pri,tcint,fs,emod,srcrld,dstrld) ((UINT32)(\
      HFIELD_SHIFT(HDMA_PRICTL_START,start)|\
      HFIELD_SHIFT(HDMA_PRICTL_SRCDIR,srcdir)|\
      HFIELD_SHIFT(HDMA_PRICTL_DSTDIR,dstdir)|\
      HFIELD_SHIFT(HDMA_PRICTL_ESIZE,esize)|\
      HFIELD_SHIFT(HDMA_PRICTL_SPLIT,split)|\
      HFIELD_SHIFT(HDMA_PRICTL_CNTRLD,cntrld)|\
      HFIELD_SHIFT(HDMA_PRICTL_INDEX,index)|\
      HFIELD_SHIFT(HDMA_PRICTL_RSYNC,rsync)|\
      HFIELD_SHIFT(HDMA_PRICTL_WSYNC,wsync)|\
      HFIELD_SHIFT(HDMA_PRICTL_PRI,pri)|\
      HFIELD_SHIFT(HDMA_PRICTL_TCINT,tcint)|\
      HFIELD_SHIFT(HDMA_PRICTL_FS,fs)|\
      HFIELD_SHIFT(HDMA_PRICTL_EMOD,emod)|\
      HFIELD_SHIFT(HDMA_PRICTL_SRCRLD,srcrld)|\
      HFIELD_SHIFT(HDMA_PRICTL_DSTRLD,dstrld)\
    )\
  )

  #define DMA_MK_SECCTL(sxie,frameie,lastie,blockie,rdropie,wdropie,\
    dmacen,fsig,rspol,wspol) ((UINT32)(\
      HFIELD_SHIFT(HDMA_SECCTL_SXIE,sxie)|\
      HFIELD_SHIFT(HDMA_SECCTL_FRAMEIE,frameie)|\
      HFIELD_SHIFT(HDMA_SECCTL_LASTIE,lastie)|\
      HFIELD_SHIFT(HDMA_SECCTL_BLOCKIE,blockie)|\
      HFIELD_SHIFT(HDMA_SECCTL_RDROPIE,rdropie)|\
      HFIELD_SHIFT(HDMA_SECCTL_WDROPIE,wdropie)|\
      HFIELD_SHIFT(HDMA_SECCTL_DMACEN,dmacen)|\
      HFIELD_SHIFT(HDMA_SECCTL_FSIG,fsig)|\
      HFIELD_SHIFT(HDMA_SECCTL_RSPOL,rspol)|\
      HFIELD_SHIFT(HDMA_SECCTL_WSPOL,wspol)\
    )\
  )

  #define DMA_MK_SRC(src) ((Uint32)(\
      HFIELD_SHIFT(HDMA_SRC_SRC,src)\
    )\
  )

  #define DMA_MK_DST(dst) ((Uint32)(\
      HFIELD_SHIFT(HDMA_DST_DST,dst)\
    )\
  )

  #define DMA_MK_XFRCNT(elecnt,frmcnt) ((Uint32)(\
      HFIELD_SHIFT(HDMA_XFRCNT_ELECNT,elecnt)|\
      HFIELD_SHIFT(HDMA_XFRCNT_FRMCNT,frmcnt)\
    )\
  )

  #define DMA_MK_GBLCNT(elecnt,frmcnt) ((Uint32)(\
      HFIELD_SHIFT(HDMA_GBLCNT_ELECNT,elecnt)|\
      HFIELD_SHIFT(HDMA_GBLCNT_FRMCNT,frmcnt)\
    )\
  )

  #define DMA_MK_GBLIDX(eleidx,frmidx) ((Uint32)(\
      HFIELD_SHIFT(HDMA_GBLIDX_ELEIDX,eleidx)|\
      HFIELD_SHIFT(HDMA_GBLIDX_FRMIDX,frmidx)\
    )\
  )

  #define DMA_MK_GBLADDR(gbladdr) ((Uint32)(\
      HFIELD_SHIFT(HDMA_GBLADDR_GBLADDR,gbladdr)\
    )\
  )
#endif /* DMA_SUPPORT */

#if (EDMA_SUPPORT)
  #define EDMA_HANDLE          EDMA_Handle
  #define EDMA_CONFIG          EDMA_Config
  #define EDMA_Reset           EDMA_reset
  #define EDMA_Open            EDMA_open
  #define EDMA_Close           EDMA_close
  #define EDMA_AllocTable      EDMA_allocTable
  #define EDMA_FreeTable       EDMA_freeTable
  #define EDMA_ConfigA         EDMA_config
  #define EDMA_ConfigB         EDMA_configArgs
  //#define EDMA_Init            EDMA_init              
  #define EDMA_Init() 
  #define EDMA_GetScratchAddr  EDMA_getScratchAddr              
  #define EDMA_GetScratchSize  EDMA_getScratchSize              
  #define EDMA_GetPriQStatus   EDMA_getPriQStatus              
  #define EDMA_EnableChannel   EDMA_enableChannel    
  #define EDMA_DisableChannel  EDMA_disableChannel              
  #define EDMA_SetChannel      EDMA_setChannel              
  #define EDMA_GetChannel      EDMA_getChannel              
  #define EDMA_ClearChannel    EDMA_clearChannel              
  #define EDMA_GetTableAddress EDMA_getTableAddress              

  #if (0)
    #define EDMA_CCER            HEDMA_CCER
    #define EDMA_CIPR            HEDMA_CIPR
    #define EDMA_CIER            HEDMA_CIER
  #endif

  #define EDMA_MK_OPT(fs,link,tcc,tcint,dum,d2d,sum,s2d,esize,pri)\
    ((Uint32)( \
      HFIELD_SHIFT(HEDMA_OPT_FS,fs)| \
      HFIELD_SHIFT(HEDMA_OPT_LINK,link)| \
      HFIELD_SHIFT(HEDMA_OPT_TCC,tcc)| \
      HFIELD_SHIFT(HEDMA_OPT_TCINT,tcint)| \
      HFIELD_SHIFT(HEDMA_OPT_DUM,dum)| \
      HFIELD_SHIFT(HEDMA_OPT_2DD,d2d)| \
      HFIELD_SHIFT(HEDMA_OPT_SUM,sum)| \
      HFIELD_SHIFT(HEDMA_OPT_2DS,s2d)| \
      HFIELD_SHIFT(HEDMA_OPT_ESIZE,esize)| \
      HFIELD_SHIFT(HEDMA_OPT_PRI,pri) \
    ) \
  )

  #define EDMA_MK_SRC(src) \
    ((Uint32)(\
      HFIELD_SHIFT(HEDMA_SRC_SRC,src)\
    )\
  )

  #define EDMA_MK_CNT(elecnt,frmcnt)\
    ((Uint32)(\
      HFIELD_SHIFT(HEDMA_CNT_ELECNT,elecnt)|\
      HFIELD_SHIFT(HEDMA_CNT_FRMCNT,frmcnt)\
    )\
  )

  #define EDMA_MK_DST(dst) \
    ((Uint32)(\
      HFIELD_SHIFT(HEDMA_DST_DST,dst)\
    )\
  )

  #define EDMA_MK_IDX(eleidx,frmidx)\
    ((Uint32)(\
      HFIELD_SHIFT(HEDMA_IDX_ELEIDX,eleidx)|\
      HFIELD_SHIFT(HEDMA_IDX_FRMIDX,frmidx)\
    )\
  )

  #define EDMA_MK_RLD(link,elerld)\
    ((Uint32)(\
      HFIELD_SHIFT(HEDMA_RLD_LINK,link)|\
      HFIELD_SHIFT(HEDMA_RLD_ELERLD,elerld)\
    )\
  )
#endif /* EDMA_SUPPORT */


#if (EMIF_SUPPORT)
 /* 3 following functions are declared later on */
  // EMIF_CONFIG           
  // EMIF_ConfigA          
  // EMIF_ConfigB         
  
  //#define EMIF_Init            EMIF_init
  #define EMIF_Init()
  
  #define EMIF_GBLCTL_RBTR8_NA             (0x00000000)
  #define EMIF_GBLCTL_SSCRT_NA             (0x00000000)
  #define EMIF_GBLCTL_CLK2EN_NA            (0x00000000)
  #define EMIF_GBLCTL_SSCEN_NA             (0x00000000)
  #define EMIF_GBLCTL_SDCEN_NA             (0x00000000)
  #define EMIF_CECTL_TA_NA                 (0x00000000)
  #define EMIF_SDCTL_SDWID_NA              (0x00000000)
  #define EMIF_SDCTL_SDCSZ_NA              (0x00000000)
  #define EMIF_SDCTL_SDRSZ_NA              (0x00000000)
  #define EMIF_SDCTL_SDBSZ_NA              (0x00000000)
  #define EMIF_SDTIM_XRFR_NA               (0x00000000)
  #define EMIF_SDEXT_NA                    (0x00000000)

/* added for reported bug SDSsq22603*/
  #define EMIF_GBLCTL_NOHOLD_0       EMIF_GBLCTL_NOHOLD_DISABLE
  #define EMIF_GBLCTL_NOHOLD_1       EMIF_GBLCTL_NOHOLD_ENABLE


  #define  EMIF_CECTL_TA_OF(x)         _VALUEOF(x)
  #define  EMIF_SDEXT_OF(x)            _VALUEOF(x)

  #define EMIF_MK_GBLCTL(rbtr8,sscrt,clk2en,clk1en,sscen,sdcen,nohold)\
    ((Uint32)( \
      HFIELD_SHIFT(HEMIF_GBLCTL_RBTR8,rbtr8)|\
      HFIELD_SHIFT(HEMIF_GBLCTL_SSCRT,sscrt)|\
      HFIELD_SHIFT(HEMIF_GBLCTL_CLK2EN,clk2en)|\
      HFIELD_SHIFT(HEMIF_GBLCTL_CLK1EN,clk1en)|\
      HFIELD_SHIFT(HEMIF_GBLCTL_SSCEN,sscen)|\
      HFIELD_SHIFT(HEMIF_GBLCTL_SDCEN,sdcen)|\
      HFIELD_SHIFT(HEMIF_GBLCTL_NOHOLD,nohold)|\
      0x00003000 \
    )\
  )

  #define EMIF_MK_CECTL(rdhld,mtype,rdstrb,ta,rdsetup,wrhld,wrstrb,wrsetup)\
    ((Uint32)( \
      HFIELD_SHIFT(HEMIF_CECTL_RDHLD,rdhld)|\
      HFIELD_SHIFT(HEMIF_CECTL_WRHLDMSB,(wrhld>>2))|\
      HFIELD_SHIFT(HEMIF_CECTL_MTYPE,mtype)|\
      HFIELD_SHIFT(HEMIF_CECTL_RDSTRB,rdstrb)|\
      HFIELD_SHIFT(HEMIF_CECTL_TA,ta)|\
      HFIELD_SHIFT(HEMIF_CECTL_RDSETUP,rdsetup)|\
      HFIELD_SHIFT(HEMIF_CECTL_WRHLD,wrhld)|\
      HFIELD_SHIFT(HEMIF_CECTL_WRSTRB,wrstrb)|\
      HFIELD_SHIFT(HEMIF_CECTL_WRSETUP,wrsetup)\
    )\
  )

  #define EMIF_MK_SDCTL(trc,trp,trcd,init,rfen,sdwid,sdcsz,sdrsz,sdbsz)\
    ((Uint32)( \
      HFIELD_SHIFT(HEMIF_SDCTL_TRC,trc)|\
      HFIELD_SHIFT(HEMIF_SDCTL_TRP,trp)|\
      HFIELD_SHIFT(HEMIF_SDCTL_TRCD,trcd)|\
      HFIELD_SHIFT(HEMIF_SDCTL_INIT,init)|\
      HFIELD_SHIFT(HEMIF_SDCTL_RFEN,rfen)|\
      HFIELD_SHIFT(HEMIF_SDCTL_SDWID,sdwid)|\
      HFIELD_SHIFT(HEMIF_SDCTL_SDCSZ,sdcsz)|\
      HFIELD_SHIFT(HEMIF_SDCTL_SDRSZ,sdrsz)|\
      HFIELD_SHIFT(HEMIF_SDCTL_SDBSZ,sdbsz)\
    )\
  )

  #define EMIF_MK_SDTIM(period,xrfr)\
    ((Uint32)( \
      HFIELD_SHIFT(HEMIF_SDTIM_PERIOD,period)|\
      HFIELD_SHIFT(HEMIF_SDTIM_XRFR,xrfr)\
    )\
  )

  #define EMIF_MK_SDEXT(tcl,tras,trrd,twr,thzp,rd2rd,rd2deac,rd2wr,\
    r2wdqm,wr2wr,wr2deac,wr2rd) ((Uint32)( \
      HFIELD_SHIFT(HEMIF_SDEXT_TCL,tcl)|\
      HFIELD_SHIFT(HEMIF_SDEXT_TRAS,tras)|\
      HFIELD_SHIFT(HEMIF_SDEXT_TRRD,trrd)|\
      HFIELD_SHIFT(HEMIF_SDEXT_TWR,twr)|\
      HFIELD_SHIFT(HEMIF_SDEXT_THZP,thzp)|\
      HFIELD_SHIFT(HEMIF_SDEXT_RD2RD,rd2rd)|\
      HFIELD_SHIFT(HEMIF_SDEXT_RD2DEAC,rd2deac)|\
      HFIELD_SHIFT(HEMIF_SDEXT_RD2WR,rd2wr)|\
      HFIELD_SHIFT(HEMIF_SDEXT_R2WDQM,r2wdqm)|\
      HFIELD_SHIFT(HEMIF_SDEXT_WR2WR,wr2wr)|\
      HFIELD_SHIFT(HEMIF_SDEXT_WR2DEAC,wr2deac)|\
      HFIELD_SHIFT(HEMIF_SDEXT_WR2RD,wr2rd)\
    )\
  )
#endif /* EMIF_SUPPORT */


#if  (GPIO_SUPPORT && C64_SUPPORT)

#define GPIO_config(config)    GPIO_config(_hGpioDev0,config);
#define GPIO_configArgs( gpgc, gpen,  gpdir, gpval, gphm,  gplm,  gppol)\
        GPIO_configArgs(_hGpioDev0, gpgc, gpen,  gpdir, gpval,   gphm,  gplm,  gppol)
#define GPIO_getConfig(config)  GPIO_getConfig(_hGpioDev0,config)


#define GPIO_pinEnable(pinId)  GPIO_pinEnable(_hGpioDev0,pinId)

#define GPIO_pinDisable(pinId) GPIO_pinDisable(_hGpioDev0, pinId)
#define GPIO_pinDirection(pinId,direction) GPIO_pinDirection(_hGpioDev0,pinId,direction)


#define GPIO_pinRead( pinId) GPIO_pinRead(_hGpioDev0, pinId)
#define GPIO_read( pinMask) GPIO_read(_hGpioDev0, pinMask)

/* For output Pins */
#define GPIO_pinWrite( pinId,  val) GPIO_pinWrite(_hGpioDev0, pinId,  val)
#define GPIO_write( pinMask,  val)  GPIO_write(_hGpioDev0, pinMask,  val)


/* For input Pins */
#define GPIO_deltaHighGet( pinId) GPIO_deltaHighGet(_hGpioDev0, pinId)
#define GPIO_deltaHighClear( pinId) GPIO_deltaHighClear(_hGpioDev0, pinId)
#define GPIO_deltaLowGet( pinId) GPIO_deltaLowGet(_hGpioDev0, pinId)
#define GPIO_deltaLowClear( pinId) GPIO_deltaLowClear(_hGpioDev0, pinId)

#define GPIO_maskHighSet( pinId) GPIO_maskHighSet(_hGpioDev0, pinId)
#define GPIO_maskHighClear( pinId) GPIO_maskHighClear(_hGpioDev0, pinId)
#define GPIO_maskLowSet( pinId) GPIO_maskLowSet(_hGpioDev0, pinId)
#define GPIO_maskLowClear( pinId) GPIO_maskLowClear(_hGpioDev0, pinId)

/* Pass Through Mode */
#define GPIO_intPolarity(signal,polarity) GPIO_intPolarity(_hGpioDev0, signal,  polarity)

#endif



#if (HPI_SUPPORT)
  //#define HPI_Init             HPI_init      
  #define HPI_Init()
  #define HPI_GetEventId       HPI_getEventId      
  #define HPI_GetHwob          HPI_getHwob      
  #define HPI_GetDspint        HPI_getDspint      
  #define HPI_GetHint          HPI_getHint      
  #define HPI_GetHrdy          HPI_getHrdy      
  #define HPI_GetFetch         HPI_getFetch      
  #define HPI_SetDspint        HPI_setDspint      
  #define HPI_SetHint          HPI_setHint      
#endif /* HPI_SUPPORT */

#if (IRQ_SUPPORT)
  #define IntMask              intMask         
  #define IRQ_EVENT            IRQ_Event         
  #define IRQ_EventTable       IRQ_eventTable         
  #define IRQ_IntTable         IRQ_intTable         
  //#define IRQ_Init             IRQ_init  
  #define IRQ_Init()                  
  #define IRQ_Map              IRQ_map         
  #define IRQ_Enable           IRQ_enable         
  #define IRQ_Disable          IRQ_disable         
  #define IRQ_Set              IRQ_set         
  #define IRQ_Clear            IRQ_clear         
  #define IRQ_Test             IRQ_test         
  #define IRQ_DisableGie       IRQ_globalDisable
  #define IRQ_RestoreGie       IRQ_globalRestore
#endif /* IRQ_SUPPORT */

#if (MCBSP_SUPPORT)

  #define BaseAddr              baseAddr 
  #define MCBSP_PRIVATE_OBJ    MCBSP_PrivateObj        
  #define MCBSP_HANDLE         MCBSP_Handle        
  #define MCBSP_CONFIG         MCBSP_Config        
  #define MCBSP_HDEV0          _MCBSP_hDev0        
  #define MCBSP_HDEV1          _MCBSP_hDev1        
  #define MCBSP_HDEV2          _MCBSP_hDev2        
  #define MCBSP_Reset          MCBSP_reset        
  #define MCBSP_Open           MCBSP_open         
  #define MCBSP_Close          MCBSP_close        
  #define MCBSP_ConfigA        MCBSP_config
  #define MCBSP_ConfigB        MCBSP_configArgs
  #define MCBSP_GetPins        MCBSP_getPins        
  #define MCBSP_SetPins        MCBSP_setPins        
  //#define MCBSP_Init           MCBSP_init         
  #define MCBSP_Init()  
  #define MCBSP_GetXmtAddr     MCBSP_getXmtAddr        
  #define MCBSP_GetRcvAddr     MCBSP_getRcvAddr        
  #define MCBSP_GetXmtEventId  MCBSP_getXmtEventId        
  #define MCBSP_GetRcvEventId  MCBSP_getRcvEventId        
  #define MCBSP_Read           MCBSP_read 
  #define MCBSP_Write          MCBSP_write   
  #define MCBSP_EnableXmt      MCBSP_enableXmt        
  #define MCBSP_EnableRcv      MCBSP_enableRcv        
  #define MCBSP_EnableFsync    MCBSP_enableFsync        
  #define MCBSP_EnableSrgr     MCBSP_enableSrgr        
  #define MCBSP_Xrdy           MCBSP_xrdy         
  #define MCBSP_Rrdy           MCBSP_rrdy         
  #define MCBSP_Xempty         MCBSP_xempty        
  #define MCBSP_Rfull          MCBSP_rfull        
  #define MCBSP_XsyncErr       MCBSP_xsyncerr        
  #define MCBSP_RsyncErr       MCBSP_rsyncerr        

  #define MCBSP_SPCR_DXENA_NA               (0x00000000)
  #define MCBSP_RCR_RWDREVRS_NA             (0x00000000)
  #define MCBSP_RCR_RPHASE2_NA              (0x00000000)
  #define MCBSP_RCR_RPHASE2_NORMAL          (0x00000000)
  #define MCBSP_RCR_RPHASE2_OPPOSITE        (0x00000000)
  #define MCBSP_XCR_XWDREVRS_NA             (0x00000000)
  #define MCBSP_XCR_XPHASE2_NA              (0x00000000)
  #define MCBSP_XCR_XPHASE2_NORMAL          (0x00000000)
  #define MCBSP_XCR_XPHASE2_OPPOSITE        (0x00000000)

  #define MCBSP_DRR_OFFSET   0
  #define MCBSP_DXR_OFFSET   1
  #define MCBSP_SPCR_OFFSET  2
  #define MCBSP_RCR_OFFSET   3
  #define MCBSP_XCR_OFFSET   4
  #define MCBSP_SRGR_OFFSET  5
  #define MCBSP_MCR_OFFSET   6
  #define MCBSP_RCER_OFFSET  7
  #define MCBSP_XCER_OFFSET  8
  #define MCBSP_PCR_OFFSET   9

  #define MCBSP_ALLOCATED(hMcbsp) ((hMcbsp)->Allocated)
  #define MCBSP_XMTEVENTID(hMcbsp) ((hMcbsp)->XmtEventId)
  #define MCBSP_RCVEVENTID(hMcbsp) ((hMcbsp)->RcvEventId)
  #define MCBSP_DRR(hMcbsp)  (((hMcbsp)->BaseAddr)[MCBSP_DRR_OFFSET])
  #define MCBSP_DXR(hMcbsp)  (((hMcbsp)->BaseAddr)[MCBSP_DXR_OFFSET])
  #define MCBSP_SPCR(hMcbsp) (((hMcbsp)->BaseAddr)[MCBSP_SPCR_OFFSET])
  #define MCBSP_RCR(hMcbsp)  (((hMcbsp)->BaseAddr)[MCBSP_RCR_OFFSET])
  #define MCBSP_XCR(hMcbsp)  (((hMcbsp)->BaseAddr)[MCBSP_XCR_OFFSET])
  #define MCBSP_SRGR(hMcbsp) (((hMcbsp)->BaseAddr)[MCBSP_SRGR_OFFSET])
  #define MCBSP_MCR(hMcbsp)  (((hMcbsp)->BaseAddr)[MCBSP_MCR_OFFSET])
  #define MCBSP_RCER(hMcbsp) (((hMcbsp)->BaseAddr)[MCBSP_RCER_OFFSET])
  #define MCBSP_XCER(hMcbsp) (((hMcbsp)->BaseAddr)[MCBSP_XCER_OFFSET])
  #define MCBSP_PCR(hMcbsp)  (((hMcbsp)->BaseAddr)[MCBSP_PCR_OFFSET])


  #define MCBSP_MK_SPCR(rrst,rintm,dxena,clkstp,rjust,dlb,xrst,xintm,grst,\
    frst) ((Uint32)( \
      HFIELD_SHIFT(HMCBSP_SPCR_RRST,rrst)| \
      HFIELD_SHIFT(HMCBSP_SPCR_RINTM,rintm)| \
      HFIELD_SHIFT(HMCBSP_SPCR_DXENA,dxena)| \
      HFIELD_SHIFT(HMCBSP_SPCR_CLKSTP,clkstp)| \
      HFIELD_SHIFT(HMCBSP_SPCR_RJUST,rjust)| \
      HFIELD_SHIFT(HMCBSP_SPCR_DLB,dlb)| \
      HFIELD_SHIFT(HMCBSP_SPCR_XRST,xrst)| \
      HFIELD_SHIFT(HMCBSP_SPCR_XINTM,xintm)| \
      HFIELD_SHIFT(HMCBSP_SPCR_GRST,grst)| \
      HFIELD_SHIFT(HMCBSP_SPCR_FRST,frst) \
    ) \
  )


/******** redefined for CSL 1.2 / 1.23 ************/
  #define _MCBSP_RCR_RPHASE2_MASK      0x00008000u
  #define _MCBSP_RCR_RPHASE2_SHIFT     0x0000000Fu
  #define  MCBSP_RCR_RPHASE2_DEFAULT   0x00000000u
  #define  MCBSP_RCR_RPHASE2_OF(x)     _VALUEOF(x)
  
  #define _MCBSP_XCR_XPHASE2_MASK      0x00008000u
  #define _MCBSP_XCR_XPHASE2_SHIFT     0x0000000Fu
  #define  MCBSP_XCR_XPHASE2_DEFAULT   0x00000000u
  #define  MCBSP_XCR_XPHASE2_OF(x)     _VALUEOF(x)



  #define MCBSP_MK_RCR(rwdrevrs,rwdlen1,rfrlen1,rphase2,rdatdly,rfig,\
    rcompand,rwdlen2,rfrlen2,rphase) ((Uint32)(\
      HFIELD_SHIFT(HMCBSP_RCR_RWDREVRS,rwdrevrs)|\
      HFIELD_SHIFT(HMCBSP_RCR_RWDLEN1,rwdlen1)|\
      HFIELD_SHIFT(HMCBSP_RCR_RFRLEN1,rfrlen1)|\
      HFIELD_SHIFT(HMCBSP_RCR_RPHASE2,rphase2)|\
      HFIELD_SHIFT(HMCBSP_RCR_RDATDLY,rdatdly)|\
      HFIELD_SHIFT(HMCBSP_RCR_RFIG,rfig)|\
      HFIELD_SHIFT(HMCBSP_RCR_RCOMPAND,rcompand)|\
      HFIELD_SHIFT(HMCBSP_RCR_RWDLEN2,rwdlen2)|\
      HFIELD_SHIFT(HMCBSP_RCR_RFRLEN2,rfrlen2)|\
      HFIELD_SHIFT(HMCBSP_RCR_RPHASE,rphase)\
    ) \
  )

  #define MCBSP_MK_XCR(xwdrevrs,xwdlen1,xfrlen1,xphase2,xdatdly,xfig,\
    xcompand,xwdlen2,xfrlen2,xphase) ((Uint32)(\
      HFIELD_SHIFT(HMCBSP_XCR_XWDREVRS,xwdrevrs)|\
      HFIELD_SHIFT(HMCBSP_XCR_XWDLEN1,xwdlen1)|\
      HFIELD_SHIFT(HMCBSP_XCR_XFRLEN1,xfrlen1)|\
      HFIELD_SHIFT(HMCBSP_XCR_XPHASE2,xphase2)|\
      HFIELD_SHIFT(HMCBSP_XCR_XDATDLY,xdatdly)|\
      HFIELD_SHIFT(HMCBSP_XCR_XFIG,xfig)|\
      HFIELD_SHIFT(HMCBSP_XCR_XCOMPAND,xcompand)|\
      HFIELD_SHIFT(HMCBSP_XCR_XWDLEN2,xwdlen2)|\
      HFIELD_SHIFT(HMCBSP_XCR_XFRLEN2,xfrlen2)|\
      HFIELD_SHIFT(HMCBSP_XCR_XPHASE,xphase)\
    ) \
  )

  /* make SRGR register value based on symbolic constants */
  #define MCBSP_MK_SRGR(clkgdv,fwid,fper,fsgm,clksm,clksp,gsync) (\
    (Uint32)(\
      HFIELD_SHIFT(HMCBSP_SRGR_CLKGDV,clkgdv)|\
      HFIELD_SHIFT(HMCBSP_SRGR_FWID,fwid)|\
      HFIELD_SHIFT(HMCBSP_SRGR_FPER,fper)|\
      HFIELD_SHIFT(HMCBSP_SRGR_FSGM,fsgm)|\
      HFIELD_SHIFT(HMCBSP_SRGR_CLKSM,clksm)|\
      HFIELD_SHIFT(HMCBSP_SRGR_CLKSP,clksp)|\
      HFIELD_SHIFT(HMCBSP_SRGR_GSYNC,gsync)\
    )\
  )
  
  #define MCBSP_MK_MCR(rmcm,rpablk,rpbblk,xmcm,xpablk,xpbblk)\
    ((Uint32)(\
      HFIELD_SHIFT(HMCBSP_MCR_RMCM,rmcm)|\
      HFIELD_SHIFT(HMCBSP_MCR_RPABLK,rpablk)|\
      HFIELD_SHIFT(HMCBSP_MCR_RPBBLK,rpbblk)|\
      HFIELD_SHIFT(HMCBSP_MCR_XMCM,xmcm)|\
      HFIELD_SHIFT(HMCBSP_MCR_XPABLK,xpablk)|\
      HFIELD_SHIFT(HMCBSP_MCR_XPBBLK,xpbblk)\
    )\
  )
  
  #define MCBSP_MK_RCER(rcea,rceb) (\
    (Uint32)(\
      (((Uint32)(rcea))&0x0000FFFF)|\
      ((((Uint32)(rceb))<<16)&0xFFFF0000)\
    )\
  )
  
  #define MCBSP_MK_XCER(xcea,xceb) (\
    (Uint32)(\
      (((Uint32)(xcea))&0x0000FFFF)|\
      ((((Uint32)(xceb))<<16)&0xFFFF0000)\
      )\
  )

  #define MCBSP_MK_PCR(clkrp,clkxp,fsrp,fsxp,dxstat,clksstat,clkrm,clkxm,\
    fsrm,fsxm,rioen,xioen) ((Uint32)(\
      HFIELD_SHIFT(HMCBSP_PCR_CLKRP,clkrp)|\
      HFIELD_SHIFT(HMCBSP_PCR_CLKXP,clkxp)|\
      HFIELD_SHIFT(HMCBSP_PCR_FSRP,fsrp)|\
      HFIELD_SHIFT(HMCBSP_PCR_FSXP,fsxp)|\
      HFIELD_SHIFT(HMCBSP_PCR_DXSTAT,dxstat)|\
      HFIELD_SHIFT(HMCBSP_PCR_CLKSSTAT,clksstat)|\
      HFIELD_SHIFT(HMCBSP_PCR_CLKRM,clkrm)|\
      HFIELD_SHIFT(HMCBSP_PCR_CLKXM,clkxm)|\
      HFIELD_SHIFT(HMCBSP_PCR_FSRM,fsrm)|\
      HFIELD_SHIFT(HMCBSP_PCR_FSXM,fsxm)|\
      HFIELD_SHIFT(HMCBSP_PCR_RIOEN,rioen)|\
      HFIELD_SHIFT(HMCBSP_PCR_XIOEN,xioen)\
    )\
  )
#endif /* MCBSP_SUPPORT */

#if (PWR_SUPPORT)
  #define PWR_MODE             PWR_Mode     
  //#define PWR_Init             PWR_init     
  #define PWR_Init() 
  #define PWR_PowerDown        PWR_powerDown    
  #define PWR_ConfigB          PWR_configArgs

  #define PWR_MK_PDCTL(dma,emif,mcbsp0,mcbsp1,mcbsp2) ((Uint32)( \
      HFIELD_SHIFT(HPWR_PDCTL_DMA,dma)|\
      HFIELD_SHIFT(HPWR_PDCTL_EMIF,emif)|\
      HFIELD_SHIFT(HPWR_PDCTL_MCBSP0,mcbsp0)|\
      HFIELD_SHIFT(HPWR_PDCTL_MCBSP1,mcbsp1)|\
      HFIELD_SHIFT(HPWR_PDCTL_MCBSP2,mcbsp2)\
    )\
  )
#endif /* PWR_SUPPORT */


#if (1)
  #define UINT8                Uint8   
  #define UINT16               Uint16   
  #define UINT32               Uint32   
  #define UINT40               Uint40   
  #define INT8                 Int8   
  #define INT16                Int16   
  #define INT32                Int32   
  #define INT40                Int40   
  #define BOOL                 int
  #define HANDLE               Handle   
#endif

#if (TIMER_SUPPORT)
  #define TIMER_PRIVATE_OBJ    TIMER_PrivateObj       
  #define TIMER_HANDLE         TIMER_Handle       
  #define TIMER_CONFIG         TIMER_Config       
  #define TIMER_HDEV0          _TIMER_hDev0       
  #define TIMER_HDEV1          _TIMER_hDev1       
  #define TIMER_Reset          TIMER_reset       
  #define TIMER_Open           TIMER_open       
  #define TIMER_Close          TIMER_close       
  #define TIMER_ConfigA        TIMER_config
  #define TIMER_ConfigB        TIMER_configArgs
  //#define TIMER_Init           TIMER_init       
  #define TIMER_Init()
  #define TIMER_GetEventId     TIMER_getEventId       
  #define TIMER_Start          TIMER_start       
  #define TIMER_Pause          TIMER_pause       
  #define TIMER_Resume         TIMER_resume       
  #define TIMER_GetPeriod      TIMER_getPeriod       
  #define TIMER_SetPeriod      TIMER_setPeriod       
  #define TIMER_GetCount       TIMER_getCount       
  #define TIMER_SetCount       TIMER_setCount       
  #define TIMER_GetDatin       TIMER_getDatIn       
  #define TIMER_SetDatout      TIMER_setDatOut       
  #define TIMER_GetTstat       TIMER_getTStat       

  /* make CTL register value based on symbolic constants */
  #define TIMER_MK_CTL(func,invout,datout,pwid,go,hld,cp,clksrc,invinp)\
    ((Uint32)( \
      HFIELD_SHIFT(HTIMER_CTL_FUNC,func)|\
      HFIELD_SHIFT(HTIMER_CTL_INVOUT,invout)|\
      HFIELD_SHIFT(HTIMER_CTL_DATOUT,datout)|\
      HFIELD_SHIFT(HTIMER_CTL_PWID,pwid)|\
      HFIELD_SHIFT(HTIMER_CTL_GO,go)|\
      HFIELD_SHIFT(HTIMER_CTL_HLD,hld)|\
      HFIELD_SHIFT(HTIMER_CTL_CP,cp)|\
      HFIELD_SHIFT(HTIMER_CTL_CLKSRC,clksrc)|\
      HFIELD_SHIFT(HTIMER_CTL_INVINP,invinp)\
    ) \
  )
#endif /* TIMER_SUPPORT */


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

#if (DMA_SUPPORT&&0)
  typedef enum {
    DMA_GBL_ADDRRLD = 0x00,
    DMA_GBL_INDEX   = 0x04,
    DMA_GBL_CNTRLD  = 0x08,
    DMA_GBL_SPLIT   = 0x0C
  } DMA_Gbl;
#endif /* DMA_SUPPORT */

#if (EMIF_SUPPORT)
/* device configuration structure */
typedef struct {
  UINT32 gblctl;
  UINT32 ce0ctl;
  UINT32 ce1ctl;
  UINT32 ce2ctl;
  UINT32 ce3ctl;
  UINT32 sdctl;
  UINT32 sdtim;
  UINT32 sdext;
} EMIF_CONFIG;
#endif /* EMIF_SUPPORT */


/******************************************************************************\
* global variable declarations
\******************************************************************************/
#if (DMA_SUPPORT&&0)
  extern far Uint32 _DMA_gblRegTbl[_DMA_GBLREG_CNT];
#endif /* DMA_SUPPORT */


/******************************************************************************\
* global function declarations
\******************************************************************************/
#if (DMA_SUPPORT&&0)
  CSLAPI Uint32 DMA_allocGlobalReg(DMA_Gbl regType, Uint32 initVal);
  CSLAPI void   DMA_freeGlobalReg(Uint32 regId);
#endif /* DMA_SUPPORT */
  
#if (EMIF_SUPPORT)
  CSLAPI void EMIF_ConfigA(EMIF_CONFIG *Config);
  CSLAPI void EMIF_ConfigB(UINT32 gblctl, UINT32 ce0ctl, UINT32 ce1ctl,
    UINT32 ce2ctl, UINT32 ce3ctl, UINT32 sdctl, UINT32 sdtim, UINT32 sdext);
#endif

/******************************************************************************\
* inline function declarations
\******************************************************************************/
#if (DMA_SUPPORT&&0)
  IDECL Uint32 DMA_getGlobalRegAddr(Uint32 regId);
  IDECL Uint32 DMA_getGlobalReg(Uint32 regId);
  IDECL void   DMA_setGlobalReg(Uint32 regId, Uint32 val);
#endif /* DMA_SUPPORT */


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
#if (DMA_SUPPORT&&0)
/*----------------------------------------------------------------------------*/
IDEF Uint32 DMA_getGlobalRegAddr(Uint32 regId) {
  return _DMA_gblRegTbl[regId&_DMA_GBLREG_MASK];
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 DMA_getGlobalReg(Uint32 regId) {
  return REG32(_DMA_gblRegTbl[regId&_DMA_GBLREG_MASK]);
}
/*----------------------------------------------------------------------------*/
IDEF void DMA_setGlobalReg(Uint32 regId, Uint32 val) {
  REG32(_DMA_gblRegTbl[regId&_DMA_GBLREG_MASK])=val;
}
/*----------------------------------------------------------------------------*/
#endif /* DMA_SUPPORT */
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* _CSL_LEGACY_H_ */
/******************************************************************************\
* End of csl_legacy.h
\******************************************************************************/


csl_legacyhal.h/1055155791  0     0     0       405941    `
/*
 *  Copyright 2001 by Texas Instruments Incorporated.
 *  All rights reserved. Property of Texas Instruments Incorporated.
 *  Restricted rights to use, duplicate or disclose this code are
 *  granted through contract.
 *  
 */
/* "@(#) DSP/BIOS 4.60.22 12-07-01 (barracuda-j15)" */
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_legacyhal.h
* DATE CREATED.. 09/01/2000
* LAST MODIFIED. 03/08/2002
\******************************************************************************/
#ifndef _CSL_LEGACYHAL_H_
#define _CSL_LEGACYHAL_H_

#include "csl_stdinc.h"
#include "csl_chiphal.h"

/*----------------------------------------------------------------------------*/
/* Legacy HAL support macro definitions                                       */
/*----------------------------------------------------------------------------*/
  #define _VALUEOF(x) ((Uint32)(x))

#ifndef UNREFERENCED_PARAMETER
  #define UNREFERENCED_PARAMETER(P)    ((P)=(P))
#endif

#ifndef REG32
  #define REG32(addr) (*(volatile unsigned int*)(addr))
  #define REG16(addr) (*(volatile unsigned short*)(addr))
  #define REG8(addr) (*(volatile unsigned char*)(addr))
#endif

/* memory mapped register macros */
#define HFIELD_GET(RegAddr,FIELD) (Uint32)( \
  (REG32(RegAddr)&##FIELD##_MASK)>>##FIELD##_SHIFT \
)

#define HFIELD_SET(RegAddr,FIELD,Val) REG32(RegAddr)=(Uint32)( \
  (REG32(RegAddr)&~##FIELD##_MASK)| \
  (((Uint32)(Val)<<##FIELD##_SHIFT)&##FIELD##_MASK) \
)

#define HFIELD_SHIFT(FIELD,Val) \
  (((Uint32)(Val)<<##FIELD##_SHIFT)&##FIELD##_MASK)

#define HREG32_GET(RegAddr) \
  (Uint32)REG32(RegAddr)

#define HREG32_SET(RegAddr,Val) \
  REG32(RegAddr)=(Uint32)(Val)

/* control register macros */
#define HCRFIELD_GET(CRREG,FIELD) (Uint32)( \
  (((CRREG)&##FIELD##_MASK)>>##FIELD##_SHIFT) \
)



#define HCRFIELD_SET(CRREG,FIELD,Val) CRREG = (Uint32)( \
  ((CRREG)&~##FIELD##_MASK)| \
  (((Uint32)(Val)<<##FIELD##_SHIFT)&##FIELD##_MASK) \
)

#define HCRFIELD_SHIFT(FIELD,Val) \
  (((Uint32)(Val)<<##FIELD##_SHIFT)&##FIELD##_MASK)

#define HCRREG32_GET(CRREG) \
  (Uint32)(CRREG)

#define HCRREG32_SET(CRREG,Val) \
  (CRREG)=(Uint32)(Val)


/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... chiphal.h
* DATE CREATED.. 08/19/1999 
* LAST MODIFIED. 03/08/2000
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the CHIP module)
* 
* CHIP Control Registers Covered
*   HCHIP_CSR    - control status register
*   HCHIP_IFR    - interrupt flag register
*   HCHIP_ISR    - interrupt set register
*   HCHIP_ICR    - interrupt clear register
*   HCHIP_IER    - interrupt enable register
*   HCHIP_ISTP   - interrupt service table pointer
*   HCHIP_IRP    - interrrupt return pointer
*   HCHIP_NRP    - nonmaskable interrupt return pointer
*   HCHIP_AMR    - addressing mode register
*   HCHIP_FADCR  - floating-point adder config register (1)
*   HCHIP_FAUCR  - floating-point auxiliary config register (1)
*   HCHIP_FMCR   - floating-point multiplier config register (1)
*
*   (1) only on devices with an FPU
*
\******************************************************************************/
#ifndef _CHIPHAL_H_
#define _CHIPHAL_H_

/*----------------------------------------------------------------*/

#define HCHIP_PERBASE_ADDR   (0x01800000)

/******************************************************************************\
* HCHIP_NULL - dummy register
*
\******************************************************************************/
  #define HCHIP_NULL_ADDR                       ((UINT32)(0x01840074))
  #define HCHIP_NULL                            REG32(HCHIP_NULL_ADDR)

/******************************************************************************\
* HCHIP_CSR - control status register
*
* Fields:
*   (RW) HCHIP_CSR_GIE
*   (RW) HCHIP_CSR_PGIE
*   (RW) HCHIP_CSR_DCC
*   (RW) HCHIP_CSR_PCC
*   (R)  HCHIP_CSR_EN
*   (RC) HCHIP_CSR_SAT
*   (RW) HCHIP_CSR_PWRD
*   (R)  HCHIP_CSR_REVID
*   (R)  HCHIP_CSR_CPUID
*
\******************************************************************************/
  extern far cregister volatile unsigned int CSR;
  #define HCHIP_CSR CSR
  
/*----------------------------------------------------------------------------*\
* (RW) HCHIP_CSR_GIE
\*----------------------------------------------------------------------------*/ 
  #define HCHIP_CSR_GIE_MASK                     (0x00000001)
  #define HCHIP_CSR_GIE_SHIFT                    (0x00000000)
  
  #define HCHIP_CSR_GIE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_CSR_GIE)

  #define HCHIP_CSR_GIE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_CSR_GIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_CSR_PGIE
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_PGIE_MASK                    (0x00000002)
  #define HCHIP_CSR_PGIE_SHIFT                   (0x00000001) 

  #define HCHIP_CSR_PGIE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_CSR_PGIE)

  #define HCHIP_CSR_PGIE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_CSR_PGIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_CSR_DCC
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_DCC_MASK                     (0x0000001C)
  #define HCHIP_CSR_DCC_SHIFT                    (0x00000002)

  #define HCHIP_CSR_DCC_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_CSR_DCC)

  #define HCHIP_CSR_DCC_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_CSR_DCC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_CSR_PCC
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_PCC_MASK                     (0x000000E0)
  #define HCHIP_CSR_PCC_SHIFT                    (0x00000005)

  #define HCHIP_CSR_PCC_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_CSR_PCC)

  #define HCHIP_CSR_PCC_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_CSR_PCC,Val)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_CSR_EN
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_EN_MASK                      (0x00000100)
  #define HCHIP_CSR_EN_SHIFT                     (0x00000008)
  
  #define HCHIP_CSR_EN_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_CSR_EN)

/*----------------------------------------------------------------------------*\
* (RC) HCHIP_CSR_SAT
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_SAT_MASK                     (0x00000200)
  #define HCHIP_CSR_SAT_SHIFT                    (0x00000009)

  #define HCHIP_CSR_SAT_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_CSR_SAT)

  #define HCHIP_CSR_SAT_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_CSR_SAT,Val)

/*----------------------------------------------------------------------------*\
* (W) HCHIP_CSR_PWRD
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_PWRD_MASK                    (0x0000FC00)
  #define HCHIP_CSR_PWRD_SHIFT                   (0x0000000A)

  #define HCHIP_CSR_PWRD_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_CSR_PWRD,Val)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_CSR_REVID
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_REVID_MASK                   (0x00FF0000)
  #define HCHIP_CSR_REVID_SHIFT                  (0x00000010) 
  
  #define HCHIP_CSR_REVID_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_CSR_REVID)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_CSR_CPUID
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_CPUID_MASK                   (0xFF000000)
  #define HCHIP_CSR_CPUID_SHIFT                  (0x00000018)

  #define HCHIP_CSR_CPUID_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_CSR_CPUID)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_CSR
\*----------------------------------------------------------------------------*/
  #define HCHIP_CSR_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_CSR_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_CSR_CFG(CrReg,gie,pgie,dcc,pcc,pwrd) CrReg=(UINT32)( \
    HCRFIELD_SHIFT(HCHIP_CSR_GIE, gie) |\
    HCRFIELD_SHIFT(HCHIP_CSR_PGIE,pgie)|\
    HCRFIELD_SHIFT(HCHIP_CSR_DCC, dcc) |\
    HCRFIELD_SHIFT(HCHIP_CSR_PCC, pcc) |\
    HCRFIELD_SHIFT(HCHIP_CSR_PWRD,pwrd) \
  )

/******************************************************************************\
* HCHIP_IFR - interrupt flag register
*
* Fields:
*   (R)  HCHIP_IFR_NMIF
*   (R)  HCHIP_IFR_IF4
*   (R)  HCHIP_IFR_IF5
*   (R)  HCHIP_IFR_IF6
*   (R)  HCHIP_IFR_IF7
*   (R)  HCHIP_IFR_IF8
*   (R)  HCHIP_IFR_IF9
*   (R)  HCHIP_IFR_IF10
*   (R)  HCHIP_IFR_IF11
*   (R)  HCHIP_IFR_IF12
*   (R)  HCHIP_IFR_IF13
*   (R)  HCHIP_IFR_IF14
*   (R)  HCHIP_IFR_IF15
*
\******************************************************************************/
  extern far cregister volatile unsigned int IFR;
  #define HCHIP_IFR IFR

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_NMIF
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_NMIF_MASK                    (0x00000002)
  #define HCHIP_IFR_NMIF_SHIFT                   (0x00000001)

  #define HCHIP_IFR_NMIF_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_NMIF)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF4
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF4_MASK                     (0x00000010)
  #define HCHIP_IFR_IF4_SHIFT                    (0x00000004)

  #define HCHIP_IFR_IF4_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF4)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF5
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF5_MASK                     (0x00000020)
  #define HCHIP_IFR_IF5_SHIFT                    (0x00000005)

  #define HCHIP_IFR_IF5_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF5)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF6
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF6_MASK                     (0x00000040)
  #define HCHIP_IFR_IF6_SHIFT                    (0x00000006)

  #define HCHIP_IFR_IF6_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF6)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF7
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF7_MASK                     (0x00000080)
  #define HCHIP_IFR_IF7_SHIFT                    (0x00000007)

  #define HCHIP_IFR_IF7_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF7)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF8
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF8_MASK                     (0x00000100)
  #define HCHIP_IFR_IF8_SHIFT                    (0x00000008)

  #define HCHIP_IFR_IF8_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF8)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF9
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF9_MASK                     (0x00000200)
  #define HCHIP_IFR_IF9_SHIFT                    (0x00000009)

  #define HCHIP_IFR_IF9_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF9)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF10
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF10_MASK                    (0x00000400)
  #define HCHIP_IFR_IF10_SHIFT                   (0x0000000A)

  #define HCHIP_IFR_IF10_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF10)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF11
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF11_MASK                    (0x00000800)
  #define HCHIP_IFR_IF11_SHIFT                   (0x0000000B)

  #define HCHIP_IFR_IF11_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF11)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF12
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF12_MASK                    (0x00001000)
  #define HCHIP_IFR_IF12_SHIFT                   (0x0000000C)

  #define HCHIP_IFR_IF12_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF12)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF13
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF13_MASK                    (0x00002000)
  #define HCHIP_IFR_IF13_SHIFT                   (0x0000000D)

  #define HCHIP_IFR_IF13_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF13)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF14
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF14_MASK                    (0x00004000)
  #define HCHIP_IFR_IF14_SHIFT                   (0x0000000E)

  #define HCHIP_IFR_IF14_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF14)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR_IF15
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_IF15_MASK                    (0x00008000)
  #define HCHIP_IFR_IF15_SHIFT                   (0x0000000F)

  #define HCHIP_IFR_IF15_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IFR_IF15)

/*----------------------------------------------------------------------------*\
* (R) HCHIP_IFR
\*----------------------------------------------------------------------------*/
  #define HCHIP_IFR_GET(CrReg) HCRREG32_GET(CrReg)

/******************************************************************************\
* HCHIP_ISR - interrupt set register
*
* Fields:
*   (W)  HCHIP_ISR_IS4
*   (W)  HCHIP_ISR_IS5
*   (W)  HCHIP_ISR_IS6
*   (W)  HCHIP_ISR_IS7
*   (W)  HCHIP_ISR_IS8
*   (W)  HCHIP_ISR_IS9
*   (W)  HCHIP_ISR_IS10
*   (W)  HCHIP_ISR_IS11
*   (W)  HCHIP_ISR_IS12
*   (W)  HCHIP_ISR_IS13
*   (W)  HCHIP_ISR_IS14
*   (W)  HCHIP_ISR_IS15
*
\******************************************************************************/
  extern far cregister volatile unsigned int ISR;
  #define HCHIP_ISR ISR

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS4
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS4_MASK                     (0x00000010)
  #define HCHIP_ISR_IS4_SHIFT                    (0x00000004)

  #define HCHIP_ISR_IS4_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS4,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS5
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS5_MASK                     (0x00000020)
  #define HCHIP_ISR_IS5_SHIFT                    (0x00000005)

  #define HCHIP_ISR_IS5_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS5,Val))
    
/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS6
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS6_MASK                     (0x00000040)
  #define HCHIP_ISR_IS6_SHIFT                    (0x00000006)

  #define HCHIP_ISR_IS6_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS6,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS7
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS7_MASK                     (0x00000080)
  #define HCHIP_ISR_IS7_SHIFT                    (0x00000007)

  #define HCHIP_ISR_IS7_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS7,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS8
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS8_MASK                     (0x00000100)
  #define HCHIP_ISR_IS8_SHIFT                    (0x00000008)

  #define HCHIP_ISR_IS8_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS8,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS9
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS9_MASK                     (0x00000200)
  #define HCHIP_ISR_IS9_SHIFT                    (0x00000009)

  #define HCHIP_ISR_IS9_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS9,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS10
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS10_MASK                    (0x00000400)
  #define HCHIP_ISR_IS10_SHIFT                   (0x0000000A)

  #define HCHIP_ISR_IS10_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS10,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS11
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS11_MASK                    (0x00000800)
  #define HCHIP_ISR_IS11_SHIFT                   (0x0000000B)

  #define HCHIP_ISR_IS11_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS11,Val))
/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS12
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS12_MASK                    (0x00001000)
  #define HCHIP_ISR_IS12_SHIFT                   (0x0000000C)

  #define HCHIP_ISR_IS12_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS12,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS13
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS13_MASK                    (0x00002000)
  #define HCHIP_ISR_IS13_SHIFT                   (0x0000000D)

  #define HCHIP_ISR_IS13_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS13,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS14
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS14_MASK                    (0x00004000)
  #define HCHIP_ISR_IS14_SHIFT                   (0x0000000E)

  #define HCHIP_ISR_IS14_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS14,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR_IS15
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_IS15_MASK                    (0x00008000)
  #define HCHIP_ISR_IS15_SHIFT                   (0x0000000F)

  #define HCHIP_ISR_IS15_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ISR_IS15,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ISR
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISR_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_ISR_CFG(CrReg,is4,is5,is6,is7,is8,is9,is10,is11,is12,is13,is14,\
  is15) CrReg=(UINT32)( \
      HCRFIELD_SHIFT(HCHIP_ISR_IS4, is4) |\
      HCRFIELD_SHIFT(HCHIP_ISR_IS5, is5) |\
      HCRFIELD_SHIFT(HCHIP_ISR_IS6, is6) |\
      HCRFIELD_SHIFT(HCHIP_ISR_IS7, is7) |\
      HCRFIELD_SHIFT(HCHIP_ISR_IS8, is8) |\
      HCRFIELD_SHIFT(HCHIP_ISR_IS9, is9) |\
      HCRFIELD_SHIFT(HCHIP_ISR_IS10,is10)|\
      HCRFIELD_SHIFT(HCHIP_ISR_IS11,is11)|\
      HCRFIELD_SHIFT(HCHIP_ISR_IS12,is12)|\
      HCRFIELD_SHIFT(HCHIP_ISR_IS13,is13)|\
      HCRFIELD_SHIFT(HCHIP_ISR_IS14,is14)|\
      HCRFIELD_SHIFT(HCHIP_ISR_IS15,is15) \
    )   

/******************************************************************************\
* HCHIP_ICR - interrupt clear register
*
* Fields:
*   (W)  HCHIP_ICR_IC4
*   (W)  HCHIP_ICR_IC5
*   (W)  HCHIP_ICR_IC6
*   (W)  HCHIP_ICR_IC7
*   (W)  HCHIP_ICR_IC8
*   (W)  HCHIP_ICR_IC9
*   (W)  HCHIP_ICR_IC10
*   (W)  HCHIP_ICR_IC11
*   (W)  HCHIP_ICR_IC12
*   (W)  HCHIP_ICR_IC13
*   (W)  HCHIP_ICR_IC14
*   (W)  HCHIP_ICR_IC15
*
\******************************************************************************/
  extern far cregister volatile unsigned int ICR;
  #define HCHIP_ICR ICR

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC4
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC4_MASK                     (0x00000010)
  #define HCHIP_ICR_IC4_SHIFT                    (0x00000004)

  #define HCHIP_ICR_IC4_SET(CrReg,Val) \
  HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC4,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC5
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC5_MASK                     (0x00000020)
  #define HCHIP_ICR_IC5_SHIFT                    (0x00000005)

  #define HCHIP_ICR_IC5_SET(CrReg,Val) \
  HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC5,Val))
    

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC6
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC6_MASK                     (0x00000040)
  #define HCHIP_ICR_IC6_SHIFT                    (0x00000006)
  
  #define HCHIP_ICR_IC6_SET(CrReg,Val) \
   HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC6,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC7
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC7_MASK                     (0x00000080)
  #define HCHIP_ICR_IC7_SHIFT                    (0x00000007)

  #define HCHIP_ICR_IC7_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC7,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC8
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC8_MASK                     (0x00000100)
  #define HCHIP_ICR_IC8_SHIFT                    (0x00000008)

  #define HCHIP_ICR_IC8_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC8,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC9
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC9_MASK                     (0x00000200)
  #define HCHIP_ICR_IC9_SHIFT                    (0x00000009)

  #define HCHIP_ICR_IC9_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC9,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC10
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC10_MASK                    (0x00000400)
  #define HCHIP_ICR_IC10_SHIFT                   (0x0000000A)

  #define HCHIP_ICR_IC10_SET(CrReg,Val) \
  HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC10,Val))
  
/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC11
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC11_MASK                    (0x00000800)
  #define HCHIP_ICR_IC11_SHIFT                   (0x0000000B)

  #define HCHIP_ICR_IC11_SET(CrReg,Val) \
   HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC11,Val))
/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC12
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC12_MASK                    (0x00001000)
  #define HCHIP_ICR_IC12_SHIFT                   (0x0000000C)

  #define HCHIP_ICR_IC12_SET(CrReg,Val) \
   HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC12,Val))
   
/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC13
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC13_MASK                    (0x00002000)
  #define HCHIP_ICR_IC13_SHIFT                   (0x0000000D)

  #define HCHIP_ICR_IC13_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC13,Val))
    
/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC14
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC14_MASK                    (0x00004000)
  #define HCHIP_ICR_IC14_SHIFT                   (0x0000000E)

  #define HCHIP_ICR_IC14_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC14,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR_IC15
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_IC15_MASK                    (0x00008000)
  #define HCHIP_ICR_IC15_SHIFT                   (0x0000000F)

  #define HCHIP_ICR_IC15_SET(CrReg,Val) \
    HCRREG32_SET(CrReg,HFIELD_SHIFT(HCHIP_ICR_IC15,Val))

/*----------------------------------------------------------------------------*\
* (W) HCHIP_ICR
\*----------------------------------------------------------------------------*/
  #define HCHIP_ICR_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_ICR_CFG(CrReg,ic4,ic5,ic6,ic7,ic8,ic9,ic10,ic11,ic12,ic13,ic14,\
  ic15) CrReg=(UINT32)( \
    HCRFIELD_SHIFT(HCHIP_ICR_IC4, ic4) |\
    HCRFIELD_SHIFT(HCHIP_ICR_IC5, ic5) |\
    HCRFIELD_SHIFT(HCHIP_ICR_IC6, ic6) |\
    HCRFIELD_SHIFT(HCHIP_ICR_IC7, ic7) |\
    HCRFIELD_SHIFT(HCHIP_ICR_IC8, ic8) |\
    HCRFIELD_SHIFT(HCHIP_ICR_IC9, ic9) |\
    HCRFIELD_SHIFT(HCHIP_ICR_IC10,ic10)|\
    HCRFIELD_SHIFT(HCHIP_ICR_IC11,ic11)|\
    HCRFIELD_SHIFT(HCHIP_ICR_IC12,ic12)|\
    HCRFIELD_SHIFT(HCHIP_ICR_IC13,ic13)|\
    HCRFIELD_SHIFT(HCHIP_ICR_IC14,ic14)|\
    HCRFIELD_SHIFT(HCHIP_ICR_IC15,ic15) \
  )

/******************************************************************************\
* HCHIP_IER - interrupt enable register
*
* Fields: 
*   (RW)  HCHIP_IER_NMIE
*   (RW)  HCHIP_IER_IE4
*   (RW)  HCHIP_IER_IE5
*   (RW)  HCHIP_IER_IE6
*   (RW)  HCHIP_IER_IE7
*   (RW)  HCHIP_IER_IE8
*   (RW)  HCHIP_IER_IE9
*   (RW)  HCHIP_IER_IE10
*   (RW)  HCHIP_IER_IE11
*   (RW)  HCHIP_IER_IE12
*   (RW)  HCHIP_IER_IE13
*   (RW)  HCHIP_IER_IE14
*   (RW)  HCHIP_IER_IE15
*
\******************************************************************************/
  extern far cregister volatile unsigned int IER;
  #define HCHIP_IER IER

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_NMIE
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_NMIE_MASK                    (0x00000002)
  #define HCHIP_IER_NMIE_SHIFT                   (0x00000001)
  
  #define HCHIP_IER_NMIE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_NMIE)

  #define HCHIP_IER_NMIE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_NMIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE4
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE4_MASK                     (0x00000010)
  #define HCHIP_IER_IE4_SHIFT                    (0x00000004)
  
  #define HCHIP_IER_IE4_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE4)

  #define HCHIP_IER_IE4_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE5
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE5_MASK                     (0x00000020)
  #define HCHIP_IER_IE5_SHIFT                    (0x00000005)
  
  #define HCHIP_IER_IE5_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE5)

  #define HCHIP_IER_IE5_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE6
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE6_MASK                     (0x00000040)
  #define HCHIP_IER_IE6_SHIFT                    (0x00000006)
  
  #define HCHIP_IER_IE6_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE6)

  #define HCHIP_IER_IE6_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE7
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE7_MASK                     (0x00000080)
  #define HCHIP_IER_IE7_SHIFT                    (0x00000007)
  
  #define HCHIP_IER_IE7_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE7)

  #define HCHIP_IER_IE7_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE8
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE8_MASK                     (0x00000100)
  #define HCHIP_IER_IE8_SHIFT                    (0x00000008)
  
  #define HCHIP_IER_IE8_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE8)

  #define HCHIP_IER_IE8_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE9
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE9_MASK                     (0x00000200)
  #define HCHIP_IER_IE9_SHIFT                    (0x00000009)
  
  #define HCHIP_IER_IE9_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE9)

  #define HCHIP_IER_IE9_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE10
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE10_MASK                    (0x00000400)
  #define HCHIP_IER_IE10_SHIFT                   (0x0000000A)
  
  #define HCHIP_IER_IE10_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE10)

  #define HCHIP_IER_IE10_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE11
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE11_MASK                    (0x00000800)
  #define HCHIP_IER_IE11_SHIFT                   (0x0000000B)
  
  #define HCHIP_IER_IE11_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE11)

  #define HCHIP_IER_IE11_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE12
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE12_MASK                    (0x00001000)
  #define HCHIP_IER_IE12_SHIFT                   (0x0000000C)
  
  #define HCHIP_IER_IE12_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE12)

  #define HCHIP_IER_IE12_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE13
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE13_MASK                    (0x00002000)
  #define HCHIP_IER_IE13_SHIFT                   (0x0000000D)
  
  #define HCHIP_IER_IE13_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE13)

  #define HCHIP_IER_IE13_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE14
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE14_MASK                    (0x00004000)
  #define HCHIP_IER_IE14_SHIFT                   (0x0000000E)
  
  #define HCHIP_IER_IE14_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE14)

  #define HCHIP_IER_IE14_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER_IE15
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_IE15_MASK                    (0x00008000)
  #define HCHIP_IER_IE15_SHIFT                   (0x0000000F)
  
  #define HCHIP_IER_IE15_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IER_IE15)

  #define HCHIP_IER_IE15_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IER_IE15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IER
\*----------------------------------------------------------------------------*/
  #define HCHIP_IER_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_IER_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_IER_CFG(CrReg,nmie,ie4,ie5,ie6,ie7,ie8,ie9,ie10,ie11,ie12,ie13,\
  ie14,ie15) CrReg=(UINT32)( \
      HCRFIELD_SHIFT(HCHIP_IER_NMIE,nmie)|\
      HCRFIELD_SHIFT(HCHIP_IER_IE4, ie4) |\
      HCRFIELD_SHIFT(HCHIP_IER_IE5, ie5) |\
      HCRFIELD_SHIFT(HCHIP_IER_IE6, ie6) |\
      HCRFIELD_SHIFT(HCHIP_IER_IE7, ie7) |\
      HCRFIELD_SHIFT(HCHIP_IER_IE8, ie8) |\
      HCRFIELD_SHIFT(HCHIP_IER_IE9, ie9) |\
      HCRFIELD_SHIFT(HCHIP_IER_IE10,ie10)|\
      HCRFIELD_SHIFT(HCHIP_IER_IE11,ie11)|\
      HCRFIELD_SHIFT(HCHIP_IER_IE12,ie12)|\
      HCRFIELD_SHIFT(HCHIP_IER_IE13,ie13)|\
      HCRFIELD_SHIFT(HCHIP_IER_IE14,ie14)|\
      HCRFIELD_SHIFT(HCHIP_IER_IE15,ie15) \
    )

/******************************************************************************\
* HCHIP_ISTP - interrupt service table pointer
*
* Fields: 
*   (R)   HCHIP_ISTP_HPEINT
*   (RW)  HCHIP_ISTP_ISTB
*
\******************************************************************************/
  extern far cregister volatile unsigned int ISTP;
  #define HCHIP_ISTP ISTP

/*----------------------------------------------------------------------------*\
* (R) HCHIP_ISTP_HPEINT
\*----------------------------------------------------------------------------*/ 
  #define HCHIP_ISTP_HPEINT_MASK                 (0x000003E0)
  #define HCHIP_ISTP_HPEINT_SHIFT                (0x00000005)
  
  #define HCHIP_ISTP_HPEINT_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_ISTP_HPEINT)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_ISTP_ISTB
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISTP_ISTB_MASK                   (0xFFFFFC00)
  #define HCHIP_ISTP_ISTB_SHIFT                  (0x0000000A)

  #define HCHIP_ISTP_ISTB_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_ISTP_ISTB)

  #define HCHIP_ISTP_ISTB_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_ISTP_ISTB,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_ISTP
\*----------------------------------------------------------------------------*/
  #define HCHIP_ISTP_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_ISTP_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_ISTP_CFG(CrReg,istb) CrReg=(UINT32)(\
    HCRFIELD_SHIFT(HCHIP_ISTP_ISTB,istb) \
  )

/******************************************************************************\
* HCHIP_IRP - interrrupt return pointer
*
* Fields: 
*   (RW) HCHIP_IRP_IRP
*
\******************************************************************************/
  extern far cregister volatile unsigned int IRP;
  #define HCHIP_IRP IRP

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IRP_IRP
\*----------------------------------------------------------------------------*/
  #define HCHIP_IRP_IRP_MASK                     (0xFFFFFFFF)
  #define HCHIP_IRP_IRP_SHIFT                    (0x00000000)

  #define HCHIP_IRP_IRP_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_IRP_IRP)

  #define HCHIP_IRP_IRP_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_IRP_IRP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_IRP
\*----------------------------------------------------------------------------*/
  #define HCHIP_IRP_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_IRP_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_IRP_CFG(CrReg,irp) CrReg=(UINT32)( \
    HCRFIELD_SHIFT(HCHIP_IRP_IRP,irp) \
  )

/******************************************************************************\
* HCHIP_NRP - nonmaskable interrupt return pointer
*
* Fields: 
*   (RW) HCHIP_NRP_NRP
*
\******************************************************************************/
  extern far cregister volatile unsigned int NRP;
  #define HCHIP_NRP NRP

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_NRP_NRP
\*----------------------------------------------------------------------------*/
  #define HCHIP_NRP_NRP_MASK                     (0xFFFFFFFF)
  #define HCHIP_NRP_NRP_SHIFT                    (0x00000000)

  #define HCHIP_NRP_NRP_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_NRP_NRP)

  #define HCHIP_NRP_NRP_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_NRP_NRP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_NRP
\*----------------------------------------------------------------------------*/
  #define HCHIP_NRP_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_NRP_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_NRP_CFG(CrReg,nrp) CrReg=(UINT32)( \
    HCRFIELD_SHIFT(HCHIP_NRP_NRP,nrp) \
  )

/******************************************************************************\
* HCHIP_AMR - addressing mode register
*
* Fields: 
*   (RW) HCHIP_AMR_A4MODE
*   (RW) HCHIP_AMR_A5MODE
*   (RW) HCHIP_AMR_A6MODE
*   (RW) HCHIP_AMR_A7MODE
*   (RW) HCHIP_AMR_B4MODE
*   (RW) HCHIP_AMR_B5MODE
*   (RW) HCHIP_AMR_B6MODE
*   (RW) HCHIP_AMR_B7MODE
*   (RW) HCHIP_AMR_BK0
*   (RW) HCHIP_AMR_BK1
*
\******************************************************************************/
  extern far cregister volatile unsigned int AMR;
  #define HCHIP_AMR AMR

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_A4MODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_A4MODE_MASK                  (0x00000003)
  #define HCHIP_AMR_A4MODE_SHIFT                 (0x00000000)

  #define HCHIP_AMR_A4MODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_A4MODE)

  #define HCHIP_AMR_A4MODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_A4MODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_A5MODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_A5MODE_MASK                  (0x0000000C)
  #define HCHIP_AMR_A5MODE_SHIFT                 (0x00000002)

  #define HCHIP_AMR_A5MODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_A5MODE)

  #define HCHIP_AMR_A5MODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_A5MODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_A6MODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_A6MODE_MASK                  (0x00000030)
  #define HCHIP_AMR_A6MODE_SHIFT                 (0x00000004)

  #define HCHIP_AMR_A6MODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_A6MODE)

  #define HCHIP_AMR_A6MODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_A6MODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_A7MODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_A7MODE_MASK                  (0x000000C0)
  #define HCHIP_AMR_A7MODE_SHIFT                 (0x00000006)

  #define HCHIP_AMR_A7MODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_A7MODE)

  #define HCHIP_AMR_A7MODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_A7MODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_B4MODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_B4MODE_MASK                  (0x00000300)
  #define HCHIP_AMR_B4MODE_SHIFT                 (0x00000008)

  #define HCHIP_AMR_B4MODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_B4MODE)

  #define HCHIP_AMR_B4MODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_B4MODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_B5MODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_B5MODE_MASK                  (0x00000C00)
  #define HCHIP_AMR_B5MODE_SHIFT                 (0x0000000A)

  #define HCHIP_AMR_B5MODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_B5MODE)

  #define HCHIP_AMR_B5MODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_B5MODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_B6MODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_B6MODE_MASK                  (0x00003000)
  #define HCHIP_AMR_B6MODE_SHIFT                 (0x0000000C)

  #define HCHIP_AMR_B6MODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_B6MODE)

  #define HCHIP_AMR_B6MODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_B6MODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_B7MODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_B7MODE_MASK                  (0x0000C000)
  #define HCHIP_AMR_B7MODE_SHIFT                 (0x0000000E)

  #define HCHIP_AMR_B7MODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_B7MODE)

  #define HCHIP_AMR_B7MODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_B7MODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_BK0
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_BK0_MASK                     (0x001F0000)
  #define HCHIP_AMR_BK0_SHIFT                    (0x00000010)

  #define HCHIP_AMR_BK0_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_BK0)

  #define HCHIP_AMR_BK0_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_BK0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR_BK1
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_BK1_MASK                     (0x001F0000)
  #define HCHIP_AMR_BK1_SHIFT                    (0x00000010)

  #define HCHIP_AMR_BK1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_AMR_BK1)

  #define HCHIP_AMR_BK1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_AMR_BK1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_AMR
\*----------------------------------------------------------------------------*/
  #define HCHIP_AMR_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_AMR_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_AMR_CFG(CrReg,a4mode,a5mode,a6mode,a7mode,b4mode,b5mode,b6mode,\
  b7mode,bk0,bk1) CrReg=(UINT32)( \
    HCRFIELD_SHIFT(HCHIP_AMR_A4MODE,a4mode)| \
    HCRFIELD_SHIFT(HCHIP_AMR_A5MODE,a5mode)| \
    HCRFIELD_SHIFT(HCHIP_AMR_A6MODE,a6mode)| \
    HCRFIELD_SHIFT(HCHIP_AMR_A7MODE,a7mode)| \
    HCRFIELD_SHIFT(HCHIP_AMR_B4MODE,b4mode)| \
    HCRFIELD_SHIFT(HCHIP_AMR_B5MODE,b5mode)| \
    HCRFIELD_SHIFT(HCHIP_AMR_B6MODE,b6mode)| \
    HCRFIELD_SHIFT(HCHIP_AMR_B7MODE,b7mode)| \
    HCRFIELD_SHIFT(HCHIP_AMR_BK0,bk0)| \
    HCRFIELD_SHIFT(HCHIP_AMR_BK1,bk1) \
  )

#if (FPU_SUPPORT)
/******************************************************************************\
* HCHIP_FADCR - floating-point adder config register (1)
*
* (1) only supported on devices with floating point unit
*
* Fields: 
*   (RW) HCHIP_FADCR_L1NAN1
*   (RW) HCHIP_FADCR_L1NAN2
*   (RW) HCHIP_FADCR_L1DEN1
*   (RW) HCHIP_FADCR_L1DEN2
*   (RW) HCHIP_FADCR_L1INVAL
*   (RW) HCHIP_FADCR_L1INFO
*   (RW) HCHIP_FADCR_L1OVER
*   (RW) HCHIP_FADCR_L1INEX
*   (RW) HCHIP_FADCR_L1UNDER
*   (RW) HCHIP_FADCR_L1RMODE
*   (RW) HCHIP_FADCR_L2NAN1
*   (RW) HCHIP_FADCR_L2NAN2
*   (RW) HCHIP_FADCR_L2DEN1
*   (RW) HCHIP_FADCR_L2DEN2
*   (RW) HCHIP_FADCR_L2INVAL
*   (RW) HCHIP_FADCR_L2INFO
*   (RW) HCHIP_FADCR_L2OVER
*   (RW) HCHIP_FADCR_L2INEX
*   (RW) HCHIP_FADCR_L2UNDER
*   (RW) HCHIP_FADCR_L2RMODE
*
\******************************************************************************/
  extern far cregister volatile unsigned int FADCR;
  #define HCHIP_FADCR FADCR

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1NAN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1NAN1_MASK               (0x00000001)
  #define HCHIP_FADCR_L1NAN1_SHIFT              (0x00000000)

  #define HCHIP_FADCR_L1NAN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1NAN1)

  #define HCHIP_FADCR_L1NAN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1NAN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1NAN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1NAN2_MASK               (0x00000002)
  #define HCHIP_FADCR_L1NAN2_SHIFT              (0x00000001)

  #define HCHIP_FADCR_L1NAN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1NAN2)

  #define HCHIP_FADCR_L1NAN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1NAN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1DEN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1DEN1_MASK               (0x00000004)
  #define HCHIP_FADCR_L1DEN1_SHIFT              (0x00000002)

  #define HCHIP_FADCR_L1DEN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1DEN1)

  #define HCHIP_FADCR_L1DEN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1DEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1DEN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1DEN2_MASK               (0x00000008)
  #define HCHIP_FADCR_L1DEN2_SHIFT              (0x00000003)

  #define HCHIP_FADCR_L1DEN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1DEN2)

  #define HCHIP_FADCR_L1DEN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1DEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1INVAL
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1INVAL_MASK              (0x00000010)
  #define HCHIP_FADCR_L1INVAL_SHIFT             (0x00000004)

  #define HCHIP_FADCR_L1INVAL_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1INVAL)

  #define HCHIP_FADCR_L1INVAL_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1INVAL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1INFO
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1INFO_MASK               (0x00000020)
  #define HCHIP_FADCR_L1INFO_SHIFT              (0x00000005)

  #define HCHIP_FADCR_L1INFO_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1INFO)

  #define HCHIP_FADCR_L1INFO_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1INFO,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1OVER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1OVER_MASK               (0x00000040)
  #define HCHIP_FADCR_L1OVER_SHIFT              (0x00000006)

  #define HCHIP_FADCR_L1OVER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1OVER)

  #define HCHIP_FADCR_L1OVER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1OVER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1INEX
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1INEX_MASK               (0x00000080)
  #define HCHIP_FADCR_L1INEX_SHIFT              (0x00000007)

  #define HCHIP_FADCR_L1INEX_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1INEX)

  #define HCHIP_FADCR_L1INEX_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1INEX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1UNDER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1UNDER_MASK              (0x00000100)
  #define HCHIP_FADCR_L1UNDER_SHIFT             (0x00000008)

  #define HCHIP_FADCR_L1UNDER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1UNDER)

  #define HCHIP_FADCR_L1UNDER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1UNDER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L1RMODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L1RMODE_MASK              (0x00000600)
  #define HCHIP_FADCR_L1RMODE_SHIFT             (0x00000009)

  #define HCHIP_FADCR_L1RMODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L1RMODE)

  #define HCHIP_FADCR_L1RMODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L1RMODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2NAN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2NAN1_MASK               (0x00010000)
  #define HCHIP_FADCR_L2NAN1_SHIFT              (0x00000010)

  #define HCHIP_FADCR_L2NAN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2NAN1)

  #define HCHIP_FADCR_L2NAN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2NAN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2NAN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2NAN2_MASK               (0x00020000)
  #define HCHIP_FADCR_L2NAN2_SHIFT              (0x00000011)

  #define HCHIP_FADCR_L2NAN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2NAN2)

  #define HCHIP_FADCR_L2NAN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2NAN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2DEN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2DEN1_MASK               (0x00040000)
  #define HCHIP_FADCR_L2DEN1_SHIFT              (0x00000012)

  #define HCHIP_FADCR_L2DEN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2DEN1)

  #define HCHIP_FADCR_L2DEN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2DEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2DEN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2DEN2_MASK               (0x00080000)
  #define HCHIP_FADCR_L2DEN2_SHIFT              (0x00000013)

  #define HCHIP_FADCR_L2DEN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2DEN2)

  #define HCHIP_FADCR_L2DEN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2DEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2INVAL
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2INVAL_MASK              (0x00100000)
  #define HCHIP_FADCR_L2INVAL_SHIFT             (0x00000014)

  #define HCHIP_FADCR_L2INVAL_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2INVAL)

  #define HCHIP_FADCR_L2INVAL_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2INVAL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2INFO
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2INFO_MASK               (0x00200000)
  #define HCHIP_FADCR_L2INFO_SHIFT              (0x00000015)

  #define HCHIP_FADCR_L2INFO_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2INFO)

  #define HCHIP_FADCR_L2INFO_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2INFO,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2OVER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2OVER_MASK               (0x00400000)
  #define HCHIP_FADCR_L2OVER_SHIFT              (0x00000016)

  #define HCHIP_FADCR_L2OVER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2OVER)

  #define HCHIP_FADCR_L2OVER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2OVER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2INEX
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2INEX_MASK               (0x00800000)
  #define HCHIP_FADCR_L2INEX_SHIFT              (0x00000017)

  #define HCHIP_FADCR_L2INEX_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2INEX)

  #define HCHIP_FADCR_L2INEX_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2INEX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2UNDER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2UNDER_MASK              (0x01000000)
  #define HCHIP_FADCR_L2UNDER_SHIFT             (0x00000018)

  #define HCHIP_FADCR_L2UNDER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2UNDER)

  #define HCHIP_FADCR_L2UNDER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2UNDER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR_L2RMODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_L2RMODE_MASK              (0x06000000)
  #define HCHIP_FADCR_L2RMODE_SHIFT             (0x00000019)

  #define HCHIP_FADCR_L2RMODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FADCR_L2RMODE)

  #define HCHIP_FADCR_L2RMODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FADCR_L2RMODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR
\*----------------------------------------------------------------------------*/
  #define HCHIP_FADCR_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_FADCR_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_FADCR_CFG(CrReg,l1nan1,l1nan2,l1den1,l1den2,l1inval,l1info,\
  l1over,l1inex,l1under,l1rmode,l2nan1,l2nan2,l2den1,l2den2,l2inval,l2info,\
  l2over,l2inex,l2under,l2rmode) CrReg=(UINT32)( \
    HCRFIELD_SHIFT(HCHIP_FADCR_L1NAN1, l1nan1) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1NAN2, l1nan2) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1DEN1, l1den1) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1DEN2, l1den2) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1INVAL,l1inval)|\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1INFO, l1info) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1OVER, l1over) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1INEX, l1inex) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1UNDER,l1under)|\
    HCRFIELD_SHIFT(HCHIP_FADCR_L1RMODE,l1rmode)|\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2NAN1, l2nan1) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2NAN2, l2nan2) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2DEN1, l2den1) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2DEN2, l2den2) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2INVAL,l2inval)|\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2INFO, l2info) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2OVER, l2over) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2INEX, l2inex) |\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2UNDER,l2under)|\
    HCRFIELD_SHIFT(HCHIP_FADCR_L2RMODE,l2rmode) \
  )
#endif /* FPU_SUPPORT */

#if (FPU_SUPPORT)
/******************************************************************************\
* HCHIP_FAUCR - floating-point auxiliary config register (1)
*
* (1) only supported on devices with floating point unit
*
* Fields: 
*   (RW) HCHIP_FAUCR_S1NAN1
*   (RW) HCHIP_FAUCR_S1NAN2
*   (RW) HCHIP_FAUCR_S1DEN1
*   (RW) HCHIP_FAUCR_S1DEN2
*   (RW) HCHIP_FAUCR_S1INVAL
*   (RW) HCHIP_FAUCR_S1INFO
*   (RW) HCHIP_FAUCR_S1OVER
*   (RW) HCHIP_FAUCR_S1INEX
*   (RW) HCHIP_FAUCR_S1UNDER
*   (RW) HCHIP_FAUCR_S1UNORD
*   (RW) HCHIP_FAUCR_S1DIV0
*   (RW) HCHIP_FAUCR_S2NAN1
*   (RW) HCHIP_FAUCR_S2NAN2
*   (RW) HCHIP_FAUCR_S2DEN1
*   (RW) HCHIP_FAUCR_S2DEN2
*   (RW) HCHIP_FAUCR_S2INVAL
*   (RW) HCHIP_FAUCR_S2INFO
*   (RW) HCHIP_FAUCR_S2OVER
*   (RW) HCHIP_FAUCR_S2INEX
*   (RW) HCHIP_FAUCR_S2UNDER
*   (RW) HCHIP_FAUCR_S2UNORD
*   (RW) HCHIP_FAUCR_S2DIV0
*
\******************************************************************************/
  extern far cregister volatile unsigned int FAUCR;
  #define HCHIP_FAUCR FAUCR
  
/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1NAN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1NAN1_MASK               (0x00000001)
  #define HCHIP_FAUCR_S1NAN1_SHIFT              (0x00000000)

  #define HCHIP_FAUCR_S1NAN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1NAN1)

  #define HCHIP_FAUCR_S1NAN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1NAN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1NAN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1NAN2_MASK               (0x00000002)
  #define HCHIP_FAUCR_S1NAN2_SHIFT              (0x00000001)

  #define HCHIP_FAUCR_S1NAN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1NAN2)

  #define HCHIP_FAUCR_S1NAN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1NAN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1DEN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1DEN1_MASK               (0x00000004)
  #define HCHIP_FAUCR_S1DEN1_SHIFT              (0x00000002)

  #define HCHIP_FAUCR_S1DEN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1DEN1)

  #define HCHIP_FAUCR_S1DEN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1DEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1DEN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1DEN2_MASK               (0x00000008)
  #define HCHIP_FAUCR_S1DEN2_SHIFT              (0x00000003)

  #define HCHIP_FAUCR_S1DEN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1DEN2)

  #define HCHIP_FAUCR_S1DEN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1DEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1INVAL
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1INVAL_MASK              (0x00000010)
  #define HCHIP_FAUCR_S1INVAL_SHIFT             (0x00000004)

  #define HCHIP_FAUCR_S1INVAL_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1INVAL)

  #define HCHIP_FAUCR_S1INVAL_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1INVAL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1INFO
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1INFO_MASK               (0x00000020)
  #define HCHIP_FAUCR_S1INFO_SHIFT              (0x00000005)

  #define HCHIP_FAUCR_S1INFO_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1INFO)

  #define HCHIP_FAUCR_S1INFO_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1INFO,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1OVER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1OVER_MASK               (0x00000040)
  #define HCHIP_FAUCR_S1OVER_SHIFT              (0x00000006)

  #define HCHIP_FAUCR_S1OVER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1OVER)

  #define HCHIP_FAUCR_S1OVER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1OVER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1INEX
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1INEX_MASK               (0x00000080)
  #define HCHIP_FAUCR_S1INEX_SHIFT              (0x00000007)

  #define HCHIP_FAUCR_S1INEX_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1INEX)

  #define HCHIP_FAUCR_S1INEX_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1INEX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1UNDER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1UNDER_MASK              (0x00000100)
  #define HCHIP_FAUCR_S1UNDER_SHIFT             (0x00000008)

  #define HCHIP_FAUCR_S1UNDER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1UNDER)

  #define HCHIP_FAUCR_S1UNDER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1UNDER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1UNORD
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1UNORD_MASK              (0x00000200)
  #define HCHIP_FAUCR_S1UNORD_SHIFT             (0x00000009)

  #define HCHIP_FAUCR_S1UNORD_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1UNORD)

  #define HCHIP_FAUCR_S1UNORD_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1UNORD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S1DIV0
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S1DIV0_MASK               (0x00000400)
  #define HCHIP_FAUCR_S1DIV0_SHIFT              (0x0000000A)

  #define HCHIP_FAUCR_S1DIV0_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S1DIV0)

  #define HCHIP_FAUCR_S1DIV0_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S1DIV0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2NAN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2NAN1_MASK               (0x00010000)
  #define HCHIP_FAUCR_S2NAN1_SHIFT              (0x00000010)

  #define HCHIP_FAUCR_S2NAN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2NAN1)

  #define HCHIP_FAUCR_S2NAN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2NAN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2NAN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2NAN2_MASK               (0x00020000)
  #define HCHIP_FAUCR_S2NAN2_SHIFT              (0x00000011)

  #define HCHIP_FAUCR_S2NAN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2NAN2)

  #define HCHIP_FAUCR_S2NAN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2NAN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2DEN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2DEN1_MASK               (0x00040000)
  #define HCHIP_FAUCR_S2DEN1_SHIFT              (0x00000012)

  #define HCHIP_FAUCR_S2DEN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2DEN1)

  #define HCHIP_FAUCR_S2DEN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2DEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2DEN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2DEN2_MASK               (0x00080000)
  #define HCHIP_FAUCR_S2DEN2_SHIFT              (0x00000013)

  #define HCHIP_FAUCR_S2DEN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2DEN2)

  #define HCHIP_FAUCR_S2DEN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2DEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2INVAL
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2INVAL_MASK              (0x00100000)
  #define HCHIP_FAUCR_S2INVAL_SHIFT             (0x00000014)

  #define HCHIP_FAUCR_S2INVAL_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2INVAL)

  #define HCHIP_FAUCR_S2INVAL_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2INVAL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2INFO
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2INFO_MASK               (0x00200000)
  #define HCHIP_FAUCR_S2INFO_SHIFT              (0x00000015)

  #define HCHIP_FAUCR_S2INFO_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2INFO)

  #define HCHIP_FAUCR_S2INFO_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2INFO,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2OVER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2OVER_MASK               (0x00400000)
  #define HCHIP_FAUCR_S2OVER_SHIFT              (0x00000016)

  #define HCHIP_FAUCR_S2OVER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2OVER)

  #define HCHIP_FAUCR_S2OVER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2OVER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2INEX
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2INEX_MASK               (0x00800000)
  #define HCHIP_FAUCR_S2INEX_SHIFT              (0x00000017)

  #define HCHIP_FAUCR_S2INEX_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2INEX)

  #define HCHIP_FAUCR_S2INEX_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2INEX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2UNDER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2UNDER_MASK              (0x01000000)
  #define HCHIP_FAUCR_S2UNDER_SHIFT             (0x00000018)

  #define HCHIP_FAUCR_S2UNDER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2UNDER)

  #define HCHIP_FAUCR_S2UNDER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2UNDER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2UNORD
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2UNORD_MASK              (0x02000000)
  #define HCHIP_FAUCR_S2UNORD_SHIFT             (0x00000019)

  #define HCHIP_FAUCR_S2UNORD_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2UNORD)

  #define HCHIP_FAUCR_S2UNORD_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2UNORD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FAUCR_S2DIV0
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_S2DIV0_MASK               (0x04000000)
  #define HCHIP_FAUCR_S2DIV0_SHIFT              (0x0000001A)

  #define HCHIP_FAUCR_S2DIV0_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FAUCR_S2DIV0)

  #define HCHIP_FAUCR_S2DIV0_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FAUCR_S2DIV0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FADCR
\*----------------------------------------------------------------------------*/
  #define HCHIP_FAUCR_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_FAUCR_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_FAUCR_CFG(CrReg,s1nan1,s1nan2,s1den1,s1den2,s1inval,s1info,\
  s1over,s1inex,s1under,s1unord,s1div0,s2nan1,s2nan2,s2den1,s2den2,s2inval,\
  s2info,s2over,s2inex,s2under,s2unord,s2div0) CrReg=(UINT32)( \
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1NAN1, s1nan1) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1NAN2, s1nan2) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1DEN1, s1den1) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1DEN2, s1den2) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1INVAL,s1inval)|\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1INFO, s1info) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1OVER, s1over) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1INEX, s1inex) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1UNDER,s1under)|\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1UNORD,s1unord)|\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S1DIV0, s1div0) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2NAN1, s2nan1) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2NAN2, s2nan2) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2DEN1, s2den1) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2DEN2, s2den2) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2INVAL,s2inval)|\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2INFO, s2info) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2OVER, s2over) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2INEX, s2inex) |\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2UNDER,s2under)|\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2UNORD,s2unord)|\
    HCRFIELD_SHIFT(HCHIP_FAUCR_S2DIV0, s2div0)  \
  )
#endif /* FPU_SUPPORT */

#if (FPU_SUPPORT)
/******************************************************************************\
* HCHIP_FMCR - floating-point multiplier config register (1)
*
* (1) only supported on devices with floating point unit
*
* Fields: 
*   (RW) HCHIP_FMCR_M1NAN1
*   (RW) HCHIP_FMCR_M1NAN2
*   (RW) HCHIP_FMCR_M1DEN1
*   (RW) HCHIP_FMCR_M1DEN2
*   (RW) HCHIP_FMCR_M1INVAL
*   (RW) HCHIP_FMCR_M1INFO
*   (RW) HCHIP_FMCR_M1OVER
*   (RW) HCHIP_FMCR_M1INEX
*   (RW) HCHIP_FMCR_M1UNDER
*   (RW) HCHIP_FMCR_M1RMODE
*   (RW) HCHIP_FMCR_M2NAN1
*   (RW) HCHIP_FMCR_M2NAN2
*   (RW) HCHIP_FMCR_M2DEN1
*   (RW) HCHIP_FMCR_M2DEN2
*   (RW) HCHIP_FMCR_M2INVAL
*   (RW) HCHIP_FMCR_M2INFO
*   (RW) HCHIP_FMCR_M2OVER
*   (RW) HCHIP_FMCR_M2INEX
*   (RW) HCHIP_FMCR_M2UNDER
*   (RW) HCHIP_FMCR_M2RMODE
*
\******************************************************************************/
  extern far cregister volatile unsigned int FMCR;
  #define HCHIP_FMCR FMCR
  
/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1NAN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1NAN1_MASK                (0x00000001)
  #define HCHIP_FMCR_M1NAN1_SHIFT               (0x00000000)

  #define HCHIP_FMCR_M1NAN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1NAN1)

  #define HCHIP_FMCR_M1NAN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1NAN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1NAN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1NAN2_MASK                (0x00000002)
  #define HCHIP_FMCR_M1NAN2_SHIFT               (0x00000001)

  #define HCHIP_FMCR_M1NAN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1NAN2)

  #define HCHIP_FMCR_M1NAN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1NAN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1DEN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1DEN1_MASK                (0x00000004)
  #define HCHIP_FMCR_M1DEN1_SHIFT               (0x00000002)

  #define HCHIP_FMCR_M1DEN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1DEN1)

  #define HCHIP_FMCR_M1DEN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1DEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1DEN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1DEN2_MASK                (0x00000008)
  #define HCHIP_FMCR_M1DEN2_SHIFT               (0x00000003)

  #define HCHIP_FMCR_M1DEN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1DEN2)

  #define HCHIP_FMCR_M1DEN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1DEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1INVAL
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1INVAL_MASK               (0x00000010)
  #define HCHIP_FMCR_M1INVAL_SHIFT              (0x00000004)

  #define HCHIP_FMCR_M1INVAL_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1INVAL)

  #define HCHIP_FMCR_M1INVAL_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1INVAL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1INFO
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1INFO_MASK                (0x00000020)
  #define HCHIP_FMCR_M1INFO_SHIFT               (0x00000005)

  #define HCHIP_FMCR_M1INFO_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1INFO)

  #define HCHIP_FMCR_M1INFO_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1INFO,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1OVER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1OVER_MASK                (0x00000040)
  #define HCHIP_FMCR_M1OVER_SHIFT               (0x00000006)

  #define HCHIP_FMCR_M1OVER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1OVER)

  #define HCHIP_FMCR_M1OVER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1OVER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1INEX
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1INEX_MASK                (0x00000080)
  #define HCHIP_FMCR_M1INEX_SHIFT               (0x00000007)

  #define HCHIP_FMCR_M1INEX_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1INEX)

  #define HCHIP_FMCR_M1INEX_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1INEX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1UNDER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1UNDER_MASK               (0x00000100)
  #define HCHIP_FMCR_M1UNDER_SHIFT              (0x00000008)

  #define HCHIP_FMCR_M1UNDER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1UNDER)

  #define HCHIP_FMCR_M1UNDER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1UNDER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M1RMODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M1RMODE_MASK               (0x00000600)
  #define HCHIP_FMCR_M1RMODE_SHIFT              (0x00000009)

  #define HCHIP_FMCR_M1RMODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M1RMODE)

  #define HCHIP_FMCR_M1RMODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M1RMODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2NAN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2NAN1_MASK                (0x00010000)
  #define HCHIP_FMCR_M2NAN1_SHIFT               (0x00000010)

  #define HCHIP_FMCR_M2NAN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2NAN1)

  #define HCHIP_FMCR_M2NAN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2NAN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2NAN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2NAN2_MASK                (0x00020000)
  #define HCHIP_FMCR_M2NAN2_SHIFT               (0x00000011)

  #define HCHIP_FMCR_M2NAN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2NAN2)

  #define HCHIP_FMCR_M2NAN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2NAN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2DEN1
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2DEN1_MASK                (0x00040000)
  #define HCHIP_FMCR_M2DEN1_SHIFT               (0x00000012)

  #define HCHIP_FMCR_M2DEN1_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2DEN1)

  #define HCHIP_FMCR_M2DEN1_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2DEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2DEN2
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2DEN2_MASK                (0x00080000)
  #define HCHIP_FMCR_M2DEN2_SHIFT               (0x00000013)

  #define HCHIP_FMCR_M2DEN2_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2DEN2)

  #define HCHIP_FMCR_M2DEN2_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2DEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2INVAL
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2INVAL_MASK               (0x00100000)
  #define HCHIP_FMCR_M2INVAL_SHIFT              (0x00000014)

  #define HCHIP_FMCR_M2INVAL_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2INVAL)

  #define HCHIP_FMCR_M2INVAL_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2INVAL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2INFO
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2INFO_MASK                (0x00200000)
  #define HCHIP_FMCR_M2INFO_SHIFT               (0x00000015)

  #define HCHIP_FMCR_M2INFO_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2INFO)

  #define HCHIP_FMCR_M2INFO_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2INFO,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2OVER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2OVER_MASK                (0x00400000)
  #define HCHIP_FMCR_M2OVER_SHIFT               (0x00000016)

  #define HCHIP_FMCR_M2OVER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2OVER)

  #define HCHIP_FMCR_M2OVER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2OVER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2INEX
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2INEX_MASK                (0x00800000)
  #define HCHIP_FMCR_M2INEX_SHIFT               (0x00000017)

  #define HCHIP_FMCR_M2INEX_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2INEX)

  #define HCHIP_FMCR_M2INEX_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2INEX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2UNDER
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2UNDER_MASK               (0x01000000)
  #define HCHIP_FMCR_M2UNDER_SHIFT              (0x00000018)

  #define HCHIP_FMCR_M2UNDER_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2UNDER)

  #define HCHIP_FMCR_M2UNDER_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2UNDER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR_M2RMODE
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_M2RMODE_MASK               (0x06000000)
  #define HCHIP_FMCR_M2RMODE_SHIFT              (0x00000019)

  #define HCHIP_FMCR_M2RMODE_GET(CrReg) \
    HCRFIELD_GET(CrReg,HCHIP_FMCR_M2RMODE)

  #define HCHIP_FMCR_M2RMODE_SET(CrReg,Val) \
    HCRFIELD_SET(CrReg,HCHIP_FMCR_M2RMODE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCHIP_FMCR
\*----------------------------------------------------------------------------*/
  #define HCHIP_FMCR_GET(CrReg) HCRREG32_GET(CrReg)

  #define HCHIP_FMCR_SET(CrReg,Val) HCRREG32_SET(CrReg,Val)

  #define HCHIP_FMCR_CFG(CrReg,m1nan1,m1nan2,m1den1,m1den2,m1inval,m1info,\
  m1over,m1inex,m1under,m1rmode,m2nan1,m2nan2,m2den1,m2den2,m2inval,m2info,\
  m2over,m2inex,m2under,m2rmode) CrReg=(UINT32)( \
    HSHIFT_FDIELD(HCHIP_FMCR_M1NAN1, m1nan1) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M1NAN2, m1nan2) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M1DEN1, m1den1) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M1DEN2, m1den2) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M1INVAL,m1inval)|\
    HSHIFT_FDIELD(HCHIP_FMCR_M1INFO, m1info) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M1OVER, m1over) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M1INEX, m1inex) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M1UNDER,m1under)|\
    HSHIFT_FDIELD(HCHIP_FMCR_M1RMODE,m1rmode)|\
    HSHIFT_FDIELD(HCHIP_FMCR_M2NAN1, m2nan1) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M2NAN2, m2nan2) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M2DEN1, m2den1) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M2DEN2, m2den2) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M2INVAL,m2inval)|\
    HSHIFT_FDIELD(HCHIP_FMCR_M2INFO, m2info) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M2OVER, m2over) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M2INEX, m2inex) |\
    HSHIFT_FDIELD(HCHIP_FMCR_M2UNDER,m2under)|\
    HSHIFT_FDIELD(HCHIP_FMCR_M2RMODE,m2rmode) \
  )
#endif /* FPU_SUPPORT */

/******************************************************************************/

#endif /* _CHIPHAL_H_ */
/******************************************************************************\
* End of chiphal.h
\******************************************************************************/



/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... cachehal.h
* DATE CREATED.. 06/12/1999 
* LAST MODIFIED. 03/08/2000
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the CACHE module)
*
* Registers Covered:
*   HCACHE_CCFG     - cache configuration register
*   HCACHE_L2FBAR   - L2 flush base address register
*   HCACHE_L2FWC    - L2 flush word count register
*   HCACHE_L2CBAR   - L2 clean base register
*   HCACHE_L2CWC    - L2 clean word count register
*   HCACHE_L1PFBAR  - L1P flush base address register
*   HCACHE_L1PFWC   - L1P flush word count register
*   HCACHE_L1DFBAR  - L1D flush base address register
*   HCACHE_L1DFWC   - L1D flush word count register
*   HCACHE_L2FLUSH  - L2 flush register
*   HCACHE_L2CLEAN  - L2 clean register
*   HCACHE_MAR0     - memory attribute register, region 0
*   HCACHE_MAR1     - memory attribute register, region 1
*   HCACHE_MAR2     - memory attribute register, region 2
*   HCACHE_MAR3     - memory attribute register, region 3
*   HCACHE_MAR4     - memory attribute register, region 4
*   HCACHE_MAR5     - memory attribute register, region 5
*   HCACHE_MAR6     - memory attribute register, region 6
*   HCACHE_MAR7     - memory attribute register, region 7
*   HCACHE_MAR8     - memory attribute register, region 8
*   HCACHE_MAR9     - memory attribute register, region 9
*   HCACHE_MAR10    - memory attribute register, region 10
*   HCACHE_MAR11    - memory attribute register, region 11
*   HCACHE_MAR12    - memory attribute register, region 12
*   HCACHE_MAR13    - memory attribute register, region 13
*   HCACHE_MAR14    - memory attribute register, region 14
*   HCACHE_MAR15    - memory attribute register, region 15
*
\******************************************************************************/
#ifndef _CACHEHAL_H_
#define _CACHEHAL_H_

#if (CACHE_SUPPORT)
/*============================================================================*\
* misc declarations
\*============================================================================*/
  #define HCACHE_BASE_ADDR        (HCHIP_PERBASE_ADDR+0x00040000)

/******************************************************************************\
* HCACHE_CCFG - cache configuration register
*
* Fields:
* (RW) HCACHE_CCFG_L2MODE
* (RW) HCACHE_CCFG_ID
* (RW) HCACHE_CCFG_IP
* (RW) HCACHE_CCFG_P
*
\******************************************************************************/
  #define HCACHE_CCFG_ADDR                     (HCACHE_BASE_ADDR+0x0000)
  #define HCACHE_CCFG                          REG32(HCACHE_CCFG_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_CCFG_L2MODE
\*----------------------------------------------------------------------------*/
  #define HCACHE_CCFG_L2MODE_MASK              (0x00000007)
  #define HCACHE_CCFG_L2MODE_SHIFT             (0x00000000)

  #define HCACHE_CCFG_L2MODE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_CCFG_L2MODE)

  #define HCACHE_CCFG_L2MODE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_CCFG_L2MODE,Val)
  
/*----------------------------------------------------------------------------*\
* (RW) HCACHE_CCFG_ID
\*----------------------------------------------------------------------------*/
  #define HCACHE_CCFG_ID_MASK                  (0x00000100)
  #define HCACHE_CCFG_ID_SHIFT                 (0x00000008)

  #define HCACHE_CCFG_ID_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_CCFG_ID)

  #define HCACHE_CCFG_ID_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_CCFG_ID,Val)
  
/*----------------------------------------------------------------------------*\
* (RW) HCACHE_CCFG_IP
\*----------------------------------------------------------------------------*/
  #define HCACHE_CCFG_IP_MASK                  (0x00000200)
  #define HCACHE_CCFG_IP_SHIFT                 (0x00000009)

  #define HCACHE_CCFG_IP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_CCFG_IP)

  #define HCACHE_CCFG_IP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_CCFG_IP,Val)
  
/*----------------------------------------------------------------------------*\
* (RW) HCACHE_CCFG_P
\*----------------------------------------------------------------------------*/
  #define HCACHE_CCFG_P_MASK                   (0x80000000)
  #define HCACHE_CCFG_P_SHIFT                  (0x0000001F)

  #define HCACHE_CCFG_P_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_CCFG_P)

  #define HCACHE_CCFG_P_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_CCFG_P,Val)
  
/*----------------------------------------------------------------------------*\
* (RW) HCACHE_CCFG
\*----------------------------------------------------------------------------*/
  #define HCACHE_CCFG_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_CCFG_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_CCFG_CFG(RegAddr,l2mode,id,ip,p) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_CCFG_L2MODE,l2mode)| \
    HFIELD_SHIFT(HCACHE_CCFG_ID,id)| \
    HFIELD_SHIFT(HCACHE_CCFG_IP,ip)| \
    HFIELD_SHIFT(HCACHE_CCFG_P,p) \
  )

/******************************************************************************\
* HCACHE_L2FBAR - L2 flush base address register
*
* Fields:
*   (RW) HCACHE_L2FBAR_L2FBAR
*
\******************************************************************************/
  #define HCACHE_L2FBAR_ADDR                   (HCACHE_BASE_ADDR+0x4000)
  #define HCACHE_L2FBAR                        REG32(HCACHE_L2FBAR_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2FBAR_L2FBAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2FBAR_L2FBAR_MASK            (0xFFFFFFFF)
  #define HCACHE_L2FBAR_L2FBAR_SHIFT           (0x00000000)

  #define HCACHE_L2FBAR_L2FBAR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L2FBAR_L2FBAR)

  #define HCACHE_L2FBAR_L2FBAR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L2FBAR_L2FBAR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2FBAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2FBAR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L2FBAR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L2FBAR_CFG(RegAddr,l2fbar) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L2FBAR_L2FBAR,l2fbar) \
  )

/******************************************************************************\
* HCACHE_L2FWC - L2 flush word count register
*
* Fields:
*   (RW) HCACHE_L2FWC_L2FWC
*
\******************************************************************************/
  #define HCACHE_L2FWC_ADDR                    (HCACHE_BASE_ADDR+0x4004)
  #define HCACHE_L2FWC                         REG32(HCACHE_L2FWC_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2FWC_L2FWC
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2FWC_L2FWC_MASK              (0x0000FFFF)
  #define HCACHE_L2FWC_L2FWC_SHIFT             (0x00000000)

  #define HCACHE_L2FWC_L2FWC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L2FWC_L2FWC)

  #define HCACHE_L2FWC_L2FWC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L2FWC_L2FWC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2FWC
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2FWC_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L2FWC_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L2FWC_CFG(RegAddr,l2fwc) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L2FWC_L2FWC,l2fwc) \
  )

/******************************************************************************\
* HCACHE_L2CBAR - L2 clean base register
*
* Fields:
*   (RW) HCACHE_L2CBAR_L2CBAR
*
\******************************************************************************/
  #define HCACHE_L2CBAR_ADDR                   (HCACHE_BASE_ADDR+0x4010)
  #define HCACHE_L2CBAR                        REG32(HCACHE_L2CBAR_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2CBAR_L2CBAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2CBAR_L2CBAR_MASK            (0xFFFFFFFF)
  #define HCACHE_L2CBAR_L2CBAR_SHIFT           (0x00000000)

  #define HCACHE_L2CBAR_L2CBAR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L2CBAR_L2CBAR)

  #define HCACHE_L2CBAR_L2CBAR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L2CBAR_L2CBAR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2CBAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2CBAR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L2CBAR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L2CBAR_CFG(RegAddr,l2cbar) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L2CBAR_L2CBAR,l2cbar) \
  )

/******************************************************************************\
* HCACHE_L2CWC - L2 clean word count register
*
* Fields:
*   (RW) HCACHE_L2CWC_L2CWC
*
\******************************************************************************/
  #define HCACHE_L2CWC_ADDR                    (HCACHE_BASE_ADDR+0x4014)
  #define HCACHE_L2CWC                         REG32(HCACHE_L2CWC_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2CWC_L2CWC
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2CWC_L2CWC_MASK              (0x0000FFFF)
  #define HCACHE_L2CWC_L2CWC_SHIFT             (0x00000000)

  #define HCACHE_L2CWC_L2CWC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L2CWC_L2CWC)

  #define HCACHE_L2CWC_L2CWC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L2CWC_L2CWC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2CWC
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2CWC_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L2CWC_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L2CWC_CFG(RegAddr,l2cwc) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L2CWC_L2CWC,l2cwc) \
  )

/******************************************************************************\
* HCACHE_L1PFBAR - L1P flush base address register
*
* Fields:
*   (RW) HCACHE_L1PFBAR_L1PFBAR
*
\******************************************************************************/
  #define HCACHE_L1PFBAR_ADDR                  (HCACHE_BASE_ADDR+0x4020)
  #define HCACHE_L1PFBAR                       REG32(HCACHE_L1PFBAR_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L1PFBAR_L1PFBAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_L1PFBAR_L1PFBAR_MASK          (0xFFFFFFFF)
  #define HCACHE_L1PFBAR_L1PFBAR_SHIFT         (0x00000000)

  #define HCACHE_L1PFBAR_L1PFBAR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L1PFBAR_L1PFBAR)

  #define HCACHE_L1PFBAR_L1PFBAR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L1PFBAR_L1PFBAR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L1PFBAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_L1PFBAR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L1PFBAR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L1PFBAR_CFG(RegAddr,l1pfbar) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L1PFBAR_L1PFBAR,l1pfbar) \
  )

/******************************************************************************\
* HCACHE_L1PFWC - L1P flush word count register
*
* Fields:
*   (RW) HCACHE_L1PFWC_L1PFWC
*
\******************************************************************************/
  #define HCACHE_L1PFWC_ADDR                   (HCACHE_BASE_ADDR+0x4024)
  #define HCACHE_L1PFWC                        REG32(HCACHE_L1PFWC_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L1PFWC_L1PFWC
\*----------------------------------------------------------------------------*/
  #define HCACHE_L1PFWC_L1PFWC_MASK            (0x0000FFFF)
  #define HCACHE_L1PFWC_L1PFWC_SHIFT           (0x00000000)

  #define HCACHE_L1PFWC_L1PFWC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L1PFWC_L1PFWC)

  #define HCACHE_L1PFWC_L1PFWC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L1PFWC_L1PFWC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L1PFWC
\*----------------------------------------------------------------------------*/
  #define HCACHE_L1PFWC_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L1PFWC_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L1PFWC_CFG(RegAddr,l1pfwc) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L1PFWC_L1PFWC,l1pfwc) \
  )

/******************************************************************************\
* HCACHE_L1DFBAR - L1D flush base address register
*
* Fields:
*   (RW) HCACHE_L1DFBAR_L1DFBAR
*
\******************************************************************************/
  #define HCACHE_L1DFBAR_ADDR                  (HCACHE_BASE_ADDR+0x4030)
  #define HCACHE_L1DFBAR                       REG32(HCACHE_L1DFBAR_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L1DFBAR_L1DFBAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_L1DFBAR_L1DFBAR_MASK          (0xFFFFFFFF)
  #define HCACHE_L1DFBAR_L1DFBAR_SHIFT         (0x00000000)

  #define HCACHE_L1DFBAR_L1DFBAR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L1DFBAR_L1DFBAR)

  #define HCACHE_L1DFBAR_L1DFBAR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L1DFBAR_L1DFBAR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L1DFBAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_L1DFBAR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L1DFBAR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L1DFBAR_CFG(RegAddr,l1dfbar) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L1DFBAR_L1DFBAR,l1dfbar) \
  )

/******************************************************************************\
* HCACHE_L1DFWC - L1D flush word count register
*
* Fields:
*   (RW) HCACHE_L1DFWC_L1DFWC
*
\******************************************************************************/
  #define HCACHE_L1DFWC_ADDR                   (HCACHE_BASE_ADDR+0x4034)
  #define HCACHE_L1DFWC                        REG32(HCACHE_L1DFWC_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L1DFWC_L1DFWC
\*----------------------------------------------------------------------------*/
  #define HCACHE_L1DFWC_L1DFWC_MASK            (0x0000FFFF)
  #define HCACHE_L1DFWC_L1DFWC_SHIFT           (0x00000000)

  #define HCACHE_L1DFWC_L1DFWC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L1DFWC_L1DFWC)

  #define HCACHE_L1DFWC_L1DFWC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L1DFWC_L1DFWC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L1DFWC
\*----------------------------------------------------------------------------*/
  #define HCACHE_L1DFWC_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L1DFWC_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HCACHE_L1DFWC_CFG(RegAddr,l1dfwc) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L1DFWC_L1DFWC,l1dfwc) \
  )

/******************************************************************************\
* HCACHE_L2FLUSH - L2 flush register
*
* Fields:
*   (RW) HCACHE_L2FLUSH_F
*
\******************************************************************************/
  #define HCACHE_L2FLUSH_ADDR                  (HCACHE_BASE_ADDR+0x5000)
  #define HCACHE_L2FLUSH                       REG32(HCACHE_L2FLUSH_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2FLUSH_F
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2FLUSH_F_MASK                (0x00000001)
  #define HCACHE_L2FLUSH_F_SHIFT               (0x00000000)

  #define HCACHE_L2FLUSH_F_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L2FLUSH_F)

  #define HCACHE_L2FLUSH_F_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L2FLUSH_F,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2FLUSH
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2FLUSH_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L2FLUSH_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L2FLUSH_CFG(RegAddr,f) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L2FLUSH_F,f) \
  )

/******************************************************************************\
* HCACHE_L2CLEAN - L2 clean register
*
* Fields:
*   (RW) HCACHE_L2CLEAN_C
*
\******************************************************************************/
  #define HCACHE_L2CLEAN_ADDR                  (HCACHE_BASE_ADDR+0x5004)
  #define HCACHE_L2CLEAN                       REG32(HCACHE_L2CLEAN_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2CLEAN_C
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2CLEAN_C_MASK                (0x00000001)
  #define HCACHE_L2CLEAN_C_SHIFT               (0x00000000)

  #define HCACHE_L2CLEAN_C_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_L2CLEAN_C)

  #define HCACHE_L2CLEAN_C_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_L2CLEAN_C,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_L2CLEAN
\*----------------------------------------------------------------------------*/
  #define HCACHE_L2CLEAN_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_L2CLEAN_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_L2CLEAN_CFG(RegAddr,c) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_L2CLEAN_C,c) \
  )

/******************************************************************************\
* HCACHE_MAR0  - memory attribute register 0  (16M) 0x80000000->0x80FFFFFF
* HCACHE_MAR1  - memory attribute register 1  (16M) 0x81000000->0x81FFFFFF
* HCACHE_MAR2  - memory attribute register 2  (16M) 0x82000000->0x82FFFFFF
* HCACHE_MAR3  - memory attribute register 3  (16M) 0x83000000->0x83FFFFFF
* HCACHE_MAR4  - memory attribute register 4  (16M) 0x90000000->0x90FFFFFF
* HCACHE_MAR5  - memory attribute register 5  (16M) 0x91000000->0x91FFFFFF
* HCACHE_MAR6  - memory attribute register 6  (16M) 0x92000000->0x92FFFFFF
* HCACHE_MAR7  - memory attribute register 7  (16M) 0x93000000->0x93FFFFFF
* HCACHE_MAR8  - memory attribute register 8  (16M) 0xA0000000->0xA0FFFFFF
* HCACHE_MAR9  - memory attribute register 9  (16M) 0xA1000000->0xA1FFFFFF
* HCACHE_MAR10 - memory attribute register 10 (16M) 0xA2000000->0xA2FFFFFF
* HCACHE_MAR11 - memory attribute register 11 (16M) 0xA3000000->0xA3FFFFFF
* HCACHE_MAR12 - memory attribute register 12 (16M) 0xB0000000->0xB0FFFFFF
* HCACHE_MAR13 - memory attribute register 13 (16M) 0xB1000000->0xB1FFFFFF
* HCACHE_MAR14 - memory attribute register 14 (16M) 0xB2000000->0xB2FFFFFF
* HCACHE_MAR15 - memory attribute register 15 (16M) 0xB3000000->0xB3FFFFFF
*
* Fields:
*   (RW) HCACHE_MAR_CE
*
\******************************************************************************/
  #define HCACHE_MAR0_ADDR                     (HCACHE_BASE_ADDR+0x8200)
  #define HCACHE_MAR1_ADDR                     (HCACHE_BASE_ADDR+0x8204)
  #define HCACHE_MAR2_ADDR                     (HCACHE_BASE_ADDR+0x8208)
  #define HCACHE_MAR3_ADDR                     (HCACHE_BASE_ADDR+0x820C)
  #define HCACHE_MAR4_ADDR                     (HCACHE_BASE_ADDR+0x8240)
  #define HCACHE_MAR5_ADDR                     (HCACHE_BASE_ADDR+0x8244)
  #define HCACHE_MAR6_ADDR                     (HCACHE_BASE_ADDR+0x8248)
  #define HCACHE_MAR7_ADDR                     (HCACHE_BASE_ADDR+0x824C)
  #define HCACHE_MAR8_ADDR                     (HCACHE_BASE_ADDR+0x8280)
  #define HCACHE_MAR9_ADDR                     (HCACHE_BASE_ADDR+0x8284)
  #define HCACHE_MAR10_ADDR                    (HCACHE_BASE_ADDR+0x8288)
  #define HCACHE_MAR11_ADDR                    (HCACHE_BASE_ADDR+0x828C)
  #define HCACHE_MAR12_ADDR                    (HCACHE_BASE_ADDR+0x82C0)
  #define HCACHE_MAR13_ADDR                    (HCACHE_BASE_ADDR+0x82C4)
  #define HCACHE_MAR14_ADDR                    (HCACHE_BASE_ADDR+0x82C8)
  #define HCACHE_MAR15_ADDR                    (HCACHE_BASE_ADDR+0x82CC)
  
  #define HCACHE_MAR0                          REG32(HCACHE_MAR0_ADDR)
  #define HCACHE_MAR1                          REG32(HCACHE_MAR1_ADDR)
  #define HCACHE_MAR2                          REG32(HCACHE_MAR2_ADDR)
  #define HCACHE_MAR3                          REG32(HCACHE_MAR3_ADDR)
  #define HCACHE_MAR4                          REG32(HCACHE_MAR4_ADDR)
  #define HCACHE_MAR5                          REG32(HCACHE_MAR5_ADDR)
  #define HCACHE_MAR6                          REG32(HCACHE_MAR6_ADDR)
  #define HCACHE_MAR7                          REG32(HCACHE_MAR7_ADDR)
  #define HCACHE_MAR8                          REG32(HCACHE_MAR8_ADDR)
  #define HCACHE_MAR9                          REG32(HCACHE_MAR9_ADDR)
  #define HCACHE_MAR10                         REG32(HCACHE_MAR10_ADDR)
  #define HCACHE_MAR11                         REG32(HCACHE_MAR11_ADDR)
  #define HCACHE_MAR12                         REG32(HCACHE_MAR12_ADDR)
  #define HCACHE_MAR13                         REG32(HCACHE_MAR13_ADDR)
  #define HCACHE_MAR14                         REG32(HCACHE_MAR14_ADDR)
  #define HCACHE_MAR15                         REG32(HCACHE_MAR15_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_MAR_CE
\*----------------------------------------------------------------------------*/
  #define HCACHE_MAR_CE_MASK                   (0x00000001)
  #define HCACHE_MAR_CE_SHIFT                  (0x00000000) 

  #define HCACHE_MAR_CE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HCACHE_MAR_CE)

  #define HCACHE_MAR_CE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HCACHE_MAR_CE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HCACHE_MAR
\*----------------------------------------------------------------------------*/
  #define HCACHE_MAR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HCACHE_MAR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HCACHE_MAR_CFG(RegAddr,ce) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HCACHE_MAR_CE,ce) \
  )

/******************************************************************************/

#endif /* CACHE_SUPPORT */
#endif /* _CACHEHAL_H_ */
/******************************************************************************\
* End of cachehal.h
\******************************************************************************/

/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... dmahal.h
* DATE CREATED.. 03/12/1999 
* LAST MODIFIED. 03/08/2000
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the DMA module)
*
* Registers Covered:
*   HDMA_AUXCTL_ADDR   - auxiliary control register
*   HDMA_PRICTL0_ADDR  - primary control register
*   HDMA_PRICTL1_ADDR  - primary control register
*   HDMA_PRICTL2_ADDR  - primary control register
*   HDMA_PRICTL3_ADDR  - primary control register
*   HDMA_SECCTL0_ADDR  - seconday control register
*   HDMA_SECCTL1_ADDR  - seconday control register
*   HDMA_SECCTL2_ADDR  - seconday control register
*   HDMA_SECCTL3_ADDR  - seconday control register
*   HDMA_SRC0_ADDR     - source address register
*   HDMA_SRC1_ADDR     - source address register
*   HDMA_SRC2_ADDR     - source address register
*   HDMA_SRC3_ADDR     - source address register
*   HDMA_DST0_ADDR     - destination address register
*   HDMA_DST1_ADDR     - destination address register
*   HDMA_DST2_ADDR     - destination address register
*   HDMA_DST3_ADDR     - destination address register
*   HDMA_XFRCNT0_ADDR  - transfer count register
*   HDMA_XFRCNT1_ADDR  - transfer count register
*   HDMA_XFRCNT2_ADDR  - transfer count register
*   HDMA_XFRCNT3_ADDR  - transfer count register
*   HDMA_GBLCNTA_ADDR  - global count reload register
*   HDMA_GBLCNTB_ADDR  - global count reload register
*   HDMA_GBLIDXA_ADDR  - global index register
*   HDMA_GBLIDXB_ADDR  - global index register
*   HDMA_GBLADDRA_ADDR - global address register
*   HDMA_GBLADDRB_ADDR - global address register
*   HDMA_GBLADDRC_ADDR - global address register
*   HDMA_GBLADDRD_ADDR - global address register
*
*
\******************************************************************************/
#ifndef _DMAHAL_H_
#define _DMAHAL_H_

#if (DMA_SUPPORT)
/*============================================================================*\
* misc declarations
\*============================================================================*/
  #define HDMA_BASE_ADDR              (HCHIP_PERBASE_ADDR+0x00040000)

  #define HDMA_CHA_CNT                (4)
  #define HDMA_GBLADDR_CNT            (4)
  #define HDMA_GBLIDX_CNT             (2)
  #define HDMA_GBLCNT_CNT             (2)

/******************************************************************************\
* HDMA_AUXCTL_ADDR   - auxiliary control register
*
* Fields:
*   (RW) HDMA_AUXCTL_CHPRI
*   (RW) HDMA_AUXCTL_AUXPRI
*
\******************************************************************************/
  #define HDMA_AUXCTL_ADDR                      (HDMA_BASE_ADDR+0x0070)
  #define HDMA_AUXCTL                           REG32(HDMA_AUXCTL_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_AUXCTL_CHPRI
\*----------------------------------------------------------------------------*/
  #define HDMA_AUXCTL_CHPRI_MASK                (0x0000000F)
  #define HDMA_AUXCTL_CHPRI_SHIFT               (0x00000000)

  #define HDMA_AUXCTL_CHPRI_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_AUXCTL_CHPRI)

  #define HDMA_AUXCTL_CHPRI_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_AUXCTL_CHPRI,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_AUXCTL_AUXPRI
\*----------------------------------------------------------------------------*/
  #define HDMA_AUXCTL_AUXPRI_MASK               (0x00000010)
  #define HDMA_AUXCTL_AUXPRI_SHIFT              (0x00000004)

  #define HDMA_AUXCTL_AUXPRI_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_AUXCTL_AUXPRI)

  #define HDMA_AUXCTL_AUXPRI_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_AUXCTL_AUXPRI,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_AUXCTL
\*----------------------------------------------------------------------------*/
  #define HDMA_AUXCTL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_AUXCTL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_AUXCTL_CFG(RegAddr,chpri,auxpri) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_AUXCTL_CHPRI,chpri)|\
    HFIELD_SHIFT(HDMA_AUXCTL_AUXPRI,auxpri)\
  )

/******************************************************************************\
* HDMA_PRICTL0_ADDR  - primary control register
* HDMA_PRICTL1_ADDR  - primary control register
* HDMA_PRICTL2_ADDR  - primary control register
* HDMA_PRICTL3_ADDR  - primary control register
*
* Fields:
*   (RW) HDMA_PRICTL_START
*   (R)  HDMA_PRICTL_STATUS
*   (RW) HDMA_PRICTL_SRCDIR
*   (RW) HDMA_PRICTL_DSTDIR
*   (RW) HDMA_PRICTL_ESIZE
*   (RW) HDMA_PRICTL_SPLIT
*   (RW) HDMA_PRICTL_CNTRLD
*   (RW) HDMA_PRICTL_INDEX
*   (RW) HDMA_PRICTL_RSYNC
*   (RW) HDMA_PRICTL_WSYNC
*   (RW) HDMA_PRICTL_PRI
*   (RW) HDMA_PRICTL_TCINT
*   (RW) HDMA_PRICTL_FS
*   (RW) HDMA_PRICTL_EMOD
*   (RW) HDMA_PRICTL_SRCRLD
*   (RW) HDMA_PRICTL_DSTRLD
*
\******************************************************************************/
  #define HDMA_PRICTL0_ADDR                     (HDMA_BASE_ADDR+0x0000)
  #define HDMA_PRICTL1_ADDR                     (HDMA_BASE_ADDR+0x0040)
  #define HDMA_PRICTL2_ADDR                     (HDMA_BASE_ADDR+0x0004)
  #define HDMA_PRICTL3_ADDR                     (HDMA_BASE_ADDR+0x0044)

  #define HDMA_PRICTL0                          REG32(HDMA_PRICTL0_ADDR)
  #define HDMA_PRICTL1                          REG32(HDMA_PRICTL1_ADDR)
  #define HDMA_PRICTL2                          REG32(HDMA_PRICTL2_ADDR)
  #define HDMA_PRICTL3                          REG32(HDMA_PRICTL3_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_START
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_START_MASK                (0x00000003)
  #define HDMA_PRICTL_START_SHIFT               (0x00000000)

  #define HDMA_PRICTL_START_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_START)

  #define HDMA_PRICTL_START_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_START,Val)

/*----------------------------------------------------------------------------*\
* (R) HDMA_PRICTL_STATUS
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_STATUS_MASK               (0x0000000C)
  #define HDMA_PRICTL_STATUS_SHIFT              (0x00000002)

  #define HDMA_PRICTL_STATUS_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_STATUS)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_SRCDIR
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_SRCDIR_MASK               (0x00000030)
  #define HDMA_PRICTL_SRCDIR_SHIFT              (0x00000004)

  #define HDMA_PRICTL_SRCDIR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_SRCDIR)

  #define HDMA_PRICTL_SRCDIR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_SRCDIR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_DSTDIR
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_DSTDIR_MASK               (0x000000C0)
  #define HDMA_PRICTL_DSTDIR_SHIFT              (0x00000006)

  #define HDMA_PRICTL_DSTDIR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_DSTDIR)

  #define HDMA_PRICTL_DSTDIR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_DSTDIR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_ESIZE
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_ESIZE_MASK                (0x00000300)
  #define HDMA_PRICTL_ESIZE_SHIFT               (0x00000008)

  #define HDMA_PRICTL_ESIZE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_ESIZE)

  #define HDMA_PRICTL_ESIZE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_ESIZE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_SPLIT
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_SPLIT_MASK                (0x00000C00)
  #define HDMA_PRICTL_SPLIT_SHIFT               (0x0000000A)

  #define HDMA_PRICTL_SPLIT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_SPLIT)

  #define HDMA_PRICTL_SPLIT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_SPLIT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_CNTRLD
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_CNTRLD_MASK               (0x00001000)
  #define HDMA_PRICTL_CNTRLD_SHIFT              (0x0000000C)

  #define HDMA_PRICTL_CNTRLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_CNTRLD)

  #define HDMA_PRICTL_CNTRLD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_CNTRLD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_INDEX
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_INDEX_MASK                (0x00002000)
  #define HDMA_PRICTL_INDEX_SHIFT               (0x0000000D)

  #define HDMA_PRICTL_INDEX_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_INDEX)

  #define HDMA_PRICTL_INDEX_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_INDEX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_RSYNC
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_RSYNC_MASK                (0x0007C000)
  #define HDMA_PRICTL_RSYNC_SHIFT               (0x0000000E)

  #define HDMA_PRICTL_RSYNC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_RSYNC)

  #define HDMA_PRICTL_RSYNC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_RSYNC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_WSYNC
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_WSYNC_MASK                (0x00F10000)
  #define HDMA_PRICTL_WSYNC_SHIFT               (0x00000013)

  #define HDMA_PRICTL_WSYNC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_WSYNC)

  #define HDMA_PRICTL_WSYNC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_WSYNC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_PRI
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_PRI_MASK                  (0x01000000)
  #define HDMA_PRICTL_PRI_SHIFT                 (0x00000018)

  #define HDMA_PRICTL_PRI_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_PRI)

  #define HDMA_PRICTL_PRI_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_PRI,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_TCINT
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_TCINT_MASK                (0x02000000)
  #define HDMA_PRICTL_TCINT_SHIFT               (0x00000019)

  #define HDMA_PRICTL_TCINT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_TCINT)

  #define HDMA_PRICTL_TCINT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_TCINT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_FS
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_FS_MASK                   (0x04000000)
  #define HDMA_PRICTL_FS_SHIFT                  (0x0000001A)

  #define HDMA_PRICTL_FS_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_FS)

  #define HDMA_PRICTL_FS_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_FS,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_EMOD
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_EMOD_MASK                 (0x08000000)
  #define HDMA_PRICTL_EMOD_SHIFT                (0x0000001B)

  #define HDMA_PRICTL_EMOD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_EMOD)

  #define HDMA_PRICTL_EMOD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_EMOD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_SRCRLD
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_SRCRLD_MASK               (0x30000000)
  #define HDMA_PRICTL_SRCRLD_SHIFT              (0x0000001C)

  #define HDMA_PRICTL_SRCRLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_SRCRLD)

  #define HDMA_PRICTL_SRCRLD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_SRCRLD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL_DSTRLD
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_DSTRLD_MASK               (0xC0000000)
  #define HDMA_PRICTL_DSTRLD_SHIFT              (0x0000001E)

  #define HDMA_PRICTL_DSTRLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_PRICTL_DSTRLD)

  #define HDMA_PRICTL_DSTRLD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_PRICTL_DSTRLD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_PRICTL
\*----------------------------------------------------------------------------*/
  #define HDMA_PRICTL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_PRICTL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_PRICTL_CFG(RegAddr,start,srcdir,dstdir,esize,split,cntrld,\
  index,rsync,wsync,pri,tcint,fs,emod,srcrld,dstrld) \
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_PRICTL_START,start)|\
    HFIELD_SHIFT(HDMA_PRICTL_SRCDIR,srcdir)|\
    HFIELD_SHIFT(HDMA_PRICTL_DSTDIR,dstdir)|\
    HFIELD_SHIFT(HDMA_PRICTL_ESIZE,esize)|\
    HFIELD_SHIFT(HDMA_PRICTL_SPLIT,split)|\
    HFIELD_SHIFT(HDMA_PRICTL_CNTRLD,cntrld)|\
    HFIELD_SHIFT(HDMA_PRICTL_INDEX,index)|\
    HFIELD_SHIFT(HDMA_PRICTL_RSYNC,rsync)|\
    HFIELD_SHIFT(HDMA_PRICTL_WSYNC,wsync)|\
    HFIELD_SHIFT(HDMA_PRICTL_PRI,pri)|\
    HFIELD_SHIFT(HDMA_PRICTL_TCINT,tcint)|\
    HFIELD_SHIFT(HDMA_PRICTL_FS,fs)|\
    HFIELD_SHIFT(HDMA_PRICTL_EMOD,emod)|\
    HFIELD_SHIFT(HDMA_PRICTL_SRCRLD,srcrld)|\
    HFIELD_SHIFT(HDMA_PRICTL_DSTRLD,dstrld)\
  )

/******************************************************************************\
* HDMA_SECCTL0_ADDR  - seconday control register
* HDMA_SECCTL1_ADDR  - seconday control register
* HDMA_SECCTL2_ADDR  - seconday control register
* HDMA_SECCTL3_ADDR  - seconday control register
*
* Fields:
*   (RW) HDMA_SECCTL_SXCOND
*   (RW) HDMA_SECCTL_SXIE
*   (RW) HDMA_SECCTL_FRAMECOND
*   (RW) HDMA_SECCTL_FRAMEIE
*   (RW) HDMA_SECCTL_LASTCOND
*   (RW) HDMA_SECCTL_LASTIE
*   (RW) HDMA_SECCTL_BLOCKCOND
*   (RW) HDMA_SECCTL_BLOCKIE
*   (RW) HDMA_SECCTL_RDROPCOND
*   (RW) HDMA_SECCTL_RDROPIE
*   (RW) HDMA_SECCTL_WDROPCOND
*   (RW) HDMA_SECCTL_WDROPIE
*   (RW) HDMA_SECCTL_RSYNCSTAT
*   (RW) HDMA_SECCTL_RSYNCCLR
*   (RW) HDMA_SECCTL_WSYNCSTAT
*   (RW) HDMA_SECCTL_WSYNCCLR
*   (RW) HDMA_SECCTL_DMACEN
*   (RW) HDMA_SECCTL_FSIG (1)
*   (RW) HDMA_SECCTL_RSPOL (1)
*   (RW) HDMA_SECCTL_WSPOL (1)
*
*   (1) only on 6202 or 6203 devices
*
\******************************************************************************/
  #define HDMA_SECCTL0_ADDR                     (HDMA_BASE_ADDR+0x0008)
  #define HDMA_SECCTL1_ADDR                     (HDMA_BASE_ADDR+0x0048)
  #define HDMA_SECCTL2_ADDR                     (HDMA_BASE_ADDR+0x000C)
  #define HDMA_SECCTL3_ADDR                     (HDMA_BASE_ADDR+0x004C)

  #define HDMA_SECCTL0                          REG32(HDMA_SECCTL0_ADDR)
  #define HDMA_SECCTL1                          REG32(HDMA_SECCTL1_ADDR)
  #define HDMA_SECCTL2                          REG32(HDMA_SECCTL2_ADDR)
  #define HDMA_SECCTL3                          REG32(HDMA_SECCTL3_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_SXCOND
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_SXCOND_MASK               (0x00000001)
  #define HDMA_SECCTL_SXCOND_SHIFT              (0x00000000)

  #define HDMA_SECCTL_SXCOND_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_SXCOND)

  #define HDMA_SECCTL_SXCOND_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_SXCOND,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_SXIE
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_SXIE_MASK                 (0x00000002)
  #define HDMA_SECCTL_SXIE_SHIFT                (0x00000001)

  #define HDMA_SECCTL_SXIE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_SXIE)

  #define HDMA_SECCTL_SXIE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_SXIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_FRAMECOND
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_FRAMECOND_MASK            (0x00000004)
  #define HDMA_SECCTL_FRAMECOND_SHIFT           (0x00000002)

  #define HDMA_SECCTL_FRAMECOND_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_FRAMECOND)

  #define HDMA_SECCTL_FRAMECOND_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_FRAMECOND,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_FRAMEIE
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_FRAMEIE_MASK              (0x00000008)
  #define HDMA_SECCTL_FRAMEIE_SHIFT             (0x00000003)

  #define HDMA_SECCTL_FRAMEIE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_FRAMEIE)

  #define HDMA_SECCTL_FRAMEIE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_FRAMEIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_LASTCOND
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_LASTCOND_MASK             (0x00000010)
  #define HDMA_SECCTL_LASTCOND_SHIFT            (0x00000004)

  #define HDMA_SECCTL_LASTCOND_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_LASTCOND)

  #define HDMA_SECCTL_LASTCOND_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_LASTCOND,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_LASTIE
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_LASTIE_MASK               (0x00000020)
  #define HDMA_SECCTL_LASTIE_SHIFT              (0x00000005)

  #define HDMA_SECCTL_LASTIE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_LASTIE)

  #define HDMA_SECCTL_LASTIE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_LASTIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_BLOCKCOND
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_BLOCKCOND_MASK            (0x00000040)
  #define HDMA_SECCTL_BLOCKCOND_SHIFT           (0x00000006)

  #define HDMA_SECCTL_BLOCKCOND_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_BLOCKCOND)

  #define HDMA_SECCTL_BLOCKCOND_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_BLOCKCOND,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_BLOCKIE
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_BLOCKIE_MASK              (0x00000080)
  #define HDMA_SECCTL_BLOCKIE_SHIFT             (0x00000007)

  #define HDMA_SECCTL_BLOCKIE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_BLOCKIE)

  #define HDMA_SECCTL_BLOCKIE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_BLOCKIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_RDROPCOND
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_RDROPCOND_MASK            (0x00000100)
  #define HDMA_SECCTL_RDROPCOND_SHIFT           (0x00000008)

  #define HDMA_SECCTL_RDROPCOND_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_RDROPCOND)

  #define HDMA_SECCTL_RDROPCOND_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_RDROPCOND,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_RDROPIE
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_RDROPIE_MASK              (0x00000200)
  #define HDMA_SECCTL_RDROPIE_SHIFT             (0x00000009)

  #define HDMA_SECCTL_RDROPIE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_RDROPIE)

  #define HDMA_SECCTL_RDROPIE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_RDROPIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_WDROPCOND
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_WDROPCOND_MASK            (0x00000400)
  #define HDMA_SECCTL_WDROPCOND_SHIFT           (0x0000000A)

  #define HDMA_SECCTL_WDROPCOND_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_WDROPCOND)

  #define HDMA_SECCTL_WDROPCOND_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_WDROPCOND,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_WDROPIE
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_WDROPIE_MASK              (0x00000800)
  #define HDMA_SECCTL_WDROPIE_SHIFT             (0x0000000B)

  #define HDMA_SECCTL_WDROPIE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_WDROPIE)

  #define HDMA_SECCTL_WDROPIE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_WDROPIE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_RSYNCSTAT
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_RSYNCSTAT_MASK            (0x00001000)
  #define HDMA_SECCTL_RSYNCSTAT_SHIFT           (0x0000000C)

  #define HDMA_SECCTL_RSYNCSTAT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_RSYNCSTAT)

  #define HDMA_SECCTL_RSYNCSTAT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_RSYNCSTAT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_RSYNCCLR
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_RSYNCCLR_MASK             (0x00002000)
  #define HDMA_SECCTL_RSYNCCLR_SHIFT            (0x0000000D)

  #define HDMA_SECCTL_RSYNCCLR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_RSYNCCLR)

  #define HDMA_SECCTL_RSYNCCLR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_RSYNCCLR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_WSYNCSTAT
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_WSYNCSTAT_MASK            (0x00004000)
  #define HDMA_SECCTL_WSYNCSTAT_SHIFT           (0x0000000E)

  #define HDMA_SECCTL_WSYNCSTAT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_WSYNCSTAT)

  #define HDMA_SECCTL_WSYNCSTAT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_WSYNCSTAT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_WSYNCCLR
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_WSYNCCLR_MASK             (0x00008000)
  #define HDMA_SECCTL_WSYNCCLR_SHIFT            (0x0000000F)

  #define HDMA_SECCTL_WSYNCCLR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_WSYNCCLR)

  #define HDMA_SECCTL_WSYNCCLR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_WSYNCCLR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_DMACEN
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_DMACEN_MASK               (0x00070000)
  #define HDMA_SECCTL_DMACEN_SHIFT              (0x00000010)

  #define HDMA_SECCTL_DMACEN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_DMACEN)

  #define HDMA_SECCTL_DMACEN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_DMACEN,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_FSIG
\*----------------------------------------------------------------------------*/
#if (CHIP_6201|CHIP_6203)
  #define HDMA_SECCTL_FSIG_MASK                 (0x00080000)
  #define HDMA_SECCTL_FSIG_SHIFT                (0x00000013)
#else
  #define HDMA_SECCTL_FSIG_MASK                 (0x00000000)
  #define HDMA_SECCTL_FSIG_SHIFT                (0x00000000)
#endif

  #define HDMA_SECCTL_FSIG_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_FSIG)

  #define HDMA_SECCTL_FSIG_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_FSIG,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_RSPOL
\*----------------------------------------------------------------------------*/
#if (CHIP_6201|CHIP_6203)
  #define HDMA_SECCTL_RSPOL_MASK                (0x00100000)
  #define HDMA_SECCTL_RSPOL_SHIFT               (0x00000014)
#else
  #define HDMA_SECCTL_RSPOL_MASK                (0x00000000)
  #define HDMA_SECCTL_RSPOL_SHIFT               (0x00000000)
#endif

  #define HDMA_SECCTL_RSPOL_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_RSPOL)

  #define HDMA_SECCTL_RSPOL_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_RSPOL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL_WSPOL
\*----------------------------------------------------------------------------*/
#if (CHIP_6201|CHIP_6203)
  #define HDMA_SECCTL_WSPOL_MASK                (0x00200000)
  #define HDMA_SECCTL_WSPOL_SHIFT               (0x00000015)
#else
  #define HDMA_SECCTL_WSPOL_MASK                (0x00000000)
  #define HDMA_SECCTL_WSPOL_SHIFT               (0x00000000)
#endif

  #define HDMA_SECCTL_WSPOL_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SECCTL_WSPOL)

  #define HDMA_SECCTL_WSPOL_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SECCTL_WSPOL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SECCTL
\*----------------------------------------------------------------------------*/
  #define HDMA_SECCTL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_SECCTL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_SECCTL_CFG(RegAddr,sxcond,sxie,framecond,frameie,lastcond,\
  lastie,blockcond,blockie,rdropcond,rdropie,wdropcond,wdropie,rsyncstat,\
  rsyncclr,wsyncstat,wsyncclr,dmacen,fsig,rspol,wspol) \
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_SECCTL_SXCOND,sxcond)|\
    HFIELD_SHIFT(HDMA_SECCTL_SXIE,sxie)|\
    HFIELD_SHIFT(HDMA_SECCTL_FRAMECOND,framecond)|\
    HFIELD_SHIFT(HDMA_SECCTL_FRAMEIE,frameie)|\
    HFIELD_SHIFT(HDMA_SECCTL_LASTCOND,lastcond)|\
    HFIELD_SHIFT(HDMA_SECCTL_LASTIE,lastie)|\
    HFIELD_SHIFT(HDMA_SECCTL_BLOCKCOND,blockcond)|\
    HFIELD_SHIFT(HDMA_SECCTL_BLOCKIE,blockie)|\
    HFIELD_SHIFT(HDMA_SECCTL_RDROPCOND,rdropcond)|\
    HFIELD_SHIFT(HDMA_SECCTL_RDROPIE,rdropie)|\
    HFIELD_SHIFT(HDMA_SECCTL_WDROPCOND,wdropcond)|\
    HFIELD_SHIFT(HDMA_SECCTL_WDROPIE,wdropie)|\
    HFIELD_SHIFT(HDMA_SECCTL_RSYNCSTAT,rsyncstat)|\
    HFIELD_SHIFT(HDMA_SECCTL_RSYNCCLR,rsyncclr)|\
    HFIELD_SHIFT(HDMA_SECCTL_WSYNCSTAT,wsyncstat)|\
    HFIELD_SHIFT(HDMA_SECCTL_WSYNCCLR,wsyncclr)|\
    HFIELD_SHIFT(HDMA_SECCTL_DMACEN,dmacen)|\
    HFIELD_SHIFT(HDMA_SECCTL_FSIG,fsig)|\
    HFIELD_SHIFT(HDMA_SECCTL_RSPOL,rspol)|\
    HFIELD_SHIFT(HDMA_SECCTL_WSPOL,wspol)\
  )

/******************************************************************************\
* HDMA_SRC0_ADDR     - source address register
* HDMA_SRC1_ADDR     - source address register
* HDMA_SRC2_ADDR     - source address register
* HDMA_SRC3_ADDR     - source address register
*
* Fields:
*   (RW) HDMA_SRC_SRC
*
\******************************************************************************/
  #define HDMA_SRC0_ADDR                        (HDMA_BASE_ADDR+0x0010)
  #define HDMA_SRC1_ADDR                        (HDMA_BASE_ADDR+0x0050)
  #define HDMA_SRC2_ADDR                        (HDMA_BASE_ADDR+0x0014)
  #define HDMA_SRC3_ADDR                        (HDMA_BASE_ADDR+0x0054)

  #define HDMA_SRC0                             REG32(HDMA_SRC0_ADDR)
  #define HDMA_SRC1                             REG32(HDMA_SRC1_ADDR)
  #define HDMA_SRC2                             REG32(HDMA_SRC2_ADDR)
  #define HDMA_SRC3                             REG32(HDMA_SRC3_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SRC_SRC
\*----------------------------------------------------------------------------*/
  #define HDMA_SRC_SRC_MASK                     (0xFFFFFFFF)
  #define HDMA_SRC_SRC_SHIFT                    (0x00000000)

  #define HDMA_SRC_SRC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_SRC_SRC)

  #define HDMA_SRC_SRC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_SRC_SRC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_SRC
\*----------------------------------------------------------------------------*/
  #define HDMA_SRC_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_SRC_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_SRC_CFG(RegAddr,src) \
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_SRC_SRC,src)\
  )

/******************************************************************************\
* HDMA_DST0_ADDR     - destination address register
* HDMA_DST1_ADDR     - destination address register
* HDMA_DST2_ADDR     - destination address register
* HDMA_DST3_ADDR     - destination address register
*
* Fields:
*   (RW) HDMA_DST_DST
*
\******************************************************************************/
  #define HDMA_DST0_ADDR                        (HDMA_BASE_ADDR+0x0018)
  #define HDMA_DST1_ADDR                        (HDMA_BASE_ADDR+0x0058)
  #define HDMA_DST2_ADDR                        (HDMA_BASE_ADDR+0x001C)
  #define HDMA_DST3_ADDR                        (HDMA_BASE_ADDR+0x005C)

  #define HDMA_DST0                             REG32(HDMA_DST0_ADDR)
  #define HDMA_DST1                             REG32(HDMA_DST1_ADDR)
  #define HDMA_DST2                             REG32(HDMA_DST2_ADDR)
  #define HDMA_DST3                             REG32(HDMA_DST3_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_DST_DST
\*----------------------------------------------------------------------------*/
  #define HDMA_DST_DST_MASK                     (0xFFFFFFFF)
  #define HDMA_DST_DST_SHIFT                    (0x00000000)

  #define HDMA_DST_DST_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_DST_DST)

  #define HDMA_DST_DST_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_DST_DST,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_DST
\*----------------------------------------------------------------------------*/
  #define HDMA_DST_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_DST_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_DST_CFG(RegAddr,dst) \
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_DST_DST,dst)\
  )

/******************************************************************************\
* HDMA_XFRCNT0_ADDR  - transfer count register
* HDMA_XFRCNT1_ADDR  - transfer count register
* HDMA_XFRCNT2_ADDR  - transfer count register
* HDMA_XFRCNT3_ADDR  - transfer count register
*
* Fields:
*   (RW) HDMA_XFRCNT_ELECNT
*   (RW) HDMA_XFRCNT_FRMCNT
*
\******************************************************************************/
  #define HDMA_XFRCNT0_ADDR                     (HDMA_BASE_ADDR+0x0020)
  #define HDMA_XFRCNT1_ADDR                     (HDMA_BASE_ADDR+0x0060)
  #define HDMA_XFRCNT2_ADDR                     (HDMA_BASE_ADDR+0x0024)
  #define HDMA_XFRCNT3_ADDR                     (HDMA_BASE_ADDR+0x0064)

  #define HDMA_XFRCNT0                          REG32(HDMA_XFRCNT0_ADDR)
  #define HDMA_XFRCNT1                          REG32(HDMA_XFRCNT1_ADDR)
  #define HDMA_XFRCNT2                          REG32(HDMA_XFRCNT2_ADDR)
  #define HDMA_XFRCNT3                          REG32(HDMA_XFRCNT3_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_XFRCNT_ELECNT
\*----------------------------------------------------------------------------*/
  #define HDMA_XFRCNT_ELECNT_MASK               (0x0000FFFF)
  #define HDMA_XFRCNT_ELECNT_SHIFT              (0x00000000)

  #define HDMA_XFRCNT_ELECNT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_XFRCNT_ELECNT)

  #define HDMA_XFRCNT_ELECNT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_XFRCNT_ELECNT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_XFRCNT_FRMCNT
\*----------------------------------------------------------------------------*/
  #define HDMA_XFRCNT_FRMCNT_MASK               (0xFFFF0000)
  #define HDMA_XFRCNT_FRMCNT_SHIFT              (0x00000010)

  #define HDMA_XFRCNT_FRMCNT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_XFRCNT_FRMCNT)

  #define HDMA_XFRCNT_FRMCNT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_XFRCNT_FRMCNT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_XFRCNT
\*----------------------------------------------------------------------------*/
  #define HDMA_XFRCNT_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_XFRCNT_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_XFRCNT_CFG(RegAddr,elecnt,frmcnt) \
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_XFRCNT_ELECNT,elecnt)|\
    HFIELD_SHIFT(HDMA_XFRCNT_FRMCNT,frmcnt)\
  )

/******************************************************************************\
* HDMA_GBLCNTA_ADDR  - global count reload register
* HDMA_GBLCNTB_ADDR  - global count reload register
*
* Fields:
*   (RW) HDMA_GBLCNT_ELECNT
*   (RW) HDMA_GBLCNT_FRMCNT
*
\******************************************************************************/
  #define HDMA_GBLCNTA_ADDR                     (HDMA_BASE_ADDR+0x0028)
  #define HDMA_GBLCNTB_ADDR                     (HDMA_BASE_ADDR+0x002C)

  #define HDMA_GBLCNTA                          REG32(HDMA_GBLCNTA_ADDR)
  #define HDMA_GBLCNTB                          REG32(HDMA_GBLCNTB_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_GBLCNT_ELECNT
\*----------------------------------------------------------------------------*/
  #define HDMA_GBLCNT_ELECNT_MASK               (0x0000FFFF)
  #define HDMA_GBLCNT_ELECNT_SHIFT              (0x00000000)

  #define HDMA_GBLCNT_ELECNT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_GBLCNT_ELECNT)

  #define HDMA_GBLCNT_ELECNT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_GBLCNT_ELECNT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_GBLCNT_FRMCNT
\*----------------------------------------------------------------------------*/
  #define HDMA_GBLCNT_FRMCNT_MASK               (0xFFFF0000)
  #define HDMA_GBLCNT_FRMCNT_SHIFT              (0x00000010)

  #define HDMA_GBLCNT_FRMCNT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_GBLCNT_FRMCNT)

  #define HDMA_GBLCNT_FRMCNT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_GBLCNT_FRMCNT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_GBLCNT
\*----------------------------------------------------------------------------*/
  #define HDMA_GBLCNT_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_GBLCNT_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_GBLCNT_CFG(RegAddr,elecnt,frmcnt) \
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_GBLCNT_ELECNT,elecnt)|\
    HFIELD_SHIFT(HDMA_GBLCNT_FRMCNT,frmcnt)\
  )

/******************************************************************************\
* HDMA_GBLIDXA_ADDR  - global index register
* HDMA_GBLIDXB_ADDR  - global index register
*
* Fields:
*   (RW) HDMA_GBLIDX_ELEIDX
*   (RW) HDMA_GBLIDX_FRMIDX
*
\******************************************************************************/
  #define HDMA_GBLIDXA_ADDR                     (HDMA_BASE_ADDR+0x0030)
  #define HDMA_GBLIDXB_ADDR                     (HDMA_BASE_ADDR+0x0034)

  #define HDMA_GBLIDXA                          REG32(HDMA_GBLIDXA_ADDR)
  #define HDMA_GBLIDXB                          REG32(HDMA_GBLIDXB_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_GBLIDX_ELEIDX
\*----------------------------------------------------------------------------*/
  #define HDMA_GBLIDX_ELEIDX_MASK               (0x0000FFFF)
  #define HDMA_GBLIDX_ELEIDX_SHIFT              (0x00000000)

  #define HDMA_GBLIDX_ELEIDX_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_GBLIDX_ELEIDX)

  #define HDMA_GBLIDX_ELEIDX_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_GBLIDX_ELEIDX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_GBLIDX_FRMIDX
\*----------------------------------------------------------------------------*/
  #define HDMA_GBLIDX_FRMIDX_MASK               (0xFFFF0000)
  #define HDMA_GBLIDX_FRMIDX_SHIFT              (0x00000010)

  #define HDMA_GBLIDX_FRMIDX_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_GBLIDX_FRMIDX)

  #define HDMA_GBLIDX_FRMIDX_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_GBLIDX_FRMIDX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_GBLIDX
\*----------------------------------------------------------------------------*/
  #define HDMA_GBLIDX_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_GBLIDX_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_GBLIDX_CFG(RegAddr,eleidx, frmidx) \
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_GBLIDX_ELEIDX,eleidx)|\
    HFIELD_SHIFT(HDMA_GBLIDX_FRMIDX,frmidx)\
  )

/******************************************************************************\
* HDMA_GBLADDRA_ADDR - global address register
* HDMA_GBLADDRB_ADDR - global address register
* HDMA_GBLADDRC_ADDR - global address register
* HDMA_GBLADDRD_ADDR - global address register
*
* Fields:
*   (RW) HDMA_GBLADDR_GBLADDR
*
\******************************************************************************/
  #define HDMA_GBLADDRA_ADDR                    (HDMA_BASE_ADDR+0x0038)
  #define HDMA_GBLADDRB_ADDR                    (HDMA_BASE_ADDR+0x003C)
  #define HDMA_GBLADDRC_ADDR                    (HDMA_BASE_ADDR+0x0068)
  #define HDMA_GBLADDRD_ADDR                    (HDMA_BASE_ADDR+0x006C)

  #define HDMA_GBLADDRA                         REG32(HDMA_GBLADDRA_ADDR)
  #define HDMA_GBLADDRB                         REG32(HDMA_GBLADDRB_ADDR)
  #define HDMA_GBLADDRC                         REG32(HDMA_GBLADDRC_ADDR)
  #define HDMA_GBLADDRD                         REG32(HDMA_GBLADDRD_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_GBLADDR_GBLADDR
\*----------------------------------------------------------------------------*/
  #define HDMA_GBLADDR_ADDR_MASK                (0xFFFFFFFF)
  #define HDMA_GBLADDR_ADDR_SHIFT               (0x00000000)

  #define HDMA_GBLADDR_GBLADDR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HDMA_GBLADDR_GBLADDR)

  #define HDMA_GBLADDR_GBLADDR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HDMA_GBLADDR_GBLADDR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HDMA_GBLADDR
\*----------------------------------------------------------------------------*/
  #define HDMA_GBLADDR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HDMA_GBLADDR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HDMA_GBLADDR_CFG(RegAddr,gbladdr) \
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HDMA_GBLADDR_GBLADDR,gbladdr)\
  )

/******************************************************************************/

#endif /* DMA_SUPPORT */
#endif /* _DMAHAL_H_ */
/******************************************************************************\
* End of dmahal.h
\******************************************************************************/
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... edmahal.h
* DATE CREATED.. 06/12/1999 
* LAST MODIFIED. 03/08/2000
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the EDMA module)
*
* Registers Covered:
*   HEDMA_OPT  - options (for both QDMA and PRAM entries)
*   HEDMA_SRC  - source address (for both QDMA and PRAM entries)
*   HEDMA_CNT  - transfer count (for both QDMA and PRAM entries)
*   HEDMA_DST  - destination address (for both QDMA and PRAM entries)
*   HEDMA_IDX  - index (for both QDMA and PRAM entries)
*   HEDMA_RLD  - reload/link (for PRAM entries)
*   HEDMA_PQSR - priority queue status register
*   HEDMA_CIPR - channel interrupt pending register
*   HEDMA_CIER - channel interrupt enable register
*   HEDMA_CCER - channel chain enable register
*   HEDMA_ER   - event register
*   HEDMA_EER  - event enable register
*   HEDMA_ECR  - event clear register
*   HEDMA_ESR  - event set register
*
\******************************************************************************/
#ifndef _EDMAHAL_H_
#define _EDMAHAL_H_

#if (EDMA_SUPPORT)
/*============================================================================*\
*  misc declarations
\*============================================================================*/
  #define HEDMA_BASE0_ADDR            (HCHIP_PERBASE_ADDR+0x00200000)
  #define HEDMA_BASE1_ADDR            (HCHIP_PERBASE_ADDR+0x00800000)

  #define HEDMA_CHA_CNT               (16)

  #define HEDMA_PRAM_START            (HEDMA_BASE0_ADDR)
  #define HEDMA_PRAM_SIZE             (0x00000800) 
  #define HEDMA_PRAM_END              (HEDMA_PRAM_START+HEDMA_PRAM_SIZE-1)
  #define HEDMA_ENTRY_SIZE            (24)
  #define HEDMA_ENTRY_CNT             (HEDMA_PRAM_SIZE / HEDMA_ENTRY_SIZE)
  
  #define HEDMA_MK_ENTRY_ADDR(cha)    (HEDMA_PRAM_START+(cha)*HEDMA_ENTRY_SIZE)

  #define HEDMA_ENTRY0_ADDR           HEDMA_MK_ENTRY_ADDR(0)
  #define HEDMA_ENTRY1_ADDR           HEDMA_MK_ENTRY_ADDR(1)
  #define HEDMA_ENTRY2_ADDR           HEDMA_MK_ENTRY_ADDR(2)
  #define HEDMA_ENTRY3_ADDR           HEDMA_MK_ENTRY_ADDR(3)
  #define HEDMA_ENTRY4_ADDR           HEDMA_MK_ENTRY_ADDR(4)
  #define HEDMA_ENTRY5_ADDR           HEDMA_MK_ENTRY_ADDR(5)
  #define HEDMA_ENTRY6_ADDR           HEDMA_MK_ENTRY_ADDR(6)
  #define HEDMA_ENTRY7_ADDR           HEDMA_MK_ENTRY_ADDR(7)
  #define HEDMA_ENTRY8_ADDR           HEDMA_MK_ENTRY_ADDR(8)
  #define HEDMA_ENTRY9_ADDR           HEDMA_MK_ENTRY_ADDR(9)
  #define HEDMA_ENTRY10_ADDR          HEDMA_MK_ENTRY_ADDR(10)
  #define HEDMA_ENTRY11_ADDR          HEDMA_MK_ENTRY_ADDR(11)
  #define HEDMA_ENTRY12_ADDR          HEDMA_MK_ENTRY_ADDR(12)
  #define HEDMA_ENTRY13_ADDR          HEDMA_MK_ENTRY_ADDR(13)
  #define HEDMA_ENTRY14_ADDR          HEDMA_MK_ENTRY_ADDR(14)
  #define HEDMA_ENTRY15_ADDR          HEDMA_MK_ENTRY_ADDR(15)

  #define HEDMA_LINK_START            HEDMA_MK_ENTRY_ADDR(16)

  #define HEDMA_LINK_CNT              ((HEDMA_PRAM_END-HEDMA_LINK_START+1)\
                                        /HEDMA_ENTRY_SIZE)
                                        
  #define HEDMA_MK_LINK_ADDR(l)       (HEDMA_LINK_START+(l)*HEDMA_ENTRY_SIZE)

  #define HEDMA_SCRATCH_START         (HEDMA_LINK_START+\
                                        (HEDMA_ENTRY_SIZE*HEDMA_LINK_CNT))
                                      
  #define HEDMA_SCRATCH_SIZE          (HEDMA_PRAM_END-HEDMA_SCRATCH_START+1)                              


  #define HEDMA_OPT_OFFSET            (0x00000000)
  #define HEDMA_SRC_OFFSET            (0x00000004)
  #define HEDMA_CNT_OFFSET            (0x00000008)
  #define HEDMA_DST_OFFSET            (0x0000000C)
  #define HEDMA_IDX_OFFSET            (0x00000010)
  #define HEDMA_RLD_OFFSET            (0x00000014)

/******************************************************************************\
* HEDMA_OPT - transfer options
*
* Fields:
*   (RW) HEDMA_OPT_FS
*   (RW) HEDMA_OPT_LINK
*   (RW) HEDMA_OPT_TCC
*   (RW) HEDMA_OPT_TCINT
*   (RW) HEDMA_OPT_DUM
*   (RW) HEDMA_OPT_2DD
*   (RW) HEDMA_OPT_SUM
*   (RW) HEDMA_OPT_2DS
*   (RW) HEDMA_OPT_ESIZE
*   (RW) HEDMA_OPT_PRI
*
\******************************************************************************/
  #define HEDMA_QOPT_ADDR              (HEDMA_BASE1_ADDR+0x0000)
  #define HEDMA_QSOPT_ADDR             (HEDMA_BASE1_ADDR+0x0020)
  #define HEDMA_QOPT                   REG32(HEDMA_QOPT_ADDR)
  #define HEDMA_QSOPT                  REG32(HEDMA_QSOPT_ADDR)

  #define HEDMA_OPT0_ADDR              (HEDMA_ENTRY0_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT1_ADDR              (HEDMA_ENTRY1_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT2_ADDR              (HEDMA_ENTRY2_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT3_ADDR              (HEDMA_ENTRY3_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT4_ADDR              (HEDMA_ENTRY4_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT5_ADDR              (HEDMA_ENTRY5_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT6_ADDR              (HEDMA_ENTRY6_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT7_ADDR              (HEDMA_ENTRY7_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT8_ADDR              (HEDMA_ENTRY8_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT9_ADDR              (HEDMA_ENTRY9_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT10_ADDR             (HEDMA_ENTRY10_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT11_ADDR             (HEDMA_ENTRY11_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT12_ADDR             (HEDMA_ENTRY12_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT13_ADDR             (HEDMA_ENTRY13_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT14_ADDR             (HEDMA_ENTRY14_ADDR+HEDMA_OPT_OFFSET)
  #define HEDMA_OPT15_ADDR             (HEDMA_ENTRY15_ADDR+HEDMA_OPT_OFFSET)

  #define HEDMA_OPT0                   REG32(HEDMA_OPT0_ADDR)
  #define HEDMA_OPT1                   REG32(HEDMA_OPT1_ADDR)
  #define HEDMA_OPT2                   REG32(HEDMA_OPT2_ADDR)
  #define HEDMA_OPT3                   REG32(HEDMA_OPT3_ADDR)
  #define HEDMA_OPT4                   REG32(HEDMA_OPT4_ADDR)
  #define HEDMA_OPT5                   REG32(HEDMA_OPT5_ADDR)
  #define HEDMA_OPT6                   REG32(HEDMA_OPT6_ADDR)
  #define HEDMA_OPT7                   REG32(HEDMA_OPT7_ADDR)
  #define HEDMA_OPT8                   REG32(HEDMA_OPT8_ADDR)
  #define HEDMA_OPT9                   REG32(HEDMA_OPT9_ADDR)
  #define HEDMA_OPT10                  REG32(HEDMA_OPT10_ADDR)
  #define HEDMA_OPT11                  REG32(HEDMA_OPT11_ADDR)
  #define HEDMA_OPT12                  REG32(HEDMA_OPT12_ADDR)
  #define HEDMA_OPT13                  REG32(HEDMA_OPT13_ADDR)
  #define HEDMA_OPT14                  REG32(HEDMA_OPT14_ADDR)
  #define HEDMA_OPT15                  REG32(HEDMA_OPT15_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_FS
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_FS_MASK                    (0x00000001)
  #define HEDMA_OPT_FS_SHIFT                   (0x00000000)

  #define HEDMA_OPT_FS_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_FS)

  #define HEDMA_OPT_FS_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_FS,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_LINK
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_LINK_MASK                  (0x00000002)
  #define HEDMA_OPT_LINK_SHIFT                 (0x00000001)

  #define HEDMA_OPT_LINK_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_LINK)

  #define HEDMA_OPT_LINK_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_LINK,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_TCC
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_TCC_MASK                   (0x000F0000)
  #define HEDMA_OPT_TCC_SHIFT                  (0x00000010)

  #define HEDMA_OPT_TCC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_TCC)

  #define HEDMA_OPT_TCC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_TCC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_TCINT
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_TCINT_MASK                 (0x00100000)
  #define HEDMA_OPT_TCINT_SHIFT                (0x00000014)

  #define HEDMA_OPT_TCINT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_TCINT)

  #define HEDMA_OPT_TCINT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_TCINT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_DUM
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_DUM_MASK                   (0x00600000)
  #define HEDMA_OPT_DUM_SHIFT                  (0x00000015)

  #define HEDMA_OPT_DUM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_DUM)

  #define HEDMA_OPT_DUM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_DUM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_2DD
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_2DD_MASK                   (0x00800000)
  #define HEDMA_OPT_2DD_SHIFT                  (0x00000017)

  #define HEDMA_OPT_2DD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_2DD)

  #define HEDMA_OPT_2DD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_2DD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_SUM
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_SUM_MASK                   (0x03000000)
  #define HEDMA_OPT_SUM_SHIFT                  (0x00000018)

  #define HEDMA_OPT_SUM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_SUM)

  #define HEDMA_OPT_SUM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_SUM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_2DS
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_2DS_MASK                   (0x04000000)
  #define HEDMA_OPT_2DS_SHIFT                  (0x0000001A)

  #define HEDMA_OPT_2DS_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_2DS)

  #define HEDMA_OPT_2DS_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_2DS,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_ESIZE
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_ESIZE_MASK                 (0x18000000)
  #define HEDMA_OPT_ESIZE_SHIFT                (0x0000001B)

  #define HEDMA_OPT_ESIZE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_ESIZE)

  #define HEDMA_OPT_ESIZE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_ESIZE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT_PRI
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_PRI_MASK                   (0xE0000000)
  #define HEDMA_OPT_PRI_SHIFT                  (0x0000001D)

  #define HEDMA_OPT_PRI_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_OPT_PRI)

  #define HEDMA_OPT_PRI_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_OPT_PRI,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_OPT
\*----------------------------------------------------------------------------*/
  #define HEDMA_OPT_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_OPT_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_OPT_CFG(RegAddr,fs,link,tcc,tcint,dum,d2d,sum,s2d,esize,pri)\
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_OPT_FS,fs)|\
    HFIELD_SHIFT(HEDMA_OPT_LINK,link)|\
    HFIELD_SHIFT(HEDMA_OPT_TCC,tcc)|\
    HFIELD_SHIFT(HEDMA_OPT_TCINT,tcint)|\
    HFIELD_SHIFT(HEDMA_OPT_DUM,dum)|\
    HFIELD_SHIFT(HEDMA_OPT_2DD,d2d)|\
    HFIELD_SHIFT(HEDMA_OPT_SUM,sum)|\
    HFIELD_SHIFT(HEDMA_OPT_2DS,s2d)|\
    HFIELD_SHIFT(HEDMA_OPT_ESIZE,esize)|\
    HFIELD_SHIFT(HEDMA_OPT_PRI,pri)\
  )

/******************************************************************************\
* HEDMA_SRC - source address
*
* Fields:
*   (RW) HEDMA_SRC_SRC
*
\******************************************************************************/
  #define HEDMA_QSRC_ADDR              (HEDMA_BASE1_ADDR+0x0004)
  #define HEDMA_QSSRC_ADDR             (HEDMA_BASE1_ADDR+0x0024)
  #define HEDMA_QSRC                   REG32(HEDMA_QSRC_ADDR)
  #define HEDMA_QSSRC                  REG32(HEDMA_QSSRC_ADDR)

  #define HEDMA_SRC0_ADDR              (HEDMA_ENTRY0_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC1_ADDR              (HEDMA_ENTRY1_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC2_ADDR              (HEDMA_ENTRY2_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC3_ADDR              (HEDMA_ENTRY3_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC4_ADDR              (HEDMA_ENTRY4_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC5_ADDR              (HEDMA_ENTRY5_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC6_ADDR              (HEDMA_ENTRY6_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC7_ADDR              (HEDMA_ENTRY7_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC8_ADDR              (HEDMA_ENTRY8_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC9_ADDR              (HEDMA_ENTRY9_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC10_ADDR             (HEDMA_ENTRY10_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC11_ADDR             (HEDMA_ENTRY11_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC12_ADDR             (HEDMA_ENTRY12_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC13_ADDR             (HEDMA_ENTRY13_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC14_ADDR             (HEDMA_ENTRY14_ADDR+HEDMA_SRC_OFFSET)
  #define HEDMA_SRC15_ADDR             (HEDMA_ENTRY15_ADDR+HEDMA_SRC_OFFSET)

  #define HEDMA_SRC0                   REG32(HEDMA_SRC0_ADDR)
  #define HEDMA_SRC1                   REG32(HEDMA_SRC1_ADDR)
  #define HEDMA_SRC2                   REG32(HEDMA_SRC2_ADDR)
  #define HEDMA_SRC3                   REG32(HEDMA_SRC3_ADDR)
  #define HEDMA_SRC4                   REG32(HEDMA_SRC4_ADDR)
  #define HEDMA_SRC5                   REG32(HEDMA_SRC5_ADDR)
  #define HEDMA_SRC6                   REG32(HEDMA_SRC6_ADDR)
  #define HEDMA_SRC7                   REG32(HEDMA_SRC7_ADDR)
  #define HEDMA_SRC8                   REG32(HEDMA_SRC8_ADDR)
  #define HEDMA_SRC9                   REG32(HEDMA_SRC9_ADDR)
  #define HEDMA_SRC10                  REG32(HEDMA_SRC10_ADDR)
  #define HEDMA_SRC11                  REG32(HEDMA_SRC11_ADDR)
  #define HEDMA_SRC12                  REG32(HEDMA_SRC12_ADDR)
  #define HEDMA_SRC13                  REG32(HEDMA_SRC13_ADDR)
  #define HEDMA_SRC14                  REG32(HEDMA_SRC14_ADDR)
  #define HEDMA_SRC15                  REG32(HEDMA_SRC15_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_SRC_SRC
\*----------------------------------------------------------------------------*/
  #define HEDMA_SRC_SRC_MASK                   (0xFFFFFFFF)
  #define HEDMA_SRC_SRC_SHIFT                  (0x00000000)
                                      
  #define HEDMA_SRC_SRC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_SRC_SRC)

  #define HEDMA_SRC_SRC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_SRC_SRC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_SRC
\*----------------------------------------------------------------------------*/
  #define HEDMA_SRC_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_SRC_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_SRC_CFG(RegAddr,src)\
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_SRC_SRC,src)\
  )

/******************************************************************************\
* HEDMA_CNT - transfer count
*
* Fields:
*   (RW) HEDMA_CNT_ELECNT
*   (RW) HEDMA_CNT_FRMCNT
*
\******************************************************************************/
  #define HEDMA_QCNT_ADDR              (HEDMA_BASE1_ADDR+0x0008)
  #define HEDMA_QSCNT_ADDR             (HEDMA_BASE1_ADDR+0x0028) 
  #define HEDMA_QCNT                   REG32(HEDMA_QCNT_ADDR)
  #define HEDMA_QSCNT                  REG32(HEDMA_QSCNT_ADDR)
  
  #define HEDMA_CNT0_ADDR              (HEDMA_ENTRY0_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT1_ADDR              (HEDMA_ENTRY1_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT2_ADDR              (HEDMA_ENTRY2_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT3_ADDR              (HEDMA_ENTRY3_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT4_ADDR              (HEDMA_ENTRY4_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT5_ADDR              (HEDMA_ENTRY5_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT6_ADDR              (HEDMA_ENTRY6_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT7_ADDR              (HEDMA_ENTRY7_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT8_ADDR              (HEDMA_ENTRY8_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT9_ADDR              (HEDMA_ENTRY9_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT10_ADDR             (HEDMA_ENTRY10_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT11_ADDR             (HEDMA_ENTRY11_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT12_ADDR             (HEDMA_ENTRY12_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT13_ADDR             (HEDMA_ENTRY13_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT14_ADDR             (HEDMA_ENTRY14_ADDR+HEDMA_CNT_OFFSET)
  #define HEDMA_CNT15_ADDR             (HEDMA_ENTRY15_ADDR+HEDMA_CNT_OFFSET)

  #define HEDMA_CNT0                   REG32(HEDMA_CNT0_ADDR)
  #define HEDMA_CNT1                   REG32(HEDMA_CNT1_ADDR)
  #define HEDMA_CNT2                   REG32(HEDMA_CNT2_ADDR)
  #define HEDMA_CNT3                   REG32(HEDMA_CNT3_ADDR)
  #define HEDMA_CNT4                   REG32(HEDMA_CNT4_ADDR)
  #define HEDMA_CNT5                   REG32(HEDMA_CNT5_ADDR)
  #define HEDMA_CNT6                   REG32(HEDMA_CNT6_ADDR)
  #define HEDMA_CNT7                   REG32(HEDMA_CNT7_ADDR)
  #define HEDMA_CNT8                   REG32(HEDMA_CNT8_ADDR)
  #define HEDMA_CNT9                   REG32(HEDMA_CNT9_ADDR)
  #define HEDMA_CNT10                  REG32(HEDMA_CNT10_ADDR)
  #define HEDMA_CNT11                  REG32(HEDMA_CNT11_ADDR)
  #define HEDMA_CNT12                  REG32(HEDMA_CNT12_ADDR)
  #define HEDMA_CNT13                  REG32(HEDMA_CNT13_ADDR)
  #define HEDMA_CNT14                  REG32(HEDMA_CNT14_ADDR)
  #define HEDMA_CNT15                  REG32(HEDMA_CNT15_ADDR)
  
/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CNT_ELECNT
\*----------------------------------------------------------------------------*/
  #define HEDMA_CNT_ELECNT_MASK                (0x0000FFFF)
  #define HEDMA_CNT_ELECNT_SHIFT               (0x00000000)
  
  #define HEDMA_CNT_ELECNT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CNT_ELECNT)

  #define HEDMA_CNT_ELECNT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CNT_ELECNT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CNT_FRMCNT
\*----------------------------------------------------------------------------*/
  #define HEDMA_CNT_FRMCNT_MASK                (0xFFFF0000)
  #define HEDMA_CNT_FRMCNT_SHIFT               (0x00000010)
                                      
  #define HEDMA_CNT_FRMCNT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CNT_FRMCNT)

  #define HEDMA_CNT_FRMCNT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CNT_FRMCNT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CNT
\*----------------------------------------------------------------------------*/
  #define HEDMA_CNT_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_CNT_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_CNT_CFG(RegAddr,elecnt,frmcnt)\
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_CNT_ELECNT,elecnt)|\
    HFIELD_SHIFT(HEDMA_CNT_FRMCNT,frmcnt)\
  )

/******************************************************************************\
* HEDMA_DST - destination address
*
* Fields:
*   (RW) HEDMA_DST_DST
*
\******************************************************************************/
  #define HEDMA_QDST_ADDR              (HEDMA_BASE1_ADDR+0x000C)
  #define HEDMA_QSDST_ADDR             (HEDMA_BASE1_ADDR+0x002C)
  #define HEDMA_QDST                   REG32(HEDMA_QDST_ADDR)
  #define HEDMA_QSDST                  REG32(HEDMA_QSDST_ADDR)

  #define HEDMA_DST0_ADDR              (HEDMA_ENTRY0_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST1_ADDR              (HEDMA_ENTRY1_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST2_ADDR              (HEDMA_ENTRY2_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST3_ADDR              (HEDMA_ENTRY3_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST4_ADDR              (HEDMA_ENTRY4_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST5_ADDR              (HEDMA_ENTRY5_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST6_ADDR              (HEDMA_ENTRY6_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST7_ADDR              (HEDMA_ENTRY7_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST8_ADDR              (HEDMA_ENTRY8_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST9_ADDR              (HEDMA_ENTRY9_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST10_ADDR             (HEDMA_ENTRY10_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST11_ADDR             (HEDMA_ENTRY11_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST12_ADDR             (HEDMA_ENTRY12_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST13_ADDR             (HEDMA_ENTRY13_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST14_ADDR             (HEDMA_ENTRY14_ADDR+HEDMA_DST_OFFSET)
  #define HEDMA_DST15_ADDR             (HEDMA_ENTRY15_ADDR+HEDMA_DST_OFFSET)

  #define HEDMA_DST0                   REG32(HEDMA_DST0_ADDR)
  #define HEDMA_DST1                   REG32(HEDMA_DST1_ADDR)
  #define HEDMA_DST2                   REG32(HEDMA_DST2_ADDR)
  #define HEDMA_DST3                   REG32(HEDMA_DST3_ADDR)
  #define HEDMA_DST4                   REG32(HEDMA_DST4_ADDR)
  #define HEDMA_DST5                   REG32(HEDMA_DST5_ADDR)
  #define HEDMA_DST6                   REG32(HEDMA_DST6_ADDR)
  #define HEDMA_DST7                   REG32(HEDMA_DST7_ADDR)
  #define HEDMA_DST8                   REG32(HEDMA_DST8_ADDR)
  #define HEDMA_DST9                   REG32(HEDMA_DST9_ADDR)
  #define HEDMA_DST10                  REG32(HEDMA_DST10_ADDR)
  #define HEDMA_DST11                  REG32(HEDMA_DST11_ADDR)
  #define HEDMA_DST12                  REG32(HEDMA_DST12_ADDR)
  #define HEDMA_DST13                  REG32(HEDMA_DST13_ADDR)
  #define HEDMA_DST14                  REG32(HEDMA_DST14_ADDR)
  #define HEDMA_DST15                  REG32(HEDMA_DST15_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_DST_DST
\*----------------------------------------------------------------------------*/
  #define HEDMA_DST_DST_MASK                   (0xFFFFFFFF)
  #define HEDMA_DST_DST_SHIFT                  (0x00000000)
                                      
  #define HEDMA_DST_DST_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_DST_DST)

  #define HEDMA_DST_DST_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_DST_DST,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_DST
\*----------------------------------------------------------------------------*/
  #define HEDMA_DST_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_DST_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_DST_CFG(RegAddr,src)\
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_DST_DST,src)\
  )

/******************************************************************************\
* HEDMA_IDX - transfer count
*
* Fields:
*   (RW) HEDMA_IDX_ELEIDX
*   (RW) HEDMA_IDX_FRMIDX
*
\******************************************************************************/
  #define HEDMA_QIDX_ADDR              (HEDMA_BASE1_ADDR+0x0010)
  #define HEDMA_QSIDX_ADDR             (HEDMA_BASE1_ADDR+0x0030)
  #define HEDMA_QIDX                   REG32(HEDMA_QIDX_ADDR)
  #define HEDMA_QSIDX                  REG32(HEDMA_QSIDX_ADDR)
  
  #define HEDMA_IDX0_ADDR              (HEDMA_ENTRY0_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX1_ADDR              (HEDMA_ENTRY1_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX2_ADDR              (HEDMA_ENTRY2_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX3_ADDR              (HEDMA_ENTRY3_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX4_ADDR              (HEDMA_ENTRY4_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX5_ADDR              (HEDMA_ENTRY5_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX6_ADDR              (HEDMA_ENTRY6_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX7_ADDR              (HEDMA_ENTRY7_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX8_ADDR              (HEDMA_ENTRY8_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX9_ADDR              (HEDMA_ENTRY9_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX10_ADDR             (HEDMA_ENTRY10_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX11_ADDR             (HEDMA_ENTRY11_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX12_ADDR             (HEDMA_ENTRY12_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX13_ADDR             (HEDMA_ENTRY13_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX14_ADDR             (HEDMA_ENTRY14_ADDR+HEDMA_IDX_OFFSET)
  #define HEDMA_IDX15_ADDR             (HEDMA_ENTRY15_ADDR+HEDMA_IDX_OFFSET)

  #define HEDMA_IDX0                   REG32(HEDMA_IDX0_ADDR)
  #define HEDMA_IDX1                   REG32(HEDMA_IDX1_ADDR)
  #define HEDMA_IDX2                   REG32(HEDMA_IDX2_ADDR)
  #define HEDMA_IDX3                   REG32(HEDMA_IDX3_ADDR)
  #define HEDMA_IDX4                   REG32(HEDMA_IDX4_ADDR)
  #define HEDMA_IDX5                   REG32(HEDMA_IDX5_ADDR)
  #define HEDMA_IDX6                   REG32(HEDMA_IDX6_ADDR)
  #define HEDMA_IDX7                   REG32(HEDMA_IDX7_ADDR)
  #define HEDMA_IDX8                   REG32(HEDMA_IDX8_ADDR)
  #define HEDMA_IDX9                   REG32(HEDMA_IDX9_ADDR)
  #define HEDMA_IDX10                  REG32(HEDMA_IDX10_ADDR)
  #define HEDMA_IDX11                  REG32(HEDMA_IDX11_ADDR)
  #define HEDMA_IDX12                  REG32(HEDMA_IDX12_ADDR)
  #define HEDMA_IDX13                  REG32(HEDMA_IDX13_ADDR)
  #define HEDMA_IDX14                  REG32(HEDMA_IDX14_ADDR)
  #define HEDMA_IDX15                  REG32(HEDMA_IDX15_ADDR)
  
/*----------------------------------------------------------------------------*\
* (RW) HEDMA_IDX_ELEIDX
\*----------------------------------------------------------------------------*/
  #define HEDMA_IDX_ELEIDX_MASK                (0x0000FFFF)
  #define HEDMA_IDX_ELEIDX_SHIFT               (0x00000000)
  
  #define HEDMA_IDX_ELEIDX_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_IDX_ELEIDX)

  #define HEDMA_IDX_ELEIDX_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_IDX_ELEIDX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_IDX_FRMIDX
\*----------------------------------------------------------------------------*/
  #define HEDMA_IDX_FRMIDX_MASK                (0xFFFF0000)
  #define HEDMA_IDX_FRMIDX_SHIFT               (0x00000010)
                                      
  #define HEDMA_IDX_FRMIDX_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_IDX_FRMIDX)

  #define HEDMA_IDX_FRMIDX_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_IDX_FRMIDX,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_IDX
\*----------------------------------------------------------------------------*/
  #define HEDMA_IDX_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_IDX_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_IDX_CFG(RegAddr,eleidx,frmidx)\
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_IDX_ELEIDX,eleidx)|\
    HFIELD_SHIFT(HEDMA_IDX_FRMIDX,frmidx)\
  )

/******************************************************************************\
* HEDMA_RLD - element reload/link address
*
* Fields:
*   (RW) HEDMA_RLD_LINK
*   (RW) HEDMA_RLD_ELERLD
*
\******************************************************************************/
  #define HEDMA_RLD0_ADDR              (HEDMA_ENTRY0_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD1_ADDR              (HEDMA_ENTRY1_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD2_ADDR              (HEDMA_ENTRY2_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD3_ADDR              (HEDMA_ENTRY3_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD4_ADDR              (HEDMA_ENTRY4_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD5_ADDR              (HEDMA_ENTRY5_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD6_ADDR              (HEDMA_ENTRY6_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD7_ADDR              (HEDMA_ENTRY7_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD8_ADDR              (HEDMA_ENTRY8_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD9_ADDR              (HEDMA_ENTRY9_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD10_ADDR             (HEDMA_ENTRY10_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD11_ADDR             (HEDMA_ENTRY11_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD12_ADDR             (HEDMA_ENTRY12_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD13_ADDR             (HEDMA_ENTRY13_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD14_ADDR             (HEDMA_ENTRY14_ADDR+HEDMA_RLD_OFFSET)
  #define HEDMA_RLD15_ADDR             (HEDMA_ENTRY15_ADDR+HEDMA_RLD_OFFSET)

  #define HEDMA_RLD0                   REG32(HEDMA_RLD0_ADDR)
  #define HEDMA_RLD1                   REG32(HEDMA_RLD1_ADDR)
  #define HEDMA_RLD2                   REG32(HEDMA_RLD2_ADDR)
  #define HEDMA_RLD3                   REG32(HEDMA_RLD3_ADDR)
  #define HEDMA_RLD4                   REG32(HEDMA_RLD4_ADDR)
  #define HEDMA_RLD5                   REG32(HEDMA_RLD5_ADDR)
  #define HEDMA_RLD6                   REG32(HEDMA_RLD6_ADDR)
  #define HEDMA_RLD7                   REG32(HEDMA_RLD7_ADDR)
  #define HEDMA_RLD8                   REG32(HEDMA_RLD8_ADDR)
  #define HEDMA_RLD9                   REG32(HEDMA_RLD9_ADDR)
  #define HEDMA_RLD10                  REG32(HEDMA_RLD10_ADDR)
  #define HEDMA_RLD11                  REG32(HEDMA_RLD11_ADDR)
  #define HEDMA_RLD12                  REG32(HEDMA_RLD12_ADDR)
  #define HEDMA_RLD13                  REG32(HEDMA_RLD13_ADDR)
  #define HEDMA_RLD14                  REG32(HEDMA_RLD14_ADDR)
  #define HEDMA_RLD15                  REG32(HEDMA_RLD15_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_RLD_LINK
\*----------------------------------------------------------------------------*/
  #define HEDMA_RLD_LINK_MASK                  (0x0000FFFF)
  #define HEDMA_RLD_LINK_SHIFT                 (0x00000000)
  
  #define HEDMA_RLD_LINK_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_RLD_LINK)

  #define HEDMA_RLD_LINK_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_RLD_LINK,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_RLD_ELERLD
\*----------------------------------------------------------------------------*/
  #define HEDMA_RLD_ELERLD_MASK                (0xFFFF0000)
  #define HEDMA_RLD_ELERLD_SHIFT               (0x00000010)
                                      
  #define HEDMA_RLD_ELERLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_RLD_ELERLD)

  #define HEDMA_RLD_ELERLD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_RLD_ELERLD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_RLD
\*----------------------------------------------------------------------------*/
  #define HEDMA_RLD_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_RLD_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_RLD_CFG(RegAddr,link,elerld)\
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_RLD_LINK,link)|\
    HFIELD_SHIFT(HEDMA_RLD_ELERLD,elerld)\
  )

/******************************************************************************\
* HEDMA_PQSR - priority queue status register
*
* Fields:
*   (R) HEDMA_PQSR_PQ0
*   (R) HEDMA_PQSR_PQ1
*   (R) HEDMA_PQSR_PQ2
*
\******************************************************************************/
  #define HEDMA_PQSR_ADDR                      (HEDMA_BASE0_ADDR+0xFFE0)
  #define HEDMA_PQSR                           REG32(HEDMA_PQSR_ADDR)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_PQSR_PQ0
\*----------------------------------------------------------------------------*/
  #define HEDMA_PQSR_PQ0_MASK                  (0x00000001)
  #define HEDMA_PQSR_PQ0_SHIFT                 (0x00000000)
  
  #define HEDMA_PQSR_PQ0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_PQSR_PQ0)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_PQSR_PQ1
\*----------------------------------------------------------------------------*/
  #define HEDMA_PQSR_PQ1_MASK                  (0x00000002)
  #define HEDMA_PQSR_PQ1_SHIFT                 (0x00000001)
  
  #define HEDMA_PQSR_PQ1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_PQSR_PQ1)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_PQSR_PQ2
\*----------------------------------------------------------------------------*/
  #define HEDMA_PQSR_PQ2_MASK                  (0x00000004)
  #define HEDMA_PQSR_PQ2_SHIFT                 (0x00000002)

  #define HEDMA_PQSR_PQ2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_PQSR_PQ2)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_PQSR
\*----------------------------------------------------------------------------*/
  #define HEDMA_PQSR_GET(RegAddr) HREG32_GET(RegAddr)

/******************************************************************************\
* HEDMA_CIPR - channel interrupt pending register
*
* Fields:
*   (RW) HEDMA_CIPR_CIP0
*   (RW) HEDMA_CIPR_CIP1
*   (RW) HEDMA_CIPR_CIP2
*   (RW) HEDMA_CIPR_CIP3
*   (RW) HEDMA_CIPR_CIP4
*   (RW) HEDMA_CIPR_CIP5
*   (RW) HEDMA_CIPR_CIP6
*   (RW) HEDMA_CIPR_CIP7
*   (RW) HEDMA_CIPR_CIP8
*   (RW) HEDMA_CIPR_CIP9
*   (RW) HEDMA_CIPR_CIP10
*   (RW) HEDMA_CIPR_CIP11
*   (RW) HEDMA_CIPR_CIP12
*   (RW) HEDMA_CIPR_CIP13
*   (RW) HEDMA_CIPR_CIP14
*   (RW) HEDMA_CIPR_CIP15
*
\******************************************************************************/
  #define HEDMA_CIPR_ADDR                      (HEDMA_BASE0_ADDR+0xFFE4)
  #define HEDMA_CIPR                           REG32(HEDMA_CIPR_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP0
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP0_MASK                 (0x00000001)
  #define HEDMA_CIPR_CIP0_SHIFT                (0x00000000)
  
  #define HEDMA_CIPR_CIP0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP0)

  #define HEDMA_CIPR_CIP0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP1
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP1_MASK                 (0x00000002)
  #define HEDMA_CIPR_CIP1_SHIFT                (0x00000001)
  
  #define HEDMA_CIPR_CIP1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP1)

  #define HEDMA_CIPR_CIP1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP2
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP2_MASK                 (0x00000004)
  #define HEDMA_CIPR_CIP2_SHIFT                (0x00000002)
  
  #define HEDMA_CIPR_CIP2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP2)

  #define HEDMA_CIPR_CIP2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP3
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP3_MASK                 (0x00000008)
  #define HEDMA_CIPR_CIP3_SHIFT                (0x00000003)
  
  #define HEDMA_CIPR_CIP3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP3)

  #define HEDMA_CIPR_CIP3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP4
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP4_MASK                 (0x00000010)
  #define HEDMA_CIPR_CIP4_SHIFT                (0x00000004)
  
  #define HEDMA_CIPR_CIP4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP4)

  #define HEDMA_CIPR_CIP4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP5
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP5_MASK                 (0x00000020)
  #define HEDMA_CIPR_CIP5_SHIFT                (0x00000005)
  
  #define HEDMA_CIPR_CIP5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP5)

  #define HEDMA_CIPR_CIP5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP6
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP6_MASK                 (0x00000040)
  #define HEDMA_CIPR_CIP6_SHIFT                (0x00000006)
  
  #define HEDMA_CIPR_CIP6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP6)

  #define HEDMA_CIPR_CIP6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP7
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP7_MASK                 (0x00000080)
  #define HEDMA_CIPR_CIP7_SHIFT                (0x00000007)
  
  #define HEDMA_CIPR_CIP7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP7)

  #define HEDMA_CIPR_CIP7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP8
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP8_MASK                 (0x00000100)
  #define HEDMA_CIPR_CIP8_SHIFT                (0x00000008)
  
  #define HEDMA_CIPR_CIP8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP8)

  #define HEDMA_CIPR_CIP8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP9
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP9_MASK                 (0x00000200)
  #define HEDMA_CIPR_CIP9_SHIFT                (0x00000009)
  
  #define HEDMA_CIPR_CIP9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP9)

  #define HEDMA_CIPR_CIP9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP10
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP10_MASK                (0x00000400)
  #define HEDMA_CIPR_CIP10_SHIFT               (0x0000000A)
  
  #define HEDMA_CIPR_CIP10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP10)

  #define HEDMA_CIPR_CIP10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP11
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP11_MASK                (0x00000800)
  #define HEDMA_CIPR_CIP11_SHIFT               (0x0000000B)
  
  #define HEDMA_CIPR_CIP11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP11)

  #define HEDMA_CIPR_CIP11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP12
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP12_MASK                (0x00001000)
  #define HEDMA_CIPR_CIP12_SHIFT               (0x0000000C)
  
  #define HEDMA_CIPR_CIP12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP12)

  #define HEDMA_CIPR_CIP12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP13
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP13_MASK                (0x00002000)
  #define HEDMA_CIPR_CIP13_SHIFT               (0x0000000D)
  
  #define HEDMA_CIPR_CIP13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP13)

  #define HEDMA_CIPR_CIP13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP14
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP14_MASK                (0x00004000)
  #define HEDMA_CIPR_CIP14_SHIFT               (0x0000000E)
  
  #define HEDMA_CIPR_CIP14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP14)

  #define HEDMA_CIPR_CIP14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR_CIP15
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_CIP15_MASK                (0x00008000)
  #define HEDMA_CIPR_CIP15_SHIFT               (0x0000000F)
  
  #define HEDMA_CIPR_CIP15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIPR_CIP15)

  #define HEDMA_CIPR_CIP15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIPR_CIP15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIPR
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIPR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_CIPR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_CIPR_CFG(RegAddr,cip0,cip1,cip2,cip3,cip4,cip5,cip6,cip7,\
  cip8,cip9,cip10,cip11,cip12,cip13,cip14,cip15) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_CIPR_CIP0,cip0)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP1,cip1)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP2,cip2)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP3,cip3)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP4,cip4)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP5,cip5)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP6,cip6)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP7,cip7)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP8,cip8)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP9,cip9)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP10,cip10)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP11,cip11)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP12,cip12)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP13,cip13)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP14,cip14)|\
    HFIELD_SHIFT(HEDMA_CIPR_CIP15,cip15)\
  )

/******************************************************************************\
* HEDMA_CIER - channel interrupt enable register
*
* Fields:
*   (RW) HEDMA_CIER_CIE0
*   (RW) HEDMA_CIER_CIE1
*   (RW) HEDMA_CIER_CIE2
*   (RW) HEDMA_CIER_CIE3
*   (RW) HEDMA_CIER_CIE4
*   (RW) HEDMA_CIER_CIE5
*   (RW) HEDMA_CIER_CIE6
*   (RW) HEDMA_CIER_CIE7
*   (RW) HEDMA_CIER_CIE8
*   (RW) HEDMA_CIER_CIE9
*   (RW) HEDMA_CIER_CIE10
*   (RW) HEDMA_CIER_CIE11
*   (RW) HEDMA_CIER_CIE12
*   (RW) HEDMA_CIER_CIE13
*   (RW) HEDMA_CIER_CIE14
*   (RW) HEDMA_CIER_CIE15
*
\******************************************************************************/
  #define HEDMA_CIER_ADDR                      (HEDMA_BASE0_ADDR+0xFFE8)
  #define HEDMA_CIER                           REG32(HEDMA_CIER_ADDR)
  
/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE0
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE0_MASK                 (0x00000001)
  #define HEDMA_CIER_CIE0_SHIFT                (0x00000000)
  
  #define HEDMA_CIER_CIE0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE0)

  #define HEDMA_CIER_CIE0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE1
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE1_MASK                 (0x00000002)
  #define HEDMA_CIER_CIE1_SHIFT                (0x00000001)
  
  #define HEDMA_CIER_CIE1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE1)

  #define HEDMA_CIER_CIE1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE2
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE2_MASK                 (0x00000004)
  #define HEDMA_CIER_CIE2_SHIFT                (0x00000002)
  
  #define HEDMA_CIER_CIE2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE2)

  #define HEDMA_CIER_CIE2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE3
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE3_MASK                 (0x00000008)
  #define HEDMA_CIER_CIE3_SHIFT                (0x00000003)
  
  #define HEDMA_CIER_CIE3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE3)

  #define HEDMA_CIER_CIE3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE4
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE4_MASK                 (0x00000010)
  #define HEDMA_CIER_CIE4_SHIFT                (0x00000004)
  
  #define HEDMA_CIER_CIE4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE4)

  #define HEDMA_CIER_CIE4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE5
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE5_MASK                 (0x00000020)
  #define HEDMA_CIER_CIE5_SHIFT                (0x00000005)
  
  #define HEDMA_CIER_CIE5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE5)

  #define HEDMA_CIER_CIE5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE6
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE6_MASK                 (0x00000040)
  #define HEDMA_CIER_CIE6_SHIFT                (0x00000006)
  
  #define HEDMA_CIER_CIE6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE6)

  #define HEDMA_CIER_CIE6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE7
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE7_MASK                 (0x00000080)
  #define HEDMA_CIER_CIE7_SHIFT                (0x00000007)
  
  #define HEDMA_CIER_CIE7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE7)

  #define HEDMA_CIER_CIE7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE8
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE8_MASK                 (0x00000100)
  #define HEDMA_CIER_CIE8_SHIFT                (0x00000008)
  
  #define HEDMA_CIER_CIE8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE8)

  #define HEDMA_CIER_CIE8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE9
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE9_MASK                 (0x00000200)
  #define HEDMA_CIER_CIE9_SHIFT                (0x00000009)
  
  #define HEDMA_CIER_CIE9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE9)

  #define HEDMA_CIER_CIE9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE10
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE10_MASK                (0x00000400)
  #define HEDMA_CIER_CIE10_SHIFT               (0x0000000A)
  
  #define HEDMA_CIER_CIE10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE10)

  #define HEDMA_CIER_CIE10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE11
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE11_MASK                (0x00000800)
  #define HEDMA_CIER_CIE11_SHIFT               (0x0000000B)
  
  #define HEDMA_CIER_CIE11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE11)

  #define HEDMA_CIER_CIE11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE12
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE12_MASK                (0x00001000)
  #define HEDMA_CIER_CIE12_SHIFT               (0x0000000C)
  
  #define HEDMA_CIER_CIE12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE12)

  #define HEDMA_CIER_CIE12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE13
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE13_MASK                (0x00002000)
  #define HEDMA_CIER_CIE13_SHIFT               (0x0000000D)
  
  #define HEDMA_CIER_CIE13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE13)

  #define HEDMA_CIER_CIE13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE14
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE14_MASK                (0x00004000)
  #define HEDMA_CIER_CIE14_SHIFT               (0x0000000E)
  
  #define HEDMA_CIER_CIE14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE14)

  #define HEDMA_CIER_CIE14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER_CIE15
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_CIE15_MASK                (0x00008000)
  #define HEDMA_CIER_CIE15_SHIFT               (0x0000000F)
  
  #define HEDMA_CIER_CIE15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CIER_CIE15)

  #define HEDMA_CIER_CIE15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CIER_CIE15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CIER
\*----------------------------------------------------------------------------*/
  #define HEDMA_CIER_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_CIER_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_CIER_CFG(RegAddr,cie0,cie1,cie2,cie3,cie4,cie5,cie6,cie7,\
  cie8,cie9,cie10,cie11,cie12,cie13,cie14,cie15) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_CIER_CIE0,cie0)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE1,cie1)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE2,cie2)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE3,cie3)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE4,cie4)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE5,cie5)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE6,cie6)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE7,cie7)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE8,cie8)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE9,cie9)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE10,cie10)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE11,cie11)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE12,cie12)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE13,cie13)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE14,cie14)|\
    HFIELD_SHIFT(HEDMA_CIER_CIE15,cie15)\
  )

/******************************************************************************\
* HEDMA_CCER - channel chain enable register
*
* Fields:
*   (RW) HEDMA_CCER_CCE8
*   (RW) HEDMA_CCER_CCE9
*   (RW) HEDMA_CCER_CCE10
*   (RW) HEDMA_CCER_CCE11
*
\******************************************************************************/
  #define HEDMA_CCER_ADDR                      (HEDMA_BASE0_ADDR+0xFFEC)
  #define HEDMA_CCER                           REG32(HEDMA_CCER_ADDR)
  
/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CCER_CCE8
\*----------------------------------------------------------------------------*/
  #define HEDMA_CCER_CCE8_MASK                 (0x00000100)
  #define HEDMA_CCER_CCE8_SHIFT                (0x00000008)
  
  #define HEDMA_CCER_CCE8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CCER_CCE8)

  #define HEDMA_CCER_CCE8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CCER_CCE8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CCER_CCE9
\*----------------------------------------------------------------------------*/
  #define HEDMA_CCER_CCE9_MASK                 (0x00000200)
  #define HEDMA_CCER_CCE9_SHIFT                (0x00000009)
  
  #define HEDMA_CCER_CCE9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CCER_CCE9)

  #define HEDMA_CCER_CCE9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CCER_CCE9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CCER_CCE10
\*----------------------------------------------------------------------------*/
  #define HEDMA_CCER_CCE10_MASK                (0x00000400)
  #define HEDMA_CCER_CCE10_SHIFT               (0x0000000A)
  
  #define HEDMA_CCER_CCE10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CCER_CCE10)

  #define HEDMA_CCER_CCE10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CCER_CCE10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CCER_CCE11
\*----------------------------------------------------------------------------*/
  #define HEDMA_CCER_CCE11_MASK                (0x00000800)
  #define HEDMA_CCER_CCE11_SHIFT               (0x0000000B)
  
  #define HEDMA_CCER_CCE11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_CCER_CCE11)

  #define HEDMA_CCER_CCE11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_CCER_CCE11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_CCER
\*----------------------------------------------------------------------------*/
  #define HEDMA_CCER_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_CCER_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_CCER_CFG(RegAddr,cce8,cce9,cce10,cce11)\
  REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_CCER_CCE8,cce8)|\
    HFIELD_SHIFT(HEDMA_CCER_CCE9,cce9)|\
    HFIELD_SHIFT(HEDMA_CCER_CCE10,cce10)|\
    HFIELD_SHIFT(HEDMA_CCER_CCE11,cce11)\
  )

/******************************************************************************\
* HEDMA_ER   - event register
*
* Fields:
*   (R) HEDMA_ER_EVT0
*   (R) HEDMA_ER_EVT1
*   (R) HEDMA_ER_EVT2
*   (R) HEDMA_ER_EVT3
*   (R) HEDMA_ER_EVT4
*   (R) HEDMA_ER_EVT5
*   (R) HEDMA_ER_EVT6
*   (R) HEDMA_ER_EVT7
*   (R) HEDMA_ER_EVT8
*   (R) HEDMA_ER_EVT9
*   (R) HEDMA_ER_EVT10
*   (R) HEDMA_ER_EVT11
*   (R) HEDMA_ER_EVT12
*   (R) HEDMA_ER_EVT13
*   (R) HEDMA_ER_EVT14
*   (R) HEDMA_ER_EVT15
*
\******************************************************************************/
  #define HEDMA_ER_ADDR                        (HEDMA_BASE0_ADDR+0xFFF0)
  #define HEDMA_ER                             REG32(HEDMA_ER_ADDR)
  
/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT0
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT0_MASK                 (0x00000001)
  #define HEDMA_ER_EVT0_SHIFT                (0x00000000)
  
  #define HEDMA_ER_EVT0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT0)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT1
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT1_MASK                 (0x00000002)
  #define HEDMA_ER_EVT1_SHIFT                (0x00000001)
  
  #define HEDMA_ER_EVT1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT1)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT2
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT2_MASK                 (0x00000004)
  #define HEDMA_ER_EVT2_SHIFT                (0x00000002)
  
  #define HEDMA_ER_EVT2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT2)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT3
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT3_MASK                 (0x00000008)
  #define HEDMA_ER_EVT3_SHIFT                (0x00000003)
  
  #define HEDMA_ER_EVT3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT3)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT4
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT4_MASK                 (0x00000010)
  #define HEDMA_ER_EVT4_SHIFT                (0x00000004)
  
  #define HEDMA_ER_EVT4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT4)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT5
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT5_MASK                 (0x00000020)
  #define HEDMA_ER_EVT5_SHIFT                (0x00000005)
  
  #define HEDMA_ER_EVT5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT5)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT6
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT6_MASK                 (0x00000040)
  #define HEDMA_ER_EVT6_SHIFT                (0x00000006)
  
  #define HEDMA_ER_EVT6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT6)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT7
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT7_MASK                 (0x00000080)
  #define HEDMA_ER_EVT7_SHIFT                (0x00000007)
  
  #define HEDMA_ER_EVT7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT7)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT8
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT8_MASK                 (0x00000100)
  #define HEDMA_ER_EVT8_SHIFT                (0x00000008)
  
  #define HEDMA_ER_EVT8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT8)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT9
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT9_MASK                 (0x00000200)
  #define HEDMA_ER_EVT9_SHIFT                (0x00000009)
  
  #define HEDMA_ER_EVT9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT9)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT10
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT10_MASK                (0x00000400)
  #define HEDMA_ER_EVT10_SHIFT               (0x0000000A)
  
  #define HEDMA_ER_EVT10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT10)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT11
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT11_MASK                (0x00000800)
  #define HEDMA_ER_EVT11_SHIFT               (0x0000000B)
  
  #define HEDMA_ER_EVT11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT11)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT12
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT12_MASK                (0x00001000)
  #define HEDMA_ER_EVT12_SHIFT               (0x0000000C)
  
  #define HEDMA_ER_EVT12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT12)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT13
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT13_MASK                (0x00002000)
  #define HEDMA_ER_EVT13_SHIFT               (0x0000000D)
  
  #define HEDMA_ER_EVT13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT13)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT14
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT14_MASK                (0x00004000)
  #define HEDMA_ER_EVT14_SHIFT               (0x0000000E)
  
  #define HEDMA_ER_EVT14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT14)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER_EVT15
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_EVT15_MASK                (0x00008000)
  #define HEDMA_ER_EVT15_SHIFT               (0x0000000F)
  
  #define HEDMA_ER_EVT15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ER_EVT15)

/*----------------------------------------------------------------------------*\
* (R) HEDMA_ER
\*----------------------------------------------------------------------------*/
  #define HEDMA_ER_GET(RegAddr) HREG32_GET(RegAddr)

/******************************************************************************\
* HEDMA_EER  - event enable register
*
* Fields:
*   (RW) HEDMA_EER_EE0
*   (RW) HEDMA_EER_EE1
*   (RW) HEDMA_EER_EE2
*   (RW) HEDMA_EER_EE3
*   (RW) HEDMA_EER_EE4
*   (RW) HEDMA_EER_EE5
*   (RW) HEDMA_EER_EE6
*   (RW) HEDMA_EER_EE7
*   (RW) HEDMA_EER_EE8
*   (RW) HEDMA_EER_EE9
*   (RW) HEDMA_EER_EE10
*   (RW) HEDMA_EER_EE11
*   (RW) HEDMA_EER_EE12
*   (RW) HEDMA_EER_EE13
*   (RW) HEDMA_EER_EE14
*   (RW) HEDMA_EER_EE15
*
\******************************************************************************/
  #define HEDMA_EER_ADDR                       (HEDMA_BASE0_ADDR+0xFFF4)
  #define HEDMA_EER                            REG32(HEDMA_EER_ADDR)
  
/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE0
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE0_MASK                 (0x00000001)
  #define HEDMA_EER_EE0_SHIFT                (0x00000000)
  
  #define HEDMA_EER_EE0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE0)

  #define HEDMA_EER_EE0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE1
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE1_MASK                 (0x00000002)
  #define HEDMA_EER_EE1_SHIFT                (0x00000001)
  
  #define HEDMA_EER_EE1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE1)

  #define HEDMA_EER_EE1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE2
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE2_MASK                 (0x00000004)
  #define HEDMA_EER_EE2_SHIFT                (0x00000002)
  
  #define HEDMA_EER_EE2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE2)

  #define HEDMA_EER_EE2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE3
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE3_MASK                 (0x00000008)
  #define HEDMA_EER_EE3_SHIFT                (0x00000003)
  
  #define HEDMA_EER_EE3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE3)

  #define HEDMA_EER_EE3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE4
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE4_MASK                 (0x00000010)
  #define HEDMA_EER_EE4_SHIFT                (0x00000004)
  
  #define HEDMA_EER_EE4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE4)

  #define HEDMA_EER_EE4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE5
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE5_MASK                 (0x00000020)
  #define HEDMA_EER_EE5_SHIFT                (0x00000005)
  
  #define HEDMA_EER_EE5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE5)

  #define HEDMA_EER_EE5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE6
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE6_MASK                 (0x00000040)
  #define HEDMA_EER_EE6_SHIFT                (0x00000006)
  
  #define HEDMA_EER_EE6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE6)

  #define HEDMA_EER_EE6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE7
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE7_MASK                 (0x00000080)
  #define HEDMA_EER_EE7_SHIFT                (0x00000007)
  
  #define HEDMA_EER_EE7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE7)

  #define HEDMA_EER_EE7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE8
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE8_MASK                 (0x00000100)
  #define HEDMA_EER_EE8_SHIFT                (0x00000008)
  
  #define HEDMA_EER_EE8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE8)

  #define HEDMA_EER_EE8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE9
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE9_MASK                 (0x00000200)
  #define HEDMA_EER_EE9_SHIFT                (0x00000009)
  
  #define HEDMA_EER_EE9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE9)

  #define HEDMA_EER_EE9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE10
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE10_MASK                (0x00000400)
  #define HEDMA_EER_EE10_SHIFT               (0x0000000A)
  
  #define HEDMA_EER_EE10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE10)

  #define HEDMA_EER_EE10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE11
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE11_MASK                (0x00000800)
  #define HEDMA_EER_EE11_SHIFT               (0x0000000B)
  
  #define HEDMA_EER_EE11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE11)

  #define HEDMA_EER_EE11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE12
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE12_MASK                (0x00001000)
  #define HEDMA_EER_EE12_SHIFT               (0x0000000C)
  
  #define HEDMA_EER_EE12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE12)

  #define HEDMA_EER_EE12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE13
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE13_MASK                (0x00002000)
  #define HEDMA_EER_EE13_SHIFT               (0x0000000D)
  
  #define HEDMA_EER_EE13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE13)

  #define HEDMA_EER_EE13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE14
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE14_MASK                (0x00004000)
  #define HEDMA_EER_EE14_SHIFT               (0x0000000E)
  
  #define HEDMA_EER_EE14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE14)

  #define HEDMA_EER_EE14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER_EE15
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_EE15_MASK                (0x00008000)
  #define HEDMA_EER_EE15_SHIFT               (0x0000000F)
  
  #define HEDMA_EER_EE15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_EER_EE15)

  #define HEDMA_EER_EE15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_EER_EE15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_EER
\*----------------------------------------------------------------------------*/
  #define HEDMA_EER_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_EER_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_EER_CFG(RegAddr,ee0,ee1,ee2,ee3,ee4,ee5,ee6,ee7,\
  ee8,ee9,ee10,ee11,ee12,ee13,ee14,ee15) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_EER_EE0,ee0)|\
    HFIELD_SHIFT(HEDMA_EER_EE1,ee1)|\
    HFIELD_SHIFT(HEDMA_EER_EE2,ee2)|\
    HFIELD_SHIFT(HEDMA_EER_EE3,ee3)|\
    HFIELD_SHIFT(HEDMA_EER_EE4,ee4)|\
    HFIELD_SHIFT(HEDMA_EER_EE5,ee5)|\
    HFIELD_SHIFT(HEDMA_EER_EE6,ee6)|\
    HFIELD_SHIFT(HEDMA_EER_EE7,ee7)|\
    HFIELD_SHIFT(HEDMA_EER_EE8,ee8)|\
    HFIELD_SHIFT(HEDMA_EER_EE9,ee9)|\
    HFIELD_SHIFT(HEDMA_EER_EE10,ee10)|\
    HFIELD_SHIFT(HEDMA_EER_EE11,ee11)|\
    HFIELD_SHIFT(HEDMA_EER_EE12,ee12)|\
    HFIELD_SHIFT(HEDMA_EER_EE13,ee13)|\
    HFIELD_SHIFT(HEDMA_EER_EE14,ee14)|\
    HFIELD_SHIFT(HEDMA_EER_EE15,ee15)\
  )

/******************************************************************************\
* HEDMA_ECR  - event clear register
*
* Fields:
*   (RW) HEDMA_ECR_EC0
*   (RW) HEDMA_ECR_EC1
*   (RW) HEDMA_ECR_EC2
*   (RW) HEDMA_ECR_EC3
*   (RW) HEDMA_ECR_EC4
*   (RW) HEDMA_ECR_EC5
*   (RW) HEDMA_ECR_EC6
*   (RW) HEDMA_ECR_EC7
*   (RW) HEDMA_ECR_EC8
*   (RW) HEDMA_ECR_EC9
*   (RW) HEDMA_ECR_EC10
*   (RW) HEDMA_ECR_EC11
*   (RW) HEDMA_ECR_EC12
*   (RW) HEDMA_ECR_EC13
*   (RW) HEDMA_ECR_EC14
*   (RW) HEDMA_ECR_EC15
*
\******************************************************************************/
  #define HEDMA_ECR_ADDR                       (HEDMA_BASE0_ADDR+0xFFF8)
  #define HEDMA_ECR                            REG32(HEDMA_ECR_ADDR)
  
/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC0
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC0_MASK                 (0x00000001)
  #define HEDMA_ECR_EC0_SHIFT                (0x00000000)
  
  #define HEDMA_ECR_EC0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC0)

  #define HEDMA_ECR_EC0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC1
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC1_MASK                 (0x00000002)
  #define HEDMA_ECR_EC1_SHIFT                (0x00000001)
  
  #define HEDMA_ECR_EC1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC1)

  #define HEDMA_ECR_EC1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC2
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC2_MASK                 (0x00000004)
  #define HEDMA_ECR_EC2_SHIFT                (0x00000002)
  
  #define HEDMA_ECR_EC2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC2)

  #define HEDMA_ECR_EC2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC3
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC3_MASK                 (0x00000008)
  #define HEDMA_ECR_EC3_SHIFT                (0x00000003)
  
  #define HEDMA_ECR_EC3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC3)

  #define HEDMA_ECR_EC3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC4
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC4_MASK                 (0x00000010)
  #define HEDMA_ECR_EC4_SHIFT                (0x00000004)
  
  #define HEDMA_ECR_EC4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC4)

  #define HEDMA_ECR_EC4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC5
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC5_MASK                 (0x00000020)
  #define HEDMA_ECR_EC5_SHIFT                (0x00000005)
  
  #define HEDMA_ECR_EC5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC5)

  #define HEDMA_ECR_EC5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC6
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC6_MASK                 (0x00000040)
  #define HEDMA_ECR_EC6_SHIFT                (0x00000006)
  
  #define HEDMA_ECR_EC6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC6)

  #define HEDMA_ECR_EC6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC7
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC7_MASK                 (0x00000080)
  #define HEDMA_ECR_EC7_SHIFT                (0x00000007)
  
  #define HEDMA_ECR_EC7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC7)

  #define HEDMA_ECR_EC7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC8
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC8_MASK                 (0x00000100)
  #define HEDMA_ECR_EC8_SHIFT                (0x00000008)
  
  #define HEDMA_ECR_EC8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC8)

  #define HEDMA_ECR_EC8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC9
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC9_MASK                 (0x00000200)
  #define HEDMA_ECR_EC9_SHIFT                (0x00000009)
  
  #define HEDMA_ECR_EC9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC9)

  #define HEDMA_ECR_EC9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC10
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC10_MASK                (0x00000400)
  #define HEDMA_ECR_EC10_SHIFT               (0x0000000A)
  
  #define HEDMA_ECR_EC10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC10)

  #define HEDMA_ECR_EC10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC11
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC11_MASK                (0x00000800)
  #define HEDMA_ECR_EC11_SHIFT               (0x0000000B)
  
  #define HEDMA_ECR_EC11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC11)

  #define HEDMA_ECR_EC11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC12
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC12_MASK                (0x00001000)
  #define HEDMA_ECR_EC12_SHIFT               (0x0000000C)
  
  #define HEDMA_ECR_EC12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC12)

  #define HEDMA_ECR_EC12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC13
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC13_MASK                (0x00002000)
  #define HEDMA_ECR_EC13_SHIFT               (0x0000000D)
  
  #define HEDMA_ECR_EC13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC13)

  #define HEDMA_ECR_EC13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC14
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC14_MASK                (0x00004000)
  #define HEDMA_ECR_EC14_SHIFT               (0x0000000E)
  
  #define HEDMA_ECR_EC14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC14)

  #define HEDMA_ECR_EC14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR_EC15
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_EC15_MASK                (0x00008000)
  #define HEDMA_ECR_EC15_SHIFT               (0x0000000F)
  
  #define HEDMA_ECR_EC15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ECR_EC15)

  #define HEDMA_ECR_EC15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ECR_EC15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ECR
\*----------------------------------------------------------------------------*/
  #define HEDMA_ECR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_ECR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_ECR_CFG(RegAddr,ec0,ec1,ec2,ec3,ec4,ec5,ec6,ec7,\
  ec8,ec9,ec10,ec11,ec12,ec13,ec14,ec15) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_ECR_EC0,ec0)|\
    HFIELD_SHIFT(HEDMA_ECR_EC1,ec1)|\
    HFIELD_SHIFT(HEDMA_ECR_EC2,ec2)|\
    HFIELD_SHIFT(HEDMA_ECR_EC3,ec3)|\
    HFIELD_SHIFT(HEDMA_ECR_EC4,ec4)|\
    HFIELD_SHIFT(HEDMA_ECR_EC5,ec5)|\
    HFIELD_SHIFT(HEDMA_ECR_EC6,ec6)|\
    HFIELD_SHIFT(HEDMA_ECR_EC7,ec7)|\
    HFIELD_SHIFT(HEDMA_ECR_EC8,ec8)|\
    HFIELD_SHIFT(HEDMA_ECR_EC9,ec9)|\
    HFIELD_SHIFT(HEDMA_ECR_EC10,ec10)|\
    HFIELD_SHIFT(HEDMA_ECR_EC11,ec11)|\
    HFIELD_SHIFT(HEDMA_ECR_EC12,ec12)|\
    HFIELD_SHIFT(HEDMA_ECR_EC13,ec13)|\
    HFIELD_SHIFT(HEDMA_ECR_EC14,ec14)|\
    HFIELD_SHIFT(HEDMA_ECR_EC15,ec15)\
  )
                     
/******************************************************************************\
* HEDMA_ESR  - event set register
*
* Fields:
*   (RW) HEDMA_ESR_ES0
*   (RW) HEDMA_ESR_ES1
*   (RW) HEDMA_ESR_ES2
*   (RW) HEDMA_ESR_ES3
*   (RW) HEDMA_ESR_ES4
*   (RW) HEDMA_ESR_ES5
*   (RW) HEDMA_ESR_ES6
*   (RW) HEDMA_ESR_ES7
*   (RW) HEDMA_ESR_ES8
*   (RW) HEDMA_ESR_ES9
*   (RW) HEDMA_ESR_ES10
*   (RW) HEDMA_ESR_ES11
*   (RW) HEDMA_ESR_ES12
*   (RW) HEDMA_ESR_ES13
*   (RW) HEDMA_ESR_ES14
*   (RW) HEDMA_ESR_ES15
*
\******************************************************************************/
  #define HEDMA_ESR_ADDR                       (HEDMA_BASE0_ADDR+0xFFFC)
  #define HEDMA_ESR                            REG32(HEDMA_ESR_ADDR)
  
/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES0
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES0_MASK                 (0x00000001)
  #define HEDMA_ESR_ES0_SHIFT                (0x00000000)
  
  #define HEDMA_ESR_ES0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES0)

  #define HEDMA_ESR_ES0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES1
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES1_MASK                 (0x00000002)
  #define HEDMA_ESR_ES1_SHIFT                (0x00000001)
  
  #define HEDMA_ESR_ES1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES1)

  #define HEDMA_ESR_ES1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES2
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES2_MASK                 (0x00000004)
  #define HEDMA_ESR_ES2_SHIFT                (0x00000002)
  
  #define HEDMA_ESR_ES2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES2)

  #define HEDMA_ESR_ES2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES3
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES3_MASK                 (0x00000008)
  #define HEDMA_ESR_ES3_SHIFT                (0x00000003)
  
  #define HEDMA_ESR_ES3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES3)

  #define HEDMA_ESR_ES3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES4
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES4_MASK                 (0x00000010)
  #define HEDMA_ESR_ES4_SHIFT                (0x00000004)
  
  #define HEDMA_ESR_ES4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES4)

  #define HEDMA_ESR_ES4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES5
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES5_MASK                 (0x00000020)
  #define HEDMA_ESR_ES5_SHIFT                (0x00000005)
  
  #define HEDMA_ESR_ES5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES5)

  #define HEDMA_ESR_ES5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES6
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES6_MASK                 (0x00000040)
  #define HEDMA_ESR_ES6_SHIFT                (0x00000006)
  
  #define HEDMA_ESR_ES6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES6)

  #define HEDMA_ESR_ES6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES7
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES7_MASK                 (0x00000080)
  #define HEDMA_ESR_ES7_SHIFT                (0x00000007)
  
  #define HEDMA_ESR_ES7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES7)

  #define HEDMA_ESR_ES7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES8
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES8_MASK                 (0x00000100)
  #define HEDMA_ESR_ES8_SHIFT                (0x00000008)
  
  #define HEDMA_ESR_ES8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES8)

  #define HEDMA_ESR_ES8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES9
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES9_MASK                 (0x00000200)
  #define HEDMA_ESR_ES9_SHIFT                (0x00000009)
  
  #define HEDMA_ESR_ES9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES9)

  #define HEDMA_ESR_ES9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES10
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES10_MASK                (0x00000400)
  #define HEDMA_ESR_ES10_SHIFT               (0x0000000A)
  
  #define HEDMA_ESR_ES10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES10)

  #define HEDMA_ESR_ES10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES11
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES11_MASK                (0x00000800)
  #define HEDMA_ESR_ES11_SHIFT               (0x0000000B)
  
  #define HEDMA_ESR_ES11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES11)

  #define HEDMA_ESR_ES11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES12
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES12_MASK                (0x00001000)
  #define HEDMA_ESR_ES12_SHIFT               (0x0000000C)
  
  #define HEDMA_ESR_ES12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES12)

  #define HEDMA_ESR_ES12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES13
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES13_MASK                (0x00002000)
  #define HEDMA_ESR_ES13_SHIFT               (0x0000000D)
  
  #define HEDMA_ESR_ES13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES13)

  #define HEDMA_ESR_ES13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES14
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES14_MASK                (0x00004000)
  #define HEDMA_ESR_ES14_SHIFT               (0x0000000E)
  
  #define HEDMA_ESR_ES14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES14)

  #define HEDMA_ESR_ES14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR_ES15
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_ES15_MASK                (0x00008000)
  #define HEDMA_ESR_ES15_SHIFT               (0x0000000F)
  
  #define HEDMA_ESR_ES15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEDMA_ESR_ES15)

  #define HEDMA_ESR_ES15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEDMA_ESR_ES15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEDMA_ESR
\*----------------------------------------------------------------------------*/
  #define HEDMA_ESR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEDMA_ESR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEDMA_ESR_CFG(RegAddr,es0,es1,es2,es3,es4,es5,es6,es7,\
  es8,es9,es10,es11,es12,es13,es14,es15) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEDMA_ESR_ES0,es0)|\
    HFIELD_SHIFT(HEDMA_ESR_ES1,es1)|\
    HFIELD_SHIFT(HEDMA_ESR_ES2,es2)|\
    HFIELD_SHIFT(HEDMA_ESR_ES3,es3)|\
    HFIELD_SHIFT(HEDMA_ESR_ES4,es4)|\
    HFIELD_SHIFT(HEDMA_ESR_ES5,es5)|\
    HFIELD_SHIFT(HEDMA_ESR_ES6,es6)|\
    HFIELD_SHIFT(HEDMA_ESR_ES7,es7)|\
    HFIELD_SHIFT(HEDMA_ESR_ES8,es8)|\
    HFIELD_SHIFT(HEDMA_ESR_ES9,es9)|\
    HFIELD_SHIFT(HEDMA_ESR_ES10,es10)|\
    HFIELD_SHIFT(HEDMA_ESR_ES11,es11)|\
    HFIELD_SHIFT(HEDMA_ESR_ES12,es12)|\
    HFIELD_SHIFT(HEDMA_ESR_ES13,es13)|\
    HFIELD_SHIFT(HEDMA_ESR_ES14,es14)|\
    HFIELD_SHIFT(HEDMA_ESR_ES15,es15)\
  )

/*----------------------------------------------------------------------------*/

#endif /* EDMA_SUPPORT */
#endif /* _EDMAHAL_H_ */
/******************************************************************************\
* End of edmahal.h
\******************************************************************************/
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... emifhal.h
* DATE CREATED.. 06/12/1999 
* LAST MODIFIED. 03/08/2000
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the EMIF module)
*
* Registers Covered:
*   (RW) HEMIF_GBLCTL - global control register
*   (RW) HEMIF_CE0CTL - chip-enable space 0 control register
*   (RW) HEMIF_CE1CTL - chip-enable space 1 control register
*   (RW) HEMIF_CE2CTL - chip-enable space 2 control register
*   (RW) HEMIF_CE3CTL - chip-enable space 3 control register
*   (RW) HEMIF_SDCTL  - SDRAM control register
*   (RW) HEMIF_SDTIM  - SDRAM timing register
*   (RW) HEMIF_SDEXT  - SDRAM extension register (1)
*
*   (1) Only available for C11_SUPPORT
*
\******************************************************************************/
#ifndef _EMIFHAL_H_
#define _EMIFHAL_H_

#if (EMIF_SUPPORT)
#define HEMIF_BASE_ADDR      (HCHIP_PERBASE_ADDR+0x00000000)

/******************************************************************************\
* HEMIF_GBLCTL - global control register
*
* Fields:
*   (R)  HEMIF_GBLCTL_MAP     (2)
*   (RW) HEMIF_GBLCTL_RBTR8   (2)
*   (RW) HEMIF_GBLCTL_SSCRT   (2)(3)
*   (RW) HEMIF_GBLCTL_CLK2EN  (3)
*   (RW) HEMIF_GBLCTL_CLK1EN
*   (RW) HEMIF_GBLCTL_SSCEN   (2)
*   (RW) HEMIF_GBLCTL_SDCEN   (2)
*   (RW) HEMIF_GBLCTL_NOHOLD
*   (R)  HEMIF_GBLCTL_HOLDA
*   (R)  HEMIF_GBLCTL_HOLD
*   (R)  HEMIF_GBLCTL_ARDY
*   (R)  HEMIF_GBLCTL_BUSREQ  (1)
*
*   (1) Field only exists for C11_SUPPORT
*   (2) Field does not exist for C11_SUPPORT
*   (3) Field does not exist for CHIP_6202, CHIP_6203
*
\******************************************************************************/
  #define HEMIF_GBLCTL_ADDR                    (HEMIF_BASE_ADDR+0x0000)
  #define HEMIF_GBLCTL                         REG32(HEMIF_GBLCTL_ADDR)

/*----------------------------------------------------------------------------*\
* (R) HEMIF_GBLCTL_MAP
\*----------------------------------------------------------------------------*/
#if !(C11_SUPPORT)
  #define HEMIF_GBLCTL_MAP_MASK                (0x00000001)
  #define HEMIF_GBLCTL_MAP_SHIFT               (0x00000000) 
#else
  #define HEMIF_GBLCTL_MAP_MASK                (0x00000000)
  #define HEMIF_GBLCTL_MAP_SHIFT               (0x00000000) 
#endif

  #define HEMIF_GBLCTL_MAP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_MAP)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_GBLCTL_RBTR8
\*----------------------------------------------------------------------------*/
#if !(C11_SUPPORT)
  #define HEMIF_GBLCTL_RBTR8_MASK              (0x00000002)
  #define HEMIF_GBLCTL_RBTR8_SHIFT             (0x00000001) 
#else
  #define HEMIF_GBLCTL_RBTR8_MASK              (0x00000000)
  #define HEMIF_GBLCTL_RBTR8_SHIFT             (0x00000000) 
#endif

  #define HEMIF_GBLCTL_RBTR8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_RBTR8)

  #define HEMIF_GBLCTL_RBTR8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_GBLCTL_RBTR8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_GBLCTL_SSCRT
\*----------------------------------------------------------------------------*/
#if !(CHIP_6202|CHIP_6203|C11_SUPPORT)
  #define HEMIF_GBLCTL_SSCRT_MASK              (0x00000004)
  #define HEMIF_GBLCTL_SSCRT_SHIFT             (0x00000002)
#else
  #define HEMIF_GBLCTL_SSCRT_MASK              (0x00000000)
  #define HEMIF_GBLCTL_SSCRT_SHIFT             (0x00000000)
#endif

  #define HEMIF_GBLCTL_SSCRT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_SSCRT)

  #define HEMIF_GBLCTL_SSCRT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_GBLCTL_SSCRT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_GBLCTL_CLK2EN
\*----------------------------------------------------------------------------*/
#if !(CHIP_6202|CHIP_6203)
  #define HEMIF_GBLCTL_CLK2EN_MASK             (0x00000008)
  #define HEMIF_GBLCTL_CLK2EN_SHIFT            (0x00000003)
#else
  #define HEMIF_GBLCTL_CLK2EN_MASK             (0x00000000)
  #define HEMIF_GBLCTL_CLK2EN_SHIFT            (0x00000000)
#endif

  #define HEMIF_GBLCTL_CLK2EN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_CLK2EN)

  #define HEMIF_GBLCTL_CLK2EN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_GBLCTL_CLK2EN,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_GBLCTL_CLK1EN
\*----------------------------------------------------------------------------*/
  #define HEMIF_GBLCTL_CLK1EN_MASK             (0x00000010)
  #define HEMIF_GBLCTL_CLK1EN_SHIFT            (0x00000004)

  #define HEMIF_GBLCTL_CLK1EN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_CLK1EN)

  #define HEMIF_GBLCTL_CLK1EN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_GBLCTL_CLK1EN,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_GBLCTL_SSCEN
\*----------------------------------------------------------------------------*/
#if !(C11_SUPPORT)
  #define HEMIF_GBLCTL_SSCEN_MASK              (0x00000020)
  #define HEMIF_GBLCTL_SSCEN_SHIFT             (0x00000005)
#else
  #define HEMIF_GBLCTL_SSCEN_MASK              (0x00000000)
  #define HEMIF_GBLCTL_SSCEN_SHIFT             (0x00000000)
#endif

  #define HEMIF_GBLCTL_SSCEN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_SSCEN)

  #define HEMIF_GBLCTL_SSCEN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_GBLCTL_SSCEN,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_GBLCTL_SDCEN
\*----------------------------------------------------------------------------*/
#if !(C11_SUPPORT)
  #define HEMIF_GBLCTL_SDCEN_MASK              (0x00000040)
  #define HEMIF_GBLCTL_SDCEN_SHIFT             (0x00000006)
#else
  #define HEMIF_GBLCTL_SDCEN_MASK              (0x00000000)
  #define HEMIF_GBLCTL_SDCEN_SHIFT             (0x00000000)
#endif

  #define HEMIF_GBLCTL_SDCEN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_SDCEN)

  #define HEMIF_GBLCTL_SDCEN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_GBLCTL_SDCEN,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_GBLCTL_NOHOLD
\*----------------------------------------------------------------------------*/
  #define HEMIF_GBLCTL_NOHOLD_MASK             (0x00000080)
  #define HEMIF_GBLCTL_NOHOLD_SHIFT            (0x00000007)

  #define HEMIF_GBLCTL_NOHOLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_NOHOLD)

  #define HEMIF_GBLCTL_NOHOLD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_GBLCTL_NOHOLD,Val)

/*----------------------------------------------------------------------------*\
* (R) HEMIF_GBLCTL_HOLDA
\*----------------------------------------------------------------------------*/
  #define HEMIF_GBLCTL_HOLDA_MASK              (0x00000100)
  #define HEMIF_GBLCTL_HOLDA_SHIFT             (0x00000008)
  
  #define HEMIF_GBLCTL_HOLDA_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_HOLDA)

/*----------------------------------------------------------------------------*\
* (R) HEMIF_GBLCTL_HOLD
\*----------------------------------------------------------------------------*/
  #define HEMIF_GBLCTL_HOLD_MASK               (0x00000200)
  #define HEMIF_GBLCTL_HOLD_SHIFT              (0x00000009)
  
  #define HEMIF_GBLCTL_HOLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_HOLD)

/*----------------------------------------------------------------------------*\
* (R) HEMIF_GBLCTL_ARDY
\*----------------------------------------------------------------------------*/
  #define HEMIF_GBLCTL_ARDY_MASK               (0x00000400)
  #define HEMIF_GBLCTL_ARDY_SHIFT              (0x0000000A)
  
  #define HEMIF_GBLCTL_ARDY_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_ARDY)

/*----------------------------------------------------------------------------*\
* (R) HEMIF_GBLCTL_BUSREQ
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_GBLCTL_BUSREQ_MASK             (0x00000800)
  #define HEMIF_GBLCTL_BUSREQ_SHIFT            (0x0000000B)
#else
  #define HEMIF_GBLCTL_BUSREQ_MASK             (0x00000000)
  #define HEMIF_GBLCTL_BUSREQ_SHIFT            (0x00000000)
#endif

  #define HEMIF_GBLCTL_BUSREQ_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_GBLCTL_BUSREQ)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_GBLCTL
\*----------------------------------------------------------------------------*/
  #define HEMIF_GBLCTL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEMIF_GBLCTL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
  
  #define HEMIF_GBLCTL_CFG(RegAddr,rbtr8,sscrt,clk2en,clk1en,sscen,sdcen,\
  nohold) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HEMIF_GBLCTL_RBTR8,rbtr8)|\
    HFIELD_SHIFT(HEMIF_GBLCTL_SSCRT,sscrt)|\
    HFIELD_SHIFT(HEMIF_GBLCTL_CLK2EN,clk2en)|\
    HFIELD_SHIFT(HEMIF_GBLCTL_CLK1EN,clk1en)|\
    HFIELD_SHIFT(HEMIF_GBLCTL_SSCEN,sscen)|\
    HFIELD_SHIFT(HEMIF_GBLCTL_SDCEN,sdcen)|\
    HFIELD_SHIFT(HEMIF_GBLCTL_NOHOLD,nohold)|\
    0x00003000 \
  )

/*----------------------------------------------------------------------------*/

/******************************************************************************\
* HEMIF_CE0CTL - chip-enable space 0 control register
* HEMIF_CE1CTL - chip-enable space 1 control register
* HEMIF_CE2CTL - chip-enable space 2 control register
* HEMIF_CE3CTL - chip-enable space 3 control register
*
* Fields:
*   (RW) HEMIF_CECTL_RDHLD
*   (RW) HEMIF_CECTL_WRHLDMSB (1)
*   (RW) HEMIF_CECTL_MTYPE
*   (RW) HEMIF_CECTL_RDSTRB
*   (RW) HEMIF_CECTL_TA       (1)
*   (RW) HEMIF_CECTL_RDSETUP
*   (RW) HEMIF_CECTL_WRHLD
*   (RW) HEMIF_CECTL_WRSTRB
*   (RW) HEMIF_CECTL_WRSETUP
*
*   (1) Field only exists for C11_SUPPORT
*
\******************************************************************************/
  #define HEMIF_CE0CTL_ADDR                    (HEMIF_BASE_ADDR+0x0008)
  #define HEMIF_CE1CTL_ADDR                    (HEMIF_BASE_ADDR+0x0004)
  #define HEMIF_CE2CTL_ADDR                    (HEMIF_BASE_ADDR+0x0010)
  #define HEMIF_CE3CTL_ADDR                    (HEMIF_BASE_ADDR+0x0014)

  #define HEMIF_CE0CTL                         REG32(HEMIF_CE0CTL_ADDR)
  #define HEMIF_CE1CTL                         REG32(HEMIF_CE1CTL_ADDR)
  #define HEMIF_CE2CTL                         REG32(HEMIF_CE2CTL_ADDR)
  #define HEMIF_CE3CTL                         REG32(HEMIF_CE3CTL_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_RDHLD
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_CECTL_RDHLD_MASK               (0x00000007)
  #define HEMIF_CECTL_RDHLD_SHIFT              (0x00000000)
#elif (C01_SUPPORT)
  #define HEMIF_CECTL_RDHLD_MASK               (0x00000003)
  #define HEMIF_CECTL_RDHLD_SHIFT              (0x00000000)
#endif

  #define HEMIF_CECTL_RDHLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_RDHLD)

  #define HEMIF_CECTL_RDHLD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_RDHLD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_WRHLDMSB
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)  
  #define HEMIF_CECTL_WRHLDMSB_MASK            (0x00000008)
  #define HEMIF_CECTL_WRHLDMSB_SHIFT           (0x00000003)
#else
  #define HEMIF_CECTL_WRHLDMSB_MASK            (0x00000000)
  #define HEMIF_CECTL_WRHLDMSB_SHIFT           (0x00000000)
#endif

  #define HEMIF_CECTL_WRHLDMSB_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_WRHLDMSB)

  #define HEMIF_CECTL_WRHLDMSB_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_WRHLDMSB,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_MTYPE
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_CECTL_MTYPE_MASK               (0x000000F0)
  #define HEMIF_CECTL_MTYPE_SHIFT              (0x00000004)
#elif (C01_SUPPORT)
  #define HEMIF_CECTL_MTYPE_MASK               (0x00000070)
  #define HEMIF_CECTL_MTYPE_SHIFT              (0x00000004)
#else
  #define HEMIF_CECTL_MTYPE_MASK               (0x00000000)
  #define HEMIF_CECTL_MTYPE_SHIFT              (0x00000000)
#endif

  #define HEMIF_CECTL_MTYPE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_MTYPE)

  #define HEMIF_CECTL_MTYPE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_MTYPE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_RDSTRB
\*----------------------------------------------------------------------------*/
  #define HEMIF_CECTL_RDSTRB_MASK              (0x00003F00)
  #define HEMIF_CECTL_RDSTRB_SHIFT             (0x00000008)
  
  #define HEMIF_CECTL_RDSTRB_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_RDSTRB)

  #define HEMIF_CECTL_RDSTRB_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_RDSTRB,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_TA
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_CECTL_TA_MASK                  (0x0000C000)
  #define HEMIF_CECTL_TA_SHIFT                 (0x0000000E)
#else
  #define HEMIF_CECTL_TA_MASK                  (0x00000000)
  #define HEMIF_CECTL_TA_SHIFT                 (0x00000000)
#endif

  #define HEMIF_CECTL_TA_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_TA)

  #define HEMIF_CECTL_TA_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_TA,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_RDSETUP
\*----------------------------------------------------------------------------*/
  #define HEMIF_CECTL_RDSETUP_MASK             (0x000F0000)
  #define HEMIF_CECTL_RDSETUP_SHIFT            (0x00000010)

  #define HEMIF_CECTL_RDSETUP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_RDSETUP)

  #define HEMIF_CECTL_RDSETUP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_RDSETUP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_WRHLD
\*----------------------------------------------------------------------------*/
  #define HEMIF_CECTL_WRHLD_MASK               (0x00300000)
  #define HEMIF_CECTL_WRHLD_SHIFT              (0x00000014)
  
  #define HEMIF_CECTL_WRHLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_WRHLD)

  #define HEMIF_CECTL_WRHLD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_WRHLD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_WRSTRB
\*----------------------------------------------------------------------------*/
  #define HEMIF_CECTL_WRSTRB_MASK              (0x0FC00000)
  #define HEMIF_CECTL_WRSTRB_SHIFT             (0x00000016)

  #define HEMIF_CECTL_WRSTRB_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_WRSTRB)

  #define HEMIF_CECTL_WRSTRB_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_WRSTRB,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL_WRSETUP
\*----------------------------------------------------------------------------*/
  #define HEMIF_CECTL_WRSETUP_MASK             (0xF0000000)
  #define HEMIF_CECTL_WRSETUP_SHIFT            (0x0000001C)

  #define HEMIF_CECTL_WRSETUP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_CECTL_WRSETUP)

  #define HEMIF_CECTL_WRSETUP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_CECTL_WRSETUP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_CECTL
\*----------------------------------------------------------------------------*/
  #define HEMIF_CECTL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEMIF_CECTL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
  
  #define HEMIF_CECTL_CFG(RegAddr,rdhld,wrhldmsb,mtype,rdstrb,ta,\
  rdsetup,wrhld,wrstrb,wrsetup) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HEMIF_CECTL_RDHLD,rdhld)|\
    HFIELD_SHIFT(HEMIF_CECTL_WRHLDMSB,wrhldmsb)|\
    HFIELD_SHIFT(HEMIF_CECTL_MTYPE,mtype)|\
    HFIELD_SHIFT(HEMIF_CECTL_RDSTRB,rdstrb)|\
    HFIELD_SHIFT(HEMIF_CECTL_TA,ta)|\
    HFIELD_SHIFT(HEMIF_CECTL_RDSETUP,rdsetup)|\
    HFIELD_SHIFT(HEMIF_CECTL_WRHLD,wrhld)|\
    HFIELD_SHIFT(HEMIF_CECTL_WRSTRB,wrstrb)|\
    HFIELD_SHIFT(HEMIF_CECTL_WRSETUP,wrsetup)\
  )

/******************************************************************************\
* HEMIF_SDCTL - SDRAM control register
*
* Fields:
*   (RW) HEMIF_SDCTL_TRC
*   (RW) HEMIF_SDCTL_TRP
*   (RW) HEMIF_SDCTL_TRCD
*   (W)  HEMIF_SDCTL_INIT
*   (RW) HEMIF_SDCTL_RFEN
*   (RW) HEMIF_SDCTL_SDWID (1)
*   (RW) HEMIF_SDCTL_SDCSZ (2)
*   (RW) HEMIF_SDCTL_SDRSZ (2)
*   (RW) HEMIF_SDCTL_SDBSZ (2)
*
*   (1) Field only exists for C01_SUPPORT
*   (2) Field only exists for C11_SUPPORT
*
\******************************************************************************/
  #define HEMIF_SDCTL_ADDR                     (HEMIF_BASE_ADDR+0x0018)
  #define HEMIF_SDCTL                          REG32(HEMIF_SDCTL_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL_TRC
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDCTL_TRC_MASK                 (0x0000F000)
  #define HEMIF_SDCTL_TRC_SHIFT                (0x0000000C)
  
  #define HEMIF_SDCTL_TRC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDCTL_TRC)

  #define HEMIF_SDCTL_TRC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_TRC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL_TRP
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDCTL_TRP_MASK                 (0x000F0000)
  #define HEMIF_SDCTL_TRP_SHIFT                (0x00000010)

  #define HEMIF_SDCTL_TRP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDCTL_TRP)

  #define HEMIF_SDCTL_TRP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_TRP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL_TRCD
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDCTL_TRCD_MASK                (0x00F00000)
  #define HEMIF_SDCTL_TRCD_SHIFT               (0x00000014)

  #define HEMIF_SDCTL_TRCD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDCTL_TRCD)

  #define HEMIF_SDCTL_TRCD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_TRCD,Val)

/*----------------------------------------------------------------------------*\
* (W) HEMIF_SDCTL_INIT
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDCTL_INIT_MASK                (0x01000000)
  #define HEMIF_SDCTL_INIT_SHIFT               (0x00000018)

  #define HEMIF_SDCTL_INIT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_INIT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL_RFEN
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDCTL_RFEN_MASK                (0x02000000)
  #define HEMIF_SDCTL_RFEN_SHIFT               (0x00000019) 

  #define HEMIF_SDCTL_RFEN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDCTL_RFEN)

  #define HEMIF_SDCTL_RFEN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_RFEN,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL_SDWID
\*----------------------------------------------------------------------------*/
#if (C01_SUPPORT)
  #define HEMIF_SDCTL_SDWID_MASK               (0x04000000)
  #define HEMIF_SDCTL_SDWID_SHIFT              (0x0000001A)
#else
  #define HEMIF_SDCTL_SDWID_MASK               (0x00000000)
  #define HEMIF_SDCTL_SDWID_SHIFT              (0x00000000)
#endif
  
  #define HEMIF_SDCTL_SDWID_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDCTL_SDWID)

  #define HEMIF_SDCTL_SDWID_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_SDWID,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL_SDCSZ
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDCTL_SDCSZ_MASK               (0x0C000000)
  #define HEMIF_SDCTL_SDCSZ_SHIFT              (0x0000001A)
#else
  #define HEMIF_SDCTL_SDCSZ_MASK               (0x00000000)
  #define HEMIF_SDCTL_SDCSZ_SHIFT              (0x00000000)
#endif
  
  #define HEMIF_SDCTL_SDCSZ_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDCTL_SDCSZ)

  #define HEMIF_SDCTL_SDCSZ_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_SDCSZ,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL_SDRSZ
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDCTL_SDRSZ_MASK               (0x30000000)
  #define HEMIF_SDCTL_SDRSZ_SHIFT              (0x0000001C)
#else
  #define HEMIF_SDCTL_SDRSZ_MASK               (0x00000000)
  #define HEMIF_SDCTL_SDRSZ_SHIFT              (0x00000000)
#endif
  
  #define HEMIF_SDCTL_SDRSZ_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDCTL_SDRSZ)

  #define HEMIF_SDCTL_SDRSZ_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_SDRSZ,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL_SDBSZ
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDCTL_SDBSZ_MASK               (0x40000000)
  #define HEMIF_SDCTL_SDBSZ_SHIFT              (0x0000001E)
#else
  #define HEMIF_SDCTL_SDBSZ_MASK               (0x00000000)
  #define HEMIF_SDCTL_SDBSZ_SHIFT              (0x00000000)
#endif
  
  #define HEMIF_SDCTL_SDBSZ_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDCTL_SDBSZ)

  #define HEMIF_SDCTL_SDBSZ_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDCTL_SDBSZ,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDCTL
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDCTL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEMIF_SDCTL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
  
  #define HEMIF_SDCTL_CFG(RegAddr,trc,trp,trcd,init,rfen,sdwid,\
  sdcsz,sdrsz,sdbsz) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HEMIF_SDCTL_TRC,trc)|\
    HFIELD_SHIFT(HEMIF_SDCTL_TRP,trp)|\
    HFIELD_SHIFT(HEMIF_SDCTL_TRCD,trcd)|\
    HFIELD_SHIFT(HEMIF_SDCTL_INIT,init)|\
    HFIELD_SHIFT(HEMIF_SDCTL_RFEN,rfen)|\
    HFIELD_SHIFT(HEMIF_SDCTL_SDWID,sdwid)|\
    HFIELD_SHIFT(HEMIF_SDCTL_SDCSZ,sdcsz)|\
    HFIELD_SHIFT(HEMIF_SDCTL_SDRSZ,sdrsz)|\
    HFIELD_SHIFT(HEMIF_SDCTL_SDBSZ,sdbsz)\
  )

/******************************************************************************\
* HEMIF_SDTIM - SDRAM timing register
*
* Fields:
*   (RW) HEMIF_SDTIM_PERIOD
*   (R)  HEMIF_SDTIM_CNTR
*   (RW) HEMIF_SDTIM_XRFR   (1)
*
*   (1) Field only exists for C11_SUPPORT
*
\******************************************************************************/
  #define HEMIF_SDTIM_ADDR                     (HEMIF_BASE_ADDR+0x001C)
  #define HEMIF_SDTIM                          REG32(HEMIF_SDTIM_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDTIM_PERIOD
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDTIM_PERIOD_MASK              (0x00000FFF)
  #define HEMIF_SDTIM_PERIOD_SHIFT             (0x00000000) 
  
  #define HEMIF_SDTIM_PERIOD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDTIM_PERIOD)

  #define HEMIF_SDTIM_PERIOD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDTIM_PERIOD,Val)

/*----------------------------------------------------------------------------*\
* (R) HEMIF_SDTIM_CNTR
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDTIM_CNTR_MASK                (0x00FFF000)
  #define HEMIF_SDTIM_CNTR_SHIFT               (0x0000000C)
  
  #define HEMIF_SDTIM_CNTR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDTIM_CNTR)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDTIM_XRFR
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDTIM_XRFR_MASK                (0x03000000)
  #define HEMIF_SDTIM_XRFR_SHIFT               (0x00000018)
#else
  #define HEMIF_SDTIM_XRFR_MASK                (0x00000000)
  #define HEMIF_SDTIM_XRFR_SHIFT               (0x00000000)
#endif

  #define HEMIF_SDTIM_XRFR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDTIM_XRFR)

  #define HEMIF_SDTIM_XRFR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDTIM_XRFR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDTIM
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDTIM_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEMIF_SDTIM_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEMIF_SDTIM_CFG(RegAddr,period,xrfr) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HEMIF_SDTIM_PERIOD,period)|\
    HFIELD_SHIFT(HEMIF_SDTIM_XRFR,xrfr)\
  )

/******************************************************************************\
* HEMIF_SDEXT - SDRAM extension register (1)
* (1) Only available for C11_SUPPORT
*
* Fields:
*   (RW) HEMIF_SDEXT_TCL
*   (RW) HEMIF_SDEXT_TRAS
*   (RW) HEMIF_SDEXT_TRRD
*   (RW) HEMIF_SDEXT_TWR
*   (RW) HEMIF_SDEXT_THZP
*   (RW) HEMIF_SDEXT_RD2RD
*   (RW) HEMIF_SDEXT_RD2DEAC
*   (RW) HEMIF_SDEXT_RD2WR
*   (RW) HEMIF_SDEXT_R2WDQM
*   (RW) HEMIF_SDEXT_WR2WR
*   (RW) HEMIF_SDEXT_WR2DEAC
*   (RW) HEMIF_SDEXT_WR2RD
*
\******************************************************************************/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_ADDR                     (HEMIF_BASE_ADDR+0x0020)
  #define HEMIF_SDEXT                          REG32(HEMIF_SDEXT_ADDR)
#else
  #define HEMIF_SDEXT_ADDR                     HCHIP_NULL_ADDR
  #define HEMIF_SDEXT                          REG32(HEMIF_SDEXT_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_TCL
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_TCL_MASK                 (0x00000001)
  #define HEMIF_SDEXT_TCL_SHIFT                (0x00000000)
#else
  #define HEMIF_SDEXT_TCL_MASK                 (0x00000000)
  #define HEMIF_SDEXT_TCL_SHIFT                (0x00000000)
#endif

  #define HEMIF_SDEXT_TCL_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_TCL)

  #define HEMIF_SDEXT_TCL_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_TCL,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_TRAS
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_TRAS_MASK                (0x0000000D)
  #define HEMIF_SDEXT_TRAS_SHIFT               (0x00000001)
#else
  #define HEMIF_SDEXT_TRAS_MASK                (0x00000000)
  #define HEMIF_SDEXT_TRAS_SHIFT               (0x00000000)
#endif

  #define HEMIF_SDEXT_TRAS_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_TRAS)

  #define HEMIF_SDEXT_TRAS_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_TRAS,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_TRRD
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_TRRD_MASK                (0x00000010)
  #define HEMIF_SDEXT_TRRD_SHIFT               (0x00000004)
#else
  #define HEMIF_SDEXT_TRRD_MASK                (0x00000000)
  #define HEMIF_SDEXT_TRRD_SHIFT               (0x00000000)
#endif

  #define HEMIF_SDEXT_TRRD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_TRRD)

  #define HEMIF_SDEXT_TRRD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_TRRD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_TWR
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_TWR_MASK                 (0x00000060)
  #define HEMIF_SDEXT_TWR_SHIFT                (0x00000005)
#else
  #define HEMIF_SDEXT_TWR_MASK                 (0x00000000)
  #define HEMIF_SDEXT_TWR_SHIFT                (0x00000000)
#endif

  #define HEMIF_SDEXT_TWR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_TWR)

  #define HEMIF_SDEXT_TWR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_TWR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_THZP
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_THZP_MASK                (0x00000180)
  #define HEMIF_SDEXT_THZP_SHIFT               (0x00000007)
#else
  #define HEMIF_SDEXT_THZP_MASK                (0x00000000)
  #define HEMIF_SDEXT_THZP_SHIFT               (0x00000000)
#endif

  #define HEMIF_SDEXT_THZP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_THZP)

  #define HEMIF_SDEXT_THZP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_THZP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_RD2RD
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_RD2RD_MASK               (0x00000200)
  #define HEMIF_SDEXT_RD2RD_SHIFT              (0x00000009)
#else
  #define HEMIF_SDEXT_RD2RD_MASK               (0x00000000)
  #define HEMIF_SDEXT_RD2RD_SHIFT              (0x00000000)
#endif

  #define HEMIF_SDEXT_RD2RD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_RD2RD)

  #define HEMIF_SDEXT_RD2RD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_RD2RD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_RD2DEAC
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_RD2DEAC_MASK             (0x00000C00)
  #define HEMIF_SDEXT_RD2DEAC_SHIFT            (0x0000000A)
#else
  #define HEMIF_SDEXT_RD2DEAC_MASK             (0x00000000)
  #define HEMIF_SDEXT_RD2DEAC_SHIFT            (0x00000000)
#endif

  #define HEMIF_SDEXT_RD2DEAC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_RD2DEAC)

  #define HEMIF_SDEXT_RD2DEAC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_RD2DEAC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_RD2WR
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_RD2WR_MASK               (0x00007000)
  #define HEMIF_SDEXT_RD2WR_SHIFT              (0x0000000C)
#else
  #define HEMIF_SDEXT_RD2WR_MASK               (0x00000000)
  #define HEMIF_SDEXT_RD2WR_SHIFT              (0x00000000)
#endif

  #define HEMIF_SDEXT_RD2WR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_RD2WR)

  #define HEMIF_SDEXT_RD2WR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_RD2WR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_R2WDQM
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_R2WDQM_MASK              (0x00018000)
  #define HEMIF_SDEXT_R2WDQM_SHIFT             (0x0000000F)
#else
  #define HEMIF_SDEXT_R2WDQM_MASK              (0x00000000)
  #define HEMIF_SDEXT_R2WDQM_SHIFT             (0x00000000)
#endif

  #define HEMIF_SDEXT_R2WDQM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_R2WDQM)

  #define HEMIF_SDEXT_R2WDQM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_R2WDQM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_WR2WR
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_WR2WR_MASK               (0x00020000)
  #define HEMIF_SDEXT_WR2WR_SHIFT              (0x00000011)
#else
  #define HEMIF_SDEXT_WR2WR_MASK               (0x00000000)
  #define HEMIF_SDEXT_WR2WR_SHIFT              (0x00000000)
#endif

  #define HEMIF_SDEXT_WR2WR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_WR2WR)

  #define HEMIF_SDEXT_WR2WR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_WR2WR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_WR2DEAC
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_WR2DEAC_MASK             (0x000C0000)
  #define HEMIF_SDEXT_WR2DEAC_SHIFT            (0x00000012)
#else
  #define HEMIF_SDEXT_WR2DEAC_MASK             (0x00000000)
  #define HEMIF_SDEXT_WR2DEAC_SHIFT            (0x00000000)
#endif

  #define HEMIF_SDEXT_WR2DEAC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_WR2DEAC)

  #define HEMIF_SDEXT_WR2DEAC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_WR2DEAC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT_WR2RD
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HEMIF_SDEXT_WR2RD_MASK               (0x00100000)
  #define HEMIF_SDEXT_WR2RD_SHIFT              (0x00000014)
#else
  #define HEMIF_SDEXT_WR2RD_MASK               (0x00000000)
  #define HEMIF_SDEXT_WR2RD_SHIFT              (0x00000000)
#endif

  #define HEMIF_SDEXT_WR2RD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HEMIF_SDEXT_WR2RD)

  #define HEMIF_SDEXT_WR2RD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HEMIF_SDEXT_WR2RD,Val)

/*----------------------------------------------------------------------------*\
* (RW) HEMIF_SDEXT
\*----------------------------------------------------------------------------*/
  #define HEMIF_SDEXT_GET(RegAddr) HREG32_GET(RegAddr)
  #define HEMIF_SDEXT_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HEMIF_SDEXT_CFG(RegAddr,tcl,tras,trrd,twr,thzp,rd2rd,rd2deac,\
  rd2wr,r2wdqm,wr2wr,wr2deac,wr2rd) REG32(RagAddr)=(UINT32)(\
    HFIELD_SHIFT(HEMIF_SDEXT_TCL,tcl)|\
    HFIELD_SHIFT(HEMIF_SDEXT_TRAS,tras)|\
    HFIELD_SHIFT(HEMIF_SDEXT_TRRD,trrd)|\
    HFIELD_SHIFT(HEMIF_SDEXT_TWR,twr)|\
    HFIELD_SHIFT(HEMIF_SDEXT_THZP,thzp)|\
    HFIELD_SHIFT(HEMIF_SDEXT_RD2RD,rd2rd)|\
    HFIELD_SHIFT(HEMIF_SDEXT_RD2DEAC,rd2deac)|\
    HFIELD_SHIFT(HEMIF_SDEXT_RD2WR,rd2wr)|\
    HFIELD_SHIFT(HEMIF_SDEXT_R2WDQM,r2wdqm)|\
    HFIELD_SHIFT(HEMIF_SDEXT_WR2WR,wr2wr)|\
    HFIELD_SHIFT(HEMIF_SDEXT_WR2DEAC,wr2deac)|\
    HFIELD_SHIFT(HEMIF_SDEXT_WR2RD,wr2rd)\
  )  

/******************************************************************************/

#endif /* EMIF_SUPPORT */
#endif /* _EMIFHAL_H_ */
/******************************************************************************\
* End of emifhal.h
\******************************************************************************/

/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... hpihal.h
* DATE CREATED.. 06/20/1999 
* LAST MODIFIED. 03/08/2000
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the HPI module)
*
* Registers Covered:
*   (RW) HHPI_HPIC - HPI control register
*
\******************************************************************************/
#ifndef _HPIHAL_H_
#define _HPIHAL_H_

#if (HPI_SUPPORT)
#define HHPI_BASE_ADDR       (HCHIP_PERBASE_ADDR+0x00080000)

/******************************************************************************\
* HHPI_HPIC - HPI control register
*
* Fields:
*   (R)  HHPI_HPIC_HWOB
*   (RW) HHPI_HPIC_DSPINT
*   (RW) HHPI_HPIC_HINT
*   (R)  HHPI_HPIC_HRDY
*   (R)  HHPI_HPIC_FETCH
*
\******************************************************************************/
  #define HHPI_HPIC_ADDR                       (HHPI_BASE_ADDR+0x0000)
  #define HHPI_HPIC                            REG32(HHPI_HPIC_ADDR)
  
/*----------------------------------------------------------------------------*\
* (R) HHPI_HPIC_HWOB
\*----------------------------------------------------------------------------*/
  #define HHPI_HPIC_HWOB_MASK                  (0x00000001)
  #define HHPI_HPIC_HWOB_SHIFT                 (0x00000000)
  
  #define HHPI_HPIC_HWOB_GET(RegAddr) \
    HFIELD_GET(RegAddr,HHPI_HPIC_HWOB)

/*----------------------------------------------------------------------------*\
* (RW) HHPI_HPIC_DSPINT
\*----------------------------------------------------------------------------*/
  #define HHPI_HPIC_DSPINT_MASK                (0x00000002)
  #define HHPI_HPIC_DSPINT_SHIFT               (0x00000001)

  #define HHPI_HPIC_DSPINT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HHPI_HPIC_DSPINT)

  #define HHPI_HPIC_DSPINT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HHPI_HPIC_DSPINT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HHPI_HPIC_HINT
\*----------------------------------------------------------------------------*/
  #define HHPI_HPIC_HINT_MASK                  (0x00000004)
  #define HHPI_HPIC_HINT_SHIFT                 (0x00000002)

  #define HHPI_HPIC_HINT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HHPI_HPIC_HINT)

  #define HHPI_HPIC_HINT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HHPI_HPIC_HINT,Val)

/*----------------------------------------------------------------------------*\
* (R) HHPI_HPIC_HRDY
\*----------------------------------------------------------------------------*/
  #define HHPI_HPIC_HRDY_MASK                  (0x00000008)
  #define HHPI_HPIC_HRDY_SHIFT                 (0x00000003)

  #define HHPI_HPIC_HRDY_GET(RegAddr) \
    HFIELD_GET(RegAddr,HHPI_HPIC_HRDY)

/*----------------------------------------------------------------------------*\
* (R) HHPI_HPIC_FETCH
\*----------------------------------------------------------------------------*/
  #define HHPI_HPIC_FETCH_MASK                 (0x00000010)
  #define HHPI_HPIC_FETCH_SHIFT                (0x00000004)

  #define HHPI_HPIC_FETCH_GET(RegAddr) \
    HFIELD_GET(RegAddr,HHPI_HPIC_FETCH)

/*----------------------------------------------------------------------------*\
* (RW) HHPI_HPIC
\*----------------------------------------------------------------------------*/
  #define HHPI_HPIC_GET(RegAddr) HREG32_GET(RegAddr)
  #define HHPI_HPIC_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HHPI_HPIC_CFG(RegAddr,dspint,hint)\
  REG32(RegAddr) = (\
    HFIELD_SHIFT(HHPI_HPIC_DSPINT, dspint)|\
    HFIELD_SHIFT(HHPI_HPIC_HINT, hint)\
  )

/*----------------------------------------------------------------------------*/

#endif /* HPI_SUPPORT */
#endif /* _HPIHAL_H_ */
/******************************************************************************\
* End of hpihal.h
\******************************************************************************/

/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... irqhal.h
* DATE CREATED.. 06/20/1999 
* LAST MODIFIED. 03/08/2000
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the IRQ module)
*
* Registers Covered:
*   (RW) HIRQ_MUXL   - interrupt multiplexer low register
*   (RW) HIRQ_MUXH   - interrupt multiplexer high register
*   (RW) HIRQ_EXTPOL - external interrupt polarity register
*
\******************************************************************************/
#ifndef _IRQHAL_H_
#define _IRQHAL_H_

#if (IRQ_SUPPORT)
/*============================================================================*\
* misc declarations
\*============================================================================*/
#define HIRQ_BASE_ADDR     (HCHIP_PERBASE_ADDR+0x001C0000)

#define HIRQ_INT_CNT     (16)   /* number of interrupts */
#define HIRQ_EVENT_CNT   (19)   /* number of mappable events */

/******************************************************************************\
* HIRQ_MUXL - interrupt multiplexer low register
*
* Fields:
*   (RW) HIRQ_MUXL_INTSEL4
*   (RW) HIRQ_MUXL_INTSEL5
*   (RW) HIRQ_MUXL_INTSEL6
*   (RW) HIRQ_MUXL_INTSEL7
*   (RW) HIRQ_MUXL_INTSEL8
*   (RW) HIRQ_MUXL_INTSEL9
*
\******************************************************************************/
  #define HIRQ_MUXL_ADDR                       (HIRQ_BASE_ADDR+0x0004)
  #define HIRQ_MUXL                            REG32(HIRQ_MUXL_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXL_INTSEL4
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXL_INTSEL4_MASK               (0x0000001F)
  #define HIRQ_MUXL_INTSEL4_SHIFT              (0x00000000)
  
  #define HIRQ_MUXL_INTSEL4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXL_INTSEL4)

  #define HIRQ_MUXL_INTSEL4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXL_INTSEL4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXL_INTSEL5
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXL_INTSEL5_MASK               (0x000003E0)
  #define HIRQ_MUXL_INTSEL5_SHIFT              (0x00000005)

  #define HIRQ_MUXL_INTSEL5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXL_INTSEL5)

  #define HIRQ_MUXL_INTSEL5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXL_INTSEL5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXL_INTSEL6
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXL_INTSEL6_MASK               (0x00007C00)
  #define HIRQ_MUXL_INTSEL6_SHIFT              (0x0000000A)

  #define HIRQ_MUXL_INTSEL6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXL_INTSEL6)

  #define HIRQ_MUXL_INTSEL6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXL_INTSEL6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXL_INTSEL7
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXL_INTSEL7_MASK               (0x001F0000)
  #define HIRQ_MUXL_INTSEL7_SHIFT              (0x00000010)

  #define HIRQ_MUXL_INTSEL7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXL_INTSEL7)

  #define HIRQ_MUXL_INTSEL7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXL_INTSEL7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXL_INTSEL8
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXL_INTSEL8_MASK               (0x03E00000)
  #define HIRQ_MUXL_INTSEL8_SHIFT              (0x00000015)

  #define HIRQ_MUXL_INTSEL8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXL_INTSEL8)

  #define HIRQ_MUXL_INTSEL8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXL_INTSEL8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXL_INTSEL9
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXL_INTSEL9_MASK               (0x7C000000)
  #define HIRQ_MUXL_INTSEL9_SHIFT              (0x0000001A)

  #define HIRQ_MUXL_INTSEL9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXL_INTSEL9)

  #define HIRQ_MUXL_INTSEL9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXL_INTSEL9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXL
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HIRQ_MUXL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HIRQ_MUXL_CFG(RegAddr,intsel4,intsel5,intsel6,intsel7,intsel8,\
  intsel9) REG32(RegAddr) = (\
    HFIELD_SHIFT(HIRQ_MUXL_INTSEL4, intsel4)|\
    HFIELD_SHIFT(HIRQ_MUXL_INTSEL5, intsel5)|\
    HFIELD_SHIFT(HIRQ_MUXL_INTSEL6, intsel6)|\
    HFIELD_SHIFT(HIRQ_MUXL_INTSEL7, intsel7)|\
    HFIELD_SHIFT(HIRQ_MUXL_INTSEL8, intsel8)|\
    HFIELD_SHIFT(HIRQ_MUXL_INTSEL9, intsel9)\
  )

/******************************************************************************\
* HIRQ_MUXH - interrupt multiplexer high register
*
* Fields:
*   (RW) HIRQ_MUXH_INTSEL10
*   (RW) HIRQ_MUXH_INTSEL11
*   (RW) HIRQ_MUXH_INTSEL12
*   (RW) HIRQ_MUXH_INTSEL13
*   (RW) HIRQ_MUXH_INTSEL14
*   (RW) HIRQ_MUXH_INTSEL15
*
\******************************************************************************/
  #define HIRQ_MUXH_ADDR                       (HIRQ_BASE_ADDR+0x0000)
  #define HIRQ_MUXH                            REG32(HIRQ_MUXH_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXH_INTSEL10
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXH_INTSEL10_MASK              (0x0000001F)
  #define HIRQ_MUXH_INTSEL10_SHIFT             (0x00000000)
  
  #define HIRQ_MUXH_INTSEL10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXH_INTSEL10)

  #define HIRQ_MUXH_INTSEL10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXH_INTSEL10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXH_INTSEL11
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXH_INTSEL11_MASK              (0x000003E0)
  #define HIRQ_MUXH_INTSEL11_SHIFT             (0x00000005)

  #define HIRQ_MUXH_INTSEL11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXH_INTSEL11)

  #define HIRQ_MUXH_INTSEL11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXH_INTSEL11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXH_INTSEL12
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXH_INTSEL12_MASK              (0x00007C00)
  #define HIRQ_MUXH_INTSEL12_SHIFT             (0x0000000A)

  #define HIRQ_MUXH_INTSEL12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXH_INTSEL12)

  #define HIRQ_MUXH_INTSEL12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXH_INTSEL12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXH_INTSEL13
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXH_INTSEL13_MASK              (0x001F0000)
  #define HIRQ_MUXH_INTSEL13_SHIFT             (0x00000010)

  #define HIRQ_MUXH_INTSEL13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXH_INTSEL13)

  #define HIRQ_MUXH_INTSEL13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXH_INTSEL13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXH_INTSEL14
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXH_INTSEL14_MASK              (0x03E00000)
  #define HIRQ_MUXH_INTSEL14_SHIFT             (0x00000015)

  #define HIRQ_MUXH_INTSEL14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXH_INTSEL14)

  #define HIRQ_MUXH_INTSEL14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXH_INTSEL14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXH_INTSEL15
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXH_INTSEL15_MASK              (0x7C000000)
  #define HIRQ_MUXH_INTSEL15_SHIFT             (0x0000001A)

  #define HIRQ_MUXH_INTSEL15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_MUXH_INTSEL15)

  #define HIRQ_MUXH_INTSEL15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_MUXH_INTSEL15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_MUXH
\*----------------------------------------------------------------------------*/
  #define HIRQ_MUXH_GET(RegAddr) HREG32_GET(RegAddr)
  #define HIRQ_MUXH_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HIRQ_MUXH_CFG(RegAddr,intsel10,intsel11,intsel12,intsel13,intsel14,\
  intsel15) REG32(RegAddr) = (\
    HFIELD_SHIFT(HIRQ_MUXH_INTSEL10, intsel10)|\
    HFIELD_SHIFT(HIRQ_MUXH_INTSEL11, intsel11)|\
    HFIELD_SHIFT(HIRQ_MUXH_INTSEL12, intsel12)|\
    HFIELD_SHIFT(HIRQ_MUXH_INTSEL13, intsel13)|\
    HFIELD_SHIFT(HIRQ_MUXH_INTSEL14, intsel14)|\
    HFIELD_SHIFT(HIRQ_MUXH_INTSEL15, intsel15)\
  )

/******************************************************************************\
* HIRQ_EXTPOL - external interrupt polarity register
*
* Fields:
*   (RW) HIRQ_EXTPOL_XIP4
*   (RW) HIRQ_EXTPOL_XIP5
*   (RW) HIRQ_EXTPOL_XIP6
*   (RW) HIRQ_EXTPOL_XIP7
*
\******************************************************************************/
  #define HIRQ_EXTPOL_ADDR                     (HIRQ_BASE_ADDR+0x0008)
  #define HIRQ_EXTPOL                          REG32(HIRQ_EXTPOL_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_EXTPOL_XIP4
\*----------------------------------------------------------------------------*/
  #define HIRQ_EXTPOL_XIP4_MASK                (0x00000001)
  #define HIRQ_EXTPOL_XIP4_SHIFT               (0x00000000)
  
  #define HIRQ_EXTPOL_XIP4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_EXTPOL_XIP4)

  #define HIRQ_EXTPOL_XIP4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_EXTPOL_XIP4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_EXTPOL_XIP5
\*----------------------------------------------------------------------------*/
  #define HIRQ_EXTPOL_XIP5_MASK                (0x00000002)
  #define HIRQ_EXTPOL_XIP5_SHIFT               (0x00000001)
  
  #define HIRQ_EXTPOL_XIP5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_EXTPOL_XIP5)

  #define HIRQ_EXTPOL_XIP5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_EXTPOL_XIP5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_EXTPOL_XIP6
\*----------------------------------------------------------------------------*/
  #define HIRQ_EXTPOL_XIP6_MASK                (0x00000004)
  #define HIRQ_EXTPOL_XIP6_SHIFT               (0x00000002)
  
  #define HIRQ_EXTPOL_XIP6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_EXTPOL_XIP6)

  #define HIRQ_EXTPOL_XIP6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_EXTPOL_XIP6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_EXTPOL_XIP7
\*----------------------------------------------------------------------------*/
  #define HIRQ_EXTPOL_XIP7_MASK                (0x00000008)
  #define HIRQ_EXTPOL_XIP7_SHIFT               (0x00000003)
  
  #define HIRQ_EXTPOL_XIP7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HIRQ_EXTPOL_XIP7)

  #define HIRQ_EXTPOL_XIP7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HIRQ_EXTPOL_XIP7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HIRQ_EXTPOL
\*----------------------------------------------------------------------------*/
  #define HIRQ_EXTPOL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HIRQ_EXTPOL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HIRQ_EXTPOL_CFG(RegAddr,xip4,xip5,xip6,xip7)\
  REG32(RegAddr) = (\
    HFIELD_SHIFT(HIRQ_EXTPOL_XIP4, xip4)|\
    HFIELD_SHIFT(HIRQ_EXTPOL_XIP5, xip5)|\
    HFIELD_SHIFT(HIRQ_EXTPOL_XIP6, xip6)|\
    HFIELD_SHIFT(HIRQ_EXTPOL_XIP7, xip7)\
  )

/*----------------------------------------------------------------------------*/

#endif /* IRQ_SUPPORT */
#endif /* _IRQHAL_H_ */
/******************************************************************************\
* End of irqhal.h
\******************************************************************************/

/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... mcbsphal.h
* DATE CREATED.. 06/12/1999 
* LAST MODIFIED. 03/08/2000
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the MCBSP module)
*
* Registers Covered:
*   HMCBSP_DRR0  - serial port 0 data receive register
*   HMCBSP_DXR0  - serial port 0 data transmit register
*   HMCBSP_SPCR0 - serial port 0 control register
*   HMCBSP_RCR0  - serial port 0 receive control register
*   HMCBSP_XCR0  - serial port 0 transmit control register
*   HMCBSP_SRGR0 - serial port 0 sample rate generator register
*   HMCBSP_MCR0  - serial port 0 multichannel control register
*   HMCBSP_RCER0 - serial port 0 receive channel enable register
*   HMCBSP_XCER0 - serial port 0 transmit channel enable register
*   HMCBSP_PCR0  - serial port 0 pin control register
*
*   HMCBSP_DRR1  - serial port 1 data receive register
*   HMCBSP_DXR1  - serial port 1 data transmit register
*   HMCBSP_SPCR1 - serial port 1 control register
*   HMCBSP_RCR1  - serial port 1 receive control register
*   HMCBSP_XCR1  - serial port 1 transmit control register
*   HMCBSP_SRGR1 - serial port 1 sample rate generator register
*   HMCBSP_MCR1  - serial port 1 multichannel control register
*   HMCBSP_RCER1 - serial port 1 receive channel enable register
*   HMCBSP_XCER1 - serial port 1 transmit channel enable register
*   HMCBSP_PCR1  - serial port 1 pin control register
*
*   HMCBSP_DRR2  - serial port 2 data receive register (1)
*   HMCBSP_DXR2  - serial port 2 data transmit register (1)
*   HMCBSP_SPCR2 - serial port 2 control register (1)
*   HMCBSP_RCR2  - serial port 2 receive control register (1)
*   HMCBSP_XCR2  - serial port 2 transmit control register (1)
*   HMCBSP_SRGR2 - serial port 2 sample rate generator register (1)
*   HMCBSP_MCR2  - serial port 2 multichannel control register (1)
*   HMCBSP_RCER2 - serial port 2 receive channel enable register (1)
*   HMCBSP_XCER2 - serial port 2 transmit channel enable register (1)
*   HMCBSP_PCR2  - serial port 2 pin control register (1)
*
*   (1) only on devices with three serial ports
*
\******************************************************************************/
#ifndef _MCBSPHAL_H_
#define _MCBSPHAL_H_

#if (MCBSP_SUPPORT)
/*============================================================================*\
*  misc declarations
\*============================================================================*/
#define HMCBSP_BASE0_ADDR              (HCHIP_PERBASE_ADDR+0x000C0000)
#define HMCBSP_BASE1_ADDR              (HCHIP_PERBASE_ADDR+0x00100000)
#define HMCBSP_BASE2_ADDR              (HCHIP_PERBASE_ADDR+0x00240000)

#if (CHIP_6202 | CHIP_6203)
  #define HMCBSP_PORT_CNT              (3)
#else
  #define HMCBSP_PORT_CNT              (2)
#endif

/******************************************************************************\
* HMCBSP_DRR0 - serial port 0 data receive register
* HMCBSP_DRR1 - serial port 1 data receive register
* HMCBSP_DRR2 - serial port 2 data receive register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*   (R) HMCBSP_DRR_DRR
*
\******************************************************************************/
#if (C11_SUPPORT & 0)
  #define HMCBSP_DRR0_ADDR                     (0x30000000)
  #define HMCBSP_DRR1_ADDR                     (0x34000000)
#else
  #define HMCBSP_DRR0_ADDR                     (HMCBSP_BASE0_ADDR+0x0000)
  #define HMCBSP_DRR1_ADDR                     (HMCBSP_BASE1_ADDR+0x0000)
#endif  
  #define HMCBSP_DRR0                          REG32(HMCBSP_DRR0_ADDR)
  #define HMCBSP_DRR1                          REG32(HMCBSP_DRR1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_DRR2_ADDR                     (HMCBSP_BASE2_ADDR+0x0000)
  #define HMCBSP_DRR2                          REG32(HMCBSP_DRR2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_DRR_DRR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_DRR_DRR_MASK                  (0xFFFFFFFF)
  #define HMCBSP_DRR_DRR_SHIFT                 (0x00000000)

  #define HMCBSP_DRR_DRR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_DRR_DRR)

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_DRR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_DRR_GET(RegAddr) HREG32_GET(RegAddr)

/******************************************************************************\
* HMCBSP_DXR0  - serial port 0 data transmit register
* HMCBSP_DXR1  - serial port 1 data transmit register
* HMCBSP_DXR2  - serial port 2 data transmit register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*   (W) HMCBSP_DXR_DXR
*
\******************************************************************************/
#if (C11_SUPPORT & 0)
  #define HMCBSP_DXR0_ADDR                     (0x30000000)
  #define HMCBSP_DXR1_ADDR                     (0x34000000)
#else
  #define HMCBSP_DXR0_ADDR                     (HMCBSP_BASE0_ADDR+0x0004)
  #define HMCBSP_DXR1_ADDR                     (HMCBSP_BASE1_ADDR+0x0004)
#endif  
  #define HMCBSP_DXR0                          REG32(HMCBSP_DXR0_ADDR)
  #define HMCBSP_DXR1                          REG32(HMCBSP_DXR1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_DXR2_ADDR                     (HMCBSP_BASE2_ADDR+0x0004)
  #define HMCBSP_DXR2                          REG32(HMCBSP_DXR2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (W) HMCBSP_DXR_DXR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_DXR_DXR_MASK                  (0xFFFFFFFF)
  #define HMCBSP_DXR_DXR_SHIFT                 (0x00000000)
  
  #define HMCBSP_DXR_DXR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_DXR_DXR,Val)

/*----------------------------------------------------------------------------*\
* (W) HMCBSP_DXR
\*----------------------------------------------------------------------------*/ 
  #define HMCBSP_DXR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_DXR_CFG(RegAddr,dxr) REG32(RegAddr)=(UINT32)( \
    HFIELD_SHIFT(HMCBSP_DXR_DXR,dxr) \
  )
  
/******************************************************************************\
* HMCBSP_SPCR0 - serial port 0 control register
* HMCBSP_SPCR1 - serial port 1 control register
* HMCBSP_SPCR2 - serial port 2 control register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*   (RW) HMCBSP_SPCR_RRST
*   (R)  HMCBSP_SPCR_RRDY
*   (R)  HMCBSP_SPCR_FULL
*   (RW) HMCBSP_SPCR_RSYNCERR
*   (RW) HMCBSP_SPCR_RINTM
*   (RW) HMCBSP_SPCR_DXENA
*   (RW) HMCBSP_SPCR_CLKSTP
*   (RW) HMCBSP_SPCR_RJUST
*   (RW) HMCBSP_SPCR_DLB
*   (RW) HMCBSP_SPCR_XRST
*   (R)  HMCBSP_SPCR_XRDY
*   (R)  HMCBSP_SPCR_XEMPTY
*   (RW) HMCBSP_SPCR_XSYNCERR
*   (RW) HMCBSP_SPCR_XINTM
*   (RW) HMCBSP_SPCR_GRST
*   (RW) HMCBSP_SPCR_FRST
*
\******************************************************************************/
  #define HMCBSP_SPCR0_ADDR                    (HMCBSP_BASE0_ADDR+0x0008)
  #define HMCBSP_SPCR1_ADDR                    (HMCBSP_BASE1_ADDR+0x0008)
  #define HMCBSP_SPCR0                         REG32(HMCBSP_SPCR0_ADDR)
  #define HMCBSP_SPCR1                         REG32(HMCBSP_SPCR1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_SPCR2_ADDR                    (HMCBSP_BASE2_ADDR+0x0008)
  #define HMCBSP_SPCR2                         REG32(HMCBSP_SPCR2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_RRST
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_RRST_MASK                (0x00000001)
  #define HMCBSP_SPCR_RRST_SHIFT               (0x00000000) 
  
  #define HMCBSP_SPCR_RRST_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_RRST)

  #define HMCBSP_SPCR_RRST_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_RRST,Val)

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_SPCR_RRDY
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_RRDY_MASK                (0x00000002)
  #define HMCBSP_SPCR_RRDY_SHIFT               (0x00000001)

  #define HMCBSP_SPCR_RRDY_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_RRDY)

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_SPCR_RFULL
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_RFULL_MASK               (0x00000004)
  #define HMCBSP_SPCR_RFULL_SHIFT              (0x00000002)

  #define HMCBSP_SPCR_RFULL_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_RFULL)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_RSYNCERR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_RSYNCERR_MASK            (0x00000008)
  #define HMCBSP_SPCR_RSYNCERR_SHIFT           (0x00000003)

  #define HMCBSP_SPCR_RSYNCERR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_RSYNCERR)

  #define HMCBSP_SPCR_RSYNCERR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_RSYNCERR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_RINTM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_RINTM_MASK               (0x00000030)
  #define HMCBSP_SPCR_RINTM_SHIFT              (0x00000004)

  #define HMCBSP_SPCR_RINTM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_RINTM)

  #define HMCBSP_SPCR_RINTM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_RINTM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_DXENA
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)    
  #define HMCBSP_SPCR_DXENA_MASK               (0x00000080)
  #define HMCBSP_SPCR_DXENA_SHIFT              (0x00000007)
#else
  #define HMCBSP_SPCR_DXENA_MASK               (0x00000000)
  #define HMCBSP_SPCR_DXENA_SHIFT              (0x00000000)
#endif  

  #define HMCBSP_SPCR_DXENA_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_DXENA)

  #define HMCBSP_SPCR_DXENA_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_DXENA,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_CLKSTP
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_CLKSTP_MASK              (0x00001800)
  #define HMCBSP_SPCR_CLKSTP_SHIFT             (0x0000000B)

  #define HMCBSP_SPCR_CLKSTP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_CLKSTP)

  #define HMCBSP_SPCR_CLKSTP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_CLKSTP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_RJUST
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_RJUST_MASK               (0x00006000)
  #define HMCBSP_SPCR_RJUST_SHIFT              (0x0000000D)

  #define HMCBSP_SPCR_RJUST_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_RJUST)

  #define HMCBSP_SPCR_RJUST_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_RJUST,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_DLB
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_DLB_MASK                 (0x00008000)
  #define HMCBSP_SPCR_DLB_SHIFT                (0x0000000F)

  #define HMCBSP_SPCR_DLB_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_DLB)

  #define HMCBSP_SPCR_DLB_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_DLB,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_XRST
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_XRST_MASK                (0x00010000)
  #define HMCBSP_SPCR_XRST_SHIFT               (0x00000010)

  #define HMCBSP_SPCR_XRST_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_XRST)

  #define HMCBSP_SPCR_XRST_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_XRST,Val)

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_SPCR_XRDY
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_XRDY_MASK                (0x00020000)
  #define HMCBSP_SPCR_XRDY_SHIFT               (0x00000011)

  #define HMCBSP_SPCR_XRDY_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_XRDY)

  #define HMCBSP_SPCR_XRDY_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_XRDY,Val)

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_SPCR_XEMPTY
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_XEMPTY_MASK              (0x00040000)
  #define HMCBSP_SPCR_XEMPTY_SHIFT             (0x00000012)

  #define HMCBSP_SPCR_XEMPTY_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_XEMPTY)

  #define HMCBSP_SPCR_XEMPTY_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_XEMPTY,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_XSYNCERR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_XSYNCERR_MASK            (0x00080000)
  #define HMCBSP_SPCR_XSYNCERR_SHIFT           (0x00000013)

  #define HMCBSP_SPCR_XSYNCERR_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_XSYNCERR)

  #define HMCBSP_SPCR_XSYNCERR_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_XSYNCERR,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_XINTM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_XINTM_MASK               (0x00300000)
  #define HMCBSP_SPCR_XINTM_SHIFT              (0x00000014)

  #define HMCBSP_SPCR_XINTM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_XINTM)

  #define HMCBSP_SPCR_XINTM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_XINTM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_GRST
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_GRST_MASK                (0x00400000)
  #define HMCBSP_SPCR_GRST_SHIFT               (0x00000016)

  #define HMCBSP_SPCR_GRST_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_GRST)

  #define HMCBSP_SPCR_GRST_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_GRST,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR_FRST
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_FRST_MASK                (0x00800000)
  #define HMCBSP_SPCR_FRST_SHIFT               (0x00000017)

  #define HMCBSP_SPCR_FRST_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SPCR_FRST)

  #define HMCBSP_SPCR_FRST_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SPCR_FRST,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SPCR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SPCR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HMCBSP_SPCR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_SPCR_CFG(RegAddr,rrst,rsyncerr,rintm,dxena,clkstp,rjust,dlb,\
  xrst,xsyncerr,xintm,grst,frst) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HMCBSP_SPCR_RRST,    rrst)    |\
    HFIELD_SHIFT(HMCBSP_SPCR_RSYNCERR,rsyncerr)|\
    HFIELD_SHIFT(HMCBSP_SPCR_RINTM,   rintm)   |\
    HFIELD_SHIFT(HMCBSP_SPCR_DXENA,   dxena)   |\
    HFIELD_SHIFT(HMCBSP_SPCR_CLKSTP,  clkstp)  |\
    HFIELD_SHIFT(HMCBSP_SPCR_RJUST,   rjust)   |\
    HFIELD_SHIFT(HMCBSP_SPCR_DLB,     dlb)     |\
    HFIELD_SHIFT(HMCBSP_SPCR_XRST,    xrst)    |\
    HFIELD_SHIFT(HMCBSP_SPCR_XSYNCERR,xsyncerr)|\
    HFIELD_SHIFT(HMCBSP_SPCR_XINTM,   xintm)   |\
    HFIELD_SHIFT(HMCBSP_SPCR_GRST,    grst)    |\
    HFIELD_SHIFT(HMCBSP_SPCR_FRST,    frst)     \
  )

/******************************************************************************\
* HMCBSP_RCR0  - serial port 0 receive control register
* HMCBSP_RCR1  - serial port 1 receive control register
* HMCBSP_RCR2  - serial port 2 receive control register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*   (RW) HMCBSP_RCR_RWDREVRS (2)
*   (RW) HMCBSP_RCR_RWDLEN1
*   (RW) HMCBSP_RCR_RFRLEN1
*   (RW) HMCBSP_RCR_RPHASE2 (2)
*   (RW) HMCBSP_RCR_RDATDLY
*   (RW) HMCBSP_RCR_RFIG
*   (RW) HMCBSP_RCR_RCOMPAND
*   (RW) HMCBSP_RCR_RWDLEN2
*   (RW) HMCBSP_RCR_RFRLEN2
*   (RW) HMCBSP_RCR_RPHASE 
*
* (2) - C11_SUPPORT only
*
\******************************************************************************/
  #define HMCBSP_RCR0_ADDR                     (HMCBSP_BASE0_ADDR+0x000C)
  #define HMCBSP_RCR1_ADDR                     (HMCBSP_BASE1_ADDR+0x000C)
  #define HMCBSP_RCR0                          REG32(HMCBSP_RCR0_ADDR)
  #define HMCBSP_RCR1                          REG32(HMCBSP_RCR1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_RCR2_ADDR                     (HMCBSP_BASE2_ADDR+0x000C)
  #define HMCBSP_RCR2                          REG32(HMCBSP_RCR2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RWDREVRS
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HMCBSP_RCR_RWDREVRS_MASK             (0x00000010)
  #define HMCBSP_RCR_RWDREVRS_SHIFT            (0x00000004)
#else
  #define HMCBSP_RCR_RWDREVRS_MASK             (0x00000000)
  #define HMCBSP_RCR_RWDREVRS_SHIFT            (0x00000000)
#endif      

  #define HMCBSP_RCR_RWDREVRS_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RWDREVRS)

  #define HMCBSP_RCR_RWDREVRS_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RWDREVRS,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RWDLEN1
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_RWDLEN1_MASK              (0x000000E0)
  #define HMCBSP_RCR_RWDLEN1_SHIFT             (0x00000005)

  #define HMCBSP_RCR_RWDLEN1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RWDLEN1)

  #define HMCBSP_RCR_RWDLEN1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RWDLEN1,Val)
/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RFRLEN1
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_RFRLEN1_MASK              (0x00007F00)
  #define HMCBSP_RCR_RFRLEN1_SHIFT             (0x00000008)

  #define HMCBSP_RCR_RFRLEN1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RFRLEN1)

  #define HMCBSP_RCR_RFRLEN1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RFRLEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RPHASE2
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HMCBSP_RCR_RPHASE2_MASK              (0x00008000)
  #define HMCBSP_RCR_RPHASE2_SHIFT             (0x0000000F)
#else
  #define HMCBSP_RCR_RPHASE2_MASK              (0x00000000)
  #define HMCBSP_RCR_RPHASE2_SHIFT             (0x00000000)
#endif

  #define HMCBSP_RCR_RPHASE2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RPHASE2)

  #define HMCBSP_RCR_RPHASE2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RPHASE2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RDATDLY
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_RDATDLY_MASK              (0x00030000)
  #define HMCBSP_RCR_RDATDLY_SHIFT             (0x00000010)

  #define HMCBSP_RCR_RDATDLY_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RDATDLY)

  #define HMCBSP_RCR_RDATDLY_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RDATDLY,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RFIG
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_RFIG_MASK                 (0x00040000)
  #define HMCBSP_RCR_RFIG_SHIFT                (0x00000012)

  #define HMCBSP_RCR_RFIG_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RFIG)

  #define HMCBSP_RCR_RFIG_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RFIG,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RCOMPAND
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_RCOMPAND_MASK             (0x00180000)
  #define HMCBSP_RCR_RCOMPAND_SHIFT            (0x00000013)

  #define HMCBSP_RCR_RCOMPAND_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RCOMPAND)

  #define HMCBSP_RCR_RCOMPAND_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RCOMPAND,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RWDLEN2
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_RWDLEN2_MASK              (0x00E00000)
  #define HMCBSP_RCR_RWDLEN2_SHIFT             (0x00000015)

  #define HMCBSP_RCR_RWDLEN2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RWDLEN2)

  #define HMCBSP_RCR_RWDLEN2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RWDLEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RFRLEN2
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_RFRLEN2_MASK              (0x7F000000)
  #define HMCBSP_RCR_RFRLEN2_SHIFT             (0x00000018)

  #define HMCBSP_RCR_FRFLEN2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_FRFLEN2)

  #define HMCBSP_RCR_FRFLEN2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_FRFLEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR_RPHASE
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_RPHASE_MASK               (0x80000000)
  #define HMCBSP_RCR_RPHASE_SHIFT              (0x0000001F)
  
  #define HMCBSP_RCR_RPHASE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCR_RPHASE)

  #define HMCBSP_RCR_RPHASE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCR_RPHASE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HMCBSP_RCR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_RCR_CFG(RegAddr,rwdrevrs,rwdlen1,rfrlen1,rphase2,rdatdly,\
  rfig,rcompand,rwdlen2,rfrlen2,rphase) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HMCBSP_RCR_RWDREVRS,rwdrevrs)|\
    HFIELD_SHIFT(HMCBSP_RCR_RWDLEN1, rwdlen1) |\
    HFIELD_SHIFT(HMCBSP_RCR_RFRLEN1, rfrlen1) |\
    HFIELD_SHIFT(HMCBSP_RCR_RPHASE2, rphase2) |\
    HFIELD_SHIFT(HMCBSP_RCR_RDATDLY, rdatdly) |\
    HFIELD_SHIFT(HMCBSP_RCR_RFIG,    rfig)    |\
    HFIELD_SHIFT(HMCBSP_RCR_RCOMPAND,rcompand)|\
    HFIELD_SHIFT(HMCBSP_RCR_RWDLEN2, rwdlen2) |\
    HFIELD_SHIFT(HMCBSP_RCR_RFRLEN2, rfrlen2) |\
    HFIELD_SHIFT(HMCBSP_RCR_RPHASE,  rphase)   \
  )

/******************************************************************************\
* HMCBSP_XCR0  - serial port 0 transmit control register
* HMCBSP_XCR1  - serial port 1 transmit control register
* HMCBSP_XCR2  - serial port 2 transmit control register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*   (RW) HMCBSP_XCR_XWDREVRS (2)
*   (RW) HMCBSP_XCR_XWDLEN1
*   (RW) HMCBSP_XCR_XFRLEN1
*   (RW) HMCBSP_XCR_XPHASE2 (2)
*   (RW) HMCBSP_XCR_XDATDLY
*   (RW) HMCBSP_XCR_XFIG
*   (RW) HMCBSP_XCR_XCOMPAND
*   (RW) HMCBSP_XCR_XWDLEN2
*   (RW) HMCBSP_XCR_XFRLEN2
*   (RW) HMCBSP_XCR_XPHASE 
*
* (2) - C11_SUPPORT only
*
\******************************************************************************/
  #define HMCBSP_XCR0_ADDR                     (HMCBSP_BASE0_ADDR+0x0010)
  #define HMCBSP_XCR1_ADDR                     (HMCBSP_BASE1_ADDR+0x0010)
  #define HMCBSP_XCR0                          REG32(HMCBSP_XCR0_ADDR)
  #define HMCBSP_XCR1                          REG32(HMCBSP_XCR1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_XCR2_ADDR                     (HMCBSP_BASE2_ADDR+0x0010)
  #define HMCBSP_XCR2                          REG32(HMCBSP_XCR2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_RWDREVRS
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HMCBSP_XCR_XWDREVRS_MASK             (0x00000010)
  #define HMCBSP_XCR_XWDREVRS_SHIFT            (0x00000004)
#else
  #define HMCBSP_XCR_XWDREVRS_MASK             (0x00000000)
  #define HMCBSP_XCR_XWDREVRS_SHIFT            (0x00000000)
#endif      

  #define HMCBSP_XCR_XWDREVRS_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XWDREVRS)

  #define HMCBSP_XCR_XWDREVRS_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XWDREVRS,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XWDLEN1
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_XWDLEN1_MASK              (0x000000E0)
  #define HMCBSP_XCR_XWDLEN1_SHIFT             (0x00000005)
  
  #define HMCBSP_XCR_XWDLEN1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XWDLEN1)

  #define HMCBSP_XCR_XWDLEN1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XWDLEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XFRLEN1
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_XFRLEN1_MASK              (0x00007F00)
  #define HMCBSP_XCR_XFRLEN1_SHIFT             (0x00000008)

  #define HMCBSP_XCR_XFRLEN1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XFRLEN1)

  #define HMCBSP_XCR_XFRLEN1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XFRLEN1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XPHASE2
\*----------------------------------------------------------------------------*/
#if (C11_SUPPORT)
  #define HMCBSP_XCR_XPHASE2_MASK              (0x00008000)
  #define HMCBSP_XCR_XPHASE2_SHIFT             (0x0000000F)
#else
  #define HMCBSP_XCR_XPHASE2_MASK              (0x00000000)
  #define HMCBSP_XCR_XPHASE2_SHIFT             (0x00000000)
#endif

  #define HMCBSP_XCR_XPHASE2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XPHASE2)

  #define HMCBSP_XCR_XPHASE2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XPHASE2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XDATDLY
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_XDATDLY_MASK              (0x00030000)
  #define HMCBSP_XCR_XDATDLY_SHIFT             (0x00000010)

  #define HMCBSP_XCR_XDATDLY_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XDATDLY)

  #define HMCBSP_XCR_XDATDLY_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XDATDLY,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XFIG
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_XFIG_MASK                 (0x00040000)
  #define HMCBSP_XCR_XFIG_SHIFT                (0x00000012)

  #define HMCBSP_XCR_XFIG_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XFIG)

  #define HMCBSP_XCR_XFIG_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XFIG,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XCOMPAND
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_XCOMPAND_MASK             (0x00180000)
  #define HMCBSP_XCR_XCOMPAND_SHIFT            (0x00000013)

  #define HMCBSP_XCR_XCOMPAND_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XCOMPAND)

  #define HMCBSP_XCR_XCOMPAND_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XCOMPAND,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XWDLEN2
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_XWDLEN2_MASK              (0x00E00000)
  #define HMCBSP_XCR_XWDLEN2_SHIFT             (0x00000015)

  #define HMCBSP_XCR_XWDLEN2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XWDLEN2)

  #define HMCBSP_XCR_XWDLEN2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XWDLEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XFRLEN2
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_XFRLEN2_MASK              (0x7F000000)
  #define HMCBSP_XCR_XFRLEN2_SHIFT             (0x00000018)

  #define HMCBSP_XCR_XFRLEN2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XFRLEN2)

  #define HMCBSP_XCR_XFRLEN2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XFRLEN2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR_XPHASE
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_XPHASE_MASK               (0x80000000)
  #define HMCBSP_XCR_XPHASE_SHIFT              (0x0000001F)

  #define HMCBSP_XCR_XPHASE_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCR_XPHASE)

  #define HMCBSP_XCR_XPHASE_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCR_XPHASE,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HMCBSP_XCR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_XCR_CFG(RegAddr,xwdrevrs,xwdlen1,xfrlen1,xphase2,xdatdly,\
  xfig,xcompand,xwdlen2,xfrlen2,xphase) (REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HMCBSP_XCR_XWDREVRS,xwdrevrs)|\
    HFIELD_SHIFT(HMCBSP_XCR_XWDLEN1, xwdlen1) |\
    HFIELD_SHIFT(HMCBSP_XCR_XFRLEN1, xfrlen1) |\
    HFIELD_SHIFT(HMCBSP_XCR_XPHASE2, xphase2) |\
    HFIELD_SHIFT(HMCBSP_XCR_XDATDLY, xdatdly) |\
    HFIELD_SHIFT(HMCBSP_XCR_XFIG,    xfig)    |\
    HFIELD_SHIFT(HMCBSP_XCR_XCOMPAND,xcompand)|\
    HFIELD_SHIFT(HMCBSP_XCR_XWDLEN2, xwdlen2) |\
    HFIELD_SHIFT(HMCBSP_XCR_XFRLEN2, xfrlen2) |\
    HFIELD_SHIFT(HMCBSP_XCR_XPHASE,  xphase)   \
  )

/******************************************************************************\
* HMCBSP_SRGR0 - serial port 0 sample rate generator register
* HMCBSP_SRGR1 - serial port 1 sample rate generator register
* HMCBSP_SRGR2 - serial port 2 sample rate generator register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*   (RW) HMCBSP_SRGR_CLKGDV
*   (RW) HMCBSP_SRGR_FWID
*   (RW) HMCBSP_SRGR_FPER
*   (RW) HMCBSP_SRGR_FSGM
*   (RW) HMCBSP_SRGR_CLKSM
*   (RW) HMCBSP_SRGR_CLKSP
*   (RW) HMCBSP_SRGR_GSYNC
*
\******************************************************************************/
  #define HMCBSP_SRGR0_ADDR                    (HMCBSP_BASE0_ADDR+0x0014)
  #define HMCBSP_SRGR1_ADDR                    (HMCBSP_BASE1_ADDR+0x0014)
  #define HMCBSP_SRGR0                         REG32(HMCBSP_SRGR0_ADDR)
  #define HMCBSP_SRGR1                         REG32(HMCBSP_SRGR1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_SRGR2_ADDR                    (HMCBSP_BASE2_ADDR+0x0014)
  #define HMCBSP_SRGR2                         REG32(HMCBSP_SRGR2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SRGR_CLKGDV
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SRGR_CLKGDV_MASK              (0x000000FF)
  #define HMCBSP_SRGR_CLKGDV_SHIFT             (0x00000000)
  
  #define HMCBSP_SRGR_CLKGDV_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SRGR_CLKGDV)

  #define HMCBSP_SRGR_CLKGDV_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SRGR_CLKGDV,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SRGR_FWID
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SRGR_FWID_MASK                (0x0000FF00)
  #define HMCBSP_SRGR_FWID_SHIFT               (0x00000008)

  #define HMCBSP_SRGR_FWID_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SRGR_FWID)

  #define HMCBSP_SRGR_FWID_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SRGR_FWID,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SRGR_FPER
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SRGR_FPER_MASK                (0x0FFF0000)
  #define HMCBSP_SRGR_FPER_SHIFT               (0x00000010)

  #define HMCBSP_SRGR_FPER_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SRGR_FPER)

  #define HMCBSP_SRGR_FPER_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SRGR_FPER,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SRGR_FSGM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SRGR_FSGM_MASK                (0x10000000)
  #define HMCBSP_SRGR_FSGM_SHIFT               (0x0000001C)

  #define HMCBSP_SRGR_FSGM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SRGR_FSGM)

  #define HMCBSP_SRGR_FSGM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SRGR_FSGM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SRGR_CLKSM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SRGR_CLKSM_MASK               (0x20000000)
  #define HMCBSP_SRGR_CLKSM_SHIFT              (0x0000001D)

  #define HMCBSP_SRGR_CLKSM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SRGR_CLKSM)

  #define HMCBSP_SRGR_CLKSM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SRGR_CLKSM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SRGR_CLKSP
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SRGR_CLKSP_MASK               (0x40000000)
  #define HMCBSP_SRGR_CLKSP_SHIFT              (0x0000001E)

  #define HMCBSP_SRGR_CLKSP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SRGR_CLKSP)

  #define HMCBSP_SRGR_CLKSP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SRGR_CLKSP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SRGR_GSYNC
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SRGR_GSYNC_MASK               (0x80000000)
  #define HMCBSP_SRGR_GSYNC_SHIFT              (0x0000001F)

  #define HMCBSP_SRGR_GSYNC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_SRGR_GSYNC)

  #define HMCBSP_SRGR_GSYNC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_SRGR_GSYNC,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_SRGR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_SRGR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HMCBSP_SRGR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_SRGR_CFG(RegAddr,clkgdv,fwid,fper,fsgm,clksm,clksp,gsync) \
  REG32(RegAddr)=(UINT32)( \
    HFIELD_SHIFT(HMCBSP_SRGR_CLKGDV ,  clkgdv )|\
    HFIELD_SHIFT(HMCBSP_SRGR_FWID   ,  fwid   )|\
    HFIELD_SHIFT(HMCBSP_SRGR_FPER   ,  fper   )|\
    HFIELD_SHIFT(HMCBSP_SRGR_FSGM   ,  fsgm   )|\
    HFIELD_SHIFT(HMCBSP_SRGR_CLKSM  ,  clksm  )|\
    HFIELD_SHIFT(HMCBSP_SRGR_CLKSP  ,  clksp  )|\
    HFIELD_SHIFT(HMCBSP_SRGR_GSYNC  ,  gsync  ) \
  )

/******************************************************************************\
* HMCBSP_MCR0  - serial port 0 multichannel control register
* HMCBSP_MCR1  - serial port 1 multichannel control register
* HMCBSP_MCR2  - serial port 2 multichannel control register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*   (RW) HMCBSP_MCR_RMCM
*   (R)  HMCBSP_MCR_RCBLK
*   (RW) HMCBSP_MCR_RPABLK
*   (RW) HMCBSP_MCR_RPBBLK
*   (RW) HMCBSP_MCR_XMCM
*   (R)  HMCBSP_MCR_XCBLK
*   (RW) HMCBSP_MCR_XPABLK
*   (RW) HMCBSP_MCR_XPBBLK
*
\******************************************************************************/
  #define HMCBSP_MCR0_ADDR                     (HMCBSP_BASE0_ADDR+0x0018)
  #define HMCBSP_MCR1_ADDR                     (HMCBSP_BASE1_ADDR+0x0018)
  #define HMCBSP_MCR0                          REG32(HMCBSP_MCR0_ADDR)
  #define HMCBSP_MCR1                          REG32(HMCBSP_MCR1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_MCR2_ADDR                     (HMCBSP_BASE2_ADDR+0x0018)
  #define HMCBSP_MCR2                          REG32(HMCBSP_MCR2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_MCR_RMCM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_RMCM_MASK                 (0x00000001)
  #define HMCBSP_MCR_RMCM_SHIFT                (0x00000000)

  #define HMCBSP_MCR_RMCM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_MCR_RMCM)

  #define HMCBSP_MCR_RMCM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_MCR_RMCM,Val)

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_MCR_RCBLK
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_RCBLK_MASK                (0x0000001C)
  #define HMCBSP_MCR_RCBLK_SHIFT               (0x00000002)

  #define HMCBSP_MCR_RCBLK_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_MCR_RCBLK)

  #define HMCBSP_MCR_RCBLK_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_MCR_RCBLK,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_MCR_RPABLK
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_RPABLK_MASK               (0x00000060)
  #define HMCBSP_MCR_RPABLK_SHIFT              (0x00000005)

  #define HMCBSP_MCR_RPABLK_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_MCR_RPABLK)

  #define HMCBSP_MCR_RPABLK_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_MCR_RPABLK,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_MCR_RPBBLK
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_RPBBLK_MASK               (0x00000180)
  #define HMCBSP_MCR_RPBBLK_SHIFT              (0x00000007)

  #define HMCBSP_MCR_RPBBLK_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_MCR_RPBBLK)

  #define HMCBSP_MCR_RPBBLK_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_MCR_RPBBLK,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_MCR_XMCM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_XMCM_MASK                 (0x00030000)
  #define HMCBSP_MCR_XMCM_SHIFT                (0x00000010)

  #define HMCBSP_MCR_XMCM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_MCR_XMCM)

  #define HMCBSP_MCR_XMCM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_MCR_XMCM,Val)

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_MCR_XCBLK
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_XCBLK_MASK                (0x001C0000)
  #define HMCBSP_MCR_XCBLK_SHIFT               (0x00000012)

  #define HMCBSP_MCR_XCBLK_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_MCR_XCBLK)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_MCR_XPABLK
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_XPABLK_MASK               (0x00600000)
  #define HMCBSP_MCR_XPABLK_SHIFT              (0x00000015)

  #define HMCBSP_MCR_XPABLK_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_MCR_XPABLK)

  #define HMCBSP_MCR_XPABLK_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_MCR_XPABLK,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_MCR_XPBBLK
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_XPBBLK_MASK               (0x01800000)
  #define HMCBSP_MCR_XPBBLK_SHIFT              (0x00000017)

  #define HMCBSP_MCR_XPBBLK_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_MCR_XPBBLK)

  #define HMCBSP_MCR_XPBBLK_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_MCR_XPBBLK,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_MCR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_MCR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HMCBSP_MCR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_MCR_CFG(RegAddr,rmcm,rpablk,rpbblk,xmcm,xpablk,xpbblk) \
  REG32(RegAddr)=(UINT32)( \
    HFIELD_SHIFT(HMCBSP_MCR_RMCM  ,rmcm  )|\
    HFIELD_SHIFT(HMCBSP_MCR_RPABLK,rpablk)|\
    HFIELD_SHIFT(HMCBSP_MCR_RPBBLK,rpbblk)|\
    HFIELD_SHIFT(HMCBSP_MCR_XMCM  ,xmcm  )|\
    HFIELD_SHIFT(HMCBSP_MCR_XPABLK,xpablk)|\
    HFIELD_SHIFT(HMCBSP_MCR_XPBBLK,xpbblk) \
  )

/******************************************************************************\
* HMCBSP_RCER0 - serial port 0 receive channel enable register
* HMCBSP_RCER1 - serial port 1 receive channel enable register
* HMCBSP_RCER2 - serial port 2 receive channel enable register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*
\******************************************************************************/
  #define HMCBSP_RCER0_ADDR                    (HMCBSP_BASE0_ADDR+0x001C)
  #define HMCBSP_RCER1_ADDR                    (HMCBSP_BASE1_ADDR+0x001C)
  #define HMCBSP_RCER0                         REG32(HMCBSP_RCER0_ADDR)
  #define HMCBSP_RCER1                         REG32(HMCBSP_RCER1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_RCER2_ADDR                    (HMCBSP_BASE2_ADDR+0x001C)
  #define HMCBSP_RCER2                         REG32(HMCBSP_RCER2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA0
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA0_MASK               (0x00000001)
  #define HMCBSP_RCER_RCEA0_SHIFT              (0x00000000)

  #define HMCBSP_RCER_RCEA0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA0)

  #define HMCBSP_RCER_RCEA0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA1
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA1_MASK               (0x00000002)
  #define HMCBSP_RCER_RCEA1_SHIFT              (0x00000001)

  #define HMCBSP_RCER_RCEA1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA1)

  #define HMCBSP_RCER_RCEA1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA2
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA2_MASK               (0x00000004)
  #define HMCBSP_RCER_RCEA2_SHIFT              (0x00000002)

  #define HMCBSP_RCER_RCEA2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA2)

  #define HMCBSP_RCER_RCEA2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA3
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA3_MASK               (0x00000008)
  #define HMCBSP_RCER_RCEA3_SHIFT              (0x00000003)

  #define HMCBSP_RCER_RCEA3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA3)

  #define HMCBSP_RCER_RCEA3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA4
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA4_MASK               (0x00000010)
  #define HMCBSP_RCER_RCEA4_SHIFT              (0x00000004)

  #define HMCBSP_RCER_RCEA4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA4)

  #define HMCBSP_RCER_RCEA4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA5
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA5_MASK               (0x00000020)
  #define HMCBSP_RCER_RCEA5_SHIFT              (0x00000005)

  #define HMCBSP_RCER_RCEA5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA5)

  #define HMCBSP_RCER_RCEA5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA6
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA6_MASK               (0x00000040)
  #define HMCBSP_RCER_RCEA6_SHIFT              (0x00000006)

  #define HMCBSP_RCER_RCEA6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA6)

  #define HMCBSP_RCER_RCEA6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA7
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA7_MASK               (0x00000080)
  #define HMCBSP_RCER_RCEA7_SHIFT              (0x00000007)

  #define HMCBSP_RCER_RCEA7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA7)

  #define HMCBSP_RCER_RCEA7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA8
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA8_MASK               (0x00000100)
  #define HMCBSP_RCER_RCEA8_SHIFT              (0x00000008)

  #define HMCBSP_RCER_RCEA8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA8)

  #define HMCBSP_RCER_RCEA8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA9
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA9_MASK               (0x00000200)
  #define HMCBSP_RCER_RCEA9_SHIFT              (0x00000009)

  #define HMCBSP_RCER_RCEA9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA9)

  #define HMCBSP_RCER_RCEA9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA10
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA10_MASK              (0x00000400)
  #define HMCBSP_RCER_RCEA10_SHIFT             (0x0000000A)

  #define HMCBSP_RCER_RCEA10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA10)

  #define HMCBSP_RCER_RCEA10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA11
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA11_MASK              (0x00000800)
  #define HMCBSP_RCER_RCEA11_SHIFT             (0x0000000B)

  #define HMCBSP_RCER_RCEA11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA11)

  #define HMCBSP_RCER_RCEA11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA12
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA12_MASK              (0x00001000)
  #define HMCBSP_RCER_RCEA12_SHIFT             (0x0000000C)

  #define HMCBSP_RCER_RCEA12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA12)

  #define HMCBSP_RCER_RCEA12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA13
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA13_MASK              (0x00002000)
  #define HMCBSP_RCER_RCEA13_SHIFT             (0x0000000D)

  #define HMCBSP_RCER_RCEA13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA13)

  #define HMCBSP_RCER_RCEA13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA14
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA14_MASK              (0x00004000)
  #define HMCBSP_RCER_RCEA14_SHIFT             (0x0000000E)

  #define HMCBSP_RCER_RCEA14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA14)

  #define HMCBSP_RCER_RCEA14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEA15
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEA15_MASK              (0x00008000)
  #define HMCBSP_RCER_RCEA15_SHIFT             (0x0000000F)

  #define HMCBSP_RCER_RCEA15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEA15)

  #define HMCBSP_RCER_RCEA15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEA15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB0
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB0_MASK               (0x00010000)
  #define HMCBSP_RCER_RCEB0_SHIFT              (0x00000010)
  
  #define HMCBSP_RCER_RCEB0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB0)

  #define HMCBSP_RCER_RCEB0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB1
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB1_MASK               (0x00020000)
  #define HMCBSP_RCER_RCEB1_SHIFT              (0x00000011)
  
  #define HMCBSP_RCER_RCEB1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB1)

  #define HMCBSP_RCER_RCEB1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB2
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB2_MASK               (0x00040000)
  #define HMCBSP_RCER_RCEB2_SHIFT              (0x00000012)
  
  #define HMCBSP_RCER_RCEB2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB2)

  #define HMCBSP_RCER_RCEB2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB3
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB3_MASK               (0x00080000)
  #define HMCBSP_RCER_RCEB3_SHIFT              (0x00000013)
  
  #define HMCBSP_RCER_RCEB3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB3)

  #define HMCBSP_RCER_RCEB3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB4
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB4_MASK               (0x00100000)
  #define HMCBSP_RCER_RCEB4_SHIFT              (0x00000014)
  
  #define HMCBSP_RCER_RCEB4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB4)

  #define HMCBSP_RCER_RCEB4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB5
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB5_MASK               (0x00200000)
  #define HMCBSP_RCER_RCEB5_SHIFT              (0x00000015)
  
  #define HMCBSP_RCER_RCEB5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB5)

  #define HMCBSP_RCER_RCEB5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB6
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB6_MASK               (0x00400000)
  #define HMCBSP_RCER_RCEB6_SHIFT              (0x00000016)
  
  #define HMCBSP_RCER_RCEB6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB6)

  #define HMCBSP_RCER_RCEB6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB7
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB7_MASK               (0x00800000)
  #define HMCBSP_RCER_RCEB7_SHIFT              (0x00000017)
  
  #define HMCBSP_RCER_RCEB7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB7)

  #define HMCBSP_RCER_RCEB7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB8
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB8_MASK               (0x01000000)
  #define HMCBSP_RCER_RCEB8_SHIFT              (0x00000018)
  
  #define HMCBSP_RCER_RCEB8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB8)

  #define HMCBSP_RCER_RCEB8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB9
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB9_MASK               (0x02000000)
  #define HMCBSP_RCER_RCEB9_SHIFT              (0x00000019)
  
  #define HMCBSP_RCER_RCEB9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB9)

  #define HMCBSP_RCER_RCEB9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB10
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB10_MASK              (0x04000000)
  #define HMCBSP_RCER_RCEB10_SHIFT             (0x0000001A)
  
  #define HMCBSP_RCER_RCEB10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB10)

  #define HMCBSP_RCER_RCEB10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB11
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB11_MASK              (0x08000000)
  #define HMCBSP_RCER_RCEB11_SHIFT             (0x0000001B)
  
  #define HMCBSP_RCER_RCEB11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB11)

  #define HMCBSP_RCER_RCEB11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB12
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB12_MASK              (0x10000000)
  #define HMCBSP_RCER_RCEB12_SHIFT             (0x0000001C)
  
  #define HMCBSP_RCER_RCEB12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB12)

  #define HMCBSP_RCER_RCEB12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB13
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB13_MASK              (0x20000000)
  #define HMCBSP_RCER_RCEB13_SHIFT             (0x0000001D)
  
  #define HMCBSP_RCER_RCEB13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB13)

  #define HMCBSP_RCER_RCEB13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB14
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB14_MASK              (0x40000000)
  #define HMCBSP_RCER_RCEB14_SHIFT             (0x0000001E)
  
  #define HMCBSP_RCER_RCEB14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB14)

  #define HMCBSP_RCER_RCEB14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER_RCEB15
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_RCEB15_MASK              (0x80000000)
  #define HMCBSP_RCER_RCEB15_SHIFT             (0x0000001F)
  
  #define HMCBSP_RCER_RCEB15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_RCER_RCEB15)

  #define HMCBSP_RCER_RCEB15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_RCER_RCEB15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_RCER
\*----------------------------------------------------------------------------*/
  #define HMCBSP_RCER_GET(RegAddr) HREG32_GET(RegAddr)
  #define HMCBSP_RCER_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_RCER_CFG(RegAddr,rcea0,rcea1,rcea2,rcea3,rcea4,rcea5,rcea6,\
  rcea7,rcea8,rcea9,rcea10,rcea11,rcea12,rcea13,rcea14,rcea15,rceb0,rceb1,\
  rceb2,rceb3,rceb4,rceb5,rceb6,rceb7,rceb8,rceb9,rceb10,rceb11,rceb12,rceb13,\
  rceb14,rceb15) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA0, rcea0 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA1, rcea1 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA2, rcea2 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA3, rcea3 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA4, rcea4 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA5, rcea5 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA6, rcea6 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA7, rcea7 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA8, rcea8 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA9, rcea9 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA10,rcea10)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA11,rcea11)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA12,rcea12)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA13,rcea13)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA14,rcea14)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEA15,rcea15)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB0, rceb0 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB1, rceb1 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB2, rceb2 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB3, rceb3 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB4, rceb4 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB5, rceb5 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB6, rceb6 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB7, rceb7 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB8, rceb8 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB9, rceb9 )|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB10,rceb10)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB11,rceb11)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB12,rceb12)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB13,rceb13)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB14,rceb14)|\
    HFIELD_SHIFT(HMCBSP_RCER_RCEB15,rceb15) \
  )

/******************************************************************************\
* HMCBSP_XCER0 - serial port 0 transmit channel enable register
* HMCBSP_XCER1 - serial port 1 transmit channel enable register
* HMCBSP_XCER2 - serial port 2 transmit channel enable register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*
\******************************************************************************/
  #define HMCBSP_XCER0_ADDR                    (HMCBSP_BASE0_ADDR+0x0020)
  #define HMCBSP_XCER1_ADDR                    (HMCBSP_BASE1_ADDR+0x0020)
  #define HMCBSP_XCER0                         REG32(HMCBSP_XCER0_ADDR)
  #define HMCBSP_XCER1                         REG32(HMCBSP_XCER1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_XCER2_ADDR                    (HMCBSP_BASE2_ADDR+0x0020)
  #define HMCBSP_XCER2                         REG32(HMCBSP_XCER2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA0
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA0_MASK               (0x00000001)
  #define HMCBSP_XCER_XCEA0_SHIFT              (0x00000000)

  #define HMCBSP_XCER_XCEA0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA0)

  #define HMCBSP_XCER_XCEA0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA1
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA1_MASK               (0x00000002)
  #define HMCBSP_XCER_XCEA1_SHIFT              (0x00000001)

  #define HMCBSP_XCER_XCEA1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA1)

  #define HMCBSP_XCER_XCEA1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA2
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA2_MASK               (0x00000004)
  #define HMCBSP_XCER_XCEA2_SHIFT              (0x00000002)

  #define HMCBSP_XCER_XCEA2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA2)

  #define HMCBSP_XCER_XCEA2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA3
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA3_MASK               (0x00000008)
  #define HMCBSP_XCER_XCEA3_SHIFT              (0x00000003)

  #define HMCBSP_XCER_XCEA3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA3)

  #define HMCBSP_XCER_XCEA3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA4
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA4_MASK               (0x00000010)
  #define HMCBSP_XCER_XCEA4_SHIFT              (0x00000004)

  #define HMCBSP_XCER_XCEA4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA4)

  #define HMCBSP_XCER_XCEA4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA5
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA5_MASK               (0x00000020)
  #define HMCBSP_XCER_XCEA5_SHIFT              (0x00000005)

  #define HMCBSP_XCER_XCEA5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA5)

  #define HMCBSP_XCER_XCEA5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA6
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA6_MASK               (0x00000040)
  #define HMCBSP_XCER_XCEA6_SHIFT              (0x00000006)

  #define HMCBSP_XCER_XCEA6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA6)

  #define HMCBSP_XCER_XCEA6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA7
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA7_MASK               (0x00000080)
  #define HMCBSP_XCER_XCEA7_SHIFT              (0x00000007)

  #define HMCBSP_XCER_XCEA7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA7)

  #define HMCBSP_XCER_XCEA7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA8
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA8_MASK               (0x00000100)
  #define HMCBSP_XCER_XCEA8_SHIFT              (0x00000008)

  #define HMCBSP_XCER_XCEA8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA8)

  #define HMCBSP_XCER_XCEA8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA9
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA9_MASK               (0x00000200)
  #define HMCBSP_XCER_XCEA9_SHIFT              (0x00000009)

  #define HMCBSP_XCER_XCEA9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA9)

  #define HMCBSP_XCER_XCEA9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA10
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA10_MASK              (0x00000400)
  #define HMCBSP_XCER_XCEA10_SHIFT             (0x0000000A)

  #define HMCBSP_XCER_XCEA10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA10)

  #define HMCBSP_XCER_XCEA10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA11
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA11_MASK              (0x00000800)
  #define HMCBSP_XCER_XCEA11_SHIFT             (0x0000000B)

  #define HMCBSP_XCER_XCEA11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA11)

  #define HMCBSP_XCER_XCEA11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA12
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA12_MASK              (0x00001000)
  #define HMCBSP_XCER_XCEA12_SHIFT             (0x0000000C)

  #define HMCBSP_XCER_XCEA12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA12)

  #define HMCBSP_XCER_XCEA12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA13
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA13_MASK              (0x00002000)
  #define HMCBSP_XCER_XCEA13_SHIFT             (0x0000000D)

  #define HMCBSP_XCER_XCEA13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA13)

  #define HMCBSP_XCER_XCEA13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA14
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA14_MASK              (0x00004000)
  #define HMCBSP_XCER_XCEA14_SHIFT             (0x0000000E)

  #define HMCBSP_XCER_XCEA14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA14)

  #define HMCBSP_XCER_XCEA14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEA15
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEA15_MASK              (0x00008000)
  #define HMCBSP_XCER_XCEA15_SHIFT             (0x0000000F)

  #define HMCBSP_XCER_XCEA15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEA15)

  #define HMCBSP_XCER_XCEA15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEA15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB0
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB0_MASK               (0x00010000)
  #define HMCBSP_XCER_XCEB0_SHIFT              (0x00000010)
  
  #define HMCBSP_XCER_XCEB0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB0)

  #define HMCBSP_XCER_XCEB0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB1
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB1_MASK               (0x00020000)
  #define HMCBSP_XCER_XCEB1_SHIFT              (0x00000011)
  
  #define HMCBSP_XCER_XCEB1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB1)

  #define HMCBSP_XCER_XCEB1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB2
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB2_MASK               (0x00040000)
  #define HMCBSP_XCER_XCEB2_SHIFT              (0x00000012)
  
  #define HMCBSP_XCER_XCEB2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB2)

  #define HMCBSP_XCER_XCEB2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB3
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB3_MASK               (0x00080000)
  #define HMCBSP_XCER_XCEB3_SHIFT              (0x00000013)
  
  #define HMCBSP_XCER_XCEB3_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB3)

  #define HMCBSP_XCER_XCEB3_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB3,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB4
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB4_MASK               (0x00100000)
  #define HMCBSP_XCER_XCEB4_SHIFT              (0x00000014)
  
  #define HMCBSP_XCER_XCEB4_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB4)

  #define HMCBSP_XCER_XCEB4_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB4,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB5
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB5_MASK               (0x00200000)
  #define HMCBSP_XCER_XCEB5_SHIFT              (0x00000015)
  
  #define HMCBSP_XCER_XCEB5_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB5)

  #define HMCBSP_XCER_XCEB5_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB5,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB6
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB6_MASK               (0x00400000)
  #define HMCBSP_XCER_XCEB6_SHIFT              (0x00000016)
  
  #define HMCBSP_XCER_XCEB6_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB6)

  #define HMCBSP_XCER_XCEB6_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB6,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB7
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB7_MASK               (0x00800000)
  #define HMCBSP_XCER_XCEB7_SHIFT              (0x00000017)
  
  #define HMCBSP_XCER_XCEB7_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB7)

  #define HMCBSP_XCER_XCEB7_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB7,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB8
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB8_MASK               (0x01000000)
  #define HMCBSP_XCER_XCEB8_SHIFT              (0x00000018)
  
  #define HMCBSP_XCER_XCEB8_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB8)

  #define HMCBSP_XCER_XCEB8_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB8,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB9
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB9_MASK               (0x02000000)
  #define HMCBSP_XCER_XCEB9_SHIFT              (0x00000019)
  
  #define HMCBSP_XCER_XCEB9_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB9)

  #define HMCBSP_XCER_XCEB9_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB9,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB10
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB10_MASK              (0x04000000)
  #define HMCBSP_XCER_XCEB10_SHIFT             (0x0000001A)
  
  #define HMCBSP_XCER_XCEB10_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB10)

  #define HMCBSP_XCER_XCEB10_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB10,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB11
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB11_MASK              (0x08000000)
  #define HMCBSP_XCER_XCEB11_SHIFT             (0x0000001B)
  
  #define HMCBSP_XCER_XCEB11_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB11)

  #define HMCBSP_XCER_XCEB11_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB11,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB12
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB12_MASK              (0x10000000)
  #define HMCBSP_XCER_XCEB12_SHIFT             (0x0000001C)
  
  #define HMCBSP_XCER_XCEB12_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB12)

  #define HMCBSP_XCER_XCEB12_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB12,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB13
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB13_MASK              (0x20000000)
  #define HMCBSP_XCER_XCEB13_SHIFT             (0x0000001D)
  
  #define HMCBSP_XCER_XCEB13_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB13)

  #define HMCBSP_XCER_XCEB13_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB13,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB14
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB14_MASK              (0x40000000)
  #define HMCBSP_XCER_XCEB14_SHIFT             (0x0000001E)
  
  #define HMCBSP_XCER_XCEB14_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB14)

  #define HMCBSP_XCER_XCEB14_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB14,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER_XCEB15
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_XCEB15_MASK              (0x80000000)
  #define HMCBSP_XCER_XCEB15_SHIFT             (0x0000001F)
  
  #define HMCBSP_XCER_XCEB15_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_XCER_XCEB15)

  #define HMCBSP_XCER_XCEB15_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_XCER_XCEB15,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_XCER
\*----------------------------------------------------------------------------*/
  #define HMCBSP_XCER_GET(RegAddr) HREG32_GET(RegAddr)
  #define HMCBSP_XCER_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_XCER_CFG(RegAddr,xcea0,xcea1,xcea2,xcea3,xcea4,xcea5,xcea6,\
  xcea7,xcea8,xcea9,xcea10,xcea11,xcea12,xcea13,xcea14,xcea15,xceb0,xceb1,\
  xceb2,xceb3,xceb4,xceb5,xceb6,xceb7,xceb8,xceb9,xceb10,xceb11,xceb12,xceb13,\
  xceb14,xceb15) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA0, xcea0 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA1, xcea1 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA2, xcea2 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA3, xcea3 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA4, xcea4 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA5, xcea5 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA6, xcea6 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA7, xcea7 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA8, xcea8 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA9, xcea9 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA10,xcea10)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA11,xcea11)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA12,xcea12)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA13,xcea13)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA14,xcea14)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEA15,xcea15)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB0, xceb0 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB1, xceb1 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB2, xceb2 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB3, xceb3 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB4, xceb4 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB5, xceb5 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB6, xceb6 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB7, xceb7 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB8, xceb8 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB9, xceb9 )|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB10,xceb10)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB11,xceb11)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB12,xceb12)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB13,xceb13)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB14,xceb14)|\
    HFIELD_SHIFT(HMCBSP_XCER_XCEB15,xceb15) \
  )

/******************************************************************************\
* HMCBSP_PCR0  - serial port 0 pin control register
* HMCBSP_PCR1  - serial port 1 pin control register
* HMCBSP_PCR2  - serial port 2 pin control register (1)
*
* (1) only on devices with three serial ports
*
* Fields:
*   (RW) HMCBSP_PCR_CLKRP
*   (RW) HMCBSP_PCR_CLKXP
*   (RW) HMCBSP_PCR_FSRP
*   (RW) HMCBSP_PCR_FSXP
*   (R)  HMCBSP_PCR_DRSTAT
*   (RW) HMCBSP_PCR_DXSTAT
*   (RW) HMCBSP_PCR_CLKSSTAT
*   (RW) HMCBSP_PCR_CLKRM
*   (RW) HMCBSP_PCR_CLKXM
*   (RW) HMCBSP_PCR_FSRM
*   (RW) HMCBSP_PCR_FSXM
*   (RW) HMCBSP_PCR_RIOEN
*   (RW) HMCBSP_PCR_XIOEN
*
\******************************************************************************/
  #define HMCBSP_PCR0_ADDR                     (HMCBSP_BASE0_ADDR+0x0024)
  #define HMCBSP_PCR1_ADDR                     (HMCBSP_BASE1_ADDR+0x0024)
  #define HMCBSP_PCR0                          REG32(HMCBSP_PCR0_ADDR)
  #define HMCBSP_PCR1                          REG32(HMCBSP_PCR1_ADDR)

#if (HMCBSP_PORT_CNT==3)
  #define HMCBSP_PCR2_ADDR                     (HMCBSP_BASE2_ADDR+0x0024)
  #define HMCBSP_PCR2                          REG32(HMCBSP_PCR2_ADDR)
#endif

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_CLKRP
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_CLKRP_MASK                (0x00000001)
  #define HMCBSP_PCR_CLKRP_SHIFT               (0x00000000)

  #define HMCBSP_PCR_CLKRP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_CLKRP)

  #define HMCBSP_PCR_CLKRP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_CLKRP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_CLKXP
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_CLKXP_MASK                (0x00000002)
  #define HMCBSP_PCR_CLKXP_SHIFT               (0x00000001)

  #define HMCBSP_PCR_CLKXP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_CLKXP)

  #define HMCBSP_PCR_CLKXP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_CLKXP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_FSRP
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_FSRP_MASK                 (0x00000004)
  #define HMCBSP_PCR_FSRP_SHIFT                (0x00000002)

  #define HMCBSP_PCR_FSRP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_FSRP)

  #define HMCBSP_PCR_FSRP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_FSRP,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_FSXP
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_FSXP_MASK                 (0x00000008)
  #define HMCBSP_PCR_FSXP_SHIFT                (0x00000003)

  #define HMCBSP_PCR_FSXP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_FSXP)

  #define HMCBSP_PCR_FSXP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_FSXP,Val)

/*----------------------------------------------------------------------------*\
* (R) HMCBSP_PCR_DTSTAT
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_DRSTAT_MASK               (0x00000010)
  #define HMCBSP_PCR_DRSTAT_SHIFT              (0x00000004)

  #define HMCBSP_PCR_DRSTAT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_DRSTAT)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_DXSTAT
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_DXSTAT_MASK               (0x00000020)
  #define HMCBSP_PCR_DXSTAT_SHIFT              (0x00000005)

  #define HMCBSP_PCR_DXSTAT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_DXSTAT)

  #define HMCBSP_PCR_DXSTAT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_DXSTAT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_CLKSSTAT
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_CLKSSTAT_MASK             (0x00000040)
  #define HMCBSP_PCR_CLKSSTAT_SHIFT            (0x00000006)

  #define HMCBSP_PCR_CLKSSTAT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_CLKSSTAT)

  #define HMCBSP_PCR_CLKSSTAT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_CLKSSTAT,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_CLKRM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_CLKRM_MASK                (0x00000100)
  #define HMCBSP_PCR_CLKRM_SHIFT               (0x00000008)

  #define HMCBSP_PCR_CLKRM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_CLKRM)

  #define HMCBSP_PCR_CLKRM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_CLKRM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_CLKXM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_CLKXM_MASK                (0x00000200)
  #define HMCBSP_PCR_CLKXM_SHIFT               (0x00000009)

  #define HMCBSP_PCR_CLKXM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_CLKXM)

  #define HMCBSP_PCR_CLKXM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_CLKXM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_FSRM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_FSRM_MASK                 (0x00000400)
  #define HMCBSP_PCR_FSRM_SHIFT                (0x0000000A)

  #define HMCBSP_PCR_FSRM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_FSRM)

  #define HMCBSP_PCR_FSRM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_FSRM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_FSXM
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_FSXM_MASK                 (0x00000800)
  #define HMCBSP_PCR_FSXM_SHIFT                (0x0000000B)

  #define HMCBSP_PCR_FSXM_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_FSXM)

  #define HMCBSP_PCR_FSXM_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_FSXM,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_RIOEN
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_RIOEN_MASK                (0x00001000)
  #define HMCBSP_PCR_RIOEN_SHIFT               (0x0000000C)

  #define HMCBSP_PCR_RIOEN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_RIOEN)

  #define HMCBSP_PCR_RIOEN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_RIOEN,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR_XIOEN
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_XIOEN_MASK                (0x00002000)
  #define HMCBSP_PCR_XIOEN_SHIFT               (0x0000000D)

  #define HMCBSP_PCR_XIOEN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HMCBSP_PCR_XIOEN)

  #define HMCBSP_PCR_XIOEN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HMCBSP_PCR_XIOEN,Val)

/*----------------------------------------------------------------------------*\
* (RW) HMCBSP_PCR
\*----------------------------------------------------------------------------*/
  #define HMCBSP_PCR_GET(RegAddr) HREG32_GET(RegAddr)
  #define HMCBSP_PCR_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)

  #define HMCBSP_PCR_CFG(RegAddr,clkrp,clkxp,fsrp,fsxp,dxstat,clksstat,clkrm,\
  clkxm,fsrm,fsxm,rioen,xioen) REG32(RegAddr)=(UINT32)(\
    HFIELD_SHIFT(HMCBSP_PCR_CLKRP   , clkrp   )|\
    HFIELD_SHIFT(HMCBSP_PCR_CLKXP   , clkxp   )|\
    HFIELD_SHIFT(HMCBSP_PCR_FSRP    , fsrp    )|\
    HFIELD_SHIFT(HMCBSP_PCR_FSXP    , fsxp    )|\
    HFIELD_SHIFT(HMCBSP_PCR_DXSTAT  , dxstat  )|\
    HFIELD_SHIFT(HMCBSP_PCR_CLKSSTAT, clksstat)|\
    HFIELD_SHIFT(HMCBSP_PCR_CLKRM   , clkrm   )|\
    HFIELD_SHIFT(HMCBSP_PCR_CLKXM   , clkxm   )|\
    HFIELD_SHIFT(HMCBSP_PCR_FSRM    , fsrm    )|\
    HFIELD_SHIFT(HMCBSP_PCR_FSXM    , fsxm    )|\
    HFIELD_SHIFT(HMCBSP_PCR_RIOEN   , rioen   )|\
    HFIELD_SHIFT(HMCBSP_PCR_XIOEN   , xioen   ) \
  )

/******************************************************************************/

#endif /* MCBSP_SUPPORT */
#endif /* _MCBSPHAL_H_ */
/******************************************************************************\
* End of mcbsphal.h
\******************************************************************************/

/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... pwrhal.h
* DATE CREATED.. 11/11/1999 
* LAST MODIFIED. 03/08/2000
*
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the PWR module)
*
* Registers Covered:
*   (RW) HPWR_PDCTL - power down control register (1)

*   (1) only on CHIP_6202, CHIP_6203
*
\******************************************************************************/
#ifndef _PWRHAL_H_
#define _PWRHAL_H_

#if (PWR_SUPPORT)
  #define HPWR_BASE_ADDR        (HCHIP_PERBASE_ADDR+0x001C0000)

/******************************************************************************\
* HPWR_PDCTL - power down control register (1)
*
* Fields:
*   (RW) HPWR_PDCTL_DMA
*   (RW) HPWR_PDCTL_EMIF
*   (RW) HPWR_PDCTL_MCBSP0
*   (RW) HPWR_PDCTL_MCBSP1
*   (RW) HPWR_PDCTL_MCBSP2
*
\******************************************************************************/
#if (CHIP_6202)
  #define HPWR_PDCTL_ADDR                      (HPWR_BASE_ADDR+0x0200)
  #define HPWR_PDCTL                           REG32(HPWR_PDCTL_ADDR)
#else
  #define HPWR_PDCTL_ADDR                      (HCHIP_NULL_ADDR)
  #define HPWR_PDCTL                           REG32(HPWR_PDCTL_ADDR)
#endif
  
/*----------------------------------------------------------------------------*\
* (RW) HPWR_PDCTL_DMA
\*----------------------------------------------------------------------------*/
  #define HPWR_PDCTL_DMA_MASK                  (0x00000001)
  #define HPWR_PDCTL_DMA_SHIFT                 (0x00000000)

  #define HPWR_PDCTL_DMA_GET(RegAddr) \
    HFIELD_GET(RegAddr,HPWR_PDCTL_DMA)

  #define HPWR_PDCTL_DMA_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HPWR_PDCTL_DMA,Val)

/*----------------------------------------------------------------------------*\
* (RW) HPWR_PDCTL_EMIF
\*----------------------------------------------------------------------------*/
  #define HPWR_PDCTL_EMIF_MASK                 (0x00000002)
  #define HPWR_PDCTL_EMIF_SHIFT                (0x00000001)

  #define HPWR_PDCTL_EMIF_GET(RegAddr) \
    HFIELD_GET(RegAddr,HPWR_PDCTL_EMIF)

  #define HPWR_PDCTL_EMIF_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HPWR_PDCTL_EMIF,Val)

/*----------------------------------------------------------------------------*\
* (RW) HPWR_PDCTL_MCBSP0
\*----------------------------------------------------------------------------*/
  #define HPWR_PDCTL_MCBSP0_MASK               (0x00000004)
  #define HPWR_PDCTL_MCBSP0_SHIFT              (0x00000002)
  
  #define HPWR_PDCTL_MCBSP0_GET(RegAddr) \
    HFIELD_GET(RegAddr,HPWR_PDCTL_MCBSP0)

  #define HPWR_PDCTL_MCBSP0_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HPWR_PDCTL_MCBSP0,Val)

/*----------------------------------------------------------------------------*\
* (RW) HPWR_PDCTL_MCBSP1
\*----------------------------------------------------------------------------*/
  #define HPWR_PDCTL_MCBSP1_MASK               (0x00000008)
  #define HPWR_PDCTL_MCBSP1_SHIFT              (0x00000003)
  
  #define HPWR_PDCTL_MCBSP1_GET(RegAddr) \
    HFIELD_GET(RegAddr,HPWR_PDCTL_MCBSP1)

  #define HPWR_PDCTL_MCBSP1_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HPWR_PDCTL_MCBSP1,Val)

/*----------------------------------------------------------------------------*\
* (RW) HPWR_PDCTL_MCBSP2
\*----------------------------------------------------------------------------*/
  #define HPWR_PDCTL_MCBSP2_MASK               (0x00000010)
  #define HPWR_PDCTL_MCBSP2_SHIFT              (0x00000004)
  
  #define HPWR_PDCTL_MCBSP2_GET(RegAddr) \
    HFIELD_GET(RegAddr,HPWR_PDCTL_MCBSP2)

  #define HPWR_PDCTL_MCBSP2_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HPWR_PDCTL_MCBSP2,Val)

/*----------------------------------------------------------------------------*\
* (RW) HPWR_PDCTL
\*----------------------------------------------------------------------------*/
  #define HPWR_PDCTL_GET(RegAddr) HREG32_GET(RegAddr)
  #define HPWR_PDCTL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HPWR_PDCTL_CFG(RegAddr,dma,emif,mcbsp0,mcbsp1,mcbsp2)\
  REG32(RegAddr) = (\
    HFIELD_SHIFT(HPWR_PDCTL_DMA,dma)|\
    HFIELD_SHIFT(HPWR_PDCTL_EMIF,emif)|\
    HFIELD_SHIFT(HPWR_PDCTL_MCBSP0,mcbsp0)|\
    HFIELD_SHIFT(HPWR_PDCTL_MCBSP1,mcbsp1)|\
    HFIELD_SHIFT(HPWR_PDCTL_MCBSP2,mcbsp2)\
  )

/*----------------------------------------------------------------------------*/

#endif /* PWR_SUPPORT */
#endif /* _PWRHAL_H_ */
/******************************************************************************\
* End of pwrhal.h
\******************************************************************************/

/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... timerhal.h
* DATE CREATED.. 06/20/1999 
* LAST MODIFIED. 03/08/2000
*   
*------------------------------------------------------------------------------
* DESCRIPTION:  (HAL interface file for the TIMER module)
*
* Registers Covered:
*   (RW) HTIMER_CTL0 - timer 0 control register
*   (RW) HTIMER_CTL1 - timer 1 control register
*   (RW) HTIMER_PRD0 - timer 0 period register
*   (RW) HTIMER_PRD1 - timer 1 perid register
*   (RW) HTIMER_CNT0 - timer 0 count register
*   (RW) HTIMER_CNT1 - timer 1 count register
*
\******************************************************************************/
#ifndef _TIMERHAL_H_
#define _TIMERHAL_H_

#if (TIMER_SUPPORT)
/*============================================================================*\
* misc declarations
\*============================================================================*/
#define HTIMER_BASE0_ADDR  (HCHIP_PERBASE_ADDR+0x00140000)
#define HTIMER_BASE1_ADDR  (HCHIP_PERBASE_ADDR+0x00180000)

#define HTIMER_DEVICE_CNT  (2)

/******************************************************************************\
* HTIMER_CTL0 - timer 0 control register
* HTIMER_CTL1 - timer 1 control register
*
* Fields:
*   (RW) HTIMER_CTL_FUNC
*   (RW) HTIMER_CTL_INVOUT
*   (RW) HTIMER_CTL_DATOUT
*   (RW) HTIMER_CTL_DATIN
*   (RW) HTIMER_CTL_PWID
*   (RW) HTIMER_CTL_GO
*   (RW) HTIMER_CTL_HLD
*   (RW) HTIMER_CTL_CP
*   (RW) HTIMER_CTL_CLKSRC
*   (RW) HTIMER_CTL_INVINP
*   (R)  HTIMER_CTL_TSTAT
*
\******************************************************************************/
  #define HTIMER_CTL0_ADDR                     (HTIMER_BASE0_ADDR+0x0000)
  #define HTIMER_CTL1_ADDR                     (HTIMER_BASE1_ADDR+0x0000)

  #define HTIMER_CTL0                          REG32(HTIMER_CTL0_ADDR)
  #define HTIMER_CTL1                          REG32(HTIMER_CTL1_ADDR)
  
/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_FUNC
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_FUNC_MASK                 (0x00000001)
  #define HTIMER_CTL_FUNC_SHIFT                (0x00000000)
  
  #define HTIMER_CTL_FUNC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_FUNC)

  #define HTIMER_CTL_FUNC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_FUNC,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_INVOUT
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_INVOUT_MASK               (0x00000002)
  #define HTIMER_CTL_INVOUT_SHIFT              (0x00000001)

  #define HTIMER_CTL_INVOUT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_INVOUT)

  #define HTIMER_CTL_INVOUT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_INVOUT,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_DATOUT
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_DATOUT_MASK               (0x00000004)
  #define HTIMER_CTL_DATOUT_SHIFT              (0x00000002)

  #define HTIMER_CTL_DATOUT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_DATOUT)

  #define HTIMER_CTL_DATOUT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_DATOUT,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_DATIN
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_DATIN_MASK                (0x00000008)
  #define HTIMER_CTL_DATIN_SHIFT               (0x00000003)

  #define HTIMER_CTL_DATIN_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_DATIN)

  #define HTIMER_CTL_DATIN_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_DATIN,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_PWID
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_PWID_MASK                 (0x00000010)
  #define HTIMER_CTL_PWID_SHIFT                (0x00000004)

  #define HTIMER_CTL_PWID_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_PWID)

  #define HTIMER_CTL_PWID_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_PWID,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_GO
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_GO_MASK                   (0x00000040)
  #define HTIMER_CTL_GO_SHIFT                  (0x00000006)

  #define HTIMER_CTL_GO_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_GO)

  #define HTIMER_CTL_GO_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_GO,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_HLD
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_HLD_MASK                  (0x00000080)
  #define HTIMER_CTL_HLD_SHIFT                 (0x00000007)

  #define HTIMER_CTL_HLD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_HLD)

  #define HTIMER_CTL_HLD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_HLD,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_CP
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_CP_MASK                   (0x00000100)
  #define HTIMER_CTL_CP_SHIFT                  (0x00000008)

  #define HTIMER_CTL_CP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_CP)

  #define HTIMER_CTL_CP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_CP,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_CLKSRC
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_CLKSRC_MASK               (0x00000200)
  #define HTIMER_CTL_CLKSRC_SHIFT              (0x00000009)

  #define HTIMER_CTL_CLKSRC_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_CLKSRC)

  #define HTIMER_CTL_CLKSRC_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_CLKSRC,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL_INVINP
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_INVINP_MASK               (0x00000400)
  #define HTIMER_CTL_INVINP_SHIFT              (0x0000000A)

  #define HTIMER_CTL_INVINP_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_INVINP)

  #define HTIMER_CTL_INVINP_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CTL_INVINP,Val)

/*----------------------------------------------------------------------------*\
* (R) TIMER_CTL_TSTAT
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_TSTAT_MASK                (0x00000800)
  #define HTIMER_CTL_TSTAT_SHIFT               (0x0000000B)

  #define HTIMER_CTL_TSTAT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CTL_TSTAT)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CTL
\*----------------------------------------------------------------------------*/
  #define HTIMER_CTL_GET(RegAddr) HREG32_GET(RegAddr)

  #define HTIMER_CTL_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HTIMER_CTL_CFG(RegAddr,func,invout,datout,datin,pwid,go,hld,cp,\
  clksrc,invinp) REG32(RegAddr) = (\
    HFIELD_SHIFT(HTIMER_CTL_FUNC,   func)   |\
    HFIELD_SHIFT(HTIMER_CTL_DATOUT, datout) |\
    HFIELD_SHIFT(HTIMER_CTL_DATIN,  datin)  |\
    HFIELD_SHIFT(HTIMER_CTL_GO,     go)     |\
    HFIELD_SHIFT(HTIMER_CTL_HLD,    hld)    |\
    HFIELD_SHIFT(HTIMER_CTL_CP,     cp)     |\
    HFIELD_SHIFT(HTIMER_CTL_PWID,   pwid)   |\
    HFIELD_SHIFT(HTIMER_CTL_CLKSRC, clksrc) |\
    HFIELD_SHIFT(HTIMER_CTL_INVINP, invinp) |\
    HFIELD_SHIFT(HTIMER_CTL_INVOUT, invout)  \
  )

/******************************************************************************\
* HTIMER_PRD0 - timer 0 period register
* HTIMER_PRD1 - timer 1 period register
*
* Fields:
*   (RW) PRD
*
\******************************************************************************/
  #define HTIMER_PRD0_ADDR                     (HTIMER_BASE0_ADDR+0x0004)
  #define HTIMER_PRD1_ADDR                     (HTIMER_BASE1_ADDR+0x0004)

  #define HTIMER_PRD0                          REG32(HTIMER_PRD0_ADDR)
  #define HTIMER_PRD1                          REG32(HTIMER_PRD1_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_PRD_PRD
\*----------------------------------------------------------------------------*/
  #define HTIMER_PRD_PRD_MASK                  (0xFFFFFFFF)
  #define HTIMER_PRD_PRD_SHIFT                 (0x00000000)
  
  #define HTIMER_PRD_PRD_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_PRD_PRD)

  #define HTIMER_PRD_PRD_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_PRD_PRD,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_PRD
\*----------------------------------------------------------------------------*/
  #define HTIMER_PRD_GET(RegAddr) HREG32_GET(RegAddr)

  #define HTIMER_PRD_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HTIMER_PRD_CFG(RegAddr,Prd) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HTIMER_PRD_RRD,prd) \
  )

/******************************************************************************\
* HTIMER_CNT0 - timer 0 count register
* HTIMER_CNT1 - timer 1 count register
*
* Fields:
*   (RW) CNT
*
\******************************************************************************/
  #define HTIMER_CNT0_ADDR                     (HTIMER_BASE0_ADDR+0x0008)
  #define HTIMER_CNT1_ADDR                     (HTIMER_BASE1_ADDR+0x0008)

  #define HTIMER_CNT0                          REG32(HTIMER_CNT0_ADDR)
  #define HTIMER_CNT1                          REG32(HTIMER_CNT1_ADDR)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CNT_CNT
\*----------------------------------------------------------------------------*/
  #define HTIMER_CNT_CNT_MASK                  (0xFFFFFFFF)
  #define HTIMER_CNT_CNT_SHIFT                 (0x00000000)

  #define HTIMER_CNT_CNT_GET(RegAddr) \
    HFIELD_GET(RegAddr,HTIMER_CNT_CNT)

  #define HTIMER_CNT_CNT_SET(RegAddr,Val) \
    HFIELD_SET(RegAddr,HTIMER_CNT_CNT,Val)

/*----------------------------------------------------------------------------*\
* (RW) TIMER_CNT
\*----------------------------------------------------------------------------*/
  #define HTIMER_CNT_GET(RegAddr) HREG32_GET(RegAddr)

  #define HTIMER_CNT_SET(RegAddr,Val) HREG32_SET(RegAddr,Val)
    
  #define HTIMER_CNT_CFG(RegAddr,Cnt) REG32(RegAddr) = (UINT32)( \
    HFIELD_SHIFT(HTIMER_CNT_CNT,cnt) \
  )

/*----------------------------------------------------------------------------*/

#endif /* TIMER_SUPPORT */
#endif /* _TIMERHAL_H_ */
/******************************************************************************\
* End of timerhal.h
\******************************************************************************/



#endif /* _CSL_LEGACYHAL_H_ */
/******************************************************************************\
* End of csl_legacyhal.h
\******************************************************************************/


csl_mcasp.h/    1091195463  0     0     0       64541     `
/******************************************************************************\
*           Copyright (C) 1999-2002 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mcasp.h
* DATE CREATED.. 08/10/2001 
* LAST MODIFIED. 02/25/2002  _write32, write32Cfg, read32, read32Cfg
*                02/14/2002  _getRbufAddrCfg()/_getXbufAddrCfg()
*                            MCASP_XBUFx / MCASP_RBUFx macros
*               
\******************************************************************************/
#ifndef _CSL_MCASP_H_
#define _CSL_MCASP_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_mcasphal.h>


#if (MCASP_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/

#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _MCASP_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/******************************************************************************\
* global macro declarations
\******************************************************************************/

/* MCASP_open() flags */
#define MCASP_OPEN_RESET     (0x00000001)


/* device identifiers for MCASP_open() */
#define MCASP_DEV0           (0) 
#if (_MCASP_PORT_CNT == 2)
  #define MCASP_DEV1         (1)
#endif


/* device identifiers for MCASP_open() */
#define MCASP_PORT0    MCASP_DEV0
#if (_MCASP_PORT_CNT == 2)
  #define MCASP_PORT1    MCASP_DEV1
#endif

/* select DIT vs. TDM mode */
#define  MCASP_XMT_DIT     1
#define  MCASP_XMT_TDM     0

/* direction = (transmitter only) MCASP_XMT or (receiver only) MCASP_RCV  */
/*             or (both) MCASP_RCVXMT / MCASP_XMTRCV */
#define MCASP_RCV       1
#define MCASP_XMT    	2
#define MCASP_RCVXMT	3
#define MCASP_XMTRCV	3

/* Mode for clk */
#define MCASP_CLK_ASYNC       1
#define MCASP_CLK_SYNC        0


/* define DSP representation */
//#define MCASP_DSP_INTEGER   0
//#define MCASP_DSP_Q31       1

/* define Mode BURST or TDM for format*/
#define MCASP_MODE_BURST    0
#define MCASP_MODE_TDM      1

/* define Mode MSB/LSB first */
#define MCASP_FORMAT_LSB    0
#define MCASP_FORMAT_MSB    1

/* define Align  */
#define MCASP_FORMAT_LEFT   0
#define MCASP_FORMAT_RIGHT  1
      

/* Address Incrementation */
#define MCASP_XBUF_BUFSIZE 4
#define MCASP_RBUF_BUFSIZE 4

#define MCASP_DITCSR_NUMCHANNELS 6
#define MCASP_DITCSR_BUFSIZE 4
#define MCASP_DITCSR_RIGHT_OFFSET (MCASP_DITCSR_BUFSIZE*MCASP_DITCSR_NUMCHANNELS)

#define MCASP_DITUDR_NUMCHANNELS 6
#define MCASP_DITUDR_BUFSIZE 4
#define MCASP_DITUDR_RIGHT_OFFSET (MCASP_DITUDR_BUFSIZE*MCASP_DITUDR_NUMCHANNELS)

/* Status clear */
#define MCASP_RSTAT_ROVRN       0
#define MCASP_RSTAT_RSYNCERR    1
#define MCASP_RSTAT_RCKFAIL     2
#define MCASP_RSTAT_REVENSLOT   3 
#define MCASP_RSTAT_RLAST       4
#define MCASP_RSTAT_RDATA       5
#define MCASP_RSTAT_RSTAFRM     6
#define MCASP_RSTAT_RDMAERR     7
#define MCASP_RSTAT_RERR        8

#define MCASP_XSTAT_XUNDRN      0
#define MCASP_XSTAT_XSYNCERR    1
#define MCASP_XSTAT_XCKFAIL     2
#define MCASP_XSTAT_XEVENSLOT   3 
#define MCASP_XSTAT_XLAST       4
#define MCASP_XSTAT_XDATA       5
#define MCASP_XSTAT_XSTAFRM     6
#define MCASP_XSTAT_XDMAERR     7
#define MCASP_XSTAT_XERR        8


#define MCASP_XBUF0              0
#define MCASP_XBUF1              1
#define MCASP_XBUF2              2 
#define MCASP_XBUF3              3
/* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define MCASP_XBUF4              4
  #define MCASP_XBUF5              5
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6)
  #define MCASP_XBUF6              6
  #define MCASP_XBUF7              7
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define MCASP_XBUF8              8
  #define MCASP_XBUF9              9
  #define MCASP_XBUF10             10
  #define MCASP_XBUF11             11 
  #define MCASP_XBUF12             12
  #define MCASP_XBUF13             13
  #define MCASP_XBUF14             14
  #define MCASP_XBUF15             15
#endif /* _MCASP_CHANNEL_CNT == 16 */

#define MCASP_RBUF0              0
#define MCASP_RBUF1              1
#define MCASP_RBUF2              2 
#define MCASP_RBUF3              3
/* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define MCASP_RBUF4              4
  #define MCASP_RBUF5              5
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6)
  #define MCASP_RBUF6              6
  #define MCASP_RBUF7              7
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define MCASP_RBUF8              8
  #define MCASP_RBUF9              9
  #define MCASP_RBUF10             10
  #define MCASP_RBUF11             11 
  #define MCASP_RBUF12             12
  #define MCASP_RBUF13             13
  #define MCASP_RBUF14             14
  #define MCASP_RBUF15             15
#endif /* _MCASP_CHANNEL_CNT == 16 */

/******************************************************************************\
* global typedef declarations
\******************************************************************************/

typedef enum {
  MCASP_DSP_INTEGER = 0,
  MCASP_DSP_Q31     = 1 
} MCASP_Dsprep;


/* device handle object */
typedef struct {
  Uint32 allocated;
  Uint32 xmtEventId;
  Uint32 rcvEventId;   
  volatile Uint32 *baseAddr;
  Uint32 xbufAddr;
  Uint32 xbufAddrCfg;
  Uint32 rbufAddr;
  Uint32 rbufAddrCfg;
  Uint32 ditcsrAddr;
  Uint32 ditudrAddr;
} MCASP_Obj, *MCASP_Handle;

/* device configuration structure */

typedef struct {
	Uint32 pfunc; 
	Uint32 pdir; 
	Uint32 ditctl;
	Uint32 dlbctl; 
	Uint32 amute;
} MCASP_ConfigGbl;

typedef struct {
	Uint32 rmask;
	Uint32 rfmt; 
	Uint32 afsrctl; 
	Uint32 aclkrctl; 
	Uint32 ahclkrctl; 
	Uint32 rtdm; 
	Uint32 rintctl; 
	Uint32 rclkchk;
} MCASP_ConfigRcv;

typedef struct {
	Uint32 xmask; 
	Uint32 xfmt; 
	Uint32 afsxctl; 
	Uint32 aclkxctl;
	Uint32 ahclkxctl; 
	Uint32 xtdm;
	Uint32 xintctl; 
	Uint32 xclkchk;
} MCASP_ConfigXmt;

#if (_MCASP_CHANNEL_CNT == 16) 
typedef struct { 
	Uint32 srctl0; 
	Uint32 srctl1; 
	Uint32 srctl2; 
	Uint32 srctl3; 
	Uint32 srctl4; 
	Uint32 srctl5; 
	Uint32 srctl6; 
	Uint32 srctl7; 
	Uint32 srctl8; 
	Uint32 srctl9; 
	Uint32 srctl10; 
	Uint32 srctl11; 
	Uint32 srctl12; 
	Uint32 srctl13; 
	Uint32 srctl14; 
	Uint32 srctl15;
} MCASP_ConfigSrctl;

#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)

typedef struct { 
	Uint32 srctl0; 
	Uint32 srctl1; 
	Uint32 srctl2; 
	Uint32 srctl3; 
	Uint32 srctl4; 
	Uint32 srctl5; 
	Uint32 srctl6; 
	Uint32 srctl7; 
} MCASP_ConfigSrctl;

#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6) 
typedef struct { 
        Uint32 srctl0; 
        Uint32 srctl1; 
        Uint32 srctl2; 
        Uint32 srctl3; 
        Uint32 srctl4; 
        Uint32 srctl5; 
} MCASP_ConfigSrctl;
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4) 
typedef struct { 
        Uint32 srctl0; 
        Uint32 srctl1; 
        Uint32 srctl2; 
        Uint32 srctl3; 
} MCASP_ConfigSrctl;
#endif /* _MCASP_CHANNEL_CNT == 4 */

typedef struct {
	MCASP_ConfigGbl	*global;
	MCASP_ConfigRcv	*receive;
	MCASP_ConfigXmt	*transmit;
	MCASP_ConfigSrctl	*srctl;
} MCASP_Config;


/* Parameter Clock Control : ACLKXCTL - ACLKRCTL   */
typedef struct {
   Uint32 syncmode;    /* Async 0 /1 : ACLKXCTL */
   Uint32 xclksrc;     /* Xmt clock source      */
   Uint32 xclkpol;     /* Xmt clock polarity    */
   Uint32 xclkdiv;     /* Xmt clock div         */  
   Uint32 rclksrc;     /* Rcv clock source      */
   Uint32 rclkpol;     /* Rcv clock polarity    */
   Uint32 rclkdiv;     /* Rcv clock div         */  
}MCASP_SetupClk;   


/* Parameter High- Freq Clock Control : AHCLKXCTL - AHCLKRCTL   */
typedef struct {
   Uint32 xhclksrc;     /* Xmt clock source      */
   Uint32 xhclkpol;     /* Xmt clock polarity    */
   Uint32 xhclkdiv;     /* Xmt clock div         */  
   Uint32 rhclksrc;     /* Rcv clock source      */
   Uint32 rhclkpol;     /* Rcv clock polarity    */
   Uint32 rhclkdiv;     /* Rcv clock div         */  
}MCASP_SetupHclk;   


/* Parameter Frame Sync Control : AFSXCTL - AFSRCTL   */
typedef struct {
   Uint32 xmode;      /* TDM - BURST   : FSXMOD - AFSXCTL reg     */
   Uint32 xslotsize;  /* slots# for TDM: FSXMOD - AFSXCTL reg    */          
   Uint32 xfssrc;     /* Internal/External  AFSXE - AFSXCTL reg   */
   Uint32 xfspol;     /* Xmt clock polarity  FSXPOL - AFSXCTL reg */
   Uint32 fxwid;     /* Xmt Frame Duration  FXWID - AFSXCTL reg */           
   Uint32 rmode;      /* TDM - BURST   FSRMOD - AFSRCTL reg       */
   Uint32 rslotsize;  /* slots# for TDM                           */
   Uint32 rfssrc;     /* Rcv Internal/External AFSRE - AFSRCTL reg */
   Uint32 rfspol;     /* Rcv clock polarity  FSRPOL- AFSRCTL reg   */ 
   Uint32 frwid;     /* Rcv Frame Duration  FRWID - AFSRCTL reg */             
}MCASP_SetupFsync;   

/* Parameters  Data Stream Format: XFMT - RFMT   */
typedef struct {
  Uint32 xbusel;        /* DAT / CFG bus                     */
  MCASP_Dsprep xdsprep;       /* DSP representation :Q31/Integer   */
  Uint32 xslotsize;     /* 8-32bits  TXSSZ field - XFMT reg  */
  Uint32 xwordsize;     /* rotation right                    */
  Uint32 xalign;        /* Left/Right Aligned                */
  Uint32 xpad;          /* Pad value for extra bits          */
  Uint32 xpbit;         /* which bit to pad the extra bits   */
  Uint32 xorder;        /* MSB/LSB XRVRS field  - XFMT reg   */
  Uint32 xdelay;        /*  Bit delay - XFMT reg             */
  Uint32 rbusel;        /* DAT / CFG bus                     */
  MCASP_Dsprep rdsprep;       /* DSP representation :Q31/Integer   */
  Uint32 rslotsize;     /* 8-32bits  RXSSZ                   */
  Uint32 rwordsize;     /* rotation right                    */
  Uint32 ralign;        /* Left/Right Aligned                */
  Uint32 rpad;          /* Pad value for extra bits          */
  Uint32 rpbit;         /* which bit to pad the extra bits   */
  Uint32 rorder;        /* MSB/LSB XRVRS field  - XFMT reg   */
  Uint32 rdelay;        /* FSXDLY Bit delay - XFMT reg       */             
} MCASP_SetupFormat;



 
/******************************************************************************\
* global variable declarations
\******************************************************************************/

/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void MCASP_reset(MCASP_Handle hMcasp);
CSLAPI void MCASP_resetAll();

CSLAPI MCASP_Handle MCASP_open(int devNum, Uint32 flags);
CSLAPI void MCASP_close(MCASP_Handle hMcasp);
CSLAPI MCASP_Handle MCASP_getHandle(int devNum);

CSLAPI Uint32 MCASP_getPins(MCASP_Handle hMcasp);
CSLAPI void MCASP_setPins(MCASP_Handle hMcasp, Uint32 pins);
CSLAPI void MCASP_clearPins(MCASP_Handle hMcasp, Uint32 pins);

/* direction = (transmitter only) MCASP_XMT - (receiver only) MCASP_RCV - (both) MCASP_RCVXMT */

/* active state machine step 8*/
CSLAPI void MCASP_enableSm(MCASP_Handle hMcasp, Uint32 direction);

/* enable data serializer step 5*/
CSLAPI void MCASP_enableSers(MCASP_Handle hMcasp, Uint32 direction);

/* enable clocks  step 4  */
CSLAPI void MCASP_enableClk(MCASP_Handle hMcasp, Uint32 direction);
CSLAPI void MCASP_enableHclk(MCASP_Handle hMcasp, Uint32 direction);

/* enable frame sync if receiver with internal frame sync */
CSLAPI void MCASP_enableFsync(MCASP_Handle hMcasp, Uint32 direction);


CSLAPI void MCASP_setupClk(MCASP_Handle hMcasp,MCASP_SetupClk *setupclk, Uint32 direction);
CSLAPI void MCASP_setupHclk(MCASP_Handle hMcasp,MCASP_SetupHclk *setuphclk, Uint32 direction);
CSLAPI void MCASP_setupFsync(MCASP_Handle hMcasp,MCASP_SetupFsync *setupfsync, Uint32 direction);
CSLAPI void MCASP_setupFormat(MCASP_Handle hMcasp,MCASP_SetupFormat *setupFormat, Uint32 direction);

/* Configuration of DIT mode */
CSLAPI void MCASP_configDit(MCASP_Handle hMcasp,MCASP_Dsprep dsprep, Uint32 datalen); 

/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 MCASP_getXbufAddrCfg(MCASP_Handle hMcasp, Uint32 xbufNum); 
IDECL Uint32 MCASP_getXbufAddr(MCASP_Handle hMcasp);

IDECL Uint32 MCASP_getRbufAddrCfg(MCASP_Handle hMcasp, Uint32 rbufNum); 
IDECL Uint32 MCASP_getRbufAddr(MCASP_Handle hMcasp);

IDECL Uint32 MCASP_getXmtEventId(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_getRcvEventId(MCASP_Handle hMcasp);

IDECL Uint32 MCASP_read32Cfg(MCASP_Handle hMcasp, Uint32 rbufNum);
IDECL void   MCASP_write32Cfg(MCASP_Handle hMcasp, Uint32 xbufNum, Uint32 val);
/* uses EDMA addresses */
IDECL Uint32 MCASP_read32(MCASP_Handle hMcasp);
IDECL void   MCASP_write32(MCASP_Handle hMcasp,Uint32 val);

IDECL Uint32 MCASP_rstat(MCASP_Handle hMcasp);

/******* Not documented ************************/
IDECL Uint32 MCASP_rovrn(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_rsyncerr(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_rckfail(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_revenslot(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_rlast(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_rdata(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_rstafrm(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_rerr(MCASP_Handle hMcasp);

IDECL Uint32 MCASP_xstat(MCASP_Handle hMcasp);
/******* Not documented ************************/
IDECL Uint32 MCASP_xundrn(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_xsyncerr(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_xckfail(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_xevenslot(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_xlast(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_xdata(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_xstafrm(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_xerr(MCASP_Handle hMcasp);

IDECL Uint32 MCASP_getRslotcnt(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_getXslotcnt(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_getRclkcnt(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_getXclkcnt(MCASP_Handle hMcasp);
IDECL Uint32 MCASP_getMutin(MCASP_Handle hMcasp);

/*****************************************************/
IDECL void MCASP_clearRcvStat(MCASP_Handle hMcasp,Uint32 fieldnum);
IDECL void MCASP_clearXmtStat(MCASP_Handle hMcasp,Uint32 fieldnum);

IDECL Uint32 MCASP_getChanStatusAddr(MCASP_Handle hMcasp, Uint32 chSide, Uint32 chNum);
IDECL Uint32 MCASP_getUserDataAddr(MCASP_Handle hMcasp, Uint32 chSide, Uint32 chNum);

IDECL void MCASP_config(MCASP_Handle hMcasp, MCASP_Config *config);
IDECL void MCASP_configGbl(MCASP_Handle hMcasp, MCASP_ConfigGbl *config);
IDECL void MCASP_configRcv(MCASP_Handle hMcasp, MCASP_ConfigRcv *config);
IDECL void MCASP_configXmt(MCASP_Handle hMcasp, MCASP_ConfigXmt *config);
IDECL void MCASP_configSrctl(MCASP_Handle hMcasp, MCASP_ConfigSrctl *config);

/************** Not documented ****************************************/

#if (_MCASP_CHANNEL_CNT == 16)
IDECL void MCASP_configArgs(MCASP_Handle hMcasp, Uint32 pfunc, Uint32 pdir, 
  Uint32 amute, Uint32 dlbctl, Uint32 ditctl, Uint32 rmask, Uint32 rfmt, Uint32 afsrctl,
  Uint32 aclkrctl, Uint32 ahclkrctl, Uint32 rtdm, Uint32 rintctl, Uint32 rclkchk,
  Uint32 xmask, Uint32 xfmt, Uint32 afsxctl, Uint32 aclkxctl, Uint32 ahclkxctl, Uint32 xtdm, 
  Uint32 xintctl, Uint32 xclkchk, Uint32 srctl0, Uint32 srctl1, Uint32 srctl2, Uint32 srctl3, 
  Uint32 srctl4, Uint32 srctl5, Uint32 srctl6, Uint32 srctl7, Uint32 srctl8, Uint32 srctl9, 
  Uint32 srctl10, Uint32 srctl11, Uint32 srctl12, Uint32 srctl13, Uint32 srctl14, Uint32 srctl15  );

#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
IDECL void MCASP_configArgs(MCASP_Handle hMcasp, Uint32 pfunc, Uint32 pdir, 
  Uint32 amute, Uint32 dlbctl, Uint32 ditctl, Uint32 rmask, Uint32 rfmt, Uint32 afsrctl,
  Uint32 aclkrctl, Uint32 ahclkrctl, Uint32 rtdm, Uint32 rintctl, Uint32 rclkchk,
  Uint32 xmask, Uint32 xfmt, Uint32 afsxctl, Uint32 aclkxctl, Uint32 ahclkxctl, Uint32 xtdm, 
  Uint32 xintctl, Uint32 xclkchk, Uint32 srctl0, Uint32 srctl1, Uint32 srctl2, Uint32 srctl3, 
  Uint32 srctl4, Uint32 srctl5, Uint32 srctl6, Uint32 srctl7);
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
IDECL void MCASP_configArgs(MCASP_Handle hMcasp, Uint32 pfunc, Uint32 pdir, 
  Uint32 amute, Uint32 dlbctl, Uint32 ditctl, Uint32 rmask, Uint32 rfmt, Uint32 afsrctl,
  Uint32 aclkrctl, Uint32 ahclkrctl, Uint32 rtdm, Uint32 rintctl, Uint32 rclkchk,
  Uint32 xmask, Uint32 xfmt, Uint32 afsxctl, Uint32 aclkxctl, Uint32 ahclkxctl, Uint32 xtdm, 
  Uint32 xintctl, Uint32 xclkchk, Uint32 srctl0, Uint32 srctl1, Uint32 srctl2, Uint32 srctl3, 
  Uint32 srctl4, Uint32 srctl5);
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
IDECL void MCASP_configArgs(MCASP_Handle hMcasp, Uint32 pfunc, Uint32 pdir, 
  Uint32 amute, Uint32 dlbctl, Uint32 ditctl, Uint32 rmask, Uint32 rfmt, Uint32 afsrctl,
  Uint32 aclkrctl, Uint32 ahclkrctl, Uint32 rtdm, Uint32 rintctl, Uint32 rclkchk,
  Uint32 xmask, Uint32 xfmt, Uint32 afsxctl, Uint32 aclkxctl, Uint32 ahclkxctl, Uint32 xtdm, 
  Uint32 xintctl, Uint32 xclkchk, Uint32 srctl0, Uint32 srctl1, Uint32 srctl2, Uint32 srctl3);
#endif /* _MCASP_CHANNEL_CNT == 4 */

/**********************************************************************/

IDECL void MCASP_getConfig(MCASP_Handle hMcasp, MCASP_Config *config);

IDECL void MCASP_resetXmt(MCASP_Handle hMcasp);
IDECL void MCASP_resetRcv(MCASP_Handle hMcasp);

/** read GBLCTL register with the right value **/
IDECL Uint32 MCASP_getGblctl(MCASP_Handle hMcasp, Uint32 direction);


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getXbufAddr(MCASP_Handle hMcasp) {
  return (Uint32)(hMcasp->xbufAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getXbufAddrCfg(MCASP_Handle hMcasp, Uint32 xbufNum) {
  return (Uint32)(hMcasp->xbufAddrCfg + (xbufNum*MCASP_XBUF_BUFSIZE));
}

/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getRbufAddr(MCASP_Handle hMcasp) {
  return (Uint32)(hMcasp->rbufAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getRbufAddrCfg(MCASP_Handle hMcasp, Uint32 rbufNum) {
  return (Uint32)(hMcasp->rbufAddrCfg + (rbufNum*MCASP_RBUF_BUFSIZE));
}

/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getGblctl(MCASP_Handle hMcasp,Uint32 direction) {
  if (direction == MCASP_XMT) {
  return (MCASP_RGETH(hMcasp,XGBLCTL)& 0x0001F00);
  } else { 
  if (direction == MCASP_RCV) {
  return (MCASP_RGETH(hMcasp,RGBLCTL)& 0x000001F);
  } else {
  return (MCASP_RGETH(hMcasp,GBLCTL));
    }
 }
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getXmtEventId(MCASP_Handle hMcasp) {
  return (hMcasp->xmtEventId);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getRcvEventId(MCASP_Handle hMcasp) {
  return (hMcasp->rcvEventId);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_read32Cfg(MCASP_Handle hMcasp, Uint32 rbufNum) {
  return (*(volatile Uint32 *)(hMcasp->rbufAddrCfg + (rbufNum*MCASP_RBUF_BUFSIZE)));
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_read32(MCASP_Handle hMcasp) {
  return (*(volatile Uint32 *)(hMcasp->rbufAddr));
}
/*----------------------------------------------------------------------------*/
IDEF void MCASP_write32Cfg(MCASP_Handle hMcasp, Uint32 xbufNum, Uint32 val) {
  (*(volatile Uint32 *)(hMcasp->xbufAddrCfg + (xbufNum*MCASP_XBUF_BUFSIZE))) = val;
}
/*----------------------------------------------------------------------------*/
IDEF void MCASP_write32(MCASP_Handle hMcasp, Uint32 val) {
  (*(volatile Uint32 *)(hMcasp->xbufAddr)) = val;
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_rstat(MCASP_Handle hMcasp) {
  return MCASP_RGETH(hMcasp,RSTAT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_rovrn(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSTAT,ROVRN);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_rsyncerr(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSTAT,RSYNCERR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_rckfail(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSTAT,RCKFAIL);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_revenslot(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSTAT,RTDMSLOT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_rlast(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSTAT,RLAST);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_rdata(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSTAT,RDATA);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_rstafrm(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSTAT,RSTAFRM);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_rerr(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSTAT,RERR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xstat(MCASP_Handle hMcasp) {
  return MCASP_RGETH(hMcasp,XSTAT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xundrn(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSTAT,XUNDRN);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xsyncerr(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSTAT,XSYNCERR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xckfail(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSTAT,XCKFAIL);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xevenslot(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSTAT,XTDMSLOT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xlast(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSTAT,XLAST);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xdata(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSTAT,XDATA);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xstafrm(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSTAT,XSTAFRM);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_xerr(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSTAT,XERR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getRslotcnt(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RSLOT,RSLOTCNT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getXslotcnt(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XSLOT,XSLOTCNT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getRclkcnt(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,RCLKCHK,RCNT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getXclkcnt(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,XCLKCHK,XCNT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getMutin(MCASP_Handle hMcasp) {
  return MCASP_FGETH(hMcasp,AMUTE,INSTAT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getChanStatusAddr(MCASP_Handle hMcasp, Uint32 chSide, Uint32 chNum) {
  return (Uint32)(hMcasp->ditcsrAddr + (chSide*MCASP_DITCSR_RIGHT_OFFSET)+
  (chNum*MCASP_DITCSR_BUFSIZE));
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCASP_getUserDataAddr(MCASP_Handle hMcasp, Uint32 chSide, Uint32 chNum) {
  return (Uint32)(hMcasp->ditudrAddr + (chSide*MCASP_DITUDR_RIGHT_OFFSET)+
  (chNum*MCASP_DITUDR_BUFSIZE));
}
/*----------------------------------------------------------------------------*/
IDEF void MCASP_clearXmtStat(MCASP_Handle hMcasp, Uint32 fieldnum){
    MCASP_RSETH(hMcasp,XSTAT,1<<fieldnum);
}
/*----------------------------------------------------------------------------*/
IDEF void MCASP_clearRcvStat(MCASP_Handle hMcasp, Uint32 fieldnum){
     MCASP_RSETH(hMcasp,RSTAT,1<<fieldnum);
}
/*----------------------------------------------------------------------------*/

IDEF void MCASP_resetRcv(MCASP_Handle hMcasp) {
/* reset State Machine = clear serial buffer = reset frame sync generator 
   reset Clock */
  MCASP_RSETH(hMcasp,GBLCTL, MCASP_RGETH(hMcasp,RGBLCTL) &\
	  MCASP_FMKS(GBLCTL,RSRCLR,CLEAR) \
	| MCASP_FMKS(GBLCTL,RSMRST,RESET) \
	| MCASP_FMKS(GBLCTL,RFRST,RESET) \
	| MCASP_FMKS(GBLCTL,RCLKRST,RESET) \
	| MCASP_FMKS(GBLCTL,RHCLKRST,RESET) \
	);
}
/*----------------------------------------------------------------------------*/
IDEF void MCASP_resetXmt(MCASP_Handle hMcasp) {
/* reset State Machine = clear serial buffer = reset frame sync generator 
   reset Clock */
  MCASP_RSETH(hMcasp,GBLCTL, MCASP_RGETH(hMcasp,XGBLCTL) &\
	  MCASP_FMKS(GBLCTL,XSRCLR,CLEAR) \
	| MCASP_FMKS(GBLCTL,XSMRST,RESET) \
	| MCASP_FMKS(GBLCTL,XFRST,RESET) \
	| MCASP_FMKS(GBLCTL,XCLKRST,RESET) \
	| MCASP_FMKS(GBLCTL,XHCLKRST,RESET) 
	);
}
/*----------------------------------------------------------------------------*/
#if (_MCASP_CHANNEL_CNT == 16)
IDEF void MCASP_config(MCASP_Handle hMcasp, MCASP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0 = config->global->pfunc;
  x1 = config->global->pdir;
  x2 = config->global->amute;
  x3 = config->global->dlbctl;
  x4 = config->global->ditctl;
  x5 = config->receive->rmask;
  x6 = config->receive->rfmt;
  x7 = config->receive->afsrctl;
  x8 = config->receive->aclkrctl;
  x9 = config->receive->ahclkrctl;
  x10 = config->receive->rtdm;
  x11 = config->receive->rintctl;
  x12 = config->receive->rclkchk;
  x13 = config->transmit->xmask;
  x14 = config->transmit->xfmt;
  x15 = config->transmit->afsxctl;
  x16 = config->transmit->aclkxctl;
  x17 = config->transmit->ahclkxctl;
  x18 = config->transmit->xtdm;
  x19 = config->transmit->xintctl;
  x20 = config->transmit->xclkchk;
  x21 = config->srctl->srctl0;
  x22 = config->srctl->srctl1;
  x23 = config->srctl->srctl2;
  x24 = config->srctl->srctl3;
  x25 = config->srctl->srctl4;
  x26 = config->srctl->srctl5;
  x27 = config->srctl->srctl6;
  x28 = config->srctl->srctl7;
  x29 = config->srctl->srctl8;
  x30 = config->srctl->srctl9;
  x31 = config->srctl->srctl10;
  x32 = config->srctl->srctl11;
  x33 = config->srctl->srctl12;
  x34 = config->srctl->srctl13;
  x35 = config->srctl->srctl14;
  x36 = config->srctl->srctl15;

  base[_MCASP_RMASK_OFFSET] = 	x5;
  base[_MCASP_RFMT_OFFSET] = 	x6;
  base[_MCASP_AFSRCTL_OFFSET] = x7;
  base[_MCASP_ACLKRCTL_OFFSET]= x8;
  base[_MCASP_AHCLKRCTL_OFFSET]= x9;
  base[_MCASP_RTDM_OFFSET] = 	x10;
  base[_MCASP_RINTCTL_OFFSET] = x11;
  base[_MCASP_RCLKCHK_OFFSET] = x12;
  base[_MCASP_XMASK_OFFSET] = 	x13;
  base[_MCASP_XFMT_OFFSET] = 	x14;
  base[_MCASP_AFSXCTL_OFFSET] = x15;
  base[_MCASP_ACLKXCTL_OFFSET]= x16;
  base[_MCASP_AHCLKXCTL_OFFSET]= x17;
  base[_MCASP_XTDM_OFFSET] = 	x18;
  base[_MCASP_XINTCTL_OFFSET] = x19;
  base[_MCASP_XCLKCHK_OFFSET] = x20;
  base[_MCASP_SRCTL0_OFFSET] = 	x21;
  base[_MCASP_SRCTL1_OFFSET] = 	x22;
  base[_MCASP_SRCTL2_OFFSET] = 	x23;
  base[_MCASP_SRCTL3_OFFSET] = 	x24;
  base[_MCASP_SRCTL4_OFFSET] = 	x25;
  base[_MCASP_SRCTL5_OFFSET] = 	x26;
  base[_MCASP_SRCTL6_OFFSET] = 	x27;
  base[_MCASP_SRCTL7_OFFSET] = 	x28;
  base[_MCASP_SRCTL8_OFFSET] = 	x29;
  base[_MCASP_SRCTL9_OFFSET] = 	x30;
  base[_MCASP_SRCTL10_OFFSET] = x31;
  base[_MCASP_SRCTL11_OFFSET] = x32;
  base[_MCASP_SRCTL12_OFFSET] = x33;
  base[_MCASP_SRCTL13_OFFSET] = x34;
  base[_MCASP_SRCTL14_OFFSET] = x35;
  base[_MCASP_SRCTL15_OFFSET] = x36;
  base[_MCASP_AMUTE_OFFSET]  = 	x2;
  base[_MCASP_DLBCTL_OFFSET] = 	x3;
  base[_MCASP_DITCTL_OFFSET] =  x4;
  base[_MCASP_PFUNC_OFFSET] = 	x0;
  base[_MCASP_PDIR_OFFSET]  = 	x1;

  IRQ_globalRestore(gie);
}

#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
IDEF void MCASP_config(MCASP_Handle hMcasp, MCASP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26,x27,x28;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0 = config->global->pfunc;
  x1 = config->global->pdir;
  x2 = config->global->amute;
  x3 = config->global->dlbctl;
  x4 = config->global->ditctl;
  x5 = config->receive->rmask;
  x6 = config->receive->rfmt;
  x7 = config->receive->afsrctl;
  x8 = config->receive->aclkrctl;
  x9 = config->receive->ahclkrctl;
  x10 = config->receive->rtdm;
  x11 = config->receive->rintctl;
  x12 = config->receive->rclkchk;
  x13 = config->transmit->xmask;
  x14 = config->transmit->xfmt;
  x15 = config->transmit->afsxctl;
  x16 = config->transmit->aclkxctl;
  x17 = config->transmit->ahclkxctl;
  x18 = config->transmit->xtdm;
  x19 = config->transmit->xintctl;
  x20 = config->transmit->xclkchk;
  x21 = config->srctl->srctl0;
  x22 = config->srctl->srctl1;
  x23 = config->srctl->srctl2;
  x24 = config->srctl->srctl3;
  x25 = config->srctl->srctl4;
  x26 = config->srctl->srctl5;
  x27 = config->srctl->srctl6;
  x28 = config->srctl->srctl7;

  base[_MCASP_RMASK_OFFSET] = 	x5;
  base[_MCASP_RFMT_OFFSET] = 	x6;
  base[_MCASP_AFSRCTL_OFFSET] = x7;
  base[_MCASP_ACLKRCTL_OFFSET]= x8;
  base[_MCASP_AHCLKRCTL_OFFSET]= x9;
  base[_MCASP_RTDM_OFFSET] = 	x10;
  base[_MCASP_RINTCTL_OFFSET] = x11;
  base[_MCASP_RCLKCHK_OFFSET] = x12;
  base[_MCASP_XMASK_OFFSET] = 	x13;
  base[_MCASP_XFMT_OFFSET] = 	x14;
  base[_MCASP_AFSXCTL_OFFSET] = x15;
  base[_MCASP_ACLKXCTL_OFFSET]= x16;
  base[_MCASP_AHCLKXCTL_OFFSET]= x17;
  base[_MCASP_XTDM_OFFSET] = 	x18;
  base[_MCASP_XINTCTL_OFFSET] = x19;
  base[_MCASP_XCLKCHK_OFFSET] = x20;
  base[_MCASP_SRCTL0_OFFSET] = 	x21;
  base[_MCASP_SRCTL1_OFFSET] = 	x22;
  base[_MCASP_SRCTL2_OFFSET] = 	x23;
  base[_MCASP_SRCTL3_OFFSET] = 	x24;
  base[_MCASP_SRCTL4_OFFSET] = 	x25;
  base[_MCASP_SRCTL5_OFFSET] = 	x26;
  base[_MCASP_SRCTL6_OFFSET] = 	x27;
  base[_MCASP_SRCTL7_OFFSET] = 	x28;
  base[_MCASP_AMUTE_OFFSET]  = 	x2;
  base[_MCASP_DLBCTL_OFFSET] = 	x3;
  base[_MCASP_DITCTL_OFFSET] =  x4;
  base[_MCASP_PFUNC_OFFSET] = 	x0;
  base[_MCASP_PDIR_OFFSET]  = 	x1;

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
IDEF void MCASP_config(MCASP_Handle hMcasp, MCASP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0 = config->global->pfunc;
  x1 = config->global->pdir;
  x2 = config->global->amute;
  x3 = config->global->dlbctl;
  x4 = config->global->ditctl;
  x5 = config->receive->rmask;
  x6 = config->receive->rfmt;
  x7 = config->receive->afsrctl;
  x8 = config->receive->aclkrctl;
  x9 = config->receive->ahclkrctl;
  x10 = config->receive->rtdm;
  x11 = config->receive->rintctl;
  x12 = config->receive->rclkchk;
  x13 = config->transmit->xmask;
  x14 = config->transmit->xfmt;
  x15 = config->transmit->afsxctl;
  x16 = config->transmit->aclkxctl;
  x17 = config->transmit->ahclkxctl;
  x18 = config->transmit->xtdm;
  x19 = config->transmit->xintctl;
  x20 = config->transmit->xclkchk;
  x21 = config->srctl->srctl0;
  x22 = config->srctl->srctl1;
  x23 = config->srctl->srctl2;
  x24 = config->srctl->srctl3;
  x25 = config->srctl->srctl4;
  x26 = config->srctl->srctl5;

  base[_MCASP_RMASK_OFFSET] = x5;
  base[_MCASP_RFMT_OFFSET] = x6;
  base[_MCASP_AFSRCTL_OFFSET] = x7;
  base[_MCASP_ACLKRCTL_OFFSET]= x8;
  base[_MCASP_AHCLKRCTL_OFFSET]= x9;
  base[_MCASP_RTDM_OFFSET] = x10;
  base[_MCASP_RINTCTL_OFFSET] = x11;
  base[_MCASP_RCLKCHK_OFFSET] = x12;
  base[_MCASP_XMASK_OFFSET] = x13;
  base[_MCASP_XFMT_OFFSET] = x14;
  base[_MCASP_AFSXCTL_OFFSET] = x15;
  base[_MCASP_ACLKXCTL_OFFSET]= x16;
  base[_MCASP_AHCLKXCTL_OFFSET]= x17;
  base[_MCASP_XTDM_OFFSET] = x18;
  base[_MCASP_XINTCTL_OFFSET] = x19;
  base[_MCASP_XCLKCHK_OFFSET] = x20;
  base[_MCASP_SRCTL0_OFFSET] = x21;
  base[_MCASP_SRCTL1_OFFSET] = x22;
  base[_MCASP_SRCTL2_OFFSET] = x23;
  base[_MCASP_SRCTL3_OFFSET] = x24;
  base[_MCASP_SRCTL4_OFFSET] = x25;
  base[_MCASP_SRCTL5_OFFSET] = x26;
  base[_MCASP_AMUTE_OFFSET]  = x2;
  base[_MCASP_DLBCTL_OFFSET] = x3;
  base[_MCASP_DITCTL_OFFSET] =  x4;
  base[_MCASP_PFUNC_OFFSET] = x0;
  base[_MCASP_PDIR_OFFSET]  = x1;

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
IDEF void MCASP_config(MCASP_Handle hMcasp, MCASP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0 = config->global->pfunc;
  x1 = config->global->pdir;
  x2 = config->global->amute;
  x3 = config->global->dlbctl;
  x4 = config->global->ditctl;
  x5 = config->receive->rmask;
  x6 = config->receive->rfmt;
  x7 = config->receive->afsrctl;
  x8 = config->receive->aclkrctl;
  x9 = config->receive->ahclkrctl;
  x10 = config->receive->rtdm;
  x11 = config->receive->rintctl;
  x12 = config->receive->rclkchk;
  x13 = config->transmit->xmask;
  x14 = config->transmit->xfmt;
  x15 = config->transmit->afsxctl;
  x16 = config->transmit->aclkxctl;
  x17 = config->transmit->ahclkxctl;
  x18 = config->transmit->xtdm;
  x19 = config->transmit->xintctl;
  x20 = config->transmit->xclkchk;
  x21 = config->srctl->srctl0;
  x22 = config->srctl->srctl1;
  x23 = config->srctl->srctl2;
  x24 = config->srctl->srctl3;

  base[_MCASP_RMASK_OFFSET] = x5;
  base[_MCASP_RFMT_OFFSET] = x6;
  base[_MCASP_AFSRCTL_OFFSET] = x7;
  base[_MCASP_ACLKRCTL_OFFSET]= x8;
  base[_MCASP_AHCLKRCTL_OFFSET]= x9;
  base[_MCASP_RTDM_OFFSET] = x10;
  base[_MCASP_RINTCTL_OFFSET] = x11;
  base[_MCASP_RCLKCHK_OFFSET] = x12;
  base[_MCASP_XMASK_OFFSET] = x13;
  base[_MCASP_XFMT_OFFSET] = x14;
  base[_MCASP_AFSXCTL_OFFSET] = x15;
  base[_MCASP_ACLKXCTL_OFFSET]= x16;
  base[_MCASP_AHCLKXCTL_OFFSET]= x17;
  base[_MCASP_XTDM_OFFSET]    = x18;
  base[_MCASP_XINTCTL_OFFSET] = x19;
  base[_MCASP_XCLKCHK_OFFSET] = x20;
  base[_MCASP_SRCTL0_OFFSET]  = x21;
  base[_MCASP_SRCTL1_OFFSET]  = x22;
  base[_MCASP_SRCTL2_OFFSET]  = x23;
  base[_MCASP_SRCTL3_OFFSET]  = x24;
  base[_MCASP_AMUTE_OFFSET]   = x2;
  base[_MCASP_DLBCTL_OFFSET]  = x3;
  base[_MCASP_DITCTL_OFFSET]  = x4;
  base[_MCASP_PFUNC_OFFSET]   = x0;
  base[_MCASP_PDIR_OFFSET]    = x1;

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 4 */


/*----------------------------------------------------------------------------*/
IDEF void MCASP_configGbl(MCASP_Handle hMcasp, MCASP_ConfigGbl *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x0,x1,x2,x3,x4;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0 = config->pfunc;
  x1 = config->pdir;
  x2 = config->amute;
  x3 = config->dlbctl;
  x4 = config->ditctl;

  base[_MCASP_PFUNC_OFFSET] = 	x0;
  base[_MCASP_AMUTE_OFFSET]  = 	x2;
  base[_MCASP_DLBCTL_OFFSET] = 	x3;
  base[_MCASP_DITCTL_OFFSET] = x4;
  base[_MCASP_PDIR_OFFSET]  = 	x1;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void MCASP_configRcv(MCASP_Handle hMcasp, MCASP_ConfigRcv *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x5,x6,x7,x8,x9,x10,x11,x12;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x5 = config->rmask;
  x6 = config->rfmt;
  x7 = config->afsrctl;
  x8 = config->aclkrctl;
  x9 = config->ahclkrctl;
  x10 = config->rtdm;
  x11 = config->rintctl;
  x12 = config->rclkchk;

  base[_MCASP_RMASK_OFFSET] = 	x5;
  base[_MCASP_RFMT_OFFSET] = 	x6;
  base[_MCASP_AFSRCTL_OFFSET] = x7;
  base[_MCASP_ACLKRCTL_OFFSET]= x8;
  base[_MCASP_AHCLKRCTL_OFFSET]= x9;
  base[_MCASP_RTDM_OFFSET] = 	x10;
  base[_MCASP_RINTCTL_OFFSET] = x11;
  base[_MCASP_RCLKCHK_OFFSET] = x12;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void MCASP_configXmt(MCASP_Handle hMcasp, MCASP_ConfigXmt *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x13,x14,x15,x16,x17,x18,x19,x20;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x13 = config->xmask;
  x14 = config->xfmt;
  x15 = config->afsxctl;
  x16 = config->aclkxctl;
  x17 = config->ahclkxctl;
  x18 = config->xtdm;
  x19 = config->xintctl;
  x20 = config->xclkchk;

  base[_MCASP_XMASK_OFFSET] = 	x13;
  base[_MCASP_XFMT_OFFSET] = 	x14;
  base[_MCASP_AFSXCTL_OFFSET] = x15;
  base[_MCASP_ACLKXCTL_OFFSET]= x16;
  base[_MCASP_AHCLKXCTL_OFFSET]= x17;
  base[_MCASP_XTDM_OFFSET] = 	x18;
  base[_MCASP_XINTCTL_OFFSET] = x19;
  base[_MCASP_XCLKCHK_OFFSET] = x20;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#if (_MCASP_CHANNEL_CNT == 16)	
IDEF void MCASP_configSrctl(MCASP_Handle hMcasp, MCASP_ConfigSrctl *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x21 = config->srctl0;
  x22 = config->srctl1;
  x23 = config->srctl2;
  x24 = config->srctl3;
  x25 = config->srctl4;
  x26 = config->srctl5;
  x27 = config->srctl6;
  x28 = config->srctl7;
  x29 = config->srctl8;
  x30 = config->srctl9;
  x31 = config->srctl10;
  x32 = config->srctl11;
  x33 = config->srctl12;
  x34 = config->srctl13;
  x35 = config->srctl14;
  x36 = config->srctl15;

  base[_MCASP_SRCTL0_OFFSET] = 	x21;
  base[_MCASP_SRCTL1_OFFSET] = 	x22;
  base[_MCASP_SRCTL2_OFFSET] = 	x23;
  base[_MCASP_SRCTL3_OFFSET] = 	x24;
  base[_MCASP_SRCTL4_OFFSET] = 	x25;
  base[_MCASP_SRCTL5_OFFSET] = 	x26;
  base[_MCASP_SRCTL6_OFFSET] = 	x27;
  base[_MCASP_SRCTL7_OFFSET] = 	x28;
  base[_MCASP_SRCTL8_OFFSET] = 	x29;
  base[_MCASP_SRCTL9_OFFSET] = 	x30;
  base[_MCASP_SRCTL10_OFFSET] = x31;
  base[_MCASP_SRCTL11_OFFSET] = x32;
  base[_MCASP_SRCTL12_OFFSET] = x33;
  base[_MCASP_SRCTL13_OFFSET] = x34;
  base[_MCASP_SRCTL14_OFFSET] = x35;
  base[_MCASP_SRCTL15_OFFSET] = x36;

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
IDEF void MCASP_configSrctl(MCASP_Handle hMcasp, MCASP_ConfigSrctl *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x21,x22,x23,x24,x25,x26,x27,x28;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x21 = config->srctl0;
  x22 = config->srctl1;
  x23 = config->srctl2;
  x24 = config->srctl3;
  x25 = config->srctl4;
  x26 = config->srctl5;
  x27 = config->srctl6;
  x28 = config->srctl7;

  base[_MCASP_SRCTL0_OFFSET] = 	x21;
  base[_MCASP_SRCTL1_OFFSET] = 	x22;
  base[_MCASP_SRCTL2_OFFSET] = 	x23;
  base[_MCASP_SRCTL3_OFFSET] = 	x24;
  base[_MCASP_SRCTL4_OFFSET] = 	x25;
  base[_MCASP_SRCTL5_OFFSET] = 	x26;
  base[_MCASP_SRCTL6_OFFSET] = 	x27;
  base[_MCASP_SRCTL7_OFFSET] = 	x28;

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
IDEF void MCASP_configSrctl(MCASP_Handle hMcasp, MCASP_ConfigSrctl *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x21,x22,x23,x24,x25,x26;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x21 = config->srctl0;
  x22 = config->srctl1;
  x23 = config->srctl2;
  x24 = config->srctl3;
  x25 = config->srctl4;
  x26 = config->srctl5;

  base[_MCASP_SRCTL0_OFFSET] = x21;
  base[_MCASP_SRCTL1_OFFSET] = x22;
  base[_MCASP_SRCTL2_OFFSET] = x23;
  base[_MCASP_SRCTL3_OFFSET] = x24;
  base[_MCASP_SRCTL4_OFFSET] = x25;
  base[_MCASP_SRCTL5_OFFSET] = x26;

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
IDEF void MCASP_configSrctl(MCASP_Handle hMcasp, MCASP_ConfigSrctl *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  register int x21,x22,x23,x24;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x21 = config->srctl0;
  x22 = config->srctl1;
  x23 = config->srctl2;
  x24 = config->srctl3;

  base[_MCASP_SRCTL0_OFFSET] = x21;
  base[_MCASP_SRCTL1_OFFSET] = x22;
  base[_MCASP_SRCTL2_OFFSET] = x23;
  base[_MCASP_SRCTL3_OFFSET] = x24;

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 4 */

/*----------------------------------------------------------------------------*/
#if (_MCASP_CHANNEL_CNT == 16)
IDEF void MCASP_configArgs(MCASP_Handle hMcasp, Uint32 pfunc, Uint32 pdir, 
  Uint32 amute, Uint32 dlbctl, Uint32 ditctl, Uint32 rmask, Uint32 rfmt, Uint32 afsrctl,
  Uint32 aclkrctl, Uint32 ahclkrctl, Uint32 rtdm, Uint32 rintctl, Uint32 rclkchk,
  Uint32 xmask, Uint32 xfmt, Uint32 afsxctl, Uint32 aclkxctl, Uint32 ahclkxctl, Uint32 xtdm, 
  Uint32 xintctl, Uint32 xclkchk, Uint32 srctl0, Uint32 srctl1, Uint32 srctl2, Uint32 srctl3, 
  Uint32 srctl4, Uint32 srctl5, Uint32 srctl6, Uint32 srctl7, Uint32 srctl8, Uint32 srctl9, 
  Uint32 srctl10, Uint32 srctl11, Uint32 srctl12, Uint32 srctl13, Uint32 srctl14, Uint32 srctl15  ) 
{

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);

  gie = IRQ_globalDisable();

  base[_MCASP_RMASK_OFFSET] = 	rmask;
  base[_MCASP_RFMT_OFFSET] = 	rfmt;  
  base[_MCASP_AFSRCTL_OFFSET] = afsrctl;  
  base[_MCASP_ACLKRCTL_OFFSET]= aclkrctl;  
  base[_MCASP_AHCLKRCTL_OFFSET]=ahclkrctl;   
  base[_MCASP_RTDM_OFFSET] = 	rtdm;
  base[_MCASP_RINTCTL_OFFSET] = rintctl;   
  base[_MCASP_RCLKCHK_OFFSET] = rclkchk;   
  base[_MCASP_XMASK_OFFSET] = 	xmask;
  base[_MCASP_XFMT_OFFSET] = 	xfmt;   
  base[_MCASP_AFSXCTL_OFFSET] = afsxctl;   
  base[_MCASP_ACLKXCTL_OFFSET]= aclkxctl;   
  base[_MCASP_AHCLKXCTL_OFFSET]=ahclkxctl;    
  base[_MCASP_XTDM_OFFSET] = 	xtdm;   
  base[_MCASP_XINTCTL_OFFSET] = xintctl;   
  base[_MCASP_XCLKCHK_OFFSET] = xclkchk;   
  base[_MCASP_SRCTL0_OFFSET] = 	srctl0;
  base[_MCASP_SRCTL1_OFFSET] = 	srctl1;         
  base[_MCASP_SRCTL2_OFFSET] = 	srctl2;         
  base[_MCASP_SRCTL3_OFFSET] = 	srctl3;         
  base[_MCASP_SRCTL4_OFFSET] = 	srctl4;         
  base[_MCASP_SRCTL5_OFFSET] = 	srctl5;         
  base[_MCASP_SRCTL6_OFFSET] = 	srctl6;         
  base[_MCASP_SRCTL7_OFFSET] = 	srctl7;         
  base[_MCASP_SRCTL8_OFFSET] = 	srctl8;         
  base[_MCASP_SRCTL9_OFFSET] = 	srctl9;         
  base[_MCASP_SRCTL10_OFFSET] = srctl10;         
  base[_MCASP_SRCTL11_OFFSET] = srctl11;         
  base[_MCASP_SRCTL12_OFFSET] = srctl12;         
  base[_MCASP_SRCTL13_OFFSET] = srctl13;         
  base[_MCASP_SRCTL14_OFFSET] = srctl14;         
  base[_MCASP_SRCTL15_OFFSET] = srctl15;         
  base[_MCASP_AMUTE_OFFSET]  = 	amute;  
  base[_MCASP_DLBCTL_OFFSET] = 	dlbctl;  
  base[_MCASP_DITCTL_OFFSET] =  ditctl;  
  base[_MCASP_PFUNC_OFFSET] = 	pfunc;
  base[_MCASP_PDIR_OFFSET]  = 	pdir;  
              
  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
IDEF void MCASP_configArgs(MCASP_Handle hMcasp, Uint32 pfunc, Uint32 pdir, 
  Uint32 amute, Uint32 dlbctl, Uint32 ditctl, Uint32 rmask, Uint32 rfmt, Uint32 afsrctl,
  Uint32 aclkrctl, Uint32 ahclkrctl, Uint32 rtdm, Uint32 rintctl, Uint32 rclkchk,
  Uint32 xmask, Uint32 xfmt, Uint32 afsxctl, Uint32 aclkxctl, Uint32 ahclkxctl, Uint32 xtdm, 
  Uint32 xintctl, Uint32 xclkchk, Uint32 srctl0, Uint32 srctl1, Uint32 srctl2, Uint32 srctl3, 
  Uint32 srctl4, Uint32 srctl5, Uint32 srctl6, Uint32 srctl7) 
{

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);

  gie = IRQ_globalDisable();

  base[_MCASP_RMASK_OFFSET] = 	rmask;
  base[_MCASP_RFMT_OFFSET] = 	rfmt;  
  base[_MCASP_AFSRCTL_OFFSET] = afsrctl;  
  base[_MCASP_ACLKRCTL_OFFSET]= aclkrctl;  
  base[_MCASP_AHCLKRCTL_OFFSET]=ahclkrctl;   
  base[_MCASP_RTDM_OFFSET] = 	rtdm;
  base[_MCASP_RINTCTL_OFFSET] = rintctl;   
  base[_MCASP_RCLKCHK_OFFSET] = rclkchk;   
  base[_MCASP_XMASK_OFFSET] = 	xmask;
  base[_MCASP_XFMT_OFFSET] = 	xfmt;   
  base[_MCASP_AFSXCTL_OFFSET] = afsxctl;   
  base[_MCASP_ACLKXCTL_OFFSET]= aclkxctl;   
  base[_MCASP_AHCLKXCTL_OFFSET]=ahclkxctl;    
  base[_MCASP_XTDM_OFFSET] = 	xtdm;   
  base[_MCASP_XINTCTL_OFFSET] = xintctl;   
  base[_MCASP_XCLKCHK_OFFSET] = xclkchk;   
  base[_MCASP_SRCTL0_OFFSET] = 	srctl0;
  base[_MCASP_SRCTL1_OFFSET] = 	srctl1;         
  base[_MCASP_SRCTL2_OFFSET] = 	srctl2;         
  base[_MCASP_SRCTL3_OFFSET] = 	srctl3;         
  base[_MCASP_SRCTL4_OFFSET] = 	srctl4;         
  base[_MCASP_SRCTL5_OFFSET] = 	srctl5;         
  base[_MCASP_SRCTL6_OFFSET] = 	srctl6;         
  base[_MCASP_SRCTL7_OFFSET] = 	srctl7;         
  base[_MCASP_AMUTE_OFFSET]  = 	amute;  
  base[_MCASP_DLBCTL_OFFSET] = 	dlbctl;  
  base[_MCASP_DITCTL_OFFSET] =  ditctl;  
  base[_MCASP_PFUNC_OFFSET] = 	pfunc;
  base[_MCASP_PDIR_OFFSET]  = 	pdir;  
              
  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
IDEF void MCASP_configArgs(MCASP_Handle hMcasp, Uint32 pfunc, Uint32 pdir, 
  Uint32 amute, Uint32 dlbctl, Uint32 ditctl, Uint32 rmask, Uint32 rfmt, Uint32 afsrctl,
  Uint32 aclkrctl, Uint32 ahclkrctl, Uint32 rtdm, Uint32 rintctl, Uint32 rclkchk,
  Uint32 xmask, Uint32 xfmt, Uint32 afsxctl, Uint32 aclkxctl, Uint32 ahclkxctl, Uint32 xtdm, 
  Uint32 xintctl, Uint32 xclkchk, Uint32 srctl0, Uint32 srctl1, Uint32 srctl2, Uint32 srctl3, 
  Uint32 srctl4, Uint32 srctl5) 
{

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);

  gie = IRQ_globalDisable();

  base[_MCASP_RMASK_OFFSET] = rmask;
  base[_MCASP_RFMT_OFFSET] = rfmt;  
  base[_MCASP_AFSRCTL_OFFSET] = afsrctl;  
  base[_MCASP_ACLKRCTL_OFFSET]= aclkrctl;  
  base[_MCASP_AHCLKRCTL_OFFSET]= ahclkrctl;   
  base[_MCASP_RTDM_OFFSET] = rtdm;
  base[_MCASP_RINTCTL_OFFSET] = rintctl;   
  base[_MCASP_RCLKCHK_OFFSET] = rclkchk;   
  base[_MCASP_XMASK_OFFSET] = xmask;
  base[_MCASP_XFMT_OFFSET] = xfmt;   
  base[_MCASP_AFSXCTL_OFFSET] = afsxctl;   
  base[_MCASP_ACLKXCTL_OFFSET]= aclkxctl;   
  base[_MCASP_AHCLKXCTL_OFFSET]=ahclkxctl;    
  base[_MCASP_XTDM_OFFSET] = xtdm;   
  base[_MCASP_XINTCTL_OFFSET] = xintctl;   
  base[_MCASP_XCLKCHK_OFFSET] = xclkchk;   
  base[_MCASP_SRCTL0_OFFSET] = srctl0;
  base[_MCASP_SRCTL1_OFFSET] = srctl1;         
  base[_MCASP_SRCTL2_OFFSET] = srctl2;         
  base[_MCASP_SRCTL3_OFFSET] = srctl3;         
  base[_MCASP_SRCTL4_OFFSET] = srctl4;         
  base[_MCASP_SRCTL5_OFFSET] = srctl5;         
  base[_MCASP_AMUTE_OFFSET]  = amute;  
  base[_MCASP_DLBCTL_OFFSET] = dlbctl;  
  base[_MCASP_DITCTL_OFFSET] =  ditctl;  
  base[_MCASP_PFUNC_OFFSET] = pfunc;
  base[_MCASP_PDIR_OFFSET]  = pdir;  
              
  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
IDEF void MCASP_configArgs(MCASP_Handle hMcasp, Uint32 pfunc, Uint32 pdir, 
  Uint32 amute, Uint32 dlbctl, Uint32 ditctl, Uint32 rmask, Uint32 rfmt, Uint32 afsrctl,
  Uint32 aclkrctl, Uint32 ahclkrctl, Uint32 rtdm, Uint32 rintctl, Uint32 rclkchk,
  Uint32 xmask, Uint32 xfmt, Uint32 afsxctl, Uint32 aclkxctl, Uint32 ahclkxctl, Uint32 xtdm, 
  Uint32 xintctl, Uint32 xclkchk, Uint32 srctl0, Uint32 srctl1, Uint32 srctl2, Uint32 srctl3) 
{

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);

  gie = IRQ_globalDisable();

  base[_MCASP_RMASK_OFFSET] = rmask;
  base[_MCASP_RFMT_OFFSET] = rfmt;  
  base[_MCASP_AFSRCTL_OFFSET] = afsrctl;  
  base[_MCASP_ACLKRCTL_OFFSET]= aclkrctl;  
  base[_MCASP_AHCLKRCTL_OFFSET]= ahclkrctl;   
  base[_MCASP_RTDM_OFFSET] = rtdm;
  base[_MCASP_RINTCTL_OFFSET] = rintctl;   
  base[_MCASP_RCLKCHK_OFFSET] = rclkchk;   
  base[_MCASP_XMASK_OFFSET] = xmask;
  base[_MCASP_XFMT_OFFSET] = xfmt;   
  base[_MCASP_AFSXCTL_OFFSET] = afsxctl;   
  base[_MCASP_ACLKXCTL_OFFSET]= aclkxctl;   
  base[_MCASP_AHCLKXCTL_OFFSET]=ahclkxctl;    
  base[_MCASP_XTDM_OFFSET] = xtdm;   
  base[_MCASP_XINTCTL_OFFSET] = xintctl;   
  base[_MCASP_XCLKCHK_OFFSET] = xclkchk;   
  base[_MCASP_SRCTL0_OFFSET] = srctl0;
  base[_MCASP_SRCTL1_OFFSET] = srctl1;         
  base[_MCASP_SRCTL2_OFFSET] = srctl2;         
  base[_MCASP_SRCTL3_OFFSET] = srctl3;         
  base[_MCASP_AMUTE_OFFSET]  = amute;  
  base[_MCASP_DLBCTL_OFFSET] = dlbctl;  
  base[_MCASP_DITCTL_OFFSET] =  ditctl;  
  base[_MCASP_PFUNC_OFFSET] = pfunc;
  base[_MCASP_PDIR_OFFSET]  = pdir;  
              
  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 4 */

/*----------------------------------------------------------------------------*/
#if (_MCASP_CHANNEL_CNT == 16)
IDEF void MCASP_getConfig(MCASP_Handle hMcasp, MCASP_Config *config)
{

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  volatile MCASP_Config* cfg = (volatile MCASP_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
	
  x0  = base[_MCASP_PFUNC_OFFSET]; 
  x1  = base[_MCASP_PDIR_OFFSET];  
  x2  = base[_MCASP_AMUTE_OFFSET]; 
  x3  = base[_MCASP_DLBCTL_OFFSET]; 
  x4  = base[_MCASP_DITCTL_OFFSET];
  x5  = base[_MCASP_RMASK_OFFSET]; 
  x6  = base[_MCASP_RFMT_OFFSET]; 
  x7  = base[_MCASP_AFSRCTL_OFFSET]; 
  x8  = base[_MCASP_ACLKRCTL_OFFSET];
  x9  = base[_MCASP_AHCLKRCTL_OFFSET];
  x10 = base[_MCASP_RTDM_OFFSET];  
  x11 = base[_MCASP_RINTCTL_OFFSET]; 
  x12 = base[_MCASP_RCLKCHK_OFFSET]; 
  x13 = base[_MCASP_XMASK_OFFSET]; 
  x14 = base[_MCASP_XFMT_OFFSET]; 
  x15 = base[_MCASP_AFSXCTL_OFFSET]; 
  x16 = base[_MCASP_ACLKXCTL_OFFSET];
  x17 = base[_MCASP_AHCLKXCTL_OFFSET];
  x18 = base[_MCASP_XTDM_OFFSET];  
  x19 = base[_MCASP_XINTCTL_OFFSET]; 
  x20 = base[_MCASP_XCLKCHK_OFFSET]; 
  x21 = base[_MCASP_SRCTL0_OFFSET]; 
  x22 = base[_MCASP_SRCTL1_OFFSET];       
  x23 = base[_MCASP_SRCTL2_OFFSET];       
  x24 = base[_MCASP_SRCTL3_OFFSET];       
  x25 = base[_MCASP_SRCTL4_OFFSET];       
  x26 = base[_MCASP_SRCTL5_OFFSET];       
  x27 = base[_MCASP_SRCTL6_OFFSET];       
  x28 = base[_MCASP_SRCTL7_OFFSET];       
  x29 = base[_MCASP_SRCTL8_OFFSET];       
  x30 = base[_MCASP_SRCTL9_OFFSET];       
  x31 = base[_MCASP_SRCTL10_OFFSET];      
  x32 = base[_MCASP_SRCTL11_OFFSET];      
  x33 = base[_MCASP_SRCTL12_OFFSET];      
  x34 = base[_MCASP_SRCTL13_OFFSET];      
  x35 = base[_MCASP_SRCTL14_OFFSET];      
  x36 = base[_MCASP_SRCTL15_OFFSET];      
  
  cfg->global->pfunc        =  x0;
  cfg->global->pdir         =  x1;     
  cfg->global->amute        =  x2;     
  cfg->global->dlbctl        =  x3;     
  cfg->global->ditctl      =  x4;     
  cfg->receive->rmask       =  x5;
  cfg->receive->rfmt        =  x6;           
  cfg->receive->afsrctl     =  x7;           
  cfg->receive->aclkrctl    =  x8;           
  cfg->receive->ahclkrctl   =  x9;     
  cfg->receive->rtdm        =  x10;
  cfg->receive->rintctl     =  x11;            
  cfg->receive->rclkchk     =  x12;            
  cfg->transmit->xmask      =  x13;            
  cfg->transmit->xfmt       =  x14;            
  cfg->transmit->afsxctl    =  x15;       
  cfg->transmit->aclkxctl   =  x16;            
  cfg->transmit->ahclkxctl  =  x17;            
  cfg->transmit->xtdm       =  x18;            
  cfg->transmit->xintctl    =  x19;            
  cfg->transmit->xclkchk    =  x20;            
  cfg->srctl->srctl0       =  x21;     
  cfg->srctl->srctl1       =  x22;                
  cfg->srctl->srctl2       =  x23;                
  cfg->srctl->srctl3       =  x24;                
  cfg->srctl->srctl4       =  x25;                
  cfg->srctl->srctl5       =  x26;                
  cfg->srctl->srctl6       =  x27;                
  cfg->srctl->srctl7       =  x28;                
  cfg->srctl->srctl8       =  x29;                
  cfg->srctl->srctl9       =  x30;           
  cfg->srctl->srctl10      =  x31;           
  cfg->srctl->srctl11      =  x32;                
  cfg->srctl->srctl12      =  x33;                
  cfg->srctl->srctl13      =  x34;                
  cfg->srctl->srctl14      =  x35;                
  cfg->srctl->srctl15      =  x36;                

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
IDEF void MCASP_getConfig(MCASP_Handle hMcasp, MCASP_Config *config)
{

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  volatile MCASP_Config* cfg = (volatile MCASP_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26,x27,x28;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
	
  x0  = base[_MCASP_PFUNC_OFFSET]; 
  x1  = base[_MCASP_PDIR_OFFSET];  
  x2  = base[_MCASP_AMUTE_OFFSET]; 
  x3  = base[_MCASP_DLBCTL_OFFSET]; 
  x4  = base[_MCASP_DITCTL_OFFSET];
  x5  = base[_MCASP_RMASK_OFFSET]; 
  x6  = base[_MCASP_RFMT_OFFSET]; 
  x7  = base[_MCASP_AFSRCTL_OFFSET]; 
  x8  = base[_MCASP_ACLKRCTL_OFFSET];
  x9  = base[_MCASP_AHCLKRCTL_OFFSET];
  x10 = base[_MCASP_RTDM_OFFSET];  
  x11 = base[_MCASP_RINTCTL_OFFSET]; 
  x12 = base[_MCASP_RCLKCHK_OFFSET]; 
  x13 = base[_MCASP_XMASK_OFFSET]; 
  x14 = base[_MCASP_XFMT_OFFSET]; 
  x15 = base[_MCASP_AFSXCTL_OFFSET]; 
  x16 = base[_MCASP_ACLKXCTL_OFFSET];
  x17 = base[_MCASP_AHCLKXCTL_OFFSET];
  x18 = base[_MCASP_XTDM_OFFSET];  
  x19 = base[_MCASP_XINTCTL_OFFSET]; 
  x20 = base[_MCASP_XCLKCHK_OFFSET]; 
  x21 = base[_MCASP_SRCTL0_OFFSET]; 
  x22 = base[_MCASP_SRCTL1_OFFSET];       
  x23 = base[_MCASP_SRCTL2_OFFSET];       
  x24 = base[_MCASP_SRCTL3_OFFSET];       
  x25 = base[_MCASP_SRCTL4_OFFSET];       
  x26 = base[_MCASP_SRCTL5_OFFSET];       
  x27 = base[_MCASP_SRCTL6_OFFSET];       
  x28 = base[_MCASP_SRCTL7_OFFSET];       
  
  cfg->global->pfunc        =  x0;
  cfg->global->pdir         =  x1;     
  cfg->global->amute        =  x2;     
  cfg->global->dlbctl       =  x3;     
  cfg->global->ditctl       =  x4;     
  cfg->receive->rmask       =  x5;
  cfg->receive->rfmt        =  x6;           
  cfg->receive->afsrctl     =  x7;           
  cfg->receive->aclkrctl    =  x8;           
  cfg->receive->ahclkrctl   =  x9;     
  cfg->receive->rtdm        =  x10;
  cfg->receive->rintctl     =  x11;            
  cfg->receive->rclkchk     =  x12;            
  cfg->transmit->xmask      =  x13;            
  cfg->transmit->xfmt       =  x14;            
  cfg->transmit->afsxctl    =  x15;       
  cfg->transmit->aclkxctl   =  x16;            
  cfg->transmit->ahclkxctl  =  x17;            
  cfg->transmit->xtdm       =  x18;            
  cfg->transmit->xintctl    =  x19;            
  cfg->transmit->xclkchk    =  x20;            
  cfg->srctl->srctl0        =  x21;     
  cfg->srctl->srctl1        =  x22;                
  cfg->srctl->srctl2        =  x23;                
  cfg->srctl->srctl3        =  x24;                
  cfg->srctl->srctl4        =  x25;                
  cfg->srctl->srctl5        =  x26;                
  cfg->srctl->srctl6        =  x27;                
  cfg->srctl->srctl7        =  x28;                

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
IDEF void MCASP_getConfig(MCASP_Handle hMcasp, MCASP_Config *config)
{

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  volatile MCASP_Config* cfg = (volatile MCASP_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */

  x0  = base[_MCASP_PFUNC_OFFSET]; 
  x1  = base[_MCASP_PDIR_OFFSET];  
  x2  = base[_MCASP_AMUTE_OFFSET]; 
  x3  = base[_MCASP_DLBCTL_OFFSET]; 
  x4  = base[_MCASP_DITCTL_OFFSET];
  x5  = base[_MCASP_RMASK_OFFSET]; 
  x6  = base[_MCASP_RFMT_OFFSET]; 
  x7  = base[_MCASP_AFSRCTL_OFFSET]; 
  x8  = base[_MCASP_ACLKRCTL_OFFSET];
  x9  = base[_MCASP_AHCLKRCTL_OFFSET];
  x10 = base[_MCASP_RTDM_OFFSET];  
  x11 = base[_MCASP_RINTCTL_OFFSET]; 
  x12 = base[_MCASP_RCLKCHK_OFFSET]; 
  x13 = base[_MCASP_XMASK_OFFSET]; 
  x14 = base[_MCASP_XFMT_OFFSET]; 
  x15 = base[_MCASP_AFSXCTL_OFFSET]; 
  x16 = base[_MCASP_ACLKXCTL_OFFSET];
  x17 = base[_MCASP_AHCLKXCTL_OFFSET];
  x18 = base[_MCASP_XTDM_OFFSET];  
  x19 = base[_MCASP_XINTCTL_OFFSET]; 
  x20 = base[_MCASP_XCLKCHK_OFFSET]; 
  x21 = base[_MCASP_SRCTL0_OFFSET]; 
  x22 = base[_MCASP_SRCTL1_OFFSET];       
  x23 = base[_MCASP_SRCTL2_OFFSET];       
  x24 = base[_MCASP_SRCTL3_OFFSET];       
  x25 = base[_MCASP_SRCTL4_OFFSET];       
  x26 = base[_MCASP_SRCTL5_OFFSET];       
  
  cfg->global->pfunc        =  x0;
  cfg->global->pdir         =  x1;     
  cfg->global->amute        =  x2;     
  cfg->global->dlbctl       =  x3;     
  cfg->global->ditctl       =  x4;     
  cfg->receive->rmask       =  x5;
  cfg->receive->rfmt        =  x6;           
  cfg->receive->afsrctl     =  x7;           
  cfg->receive->aclkrctl    =  x8;           
  cfg->receive->ahclkrctl   =  x9;     
  cfg->receive->rtdm        =  x10;
  cfg->receive->rintctl     =  x11;            
  cfg->receive->rclkchk     =  x12;            
  cfg->transmit->xmask      =  x13;            
  cfg->transmit->xfmt       =  x14;            
  cfg->transmit->afsxctl    =  x15;       
  cfg->transmit->aclkxctl   =  x16;            
  cfg->transmit->ahclkxctl  =  x17;            
  cfg->transmit->xtdm       =  x18;            
  cfg->transmit->xintctl    =  x19;            
  cfg->transmit->xclkchk    =  x20;            
  cfg->srctl->srctl0        =  x21;     
  cfg->srctl->srctl1        =  x22;                
  cfg->srctl->srctl2        =  x23;                
  cfg->srctl->srctl3        =  x24;                
  cfg->srctl->srctl4        =  x25;                
  cfg->srctl->srctl5        =  x26;                

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
IDEF void MCASP_getConfig(MCASP_Handle hMcasp, MCASP_Config *config)
{

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcasp->baseAddr);
  volatile MCASP_Config* cfg = (volatile MCASP_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */

  x0  = base[_MCASP_PFUNC_OFFSET]; 
  x1  = base[_MCASP_PDIR_OFFSET];  
  x2  = base[_MCASP_AMUTE_OFFSET]; 
  x3  = base[_MCASP_DLBCTL_OFFSET]; 
  x4  = base[_MCASP_DITCTL_OFFSET];
  x5  = base[_MCASP_RMASK_OFFSET]; 
  x6  = base[_MCASP_RFMT_OFFSET]; 
  x7  = base[_MCASP_AFSRCTL_OFFSET]; 
  x8  = base[_MCASP_ACLKRCTL_OFFSET];
  x9  = base[_MCASP_AHCLKRCTL_OFFSET];
  x10 = base[_MCASP_RTDM_OFFSET];  
  x11 = base[_MCASP_RINTCTL_OFFSET]; 
  x12 = base[_MCASP_RCLKCHK_OFFSET]; 
  x13 = base[_MCASP_XMASK_OFFSET]; 
  x14 = base[_MCASP_XFMT_OFFSET]; 
  x15 = base[_MCASP_AFSXCTL_OFFSET]; 
  x16 = base[_MCASP_ACLKXCTL_OFFSET];
  x17 = base[_MCASP_AHCLKXCTL_OFFSET];
  x18 = base[_MCASP_XTDM_OFFSET];  
  x19 = base[_MCASP_XINTCTL_OFFSET]; 
  x20 = base[_MCASP_XCLKCHK_OFFSET]; 
  x21 = base[_MCASP_SRCTL0_OFFSET]; 
  x22 = base[_MCASP_SRCTL1_OFFSET];       
  x23 = base[_MCASP_SRCTL2_OFFSET];       
  x24 = base[_MCASP_SRCTL3_OFFSET];       
  
  cfg->global->pfunc        =  x0;
  cfg->global->pdir         =  x1;     
  cfg->global->amute        =  x2;     
  cfg->global->dlbctl       =  x3;     
  cfg->global->ditctl       =  x4;     
  cfg->receive->rmask       =  x5;
  cfg->receive->rfmt        =  x6;           
  cfg->receive->afsrctl     =  x7;           
  cfg->receive->aclkrctl    =  x8;           
  cfg->receive->ahclkrctl   =  x9;     
  cfg->receive->rtdm        =  x10;
  cfg->receive->rintctl     =  x11;            
  cfg->receive->rclkchk     =  x12;            
  cfg->transmit->xmask      =  x13;            
  cfg->transmit->xfmt       =  x14;            
  cfg->transmit->afsxctl    =  x15;       
  cfg->transmit->aclkxctl   =  x16;            
  cfg->transmit->ahclkxctl  =  x17;            
  cfg->transmit->xtdm       =  x18;            
  cfg->transmit->xintctl    =  x19;            
  cfg->transmit->xclkchk    =  x20;            
  cfg->srctl->srctl0        =  x21;     
  cfg->srctl->srctl1        =  x22;                
  cfg->srctl->srctl2        =  x23;                
  cfg->srctl->srctl3        =  x24;                

  IRQ_globalRestore(gie);
}
#endif /* _MCASP_CHANNEL_CNT == 4 */


/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* MCASP_SUPPORT */
#endif /* _CSL_MCASP_H_ */
/******************************************************************************\
* End of csl_mcasp.h
\******************************************************************************/


csl_mcasphal.h/ 1092218722  0     0     0       289612    `
/******************************************************************************\
* Step 1.     Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mcasphal.h
* DATE CREATED.. 06/28/2001 
* LAST MODIFIED. 
*                08/02/2004 - Adding support for C6418
*------------------------------------------------------------------------------
*HISTORY......6/29/01, changed RSLOT to RSLOTCNT, XSLOT to XSLOTCNT
* 7/2/01, XFMT: changed XROT field to 0-2 instead of 0-3
*	also added field XDATDLY in bits 17:16 (made appropriate macro changes)
*	RFMT: same as above (RROT wasn't specified, but made sense)
*	AFSXCTL/AFSRCTL: removed X(R)DATDLY fields and macro entries.
*	ACLKRCTL: changed CLKRDIV field to bits 4:0(was 5:0),CLKRM to bit 5(was 6)
*	HCLKXDIV/HCLKRDIV: changed field HCLKX(R)DIV to bit 11:0 (was 12:0)
*	SCRTL: changed defaults of fields XRDY and RRDY to 0b (was 1b)
*	Added register DLBCTL
*	Added registers X(R)INTCTL
*	8/6/01 fixed MCASP_RFMT_RPAD_RPBIT; was formerly _XPBIT
*	08/13/01  V.G.  Reordered the registers and added OFFSETs
*	08/14/01  V.G.  Corrected syntax errors
*	08/20/01  V.G.	Added addresses for each register
*
*     17/06/04        Adding support for DM640/641
*     11/03/01  F.S   CRFAIL -> RCKFAIL / CXFAIL -> XCKFAIL
*     11/15/01  F.S   PWREMUMGT -> PWRDEMU
*                     PFUNC / PDIR /PDSOUT /PDSET /PDCLR -> fields renaming
*     11/20/01  F.S   GBLCTL / XGBLCTL / RGBLCTL 
*                     RRST -> RSMRST , RGRST -> RCLKRST , HCLKRRST -> RHCLKRST
*                     XRST -> XSMRST , XGRST -> XCLKRST , HCLKXRST -> XHCLKRST
*     10/22/03        Fixed the typos in MCASP_PDOUT_DEFAULT and MCASP_PDOUT_RMK
*                            
*------------------------------------------------------------------------------
* REGISTERS (register list)
*
* PID		- Peripheral Identification Register            
* PWRDEMU	- Power Down and Emulation Management Register  
* PFUNC		- Pin Function / GPIO Enable Register  
* PDIR		- Pin Direction Register 
* PDAT		- Pin Data Register   
* PDIN		- Pin Data Input Register  
* PDOUT		- Pin Data Output Register  
* PDSET		- Pin Data Set Register 
* PDCLR		- Pin Data Clear Register  
* DITCTL    - Transmit DIT Control Register  
* DLBCTL    -  Loop Back Control Mode
* XFMT		- Transmit Bitstream Format Register 
* RFMT		- Receive Bitstream Format Register  
* XMASK
* RMASK		
* AFSXCTL	- Transmit Frame Control Register 
* AFSRCTL	- Receive Frame Control Register 
* ACLKXCTL	- Transmit Clock Control Register 
* ACLKRCTL	- Receive Clock Control Register 
* AHCLKXCTL	- High Frequency Transmit Clock Control Register Description
* AHCLKRCTL	- High Frequency Receive Clock Control Register Description     
* SRCTL0	- Serializer Control Register 0
* SRCTL1	- Serializer Control Register 1
* SRCTL2	- Serializer Control Register 2
* SRCTL3	- Serializer Control Register 3
* SRCTL4	- Serializer Control Register 4
* SRCTL5	- Serializer Control Register 5
* SRCTL6	- Serializer Control Register 6
* SRCTL7	- Serializer Control Register 7
* SRCTL8	- Serializer Control Register 8 (1)
* SRCTL9	- Serializer Control Register 9 (1)
* SRCTL10	- Serializer Control Register 10 (1)
* SRCTL11	- Serializer Control Register 11 (1)
* SRCTL12	- Serializer Control Register 12 (1)
* SRCTL13	- Serializer Control Register 13 (1)
* SRCTL14	- Serializer Control Register 14 (1)
* SRCTL15	- Serializer Control Register 15 (1)
* XTDM		- Transmit TDM Register
* RTDM		- Receive TDM Register          
* GBLCTL	- Global Control Register            
* XGBLCTL	- Global Control Register            
* RGBLCTL	- Global Control Register            
* AMUTE	- Mute Control Register        
* XINTCTL   - Transmitter Interrupt Control Register
* RINTCTL   - Receiver Interrupt Control Register
* RSTAT	- Receiver Status Register 
* XSTAT	- Transmitter Status Register 
* RSLOTCNT	- Receiver TDM Slot Counter
* XSLOTCNT	- Transmitter TDM Slot Counter
* XCLKCHK	- Transmit Clock Check Control Register
* RCLKCHK	- Receive Clock Check Control Register
* XBUF0	- Transmit Buffer for Serializer 0
* XBUF1	- Transmit Buffer for Serializer 1
* XBUF2	- Transmit Buffer for Serializer 2
* XBUF3	- Transmit Buffer for Serializer 3
* XBUF4	- Transmit Buffer for Serializer 4
* XBUF5	- Transmit Buffer for Serializer 5
* XBUF6	- Transmit Buffer for Serializer 6
* XBUF7	- Transmit Buffer for Serializer 7
* XBUF8	- Transmit Buffer for Serializer 8 (1)
* XBUF9	- Transmit Buffer for Serializer 9 (1)
* XBUF10	- Transmit Buffer for Serializer 10 (1)
* XBUF11	- Transmit Buffer for Serializer 11 (1)
* XBUF12	- Transmit Buffer for Serializer 12 (1)
* XBUF13	- Transmit Buffer for Serializer 13 (1)
* XBUF14	- Transmit Buffer for Serializer 14 (1)
* XBUF15	- Transmit Buffer for Serializer 15 (1)
* RBUF0	- Receive Buffer for Serializer 0
* RBUF1	- Receive Buffer for Serializer 1
* RBUF2	- Receive Buffer for Serializer 2
* RBUF3	- Receive Buffer for Serializer 3
* RBUF4	- Receive Buffer for Serializer 4
* RBUF5	- Receive Buffer for Serializer 5
* RBUF6	- Receive Buffer for Serializer 6
* RBUF7	- Receive Buffer for Serializer 7
* RBUF8	- Receive Buffer for Serializer 8 
* RBUF9	- Receive Buffer for Serializer 9 
* RBUF10	- Receive Buffer for Serializer 10
* RBUF11	- Receive Buffer for Serializer 11 
* RBUF12	- Receive Buffer for Serializer 12 
* RBUF13	- Receive Buffer for Serializer 13 
* RBUF14	- Receive Buffer for Serializer 14 
* RBUF15	- Receive Buffer for Serializer 15 
* DITCSRA0n	- Left (even TDM Slot) Channel Status Register File
* DITCSRA1n
* DITCSRA2n
* DITCSRA3n
* DITCSRA4n
* DITCSRA5n
* DITCSRB0n	- Right (even TDM Slot) Channel Status Register File
* DITCSRB1n
* DITCSRB2n
* DITCSRB3n
* DITCSRB4n
* DITCSRB5n
* DITUDRA0n	- Left (even TDM Slot) User Data Register File
* DITUDRA1n
* DITUDRA2n
* DITUDRA3n
* DITUDRA4n
* DITUDRA5n
* DITUDRB0n	- Right (even TDM Slot) User Data Register File
* DITUDRB1n
* DITUDRB2n
* DITUDRB3n
* DITUDRB4n
* DITUDRB5n
* 
*
\******************************************************************************/
/******************************************************************************\
* Step 2. Private Macros and Include files
\******************************************************************************/
#ifndef _CSL_MCASPHAL_H_
#define _CSL_MCASPHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (MCASP_SUPPORT)
/******************************************************************************\
* Step 3. MISC section 
* Example:
* #define _MCASP_BASE_GLOBAL   0xXXXXXXXXu
\******************************************************************************/
#if (CHIP_6713 | CHIP_DA610 | CHIP_6413 | CHIP_6418 | CHIP_6410)
 #define _MCASP_PORT_CNT        2
#endif

#if (CHIP_DM642 | CHIP_DM641 | CHIP_DM640)
 #define _MCASP_PORT_CNT        1
#endif

#if (CHIP_DM641 | CHIP_DM640)
    #define _MCASP_CHANNEL_CNT    4
#endif

#if (CHIP_6413 | CHIP_6418 | CHIP_6410)
    #define _MCASP_CHANNEL_CNT    6
#endif

#if (CHIP_DM642 | CHIP_6713)
    #define _MCASP_CHANNEL_CNT    8
#endif

#if (CHIP_DA610)
    #define _MCASP_CHANNEL_CNT    16
#endif

#define _MCASP_BASE_PORT0      0x01B4C000u
#define _MCASP_BASE_PORT1      0x01B50000u

/******************************************************************************\
* Step 4. Module level register/field access macros
\******************************************************************************/

  /* -------------------------- */
  /* Step 4.1 FIELD MAKE MACROS */
  /* -------------------------- */

  #define MCASP_FMK(REG,FIELD,x)\
    _PER_FMK(MCASP,##REG,##FIELD,x)

  #define MCASP_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(MCASP,##REG,##FIELD,##SYM)
 
 
  /* ----------------------------------------- */
  /* Step 4.2 RAW REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define MCASP_ADDR(REG)\
    _MCASP_##REG##_ADDR

  #define MCASP_RGET(REG)\
    _PER_RGET(_MCASP_##REG##_ADDR,MCASP,##REG)

  #define MCASP_RSET(REG,x)\
    _PER_RSET(_MCASP_##REG##_ADDR,MCASP,##REG,x)

  #define MCASP_FGET(REG,FIELD)\
    _MCASP_##REG##_FGET(##FIELD)

  #define MCASP_FSET(REG,FIELD,x)\
    _MCASP_##REG##_FSET(##FIELD,x)

  #define MCASP_FSETS(REG,FIELD,SYM)\
    _MCASP_##REG##_FSETS(##FIELD,##SYM)
 
 
  /* --------------------------------------------------- */
  /* Step 4.3 ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* --------------------------------------------------- */

  #define MCASP_RGETA(addr,REG)\
    _PER_RGET(addr,MCASP,##REG)

  #define MCASP_RSETA(addr,REG,x)\
    _PER_RSET(addr,MCASP,##REG,x)

  #define MCASP_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,MCASP,##REG,##FIELD)

  #define MCASP_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,MCASP,##REG,##FIELD,x)

  #define MCASP_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,MCASP,##REG,##FIELD,##SYM)

  /* -------------------------------------------------- */
  /* Step 4.4 HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------------------------- */
  
  /* For non-handle based Module : remove the following macros  (remove me)*/
  /* See CDK Chapter 3. Module specification and CSL definitions ( remove me)*/ 
  
   #define MCASP_ADDRH(h,REG)\
    (Uint32)(&((h)->baseAddr[_MCASP_##REG##_OFFSET]))

  #define MCASP_RGETH(h,REG)\
    MCASP_RGETA(MCASP_ADDRH(h,##REG),##REG)

  #define MCASP_RSETH(h,REG,x)\
    MCASP_RSETA(MCASP_ADDRH(h,##REG),##REG,x)

  #define MCASP_FGETH(h,REG,FIELD)\
    MCASP_FGETA(MCASP_ADDRH(h,##REG),##REG,##FIELD)

  #define MCASP_FSETH(h,REG,FIELD,x)\
    MCASP_FSETA(MCASP_ADDRH(h,##REG),##REG,##FIELD,x)

  #define MCASP_FSETSH(h,REG,FIELD,SYM)\
    MCASP_FSETSA(MCASP_ADDRH(h,##REG),##REG,##FIELD,##SYM)



/******************************************************************************\
*  
* _____________________
* |                   |
* |     P  I  D       |
* |___________________|
*
* PID  -  Peripheral Identification Register
*
* FIELDS (msb -> lsb)
* (r)  TYPE
* (r)  CLASS
* (r)  REV
*
\******************************************************************************/

  #define _MCASP_PID_OFFSET		0

  #define _MCASP_PID0_ADDR		(_MCASP_BASE_PORT0 + 4*_MCASP_PID_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PID1_ADDR		(_MCASP_BASE_PORT1 + 4*_MCASP_PID_OFFSET)
#endif

  #define _MCASP_PID_TYPE_MASK		0x00FF0000u
  #define _MCASP_PID_TYPE_SHIFT		0x00000010u
  #define  MCASP_PID_TYPE_DEFAULT	0x00000010u
  #define  MCASP_PID_TYPE_OF(x)		_VALUEOF(x)
  #define  MCASP_PID_TYPE_MCASP		0x00000010u
 

  #define _MCASP_PID_CLASS_MASK		0x0000FF00u
  #define _MCASP_PID_CLASS_SHIFT	0x00000008u
  #define  MCASP_PID_CLASS_DEFAULT	0x00000001u
  #define  MCASP_PID_CLASS_OF(x)	_VALUEOF(x)
  #define  MCASP_PID_CLASS_SERPORT	0x00000001u
  

  #define _MCASP_PID_REV_MASK		0x000000FFu
  #define _MCASP_PID_REV_SHIFT		0x00000000u
  #define  MCASP_PID_REV_DEFAULT	0x00000001u
  #define  MCASP_PID_REV_OF(x)		_VALUEOF(x)
  #define  MCASP_PID_REV_ONE		0x00000001u


  #define  MCASP_PID_OF(x)		_VALUEOF(x)

  #define MCASP_PID_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PID,TYPE)\
	| _PER_FDEFAULT(MCASP,PID,CLASS)\
	| _PER_FDEFAULT(MCASP,PID,REV)\
  )

     
  #define MCASP_PID_RMK(type, class, rev) (Uint32)( \
     _PER_FMK(MCASP,PID,TYPE,type)\
	| _PER_FMK(MCASP,PID,CLASS,class)\
	| _PER_FMK(MCASP,PID,REV,rev)\
  )

  
  #define _MCASP_PID_FGET(N,FIELD)\
    _PER_FGET(_MCASP_PID##N##_ADDR,MCASP,PID,##FIELD)

  #define _MCASP_PID_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_PID##N##_ADDR,MCASP,PID,##FIELD,field)

  #define _MCASP_PID_FSETS(N,FIELD,SYM)\
  	_PER_FSETS(_MCASP_PID##N##_ADDR,MCASP,PID,##FIELD,##SYM)

  #define _MCASP_PID0_FGET(FIELD) _MCASP_PID_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PID1_FGET(FIELD) _MCASP_PID_FGET(1,##FIELD)
#endif
 
  #define _MCASP_PID0_FSET(FIELD,f) _MCASP_PID_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PID1_FSET(FIELD,f) _MCASP_PID_FSET(1,##FIELD,f)
#endif

  #define _MCASP_PID0_FSETS(FIELD,SYM) _MCASP_PID_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PID1_FSETS(FIELD,SYM) _MCASP_PID_FSETS(1,##FIELD,##SYM)
#endif

/******************************************************************************\
* Step 4.5
* _____________________
* |                   |
* |     PWRDEMU       |  
* |___________________|
*
* PWRDEMU  -  Power Down and Emulation Management
*
* FIELDS (msb -> lsb)
* (rw)  FREE  
*
\******************************************************************************/

  #define _MCASP_PWRDEMU_OFFSET                 1

  #define _MCASP_PWRDEMU0_ADDR			(_MCASP_BASE_PORT0+4*_MCASP_PWRDEMU_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PWRDEMU1_ADDR			(_MCASP_BASE_PORT1+4*_MCASP_PWRDEMU_OFFSET)
#endif

  #define _MCASP_PWRDEMU_FREE_MASK              0x00000001u
  #define _MCASP_PWRDEMU_FREE_SHIFT             0x00000000u
  #define  MCASP_PWRDEMU_FREE_DEFAULT           0x00000000u
  #define  MCASP_PWRDEMU_FREE_OF(x)             _VALUEOF(x)
  #define  MCASP_PWRDEMU_FREE_OFF               0x00000000u
  #define  MCASP_PWRDEMU_FREE_ON                0x00000001u

  #define  MCASP_PWRDEMU_OF(x)                _VALUEOF(x)

  #define MCASP_PWRDEMU_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PWRDEMU,FREE)\
  )

  #define MCASP_PWRDEMU_RMK(free) (Uint32)( \
     _PER_FMK(MCASP,PWRDEMU,FREE,free)\
  )

  #define _MCASP_PWRDEMU_FGET(N,FIELD)\
    _PER_FGET(_MCASP_PWRDEMU##N##_ADDR,MCASP,PWRDEMU,##FIELD)

  #define _MCASP_PWRDEMU_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_PWRDEMU##N##_ADDR,MCASP,PWRDEMU,##FIELD,field)

  #define _MCASP_PWRDEMU_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_PWRDEMU##N##_ADDR,MCASP,PWRDEMU,##FIELD,##SYM)

  #define _MCASP_PWRDEMU0_FGET(FIELD) _MCASP_PWRDEMU_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PWRDEMU1_FGET(FIELD) _MCASP_PWRDEMU_FGET(1,##FIELD)
#endif
 
  #define _MCASP_PWRDEMU0_FSET(FIELD,f) _MCASP_PWRDEMU_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PWRDEMU1_FSET(FIELD,f) _MCASP_PWRDEMU_FSET(1,##FIELD,f)
#endif

  #define _MCASP_PWRDEMU0_FSETS(FIELD,SYM) _MCASP_PWRDEMU_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PWRDEMU1_FSETS(FIELD,SYM) _MCASP_PWRDEMU_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* Step 4.5
* _____________________
* |                   |
* |     PFUNC         |
* |___________________|
*
* PFUNC		- Pin Function / GPIO Enable Register
*
* FIELDS (msb -> lsb)
* (rw)  AFSR
* (rw)  AHCLKR 
* (rw)  ACLKR 
* (rw)  AFSX
* (rw)  AHCLKX 
* (rw)  ACLKX
* (rw)  AMUTE
* (rw)  AXR0-15 
\******************************************************************************/

  #define _MCASP_PFUNC_OFFSET                   4

  #define _MCASP_PFUNC0_ADDR		        (_MCASP_BASE_PORT0+4*_MCASP_PFUNC_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PFUNC1_ADDR		        (_MCASP_BASE_PORT1+4*_MCASP_PFUNC_OFFSET)
#endif
  #define _MCASP_PFUNC_AXR0_MASK		0x00000001u
  #define _MCASP_PFUNC_AXR0_SHIFT		0x00000000u
  #define  MCASP_PFUNC_AXR0_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR0_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR0_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR0_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR1_MASK		0x00000002u
  #define _MCASP_PFUNC_AXR1_SHIFT		0x00000001u
  #define  MCASP_PFUNC_AXR1_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR1_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR1_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR1_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR2_MASK		0x00000004u
  #define _MCASP_PFUNC_AXR2_SHIFT		0x00000002u
  #define  MCASP_PFUNC_AXR2_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR2_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR2_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR2_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR3_MASK		0x00000008u
  #define _MCASP_PFUNC_AXR3_SHIFT		0x00000003u
  #define  MCASP_PFUNC_AXR3_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR3_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR3_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR3_GPIO		0x00000001u
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_PFUNC_AXR4_MASK		0x00000010u
  #define _MCASP_PFUNC_AXR4_SHIFT		0x00000004u
  #define  MCASP_PFUNC_AXR4_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR4_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR4_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR4_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR5_MASK		0x00000020u
  #define _MCASP_PFUNC_AXR5_SHIFT		0x00000005u
  #define  MCASP_PFUNC_AXR5_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR5_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR5_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR5_GPIO		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_PFUNC_AXR6_MASK		0x00000040u
  #define _MCASP_PFUNC_AXR6_SHIFT		0x00000006u
  #define  MCASP_PFUNC_AXR6_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR6_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR6_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR6_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR7_MASK		0x00000080u
  #define _MCASP_PFUNC_AXR7_SHIFT		0x00000007u
  #define  MCASP_PFUNC_AXR7_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR7_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR7_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR7_GPIO		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_PFUNC_AXR8_MASK		0x00000100u
  #define _MCASP_PFUNC_AXR8_SHIFT		0x00000008u
  #define  MCASP_PFUNC_AXR8_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR8_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR8_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR8_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR9_MASK		0x00000200u
  #define _MCASP_PFUNC_AXR9_SHIFT		0x00000009u
  #define  MCASP_PFUNC_AXR9_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR9_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR9_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR9_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR10_MASK		0x00000400u
  #define _MCASP_PFUNC_AXR10_SHIFT		0x0000000Au
  #define  MCASP_PFUNC_AXR10_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR10_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR10_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR10_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR11_MASK		0x00000800u
  #define _MCASP_PFUNC_AXR11_SHIFT		0x0000000Bu
  #define  MCASP_PFUNC_AXR11_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR11_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR11_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR11_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR12_MASK		0x00001000u
  #define _MCASP_PFUNC_AXR12_SHIFT		0x0000000Cu
  #define  MCASP_PFUNC_AXR12_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR12_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR12_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR12_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR13_MASK		0x00002000u
  #define _MCASP_PFUNC_AXR13_SHIFT		0x0000000Du
  #define  MCASP_PFUNC_AXR13_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR13_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR13_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR13_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR14_MASK		0x00004000u
  #define _MCASP_PFUNC_AXR14_SHIFT		0x0000000Eu
  #define  MCASP_PFUNC_AXR14_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR14_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR14_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR14_GPIO		0x00000001u

  #define _MCASP_PFUNC_AXR15_MASK		0x00008000u
  #define _MCASP_PFUNC_AXR15_SHIFT		0x0000000Fu
  #define  MCASP_PFUNC_AXR15_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AXR15_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AXR15_MCASP		0x00000000u
  #define  MCASP_PFUNC_AXR15_GPIO		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_PFUNC_AMUTE_MASK		0x02000000u
  #define _MCASP_PFUNC_AMUTE_SHIFT		0x00000019u
  #define  MCASP_PFUNC_AMUTE_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AMUTE_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AMUTE_MCASP		0x00000000u
  #define  MCASP_PFUNC_AMUTE_GPIO		0x00000001u

  #define _MCASP_PFUNC_ACLKX_MASK		0x04000000u
  #define _MCASP_PFUNC_ACLKX_SHIFT		0x0000001Au
  #define  MCASP_PFUNC_ACLKX_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_ACLKX_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_ACLKX_MCASP		0x00000000u
  #define  MCASP_PFUNC_ACLKX_GPIO		0x00000001u

  #define _MCASP_PFUNC_AHCLKX_MASK		0x08000000u
  #define _MCASP_PFUNC_AHCLKX_SHIFT		0x0000001Bu
  #define  MCASP_PFUNC_AHCLKX_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AHCLKX_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AHCLKX_MCASP		0x00000000u
  #define  MCASP_PFUNC_AHCLKX_GPIO		0x00000001u

  #define _MCASP_PFUNC_AFSX_MASK		0x10000000u
  #define _MCASP_PFUNC_AFSX_SHIFT		0x0000001Cu
  #define  MCASP_PFUNC_AFSX_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AFSX_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AFSX_MCASP		0x00000000u
  #define  MCASP_PFUNC_AFSX_GPIO		0x00000001u

  #define _MCASP_PFUNC_ACLKR_MASK		0x20000000u
  #define _MCASP_PFUNC_ACLKR_SHIFT		0x0000001Du
  #define  MCASP_PFUNC_ACLKR_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_ACLKR_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_ACLKR_MCASP		0x00000000u
  #define  MCASP_PFUNC_ACLKR_GPIO		0x00000001u

  #define _MCASP_PFUNC_AHCLKR_MASK		0x40000000u
  #define _MCASP_PFUNC_AHCLKR_SHIFT		0x0000001Eu
  #define  MCASP_PFUNC_AHCLKR_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AHCLKR_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AHCLKR_MCASP		0x00000000u
  #define  MCASP_PFUNC_AHCLKR_GPIO		0x00000001u

  #define _MCASP_PFUNC_AFSR_MASK		0x80000000u
  #define _MCASP_PFUNC_AFSR_SHIFT		0x0000001Fu
  #define  MCASP_PFUNC_AFSR_DEFAULT		0x00000000u
  #define  MCASP_PFUNC_AFSR_OF(x)		_VALUEOF(x)
  #define  MCASP_PFUNC_AFSR_MCASP		0x00000000u
  #define  MCASP_PFUNC_AFSR_GPIO		0x00000001u


  #define  MCASP_PFUNC_OF(x)                    _VALUEOF(x)

#if (_MCASP_CHANNEL_CNT == 16)
  #define MCASP_PFUNC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PFUNC,AXR0)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR1)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR2)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR3)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR4)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR5)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR6)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR7)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR8)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR9)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR10)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR11)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR12)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR13)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR14)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR15)\
    |_PER_FDEFAULT(MCASP,PFUNC,AMUTE)\
    |_PER_FDEFAULT(MCASP,PFUNC,ACLKX)\
    |_PER_FDEFAULT(MCASP,PFUNC,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PFUNC,AFSX)\
    |_PER_FDEFAULT(MCASP,PFUNC,ACLKR)\
    |_PER_FDEFAULT(MCASP,PFUNC,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PFUNC,AFSR)\
  )

  #define MCASP_PFUNC_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
    axr15,axr14,axr13,axr12,axr11,axr10,\
    axr9, axr8,axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
 (Uint32)( \
     _PER_FMK(MCASP,PFUNC,AXR0,axr0)\
    |_PER_FMK(MCASP,PFUNC,AXR1,axr1)\
    |_PER_FMK(MCASP,PFUNC,AXR2,axr2)\
    |_PER_FMK(MCASP,PFUNC,AXR3,axr3)\
    |_PER_FMK(MCASP,PFUNC,AXR4,axr4)\
    |_PER_FMK(MCASP,PFUNC,AXR5,axr5)\
    |_PER_FMK(MCASP,PFUNC,AXR6,axr6)\
    |_PER_FMK(MCASP,PFUNC,AXR7,axr7)\
    |_PER_FMK(MCASP,PFUNC,AXR8,axr8)\
    |_PER_FMK(MCASP,PFUNC,AXR9,axr9)\
    |_PER_FMK(MCASP,PFUNC,AXR10,axr10)\
    |_PER_FMK(MCASP,PFUNC,AXR11,axr11)\
    |_PER_FMK(MCASP,PFUNC,AXR12,axr12)\
    |_PER_FMK(MCASP,PFUNC,AXR13,axr13)\
    |_PER_FMK(MCASP,PFUNC,AXR14,axr14)\
    |_PER_FMK(MCASP,PFUNC,AXR15,axr15)\
    |_PER_FMK(MCASP,PFUNC,AMUTE,amute)\
    |_PER_FMK(MCASP,PFUNC,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PFUNC,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PFUNC,AFSX,afsx)\
    |_PER_FMK(MCASP,PFUNC,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PFUNC,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PFUNC,AFSR,afsr)\
  )
#endif  /* (_MCASP_CHANNEL_CNT == 16) */

#if (_MCASP_CHANNEL_CNT == 8)
  #define MCASP_PFUNC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PFUNC,AXR0)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR1)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR2)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR3)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR4)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR5)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR6)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR7)\
    |_PER_FDEFAULT(MCASP,PFUNC,AMUTE)\
    |_PER_FDEFAULT(MCASP,PFUNC,ACLKX)\
    |_PER_FDEFAULT(MCASP,PFUNC,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PFUNC,AFSX)\
    |_PER_FDEFAULT(MCASP,PFUNC,ACLKR)\
    |_PER_FDEFAULT(MCASP,PFUNC,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PFUNC,AFSR)\
  )

  #define MCASP_PFUNC_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
 (Uint32)( \
     _PER_FMK(MCASP,PFUNC,AXR0,axr0)\
    |_PER_FMK(MCASP,PFUNC,AXR1,axr1)\
    |_PER_FMK(MCASP,PFUNC,AXR2,axr2)\
    |_PER_FMK(MCASP,PFUNC,AXR3,axr3)\
    |_PER_FMK(MCASP,PFUNC,AXR4,axr4)\
    |_PER_FMK(MCASP,PFUNC,AXR5,axr5)\
    |_PER_FMK(MCASP,PFUNC,AXR6,axr6)\
    |_PER_FMK(MCASP,PFUNC,AXR7,axr7)\
    |_PER_FMK(MCASP,PFUNC,AMUTE,amute)\
    |_PER_FMK(MCASP,PFUNC,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PFUNC,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PFUNC,AFSX,afsx)\
    |_PER_FMK(MCASP,PFUNC,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PFUNC,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PFUNC,AFSR,afsr)\
  )
#endif /* (_MCASP_CHANNEL_CNT == 8) */

#if (_MCASP_CHANNEL_CNT == 6)
  #define MCASP_PFUNC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PFUNC,AXR0)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR1)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR2)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR3)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR4)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR5)\
    |_PER_FDEFAULT(MCASP,PFUNC,AMUTE)\
    |_PER_FDEFAULT(MCASP,PFUNC,ACLKX)\
    |_PER_FDEFAULT(MCASP,PFUNC,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PFUNC,AFSX)\
    |_PER_FDEFAULT(MCASP,PFUNC,ACLKR)\
    |_PER_FDEFAULT(MCASP,PFUNC,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PFUNC,AFSR)\
  )

  #define MCASP_PFUNC_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr5,axr4,axr3,axr2,axr1, axr0) \
 (Uint32)( \
     _PER_FMK(MCASP,PFUNC,AXR0,axr0)\
    |_PER_FMK(MCASP,PFUNC,AXR1,axr1)\
    |_PER_FMK(MCASP,PFUNC,AXR2,axr2)\
    |_PER_FMK(MCASP,PFUNC,AXR3,axr3)\
    |_PER_FMK(MCASP,PFUNC,AXR4,axr4)\
    |_PER_FMK(MCASP,PFUNC,AXR5,axr5)\
    |_PER_FMK(MCASP,PFUNC,AMUTE,amute)\
    |_PER_FMK(MCASP,PFUNC,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PFUNC,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PFUNC,AFSX,afsx)\
    |_PER_FMK(MCASP,PFUNC,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PFUNC,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PFUNC,AFSR,afsr)\
  )
#endif /* (_MCASP_CHANNEL_CNT == 6) */

#if (_MCASP_CHANNEL_CNT == 4)
  #define MCASP_PFUNC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PFUNC,AXR0)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR1)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR2)\
    |_PER_FDEFAULT(MCASP,PFUNC,AXR3)\
    |_PER_FDEFAULT(MCASP,PFUNC,AMUTE)\
    |_PER_FDEFAULT(MCASP,PFUNC,ACLKX)\
    |_PER_FDEFAULT(MCASP,PFUNC,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PFUNC,AFSX)\
    |_PER_FDEFAULT(MCASP,PFUNC,ACLKR)\
    |_PER_FDEFAULT(MCASP,PFUNC,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PFUNC,AFSR)\
  )

  #define MCASP_PFUNC_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr3,axr2,axr1, axr0) \
 (Uint32)( \
     _PER_FMK(MCASP,PFUNC,AXR0,axr0)\
    |_PER_FMK(MCASP,PFUNC,AXR1,axr1)\
    |_PER_FMK(MCASP,PFUNC,AXR2,axr2)\
    |_PER_FMK(MCASP,PFUNC,AXR3,axr3)\
    |_PER_FMK(MCASP,PFUNC,AMUTE,amute)\
    |_PER_FMK(MCASP,PFUNC,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PFUNC,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PFUNC,AFSX,afsx)\
    |_PER_FMK(MCASP,PFUNC,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PFUNC,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PFUNC,AFSR,afsr)\
  )
#endif /* (_MCASP_CHANNEL_CNT == 4) */


  #define _MCASP_PFUNC_FGET(N,FIELD)\
    _PER_FGET(_MCASP_PFUNC##N##_ADDR,MCASP,PFUNC,##FIELD)

  #define _MCASP_PFUNC_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_PFUNC##N##_ADDR,MCASP,PFUNC,##FIELD,field)

  #define _MCASP_PFUNC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_PFUNC##N##_ADDR,MCASP,PFUNC,##FIELD,##SYM)

  #define _MCASP_PFUNC0_FGET(FIELD) _MCASP_PFUNC_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PFUNC1_FGET(FIELD) _MCASP_PFUNC_FGET(1,##FIELD)
#endif
 
  #define _MCASP_PFUNC0_FSET(FIELD,f) _MCASP_PFUNC_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PFUNC1_FSET(FIELD,f) _MCASP_PFUNC_FSET(1,##FIELD,f)
#endif

  #define _MCASP_PFUNC0_FSETS(FIELD,SYM) _MCASP_PFUNC_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PFUNC1_FSETS(FIELD,SYM) _MCASP_PFUNC_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* Step 4.5
* _____________________
* |                   |
* |     PDIR          |
* |___________________|
*
* PDIR		- Pin Direction Register
*
* FIELDS (msb -> lsb)
* (rw)  AFSR
* (rw)  AHCLKR 
* (rw)  ACLKR 
* (rw)  AFSX
* (rw)  AHCLKX 
* (rw)  ACLKX
* (rw)  AMUTE
* (rw)  AXR0-15 
*
\******************************************************************************/

  #define _MCASP_PDIR_OFFSET		5

  #define _MCASP_PDIR0_ADDR		(_MCASP_BASE_PORT0+4*_MCASP_PDIR_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDIR1_ADDR		(_MCASP_BASE_PORT1+4*_MCASP_PDIR_OFFSET)
#endif

  #define _MCASP_PDIR_AXR0_MASK		0x00000001u
  #define _MCASP_PDIR_AXR0_SHIFT	0x00000000u
  #define  MCASP_PDIR_AXR0_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR0_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR0_IN		0x00000000u
  #define  MCASP_PDIR_AXR0_OUT		0x00000001u

  #define _MCASP_PDIR_AXR1_MASK		0x00000002u
  #define _MCASP_PDIR_AXR1_SHIFT	0x00000001u
  #define  MCASP_PDIR_AXR1_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR1_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR1_IN		0x00000000u
  #define  MCASP_PDIR_AXR1_OUT		0x00000001u

  #define _MCASP_PDIR_AXR2_MASK		0x00000004u
  #define _MCASP_PDIR_AXR2_SHIFT	0x00000002u
  #define  MCASP_PDIR_AXR2_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR2_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR2_IN		0x00000000u
  #define  MCASP_PDIR_AXR2_OUT		0x00000001u

  #define _MCASP_PDIR_AXR3_MASK		0x00000008u
  #define _MCASP_PDIR_AXR3_SHIFT	0x00000003u
  #define  MCASP_PDIR_AXR3_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR3_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR3_IN		0x00000000u
  #define  MCASP_PDIR_AXR3_OUT		0x00000001u
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_PDIR_AXR4_MASK		0x00000010u
  #define _MCASP_PDIR_AXR4_SHIFT	0x00000004u
  #define  MCASP_PDIR_AXR4_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR4_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR4_IN		0x00000000u
  #define  MCASP_PDIR_AXR4_OUT		0x00000001u

  #define _MCASP_PDIR_AXR5_MASK		0x00000020u
  #define _MCASP_PDIR_AXR5_SHIFT	0x00000005u
  #define  MCASP_PDIR_AXR5_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR5_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR5_IN		0x00000000u
  #define  MCASP_PDIR_AXR5_OUT		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_PDIR_AXR6_MASK		0x00000040u
  #define _MCASP_PDIR_AXR6_SHIFT	0x00000006u
  #define  MCASP_PDIR_AXR6_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR6_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR6_IN		0x00000000u
  #define  MCASP_PDIR_AXR6_OUT		0x00000001u

  #define _MCASP_PDIR_AXR7_MASK		0x00000080u
  #define _MCASP_PDIR_AXR7_SHIFT	0x00000007u
  #define  MCASP_PDIR_AXR7_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR7_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR7_IN		0x00000000u
  #define  MCASP_PDIR_AXR7_OUT		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_PDIR_AXR8_MASK		0x00000100u
  #define _MCASP_PDIR_AXR8_SHIFT	0x00000008u
  #define  MCASP_PDIR_AXR8_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR8_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR8_IN		0x00000000u
  #define  MCASP_PDIR_AXR8_OUT		0x00000001u

  #define _MCASP_PDIR_AXR9_MASK		0x00000200u
  #define _MCASP_PDIR_AXR9_SHIFT	0x00000009u
  #define  MCASP_PDIR_AXR9_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR9_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR9_IN		0x00000000u
  #define  MCASP_PDIR_AXR9_OUT		0x00000001u

  #define _MCASP_PDIR_AXR10_MASK	0x00000400u
  #define _MCASP_PDIR_AXR10_SHIFT	0x0000000Au
  #define  MCASP_PDIR_AXR10_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR10_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR10_IN		0x00000000u
  #define  MCASP_PDIR_AXR10_OUT		0x00000001u

  #define _MCASP_PDIR_AXR11_MASK	0x00000800u
  #define _MCASP_PDIR_AXR11_SHIFT	0x0000000Bu
  #define  MCASP_PDIR_AXR11_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR11_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR11_IN		0x00000000u
  #define  MCASP_PDIR_AXR11_OUT		0x00000001u

  #define _MCASP_PDIR_AXR12_MASK	0x00001000u
  #define _MCASP_PDIR_AXR12_SHIFT	0x0000000Cu
  #define  MCASP_PDIR_AXR12_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR12_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR12_IN		0x00000000u
  #define  MCASP_PDIR_AXR12_OUT		0x00000001u

  #define _MCASP_PDIR_AXR13_MASK	0x00002000u
  #define _MCASP_PDIR_AXR13_SHIFT	0x0000000Du
  #define  MCASP_PDIR_AXR13_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR13_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR13_IN		0x00000000u
  #define  MCASP_PDIR_AXR13_OUT		0x00000001u

  #define _MCASP_PDIR_AXR14_MASK	0x00004000u
  #define _MCASP_PDIR_AXR14_SHIFT	0x0000000Eu
  #define  MCASP_PDIR_AXR14_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR14_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR14_IN		0x00000000u
  #define  MCASP_PDIR_AXR14_OUT		0x00000001u

  #define _MCASP_PDIR_AXR15_MASK	0x00008000u
  #define _MCASP_PDIR_AXR15_SHIFT	0x0000000Fu
  #define  MCASP_PDIR_AXR15_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AXR15_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AXR15_IN		0x00000000u
  #define  MCASP_PDIR_AXR15_OUT		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_PDIR_AMUTE_MASK	0x02000000u
  #define _MCASP_PDIR_AMUTE_SHIFT	0x00000019u
  #define  MCASP_PDIR_AMUTE_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AMUTE_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AMUTE_IN		0x00000000u
  #define  MCASP_PDIR_AMUTE_OUT		0x00000001u

  #define _MCASP_PDIR_ACLKX_MASK	0x04000000u
  #define _MCASP_PDIR_ACLKX_SHIFT	0x0000001Au
  #define  MCASP_PDIR_ACLKX_DEFAULT	0x00000000u
  #define  MCASP_PDIR_ACLKX_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_ACLKX_IN		0x00000000u
  #define  MCASP_PDIR_ACLKX_OUT		0x00000001u

  #define _MCASP_PDIR_AHCLKX_MASK	0x08000000u
  #define _MCASP_PDIR_AHCLKX_SHIFT	0x0000001Bu
  #define  MCASP_PDIR_AHCLKX_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AHCLKX_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AHCLKX_IN		0x00000000u
  #define  MCASP_PDIR_AHCLKX_OUT	0x00000001u

  #define _MCASP_PDIR_AFSX_MASK		0x10000000u
  #define _MCASP_PDIR_AFSX_SHIFT	0x0000001Cu
  #define  MCASP_PDIR_AFSX_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AFSX_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AFSX_IN		0x00000000u
  #define  MCASP_PDIR_AFSX_OUT		0x00000001u

  #define _MCASP_PDIR_ACLKR_MASK	0x20000000u
  #define _MCASP_PDIR_ACLKR_SHIFT	0x0000001Du
  #define  MCASP_PDIR_ACLKR_DEFAULT	0x00000000u
  #define  MCASP_PDIR_ACLKR_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_ACLKR_IN		0x00000000u
  #define  MCASP_PDIR_ACLKR_OUT		0x00000001u

  #define _MCASP_PDIR_AHCLKR_MASK	0x40000000u
  #define _MCASP_PDIR_AHCLKR_SHIFT	0x0000001Eu
  #define  MCASP_PDIR_AHCLKR_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AHCLKR_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AHCLKR_IN		0x00000000u
  #define  MCASP_PDIR_AHCLKR_OUT	0x00000001u

  #define _MCASP_PDIR_AFSR_MASK		0x80000000u
  #define _MCASP_PDIR_AFSR_SHIFT	0x0000001Fu
  #define  MCASP_PDIR_AFSR_DEFAULT	0x00000000u
  #define  MCASP_PDIR_AFSR_OF(x)	_VALUEOF(x)
  #define  MCASP_PDIR_AFSR_IN		0x00000000u
  #define  MCASP_PDIR_AFSR_OUT		0x00000001u

  #define  MCASP_PDIR_OF(x)	        _VALUEOF(x)

#if (_MCASP_CHANNEL_CNT == 16)
  #define MCASP_PDIR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDIR,AXR0)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR1)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR2)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR3)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR4)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR5)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR6)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR7)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR8)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR9)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR10)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR11)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR12)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR13)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR14)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR15)\
    |_PER_FDEFAULT(MCASP,PDIR,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDIR,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDIR,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDIR,AFSX)\
    |_PER_FDEFAULT(MCASP,PDIR,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDIR,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDIR,AFSR)\
  )

  #define MCASP_PDIR_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
    axr15,axr14,axr13,axr12,axr11,axr10,\
    axr9, axr8,axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
   (Uint32)( \
     _PER_FMK(MCASP,PDIR,AXR0,axr0)\
    |_PER_FMK(MCASP,PDIR,AXR1,axr1)\
    |_PER_FMK(MCASP,PDIR,AXR2,axr2)\
    |_PER_FMK(MCASP,PDIR,AXR3,axr3)\
    |_PER_FMK(MCASP,PDIR,AXR4,axr4)\
    |_PER_FMK(MCASP,PDIR,AXR5,axr5)\
    |_PER_FMK(MCASP,PDIR,AXR6,axr6)\
    |_PER_FMK(MCASP,PDIR,AXR7,axr7)\
    |_PER_FMK(MCASP,PDIR,AXR8,axr8)\
    |_PER_FMK(MCASP,PDIR,AXR9,axr9)\
    |_PER_FMK(MCASP,PDIR,AXR10,axr10)\
    |_PER_FMK(MCASP,PDIR,AXR11,axr11)\
    |_PER_FMK(MCASP,PDIR,AXR12,axr12)\
    |_PER_FMK(MCASP,PDIR,AXR13,axr13)\
    |_PER_FMK(MCASP,PDIR,AXR14,axr14)\
    |_PER_FMK(MCASP,PDIR,AXR15,axr15)\
    |_PER_FMK(MCASP,PDIR,AMUTE,amute)\
    |_PER_FMK(MCASP,PDIR,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDIR,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDIR,AFSX,afsx)\
    |_PER_FMK(MCASP,PDIR,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDIR,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDIR,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
  #define MCASP_PDIR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDIR,AXR0)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR1)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR2)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR3)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR4)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR5)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR6)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR7)\
    |_PER_FDEFAULT(MCASP,PDIR,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDIR,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDIR,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDIR,AFSX)\
    |_PER_FDEFAULT(MCASP,PDIR,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDIR,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDIR,AFSR)\
  )

  #define MCASP_PDIR_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                         axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
   (Uint32)( \
     _PER_FMK(MCASP,PDIR,AXR0,axr0)\
    |_PER_FMK(MCASP,PDIR,AXR1,axr1)\
    |_PER_FMK(MCASP,PDIR,AXR2,axr2)\
    |_PER_FMK(MCASP,PDIR,AXR3,axr3)\
    |_PER_FMK(MCASP,PDIR,AXR4,axr4)\
    |_PER_FMK(MCASP,PDIR,AXR5,axr5)\
    |_PER_FMK(MCASP,PDIR,AXR6,axr6)\
    |_PER_FMK(MCASP,PDIR,AXR7,axr7)\
    |_PER_FMK(MCASP,PDIR,AMUTE,amute)\
    |_PER_FMK(MCASP,PDIR,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDIR,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDIR,AFSX,afsx)\
    |_PER_FMK(MCASP,PDIR,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDIR,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDIR,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
  #define MCASP_PDIR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDIR,AXR0)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR1)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR2)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR3)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR4)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR5)\
    |_PER_FDEFAULT(MCASP,PDIR,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDIR,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDIR,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDIR,AFSX)\
    |_PER_FDEFAULT(MCASP,PDIR,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDIR,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDIR,AFSR)\
  )

  #define MCASP_PDIR_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                         axr5,axr4,axr3,axr2,axr1, axr0) \
   (Uint32)( \
     _PER_FMK(MCASP,PDIR,AXR0,axr0)\
    |_PER_FMK(MCASP,PDIR,AXR1,axr1)\
    |_PER_FMK(MCASP,PDIR,AXR2,axr2)\
    |_PER_FMK(MCASP,PDIR,AXR3,axr3)\
    |_PER_FMK(MCASP,PDIR,AXR4,axr4)\
    |_PER_FMK(MCASP,PDIR,AXR5,axr5)\
    |_PER_FMK(MCASP,PDIR,AMUTE,amute)\
    |_PER_FMK(MCASP,PDIR,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDIR,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDIR,AFSX,afsx)\
    |_PER_FMK(MCASP,PDIR,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDIR,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDIR,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
  #define MCASP_PDIR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDIR,AXR0)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR1)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR2)\
    |_PER_FDEFAULT(MCASP,PDIR,AXR3)\
    |_PER_FDEFAULT(MCASP,PDIR,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDIR,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDIR,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDIR,AFSX)\
    |_PER_FDEFAULT(MCASP,PDIR,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDIR,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDIR,AFSR)\
  )

  #define MCASP_PDIR_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                         axr3,axr2,axr1, axr0) \
   (Uint32)( \
     _PER_FMK(MCASP,PDIR,AXR0,axr0)\
    |_PER_FMK(MCASP,PDIR,AXR1,axr1)\
    |_PER_FMK(MCASP,PDIR,AXR2,axr2)\
    |_PER_FMK(MCASP,PDIR,AXR3,axr3)\
    |_PER_FMK(MCASP,PDIR,AMUTE,amute)\
    |_PER_FMK(MCASP,PDIR,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDIR,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDIR,AFSX,afsx)\
    |_PER_FMK(MCASP,PDIR,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDIR,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDIR,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 4 */

  #define _MCASP_PDIR_FGET(N,FIELD)\
    _PER_FGET(_MCASP_PDIR##N##_ADDR,MCASP,PDIR,##FIELD)

  #define _MCASP_PDIR_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_PDIR##N##_ADDR,MCASP,PDIR,##FIELD,field)

  #define _MCASP_PDIR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_PDIR##N##_ADDR,MCASP,PDIR,##FIELD,##SYM)
 
  #define _MCASP_PDIR0_FGET(FIELD) _MCASP_PDIR_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDIR1_FGET(FIELD) _MCASP_PDIR_FGET(1,##FIELD)
#endif

  #define _MCASP_PDIR0_FSET(FIELD,f) _MCASP_PDIR_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDIR1_FSET(FIELD,f) _MCASP_PDIR_FSET(1,##FIELD,f)
#endif

  #define _MCASP_PDIR0_FSETS(FIELD,SYM) _MCASP_PDIR_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDIR1_FSETS(FIELD,SYM) _MCASP_PDIR_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     PDOUT         |
* |___________________|
*
* PDOUT		- Pin Data Output Register
*
* FIELDS (msb -> lsb)
* (rw)  AFSR
* (rw)  AHCLKR 
* (rw)  ACLKR 
* (rw)  AFSX
* (rw)  AHCLKX 
* (rw)  ACLKX
* (rw)  AMUTE
* (rw)  AXR0-15 
*
\******************************************************************************/

  #define _MCASP_PDOUT_OFFSET                   6

  #define _MCASP_PDOUT0_ADDR			(_MCASP_BASE_PORT0+4*_MCASP_PDOUT_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDOUT1_ADDR			(_MCASP_BASE_PORT1+4*_MCASP_PDOUT_OFFSET)
#endif

  #define _MCASP_PDOUT_AXR0_MASK        	0x00000001u
  #define _MCASP_PDOUT_AXR0_SHIFT       	0x00000000u
  #define  MCASP_PDOUT_AXR0_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR0_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR0_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR0_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR1_MASK        	0x00000002u
  #define _MCASP_PDOUT_AXR1_SHIFT       	0x00000001u
  #define  MCASP_PDOUT_AXR1_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR1_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR1_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR1_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR2_MASK        	0x00000004u
  #define _MCASP_PDOUT_AXR2_SHIFT       	0x00000002u
  #define  MCASP_PDOUT_AXR2_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR2_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR2_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR2_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR3_MASK        	0x00000008u
  #define _MCASP_PDOUT_AXR3_SHIFT       	0x00000003u
  #define  MCASP_PDOUT_AXR3_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR3_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR3_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR3_HIGH		0x00000001u
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_PDOUT_AXR4_MASK        	0x00000010u
  #define _MCASP_PDOUT_AXR4_SHIFT       	0x00000004u
  #define  MCASP_PDOUT_AXR4_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR4_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR4_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR4_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR5_MASK        	0x00000020u
  #define _MCASP_PDOUT_AXR5_SHIFT       	0x00000005u
  #define  MCASP_PDOUT_AXR5_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR5_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR5_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR5_HIGH		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_PDOUT_AXR6_MASK        	0x00000040u
  #define _MCASP_PDOUT_AXR6_SHIFT       	0x00000006u
  #define  MCASP_PDOUT_AXR6_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR6_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR6_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR6_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR7_MASK        	0x00000080u
  #define _MCASP_PDOUT_AXR7_SHIFT       	0x00000007u
  #define  MCASP_PDOUT_AXR7_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR7_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR7_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR7_HIGH		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_PDOUT_AXR8_MASK        	0x00000100u
  #define _MCASP_PDOUT_AXR8_SHIFT       	0x00000008u
  #define  MCASP_PDOUT_AXR8_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR8_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR8_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR8_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR9_MASK        	0x00000200u
  #define _MCASP_PDOUT_AXR9_SHIFT       	0x00000009u
  #define  MCASP_PDOUT_AXR9_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR9_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR9_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AXR9_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR10_MASK        	0x00000400u
  #define _MCASP_PDOUT_AXR10_SHIFT       	0x0000000Au
  #define  MCASP_PDOUT_AXR10_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR10_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR10_LOW		0x00000000u
  #define  MCASP_PDOUT_AXR10_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR11_MASK        	0x00000800u
  #define _MCASP_PDOUT_AXR11_SHIFT       	0x0000000Bu
  #define  MCASP_PDOUT_AXR11_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR11_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR11_LOW		0x00000000u
  #define  MCASP_PDOUT_AXR11_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR12_MASK        	0x00001000u
  #define _MCASP_PDOUT_AXR12_SHIFT       	0x0000000Cu
  #define  MCASP_PDOUT_AXR12_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR12_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR12_LOW		0x00000000u
  #define  MCASP_PDOUT_AXR12_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR13_MASK        	0x00002000u
  #define _MCASP_PDOUT_AXR13_SHIFT       	0x0000000Du
  #define  MCASP_PDOUT_AXR13_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR13_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR13_LOW		0x00000000u
  #define  MCASP_PDOUT_AXR13_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR14_MASK        	0x00004000u
  #define _MCASP_PDOUT_AXR14_SHIFT       	0x0000000Eu
  #define  MCASP_PDOUT_AXR14_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR14_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR14_LOW		0x00000000u
  #define  MCASP_PDOUT_AXR14_HIGH		0x00000001u

  #define _MCASP_PDOUT_AXR15_MASK        	0x00008000u
  #define _MCASP_PDOUT_AXR15_SHIFT       	0x0000000Fu
  #define  MCASP_PDOUT_AXR15_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AXR15_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AXR15_LOW		0x00000000u
  #define  MCASP_PDOUT_AXR15_HIGH		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_PDOUT_AMUTE_MASK        	0x02000000u
  #define _MCASP_PDOUT_AMUTE_SHIFT       	0x00000019u
  #define  MCASP_PDOUT_AMUTE_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AMUTE_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AMUTE_LOW		0x00000000u
  #define  MCASP_PDOUT_AMUTE_HIGH		0x00000001u

  #define _MCASP_PDOUT_ACLKX_MASK        	0x04000000u
  #define _MCASP_PDOUT_ACLKX_SHIFT       	0x0000001Au
  #define  MCASP_PDOUT_ACLKX_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_ACLKX_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_ACLKX_LOW		0x00000000u
  #define  MCASP_PDOUT_ACLKX_HIGH		0x00000001u

  #define _MCASP_PDOUT_AHCLKX_MASK              0x08000000u
  #define _MCASP_PDOUT_AHCLKX_SHIFT             0x0000001Bu
  #define  MCASP_PDOUT_AHCLKX_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AHCLKX_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AHCLKX_LOW		0x00000000u
  #define  MCASP_PDOUT_AHCLKX_HIGH		0x00000001u

  #define _MCASP_PDOUT_AFSX_MASK        	0x10000000u
  #define _MCASP_PDOUT_AFSX_SHIFT       	0x0000001Cu
  #define  MCASP_PDOUT_AFSX_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AFSX_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AFSX_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AFSX_HIGH		0x00000001u

  #define _MCASP_PDOUT_ACLKR_MASK        	0x20000000u
  #define _MCASP_PDOUT_ACLKR_SHIFT       	0x0000001Du
  #define  MCASP_PDOUT_ACLKR_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_ACLKR_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_ACLKR_LOW		0x00000000u
  #define  MCASP_PDOUT_ACLKR_HIGH		0x00000001u

  #define _MCASP_PDOUT_AHCLKR_MASK              0x40000000u
  #define _MCASP_PDOUT_AHCLKR_SHIFT             0x0000001Eu
  #define  MCASP_PDOUT_AHCLKR_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AHCLKR_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AHCLKR_LOW		0x00000000u
  #define  MCASP_PDOUT_AHCLKR_HIGH		0x00000001u

  #define _MCASP_PDOUT_AFSR_MASK        	0x80000000u
  #define _MCASP_PDOUT_AFSR_SHIFT       	0x0000001Fu
  #define  MCASP_PDOUT_AFSR_DEFAULT		0x00000000u
  #define  MCASP_PDOUT_AFSR_OF(x)		_VALUEOF(x)
  #define  MCASP_PDOUT_AFSR_LOW	         	0x00000000u
  #define  MCASP_PDOUT_AFSR_HIGH		0x00000001u

  #define  MCASP_PDOUT_OF(x)                    _VALUEOF(x)

#if (_MCASP_CHANNEL_CNT == 16)
  #define MCASP_PDOUT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDOUT,AXR0)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR1)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR2)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR3)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR4)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR5)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR6)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR7)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR8)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR9)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR10)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR11)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR12)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR13)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR14)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR15)\
    |_PER_FDEFAULT(MCASP,PDOUT,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDOUT,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDOUT,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDOUT,AFSX)\
    |_PER_FDEFAULT(MCASP,PDOUT,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDOUT,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDOUT,AFSR)\
  )

  #define MCASP_PDOUT_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
    axr15,axr14,axr13,axr12,axr11,axr10,\
    axr9, axr8,axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
  (Uint32)( \
     _PER_FMK(MCASP,PDOUT,AXR0,axr0)\
    |_PER_FMK(MCASP,PDOUT,AXR1,axr1)\
    |_PER_FMK(MCASP,PDOUT,AXR2,axr2)\
    |_PER_FMK(MCASP,PDOUT,AXR3,axr3)\
    |_PER_FMK(MCASP,PDOUT,AXR4,axr4)\
    |_PER_FMK(MCASP,PDOUT,AXR5,axr5)\
    |_PER_FMK(MCASP,PDOUT,AXR6,axr6)\
    |_PER_FMK(MCASP,PDOUT,AXR7,axr7)\
    |_PER_FMK(MCASP,PDOUT,AXR8,axr8)\
    |_PER_FMK(MCASP,PDOUT,AXR9,axr9)\
    |_PER_FMK(MCASP,PDOUT,AXR10,axr10)\
    |_PER_FMK(MCASP,PDOUT,AXR11,axr11)\
    |_PER_FMK(MCASP,PDOUT,AXR12,axr12)\
    |_PER_FMK(MCASP,PDOUT,AXR13,axr13)\
    |_PER_FMK(MCASP,PDOUT,AXR14,axr14)\
    |_PER_FMK(MCASP,PDOUT,AXR15,axr15)\
    |_PER_FMK(MCASP,PDOUT,AMUTE,amute)\
    |_PER_FMK(MCASP,PDOUT,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDOUT,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDOUT,AFSX,afsx)\
    |_PER_FMK(MCASP,PDOUT,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDOUT,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDOUT,AFSR,afsr)\
  )
#endif  /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
  #define MCASP_PDOUT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDOUT,AXR0)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR1)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR2)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR3)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR4)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR5)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR6)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR7)\
    |_PER_FDEFAULT(MCASP,PDOUT,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDOUT,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDOUT,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDOUT,AFSX)\
    |_PER_FDEFAULT(MCASP,PDOUT,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDOUT,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDOUT,AFSR)\
  )

  #define MCASP_PDOUT_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
  (Uint32)( \
     _PER_FMK(MCASP,PDOUT,AXR0,axr0)\
    |_PER_FMK(MCASP,PDOUT,AXR1,axr1)\
    |_PER_FMK(MCASP,PDOUT,AXR2,axr2)\
    |_PER_FMK(MCASP,PDOUT,AXR3,axr3)\
    |_PER_FMK(MCASP,PDOUT,AXR4,axr4)\
    |_PER_FMK(MCASP,PDOUT,AXR5,axr5)\
    |_PER_FMK(MCASP,PDOUT,AXR6,axr6)\
    |_PER_FMK(MCASP,PDOUT,AXR7,axr7)\
    |_PER_FMK(MCASP,PDOUT,AMUTE,amute)\
    |_PER_FMK(MCASP,PDOUT,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDOUT,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDOUT,AFSX,afsx)\
    |_PER_FMK(MCASP,PDOUT,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDOUT,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDOUT,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
  #define MCASP_PDOUT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDOUT,AXR0)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR1)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR2)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR3)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR4)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR5)\
    |_PER_FDEFAULT(MCASP,PDOUT,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDOUT,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDOUT,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDOUT,AFSX)\
    |_PER_FDEFAULT(MCASP,PDOUT,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDOUT,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDOUT,AFSR)\
  )

  #define MCASP_PDOUT_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr5,axr4,axr3,axr2,axr1, axr0) \
  (Uint32)( \
     _PER_FMK(MCASP,PDOUT,AXR0,axr0)\
    |_PER_FMK(MCASP,PDOUT,AXR1,axr1)\
    |_PER_FMK(MCASP,PDOUT,AXR2,axr2)\
    |_PER_FMK(MCASP,PDOUT,AXR3,axr3)\
    |_PER_FMK(MCASP,PDOUT,AXR4,axr4)\
    |_PER_FMK(MCASP,PDOUT,AXR5,axr5)\
    |_PER_FMK(MCASP,PDOUT,AMUTE,amute)\
    |_PER_FMK(MCASP,PDOUT,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDOUT,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDOUT,AFSX,afsx)\
    |_PER_FMK(MCASP,PDOUT,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDOUT,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDOUT,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
  #define MCASP_PDOUT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDOUT,AXR0)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR1)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR2)\
    |_PER_FDEFAULT(MCASP,PDOUT,AXR3)\
    |_PER_FDEFAULT(MCASP,PDOUT,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDOUT,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDOUT,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDOUT,AFSX)\
    |_PER_FDEFAULT(MCASP,PDOUT,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDOUT,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDOUT,AFSR)\
  )

  #define MCASP_PDOUT_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr3,axr2,axr1, axr0) \
  (Uint32)( \
     _PER_FMK(MCASP,PDOUT,AXR0,axr0)\
    |_PER_FMK(MCASP,PDOUT,AXR1,axr1)\
    |_PER_FMK(MCASP,PDOUT,AXR2,axr2)\
    |_PER_FMK(MCASP,PDOUT,AXR3,axr3)\
    |_PER_FMK(MCASP,PDOUT,AMUTE,amute)\
    |_PER_FMK(MCASP,PDOUT,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDOUT,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDOUT,AFSX,afsx)\
    |_PER_FMK(MCASP,PDOUT,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDOUT,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDOUT,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 4 */

  #define _MCASP_PDOUT_FGET(N,FIELD)\
    _PER_FGET(_MCASP_PDOUT##N##_ADDR,MCASP,PDOUT,##FIELD)

  #define _MCASP_PDOUT_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_PDOUT##N##_ADDR,MCASP,PDOUT,##FIELD,field)

  #define _MCASP_PDOUT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_PDOUT##N##_ADDR,MCASP,PDOUT,##FIELD,##SYM)

  #define _MCASP_PDOUT0_FGET(FIELD) _MCASP_PDOUT_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDOUT1_FGET(FIELD) _MCASP_PDOUT_FGET(1,##FIELD)
#endif
 
  #define _MCASP_PDOUT0_FSET(FIELD,f) _MCASP_PDOUT_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDOUT1_FSET(FIELD,f) _MCASP_PDOUT_FSET(1,##FIELD,f)
#endif

  #define _MCASP_PDOUT0_FSETS(FIELD,SYM) _MCASP_PDOUT_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDOUT1_FSETS(FIELD,SYM) _MCASP_PDOUT_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     PDIN          |
* |___________________|
*
* PDIN		- Pin Data Input Register
*
* FIELDS (msb -> lsb)
* (rw)  AFSR
* (rw)  AHCLKR 
* (rw)  ACLKR 
* (rw)  AFSX
* (rw)  AHCLKX 
* (rw)  ACLKX
* (rw)  AMUTE
* (rw)  AXR0-15 
*
\******************************************************************************/

  #define _MCASP_PDIN_OFFSET            7

  #define _MCASP_PDIN0_ADDR		(_MCASP_BASE_PORT0+4*_MCASP_PDIN_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDIN1_ADDR		(_MCASP_BASE_PORT1+4*_MCASP_PDIN_OFFSET)
#endif

  #define _MCASP_PDIN_AXR0_MASK        	0x00000001u
  #define _MCASP_PDIN_AXR0_SHIFT       	0x00000000u
  #define  MCASP_PDIN_AXR0_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR0_OF(x)   	_VALUEOF(x)
  #define  MCASP_PDIN_AXR0_SET          0x00000001u

  #define _MCASP_PDIN_AXR1_MASK        	0x00000002u
  #define _MCASP_PDIN_AXR1_SHIFT       	0x00000001u
  #define  MCASP_PDIN_AXR1_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR1_OF(x)   	_VALUEOF(x)
  #define  MCASP_PDIN_AXR1_SET         	0x00000001u

  #define _MCASP_PDIN_AXR2_MASK        	0x00000004u
  #define _MCASP_PDIN_AXR2_SHIFT       	0x00000002u
  #define  MCASP_PDIN_AXR2_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR2_OF(x)        _VALUEOF(x)
  #define  MCASP_PDIN_AXR2_SET         	0x00000001u

  #define _MCASP_PDIN_AXR3_MASK        	0x00000008u
  #define _MCASP_PDIN_AXR3_SHIFT       	0x00000003u
  #define  MCASP_PDIN_AXR3_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR3_OF(x)        _VALUEOF(x)
  #define  MCASP_PDIN_AXR3_SET         	0x00000001u
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_PDIN_AXR4_MASK        	0x00000010u
  #define _MCASP_PDIN_AXR4_SHIFT       	0x00000004u
  #define  MCASP_PDIN_AXR4_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR4_OF(x)        _VALUEOF(x)
  #define  MCASP_PDIN_AXR4_SET         	0x00000001

  #define _MCASP_PDIN_AXR5_MASK        	0x00000020u
  #define _MCASP_PDIN_AXR5_SHIFT       	0x00000005u
  #define  MCASP_PDIN_AXR5_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR5_OF(x)        _VALUEOF(x)
  #define  MCASP_PDIN_AXR5_SET         	0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_PDIN_AXR6_MASK        	0x00000040u
  #define _MCASP_PDIN_AXR6_SHIFT       	0x00000006u
  #define  MCASP_PDIN_AXR6_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR6_OF(x)         _VALUEOF(x)
  #define  MCASP_PDIN_AXR6_SET         	0x00000001u

  #define _MCASP_PDIN_AXR7_MASK        	0x00000080u
  #define _MCASP_PDIN_AXR7_SHIFT       	0x00000007u
  #define  MCASP_PDIN_AXR7_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR7_OF(x)   	      _VALUEOF(x)
  #define  MCASP_PDIN_AXR7_SET        	0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_PDIN_AXR8_MASK        	0x00000100u
  #define _MCASP_PDIN_AXR8_SHIFT       	0x00000008u
  #define  MCASP_PDIN_AXR8_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR8_OF(x)   	      _VALUEOF(x)
  #define  MCASP_PDIN_AXR8_SET          	0x00000001u

  #define _MCASP_PDIN_AXR9_MASK        	0x00000200u
  #define _MCASP_PDIN_AXR9_SHIFT       	0x00000009u
  #define  MCASP_PDIN_AXR9_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR9_OF(x)   	      _VALUEOF(x)
  #define  MCASP_PDIN_AXR9_SET           	0x00000001u

  #define _MCASP_PDIN_AXR10_MASK        	0x00000400u
  #define _MCASP_PDIN_AXR10_SHIFT       	0x0000000Au
  #define  MCASP_PDIN_AXR10_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR10_OF(x)         _VALUEOF(x)
  #define  MCASP_PDIN_AXR10_SET         	0x00000001u

  #define _MCASP_PDIN_AXR11_MASK        	0x00000800u
  #define _MCASP_PDIN_AXR11_SHIFT       	0x0000000Bu
  #define  MCASP_PDIN_AXR11_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR11_OF(x)          _VALUEOF(x)
  #define  MCASP_PDIN_AXR11_SET        	0x00000001u

  #define _MCASP_PDIN_AXR12_MASK        	0x00001000u
  #define _MCASP_PDIN_AXR12_SHIFT       	0x0000000Cu
  #define  MCASP_PDIN_AXR12_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR12_OF(x)         _VALUEOF(x)
  #define  MCASP_PDIN_AXR12_SET       	0x00000001u

  #define _MCASP_PDIN_AXR13_MASK        	0x00002000u
  #define _MCASP_PDIN_AXR13_SHIFT       	0x0000000Du
  #define  MCASP_PDIN_AXR13_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR13_OF(x)         _VALUEOF(x)
  #define  MCASP_PDIN_AXR13_SET         	0x00000001u

  #define _MCASP_PDIN_AXR14_MASK        	0x00004000u
  #define _MCASP_PDIN_AXR14_SHIFT       	0x0000000Eu
  #define  MCASP_PDIN_AXR14_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR14_OF(x)          _VALUEOF(x)
  #define  MCASP_PDIN_AXR14_SET          	0x00000001u

  #define _MCASP_PDIN_AXR15_MASK        	0x00008000u
  #define _MCASP_PDIN_AXR15_SHIFT       	0x0000000Fu
  #define  MCASP_PDIN_AXR15_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AXR15_OF(x)         _VALUEOF(x)
  #define  MCASP_PDIN_AXR15_SET         	0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_PDIN_AMUTE_MASK        	0x02000000u
  #define _MCASP_PDIN_AMUTE_SHIFT       	0x00000019u
  #define  MCASP_PDIN_AMUTE_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AMUTE_OF(x)         _VALUEOF(x)
  #define  MCASP_PDIN_AMUTE_SET         	0x00000001u

  #define _MCASP_PDIN_ACLKX_MASK        	0x04000000u
  #define _MCASP_PDIN_ACLKX_SHIFT       	0x0000001Au
  #define  MCASP_PDIN_ACLKX_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_ACLKX_OF(x)         _VALUEOF(x)
  #define  MCASP_PDIN_ACLKX_SET         	0x00000001u

  #define _MCASP_PDIN_AHCLKX_MASK        	0x08000000u
  #define _MCASP_PDIN_AHCLKX_SHIFT       	0x0000001Bu
  #define  MCASP_PDIN_AHCLKX_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AHCLKX_OF(x)       _VALUEOF(x)
  #define  MCASP_PDIN_AHCLKX_SET          0x00000001u

  #define _MCASP_PDIN_AFSX_MASK        	0x10000000u
  #define _MCASP_PDIN_AFSX_SHIFT       	0x0000001Cu
  #define  MCASP_PDIN_AFSX_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AFSX_OF(x)   	     _VALUEOF(x)
  #define  MCASP_PDIN_AFSX_SET          	0x00000001u

  #define _MCASP_PDIN_ACLKR_MASK        	0x20000000u
  #define _MCASP_PDIN_ACLKR_SHIFT       	0x0000001Du
  #define  MCASP_PDIN_ACLKR_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_ACLKR_OF(x)         _VALUEOF(x)
  #define  MCASP_PDIN_ACLKR_SET          	0x00000001u

  #define _MCASP_PDIN_AHCLKR_MASK        	0x40000000u
  #define _MCASP_PDIN_AHCLKR_SHIFT       	0x0000001Eu
  #define  MCASP_PDIN_AHCLKR_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AHCLKR_OF(x)       _VALUEOF(x)
  #define  MCASP_PDIN_AHCLKR_SET        	0x00000001u

  #define _MCASP_PDIN_AFSR_MASK        	0x80000000u
  #define _MCASP_PDIN_AFSR_SHIFT       	0x0000001Fu
  #define  MCASP_PDIN_AFSR_DEFAULT     	0x00000000u
  #define  MCASP_PDIN_AFSR_OF(x)   	      _VALUEOF(x)
  #define  MCASP_PDIN_AFSR_SET          	0x00000001u

  #define  MCASP_PDIN_OF(x)              _VALUEOF(x)

#if (_MCASP_CHANNEL_CNT == 16)
  #define MCASP_PDIN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDIN,AXR0)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR1)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR2)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR3)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR4)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR5)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR6)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR7)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR8)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR9)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR10)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR11)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR12)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR13)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR14)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR15)\
    |_PER_FDEFAULT(MCASP,PDIN,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDIN,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDIN,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDIN,AFSX)\
    |_PER_FDEFAULT(MCASP,PDIN,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDIN,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDIN,AFSR)\
  )

  #define MCASP_PDIN_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
    axr15,axr14,axr13,axr12,axr11,axr10,\
    axr9, axr8,axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
   (Uint32)( \
     _PER_FMK(MCASP,PDIN,AXR0,axr0)\
    |_PER_FMK(MCASP,PDIN,AXR1,axr1)\
    |_PER_FMK(MCASP,PDIN,AXR2,axr2)\
    |_PER_FMK(MCASP,PDIN,AXR3,axr3)\
    |_PER_FMK(MCASP,PDIN,AXR4,axr4)\
    |_PER_FMK(MCASP,PDIN,AXR5,axr5)\
    |_PER_FMK(MCASP,PDIN,AXR6,axr6)\
    |_PER_FMK(MCASP,PDIN,AXR7,axr7)\
    |_PER_FMK(MCASP,PDIN,AXR8,axr8)\
    |_PER_FMK(MCASP,PDIN,AXR9,axr9)\
    |_PER_FMK(MCASP,PDIN,AXR10,axr10)\
    |_PER_FMK(MCASP,PDIN,AXR11,axr11)\
    |_PER_FMK(MCASP,PDIN,AXR12,axr12)\
    |_PER_FMK(MCASP,PDIN,AXR13,axr13)\
    |_PER_FMK(MCASP,PDIN,AXR14,axr14)\
    |_PER_FMK(MCASP,PDIN,AXR15,axr15)\
    |_PER_FMK(MCASP,PDIN,AMUTE,amute)\
    |_PER_FMK(MCASP,PDIN,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDIN,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDIN,AFSX,afsx)\
    |_PER_FMK(MCASP,PDIN,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDIN,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDIN,AFSR,afsr)\
  )
#endif  /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
  #define MCASP_PDIN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDIN,AXR0)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR1)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR2)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR3)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR4)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR5)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR6)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR7)\
    |_PER_FDEFAULT(MCASP,PDIN,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDIN,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDIN,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDIN,AFSX)\
    |_PER_FDEFAULT(MCASP,PDIN,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDIN,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDIN,AFSR)\
  )

  #define MCASP_PDIN_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                         axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
   (Uint32)( \
     _PER_FMK(MCASP,PDIN,AXR0,axr0)\
    |_PER_FMK(MCASP,PDIN,AXR1,axr1)\
    |_PER_FMK(MCASP,PDIN,AXR2,axr2)\
    |_PER_FMK(MCASP,PDIN,AXR3,axr3)\
    |_PER_FMK(MCASP,PDIN,AXR4,axr4)\
    |_PER_FMK(MCASP,PDIN,AXR5,axr5)\
    |_PER_FMK(MCASP,PDIN,AXR6,axr6)\
    |_PER_FMK(MCASP,PDIN,AXR7,axr7)\
    |_PER_FMK(MCASP,PDIN,AMUTE,amute)\
    |_PER_FMK(MCASP,PDIN,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDIN,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDIN,AFSX,afsx)\
    |_PER_FMK(MCASP,PDIN,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDIN,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDIN,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
  #define MCASP_PDIN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDIN,AXR0)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR1)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR2)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR3)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR4)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR5)\
    |_PER_FDEFAULT(MCASP,PDIN,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDIN,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDIN,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDIN,AFSX)\
    |_PER_FDEFAULT(MCASP,PDIN,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDIN,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDIN,AFSR)\
  )

  #define MCASP_PDIN_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                         axr5,axr4,axr3,axr2,axr1, axr0) \
   (Uint32)( \
     _PER_FMK(MCASP,PDIN,AXR0,axr0)\
    |_PER_FMK(MCASP,PDIN,AXR1,axr1)\
    |_PER_FMK(MCASP,PDIN,AXR2,axr2)\
    |_PER_FMK(MCASP,PDIN,AXR3,axr3)\
    |_PER_FMK(MCASP,PDIN,AXR4,axr4)\
    |_PER_FMK(MCASP,PDIN,AXR5,axr5)\
    |_PER_FMK(MCASP,PDIN,AMUTE,amute)\
    |_PER_FMK(MCASP,PDIN,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDIN,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDIN,AFSX,afsx)\
    |_PER_FMK(MCASP,PDIN,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDIN,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDIN,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
  #define MCASP_PDIN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDIN,AXR0)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR1)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR2)\
    |_PER_FDEFAULT(MCASP,PDIN,AXR3)\
    |_PER_FDEFAULT(MCASP,PDIN,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDIN,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDIN,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDIN,AFSX)\
    |_PER_FDEFAULT(MCASP,PDIN,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDIN,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDIN,AFSR)\
  )

  #define MCASP_PDIN_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                         axr3,axr2,axr1, axr0) \
   (Uint32)( \
     _PER_FMK(MCASP,PDIN,AXR0,axr0)\
    |_PER_FMK(MCASP,PDIN,AXR1,axr1)\
    |_PER_FMK(MCASP,PDIN,AXR2,axr2)\
    |_PER_FMK(MCASP,PDIN,AXR3,axr3)\
    |_PER_FMK(MCASP,PDIN,AMUTE,amute)\
    |_PER_FMK(MCASP,PDIN,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDIN,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDIN,AFSX,afsx)\
    |_PER_FMK(MCASP,PDIN,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDIN,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDIN,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 4 */

  #define _MCASP_PDIN_FGET(N,FIELD)\
    _PER_FGET(_MCASP_PDIN##N##_ADDR,MCASP,PDIN,##FIELD)

  #define _MCASP_PDIN_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_PDIN##N##_ADDR,MCASP,PDIN,##FIELD,field)

  #define _MCASP_PDIN_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_PDIN##N##_ADDR,MCASP,PDIN,##FIELD,##SYM)

  #define _MCASP_PDIN0_FGET(FIELD) _MCASP_PDIN_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDIN1_FGET(FIELD) _MCASP_PDIN_FGET(1,##FIELD)
#endif

  #define _MCASP_PDIN0_FSET(FIELD,f) _MCASP_PDIN_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDIN1_FSET(FIELD,f) _MCASP_PDIN_FSET(1,##FIELD,f)
#endif

  #define _MCASP_PDIN0_FSETS(FIELD,SYM) _MCASP_PDIN_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDIN1_FSETS(FIELD,SYM) _MCASP_PDIN_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     PDSET         |
* |___________________|
*
* PDSET		- Pin Data Input Register
*
* FIELDS (msb -> lsb)
* (rw)  AFSR
* (rw)  AHCLKR 
* (rw)  ACLKR 
* (rw)  AFSX
* (rw)  AHCLKX 
* (rw)  ACLKX
* (rw)  AMUTE
* (rw)  AXR0-15 
*
\******************************************************************************/

  #define _MCASP_PDSET_OFFSET                   7

  #define _MCASP_PDSET0_ADDR			(_MCASP_BASE_PORT0+4*_MCASP_PDSET_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDSET1_ADDR			(_MCASP_BASE_PORT1+4*_MCASP_PDSET_OFFSET)
#endif


  #define _MCASP_PDSET_AXR0_MASK        	0x00000001u
  #define _MCASP_PDSET_AXR0_SHIFT       	0x00000000u
  #define  MCASP_PDSET_AXR0_DEFAULT		0x00000000u
  #define  MCASP_PDSET_AXR0_OF(x)		_VALUEOF(x)
  #define  MCASP_PDSET_AXR0_SET		0x00000001u

  #define _MCASP_PDSET_AXR1_MASK        	0x00000002u
  #define _MCASP_PDSET_AXR1_SHIFT       	0x00000001u
  #define  MCASP_PDSET_AXR1_DEFAULT		0x00000000u
  #define  MCASP_PDSET_AXR1_OF(x)		_VALUEOF(x)
  #define  MCASP_PDSET_AXR1_SET		0x00000001u

  #define _MCASP_PDSET_AXR2_MASK        	0x00000004u
  #define _MCASP_PDSET_AXR2_SHIFT       	0x00000002u
  #define  MCASP_PDSET_AXR2_DEFAULT		0x00000000u
  #define  MCASP_PDSET_AXR2_OF(x)		_VALUEOF(x)
  #define  MCASP_PDSET_AXR2_SET		0x00000001u

  #define _MCASP_PDSET_AXR3_MASK        	0x00000008u
  #define _MCASP_PDSET_AXR3_SHIFT       	0x00000003u
  #define  MCASP_PDSET_AXR3_DEFAULT		0x00000000u
  #define  MCASP_PDSET_AXR3_OF(x)		_VALUEOF(x)
  #define  MCASP_PDSET_AXR3_SET		0x00000001u
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_PDSET_AXR4_MASK        	0x00000010u
  #define _MCASP_PDSET_AXR4_SHIFT       	0x00000004u
  #define  MCASP_PDSET_AXR4_DEFAULT		0x00000000u
  #define  MCASP_PDSET_AXR4_OF(x)		_VALUEOF(x)
  #define  MCASP_PDSET_AXR4_SET		0x00000001u

  #define _MCASP_PDSET_AXR5_MASK        	0x00000020u
  #define _MCASP_PDSET_AXR5_SHIFT       	0x00000005u
  #define  MCASP_PDSET_AXR5_DEFAULT		0x00000000u
  #define  MCASP_PDSET_AXR5_OF(x)		_VALUEOF(x)
  #define  MCASP_PDSET_AXR5_SET		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_PDSET_AXR6_MASK                0x00000040u
  #define _MCASP_PDSET_AXR6_SHIFT               0x00000006u
  #define  MCASP_PDSET_AXR6_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR6_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR6_SET        		0x00000001u

  #define _MCASP_PDSET_AXR7_MASK                0x00000080u
  #define _MCASP_PDSET_AXR7_SHIFT               0x00000007u
  #define  MCASP_PDSET_AXR7_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR7_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR7_SET        		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_PDSET_AXR8_MASK                0x00000100u
  #define _MCASP_PDSET_AXR8_SHIFT               0x00000008u
  #define  MCASP_PDSET_AXR8_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR8_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR8_SET        		0x00000001u

  #define _MCASP_PDSET_AXR9_MASK                0x00000200u
  #define _MCASP_PDSET_AXR9_SHIFT               0x00000009u
  #define  MCASP_PDSET_AXR9_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR9_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR9_SET        		0x00000001u

  #define _MCASP_PDSET_AXR10_MASK                0x00000400u
  #define _MCASP_PDSET_AXR10_SHIFT               0x0000000Au
  #define  MCASP_PDSET_AXR10_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR10_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR10_SET        	0x00000001u

  #define _MCASP_PDSET_AXR11_MASK                0x00000800u
  #define _MCASP_PDSET_AXR11_SHIFT               0x0000000Bu
  #define  MCASP_PDSET_AXR11_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR11_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR11_SET        	0x00000001u

  #define _MCASP_PDSET_AXR12_MASK                0x00001000u
  #define _MCASP_PDSET_AXR12_SHIFT               0x0000000Cu
  #define  MCASP_PDSET_AXR12_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR12_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR12_SET        	0x00000001u

  #define _MCASP_PDSET_AXR13_MASK                0x00002000u
  #define _MCASP_PDSET_AXR13_SHIFT               0x0000000Du
  #define  MCASP_PDSET_AXR13_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR13_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR13_SET        	0x00000001u

  #define _MCASP_PDSET_AXR14_MASK                0x00004000u
  #define _MCASP_PDSET_AXR14_SHIFT               0x0000000Eu
  #define  MCASP_PDSET_AXR14_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR14_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR14_SET        	0x00000001u

  #define _MCASP_PDSET_AXR15_MASK                0x00008000u
  #define _MCASP_PDSET_AXR15_SHIFT               0x0000000Fu
  #define  MCASP_PDSET_AXR15_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AXR15_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AXR15_SET        	0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_PDSET_AMUTE_MASK                0x02000000u
  #define _MCASP_PDSET_AMUTE_SHIFT               0x00000019u
  #define  MCASP_PDSET_AMUTE_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AMUTE_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AMUTE_SET        	0x00000001u

  #define _MCASP_PDSET_ACLKX_MASK                0x04000000u
  #define _MCASP_PDSET_ACLKX_SHIFT               0x0000001Au
  #define  MCASP_PDSET_ACLKX_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_ACLKX_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_ACLKX_SET        	0x00000001u

  #define _MCASP_PDSET_AHCLKX_MASK              0x08000000u
  #define _MCASP_PDSET_AHCLKX_SHIFT             0x0000001Bu
  #define  MCASP_PDSET_AHCLKX_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AHCLKX_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AHCLKX_SET        	0x00000001u

  #define _MCASP_PDSET_AFSX_MASK                0x10000000u
  #define _MCASP_PDSET_AFSX_SHIFT               0x0000001Cu
  #define  MCASP_PDSET_AFSX_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AFSX_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AFSX_SET        		0x00000001u

  #define _MCASP_PDSET_ACLKR_MASK                0x20000000u
  #define _MCASP_PDSET_ACLKR_SHIFT               0x0000001Du
  #define  MCASP_PDSET_ACLKR_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_ACLKR_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_ACLKR_SET        	0x00000001u

  #define _MCASP_PDSET_AHCLKR_MASK        0x40000000u
  #define _MCASP_PDSET_AHCLKR_SHIFT       0x0000001Eu
  #define  MCASP_PDSET_AHCLKR_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AHCLKR_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AHCLKR_SET        	0x00000001u

  #define _MCASP_PDSET_AFSR_MASK                0x80000000u
  #define _MCASP_PDSET_AFSR_SHIFT               0x0000001Fu
  #define  MCASP_PDSET_AFSR_DEFAULT        	0x00000000u
  #define  MCASP_PDSET_AFSR_OF(x)        	_VALUEOF(x)
  #define  MCASP_PDSET_AFSR_SET        		0x00000001u



  #define  MCASP_PDSET_OF(x)        	_VALUEOF(x)

#if (_MCASP_CHANNEL_CNT == 16)
  #define MCASP_PDSET_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDSET,AXR0)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR1)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR2)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR3)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR4)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR5)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR6)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR7)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR8)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR9)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR10)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR11)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR12)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR13)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR14)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR15)\
    |_PER_FDEFAULT(MCASP,PDSET,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDSET,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDSET,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDSET,AFSX)\
    |_PER_FDEFAULT(MCASP,PDSET,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDSET,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDSET,AFSR)\
  )

  #define MCASP_PDSET_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
    axr15,axr14,axr13,axr12,axr11,axr10,\
    axr9, axr8,axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
 (Uint32)( \
     _PER_FMK(MCASP,PDSET,AXR0,axr0)\
    |_PER_FMK(MCASP,PDSET,AXR1,axr1)\
    |_PER_FMK(MCASP,PDSET,AXR2,axr2)\
    |_PER_FMK(MCASP,PDSET,AXR3,axr3)\
    |_PER_FMK(MCASP,PDSET,AXR4,axr4)\
    |_PER_FMK(MCASP,PDSET,AXR5,axr5)\
    |_PER_FMK(MCASP,PDSET,AXR6,axr6)\
    |_PER_FMK(MCASP,PDSET,AXR7,axr7)\
    |_PER_FMK(MCASP,PDSET,AXR8,axr8)\
    |_PER_FMK(MCASP,PDSET,AXR9,axr9)\
    |_PER_FMK(MCASP,PDSET,AXR10,axr10)\
    |_PER_FMK(MCASP,PDSET,AXR11,axr11)\
    |_PER_FMK(MCASP,PDSET,AXR12,axr12)\
    |_PER_FMK(MCASP,PDSET,AXR13,axr13)\
    |_PER_FMK(MCASP,PDSET,AXR14,axr14)\
    |_PER_FMK(MCASP,PDSET,AXR15,axr15)\
    |_PER_FMK(MCASP,PDSET,AMUTE,amute)\
    |_PER_FMK(MCASP,PDSET,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDSET,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDSET,AFSX,afsx)\
    |_PER_FMK(MCASP,PDSET,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDSET,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDSET,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
  #define MCASP_PDSET_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDSET,AXR0)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR1)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR2)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR3)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR4)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR5)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR6)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR7)\
    |_PER_FDEFAULT(MCASP,PDSET,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDSET,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDSET,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDSET,AFSX)\
    |_PER_FDEFAULT(MCASP,PDSET,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDSET,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDSET,AFSR)\
  )

  #define MCASP_PDSET_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
 (Uint32)( \
     _PER_FMK(MCASP,PDSET,AXR0,axr0)\
    |_PER_FMK(MCASP,PDSET,AXR1,axr1)\
    |_PER_FMK(MCASP,PDSET,AXR2,axr2)\
    |_PER_FMK(MCASP,PDSET,AXR3,axr3)\
    |_PER_FMK(MCASP,PDSET,AXR4,axr4)\
    |_PER_FMK(MCASP,PDSET,AXR5,axr5)\
    |_PER_FMK(MCASP,PDSET,AXR6,axr6)\
    |_PER_FMK(MCASP,PDSET,AXR7,axr7)\
    |_PER_FMK(MCASP,PDSET,AMUTE,amute)\
    |_PER_FMK(MCASP,PDSET,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDSET,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDSET,AFSX,afsx)\
    |_PER_FMK(MCASP,PDSET,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDSET,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDSET,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
  #define MCASP_PDSET_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDSET,AXR0)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR1)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR2)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR3)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR4)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR5)\
    |_PER_FDEFAULT(MCASP,PDSET,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDSET,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDSET,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDSET,AFSX)\
    |_PER_FDEFAULT(MCASP,PDSET,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDSET,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDSET,AFSR)\
  )

  #define MCASP_PDSET_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr5,axr4,axr3,axr2,axr1, axr0) \
 (Uint32)( \
     _PER_FMK(MCASP,PDSET,AXR0,axr0)\
    |_PER_FMK(MCASP,PDSET,AXR1,axr1)\
    |_PER_FMK(MCASP,PDSET,AXR2,axr2)\
    |_PER_FMK(MCASP,PDSET,AXR3,axr3)\
    |_PER_FMK(MCASP,PDSET,AXR4,axr4)\
    |_PER_FMK(MCASP,PDSET,AXR5,axr5)\
    |_PER_FMK(MCASP,PDSET,AMUTE,amute)\
    |_PER_FMK(MCASP,PDSET,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDSET,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDSET,AFSX,afsx)\
    |_PER_FMK(MCASP,PDSET,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDSET,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDSET,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
  #define MCASP_PDSET_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDSET,AXR0)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR1)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR2)\
    |_PER_FDEFAULT(MCASP,PDSET,AXR3)\
    |_PER_FDEFAULT(MCASP,PDSET,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDSET,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDSET,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDSET,AFSX)\
    |_PER_FDEFAULT(MCASP,PDSET,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDSET,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDSET,AFSR)\
  )

  #define MCASP_PDSET_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr3,axr2,axr1, axr0) \
 (Uint32)( \
     _PER_FMK(MCASP,PDSET,AXR0,axr0)\
    |_PER_FMK(MCASP,PDSET,AXR1,axr1)\
    |_PER_FMK(MCASP,PDSET,AXR2,axr2)\
    |_PER_FMK(MCASP,PDSET,AXR3,axr3)\
    |_PER_FMK(MCASP,PDSET,AMUTE,amute)\
    |_PER_FMK(MCASP,PDSET,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDSET,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDSET,AFSX,afsx)\
    |_PER_FMK(MCASP,PDSET,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDSET,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDSET,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 4 */

  #define _MCASP_PDSET_FGET(N,FIELD)\
    _PER_FGET(_MCASP_PDSET##N##_ADDR,MCASP,PDSET,##FIELD)

  #define _MCASP_PDSET_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_PDSET##N##_ADDR,MCASP,PDSET,##FIELD,field)

  #define _MCASP_PDSET_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_PDSET##N##_ADDR,MCASP,PDSET,##FIELD,##SYM)

  #define _MCASP_PDSET0_FGET(FIELD) _MCASP_PDSET_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDSET1_FGET(FIELD) _MCASP_PDSET_FGET(1,##FIELD)
#endif
 
  #define _MCASP_PDSET0_FSET(FIELD,f) _MCASP_PDSET_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDSET1_FSET(FIELD,f) _MCASP_PDSET_FSET(1,##FIELD,f)
#endif

  #define _MCASP_PDSET0_FSETS(FIELD,SYM) _MCASP_PDSET_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDSET1_FSETS(FIELD,SYM) _MCASP_PDSET_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     P D C L R     |
* |___________________|
*
* PDCLR		- Pin Data Clear Register
*
* FIELDS (msb -> lsb)
* (rw)  AFSR
* (rw)  AHCLKR 
* (rw)  ACLKR 
* (rw)  AFSX
* (rw)  AHCLKX 
* (rw)  ACLKX
* (rw)  AMUTE
* (rw)  AXR0-15 
*
\******************************************************************************/

  #define _MCASP_PDCLR_OFFSET		8

  #define _MCASP_PDCLR0_ADDR		(_MCASP_BASE_PORT0+4*_MCASP_PDCLR_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDCLR1_ADDR		(_MCASP_BASE_PORT1+4*_MCASP_PDCLR_OFFSET)
#endif

  #define _MCASP_PDCLR_AXR0_MASK		0x00000001u
  #define _MCASP_PDCLR_AXR0_SHIFT		0x00000000u
  #define  MCASP_PDCLR_AXR0_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR0_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR0_CLR	         	0x00000001u

  #define _MCASP_PDCLR_AXR1_MASK		0x00000002u
  #define _MCASP_PDCLR_AXR1_SHIFT		0x00000001u
  #define  MCASP_PDCLR_AXR1_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR1_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR1_CLR	         	0x00000001u

  #define _MCASP_PDCLR_AXR2_MASK		0x00000004u
  #define _MCASP_PDCLR_AXR2_SHIFT		0x00000002u
  #define  MCASP_PDCLR_AXR2_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR2_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR2_CLR	         	0x00000001u

  #define _MCASP_PDCLR_AXR3_MASK		0x00000008u
  #define _MCASP_PDCLR_AXR3_SHIFT		0x00000003u
  #define  MCASP_PDCLR_AXR3_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR3_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR3_CLR	         	0x00000001u
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_PDCLR_AXR4_MASK		0x00000010u
  #define _MCASP_PDCLR_AXR4_SHIFT		0x00000004u
  #define  MCASP_PDCLR_AXR4_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR4_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR4_CLR	         	0x00000001u

  #define _MCASP_PDCLR_AXR5_MASK		0x00000020u
  #define _MCASP_PDCLR_AXR5_SHIFT		0x00000005u
  #define  MCASP_PDCLR_AXR5_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR5_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR5_CLR	         	0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_PDCLR_AXR6_MASK		0x00000040u
  #define _MCASP_PDCLR_AXR6_SHIFT		0x00000006u
  #define  MCASP_PDCLR_AXR6_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR6_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR6_CLR	         	0x00000001u

  #define _MCASP_PDCLR_AXR7_MASK		0x00000080u
  #define _MCASP_PDCLR_AXR7_SHIFT		0x00000007u
  #define  MCASP_PDCLR_AXR7_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR7_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR7_CLR	         	0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_PDCLR_AXR8_MASK		0x00000100u
  #define _MCASP_PDCLR_AXR8_SHIFT		0x00000008u
  #define  MCASP_PDCLR_AXR8_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR8_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR8_CLR	         	0x00000001u

  #define _MCASP_PDCLR_AXR9_MASK		0x00000200u
  #define _MCASP_PDCLR_AXR9_SHIFT		0x00000009u
  #define  MCASP_PDCLR_AXR9_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR9_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR9_CLR	         	0x00000001u

  #define _MCASP_PDCLR_AXR10_MASK		0x00000400u
  #define _MCASP_PDCLR_AXR10_SHIFT		0x0000000Au
  #define  MCASP_PDCLR_AXR10_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR10_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR10_CLR		0x00000001u

  #define _MCASP_PDCLR_AXR11_MASK		0x00000800u
  #define _MCASP_PDCLR_AXR11_SHIFT		0x0000000Bu
  #define  MCASP_PDCLR_AXR11_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR11_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR11_CLR		0x00000001u

  #define _MCASP_PDCLR_AXR12_MASK		0x00001000u
  #define _MCASP_PDCLR_AXR12_SHIFT		0x0000000Cu
  #define  MCASP_PDCLR_AXR12_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR12_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR12_CLR		0x00000001u

  #define _MCASP_PDCLR_AXR13_MASK		0x00002000u
  #define _MCASP_PDCLR_AXR13_SHIFT		0x0000000Du
  #define  MCASP_PDCLR_AXR13_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR13_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR13_CLR		0x00000001u

  #define _MCASP_PDCLR_AXR14_MASK		0x00004000u
  #define _MCASP_PDCLR_AXR14_SHIFT		0x0000000Eu
  #define  MCASP_PDCLR_AXR14_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR14_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR14_CLR		0x00000001u

  #define _MCASP_PDCLR_AXR15_MASK		0x00008000u
  #define _MCASP_PDCLR_AXR15_SHIFT		0x0000000Fu
  #define  MCASP_PDCLR_AXR15_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AXR15_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AXR15_CLR		0x00000001u
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_PDCLR_AMUTE_MASK		0x02000000u
  #define _MCASP_PDCLR_AMUTE_SHIFT		0x00000019u
  #define  MCASP_PDCLR_AMUTE_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AMUTE_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AMUTE_CLR		0x00000001u

  #define _MCASP_PDCLR_ACLKX_MASK		0x04000000u
  #define _MCASP_PDCLR_ACLKX_SHIFT		0x0000001Au
  #define  MCASP_PDCLR_ACLKX_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_ACLKX_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_ACLKX_CLR		0x00000001u

  #define _MCASP_PDCLR_AHCLKX_MASK		0x08000000u
  #define _MCASP_PDCLR_AHCLKX_SHIFT		0x0000001Bu
  #define  MCASP_PDCLR_AHCLKX_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AHCLKX_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AHCLKX_CLR		0x00000001u

  #define _MCASP_PDCLR_AFSX_MASK		0x10000000u
  #define _MCASP_PDCLR_AFSX_SHIFT		0x0000001Cu
  #define  MCASP_PDCLR_AFSX_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AFSX_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AFSX_CLR	         	0x00000001u

  #define _MCASP_PDCLR_ACLKR_MASK		0x20000000u
  #define _MCASP_PDCLR_ACLKR_SHIFT		0x0000001Du
  #define  MCASP_PDCLR_ACLKR_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_ACLKR_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_ACLKR_CLR		0x00000001u


  #define _MCASP_PDCLR_AHCLKR_MASK		0x40000000u
  #define _MCASP_PDCLR_AHCLKR_SHIFT		0x0000001Eu
  #define  MCASP_PDCLR_AHCLKR_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AHCLKR_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AHCLKR_CLR		0x00000001u

  #define _MCASP_PDCLR_AFSR_MASK		0x80000000u
  #define _MCASP_PDCLR_AFSR_SHIFT		0x0000001Fu
  #define  MCASP_PDCLR_AFSR_DEFAULT		0x00000000u
  #define  MCASP_PDCLR_AFSR_OF(x)		_VALUEOF(x)
  #define  MCASP_PDCLR_AFSR_CLR	         	0x00000001u

  #define  MCASP_PDCLR_OF(x)                    _VALUEOF(x)

#if (_MCASP_CHANNEL_CNT == 16)
  #define MCASP_PDCLR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDCLR,AXR0)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR1)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR2)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR3)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR4)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR5)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR6)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR7)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR8)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR9)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR10)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR11)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR12)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR13)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR14)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR15)\
    |_PER_FDEFAULT(MCASP,PDCLR,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDCLR,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDCLR,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDCLR,AFSX)\
    |_PER_FDEFAULT(MCASP,PDCLR,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDCLR,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDCLR,AFSR)\
  )

  #define MCASP_PDCLR_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
    axr15,axr14,axr13,axr12,axr11,axr10,\
    axr9, axr8,axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
  (Uint32)( \
     _PER_FMK(MCASP,PDCLR,AXR0,axr0)\
    |_PER_FMK(MCASP,PDCLR,AXR1,axr1)\
    |_PER_FMK(MCASP,PDCLR,AXR2,axr2)\
    |_PER_FMK(MCASP,PDCLR,AXR3,axr3)\
    |_PER_FMK(MCASP,PDCLR,AXR4,axr4)\
    |_PER_FMK(MCASP,PDCLR,AXR5,axr5)\
    |_PER_FMK(MCASP,PDCLR,AXR6,axr6)\
    |_PER_FMK(MCASP,PDCLR,AXR7,axr7)\
    |_PER_FMK(MCASP,PDCLR,AXR8,axr8)\
    |_PER_FMK(MCASP,PDCLR,AXR9,axr9)\
    |_PER_FMK(MCASP,PDCLR,AXR10,axr10)\
    |_PER_FMK(MCASP,PDCLR,AXR11,axr11)\
    |_PER_FMK(MCASP,PDCLR,AXR12,axr12)\
    |_PER_FMK(MCASP,PDCLR,AXR13,axr13)\
    |_PER_FMK(MCASP,PDCLR,AXR14,axr14)\
    |_PER_FMK(MCASP,PDCLR,AXR15,axr15)\
    |_PER_FMK(MCASP,PDCLR,AMUTE,amute)\
    |_PER_FMK(MCASP,PDCLR,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDCLR,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDCLR,AFSX,afsx)\
    |_PER_FMK(MCASP,PDCLR,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDCLR,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDCLR,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_CHANNEL_CNT == 8)
  #define MCASP_PDCLR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDCLR,AXR0)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR1)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR2)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR3)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR4)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR5)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR6)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR7)\
    |_PER_FDEFAULT(MCASP,PDCLR,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDCLR,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDCLR,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDCLR,AFSX)\
    |_PER_FDEFAULT(MCASP,PDCLR,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDCLR,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDCLR,AFSR)\
  )

  #define MCASP_PDCLR_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr7,axr6,axr5,axr4,axr3,axr2,axr1, axr0) \
  (Uint32)( \
     _PER_FMK(MCASP,PDCLR,AXR0,axr0)\
    |_PER_FMK(MCASP,PDCLR,AXR1,axr1)\
    |_PER_FMK(MCASP,PDCLR,AXR2,axr2)\
    |_PER_FMK(MCASP,PDCLR,AXR3,axr3)\
    |_PER_FMK(MCASP,PDCLR,AXR4,axr4)\
    |_PER_FMK(MCASP,PDCLR,AXR5,axr5)\
    |_PER_FMK(MCASP,PDCLR,AXR6,axr6)\
    |_PER_FMK(MCASP,PDCLR,AXR7,axr7)\
    |_PER_FMK(MCASP,PDCLR,AMUTE,amute)\
    |_PER_FMK(MCASP,PDCLR,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDCLR,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDCLR,AFSX,afsx)\
    |_PER_FMK(MCASP,PDCLR,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDCLR,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDCLR,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 6)
  #define MCASP_PDCLR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDCLR,AXR0)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR1)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR2)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR3)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR4)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR5)\
    |_PER_FDEFAULT(MCASP,PDCLR,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDCLR,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDCLR,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDCLR,AFSX)\
    |_PER_FDEFAULT(MCASP,PDCLR,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDCLR,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDCLR,AFSR)\
  )

  #define MCASP_PDCLR_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr5,axr4,axr3,axr2,axr1, axr0) \
  (Uint32)( \
     _PER_FMK(MCASP,PDCLR,AXR0,axr0)\
    |_PER_FMK(MCASP,PDCLR,AXR1,axr1)\
    |_PER_FMK(MCASP,PDCLR,AXR2,axr2)\
    |_PER_FMK(MCASP,PDCLR,AXR3,axr3)\
    |_PER_FMK(MCASP,PDCLR,AXR4,axr4)\
    |_PER_FMK(MCASP,PDCLR,AXR5,axr5)\
    |_PER_FMK(MCASP,PDCLR,AMUTE,amute)\
    |_PER_FMK(MCASP,PDCLR,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDCLR,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDCLR,AFSX,afsx)\
    |_PER_FMK(MCASP,PDCLR,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDCLR,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDCLR,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT == 4)
  #define MCASP_PDCLR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,PDCLR,AXR0)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR1)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR2)\
    |_PER_FDEFAULT(MCASP,PDCLR,AXR3)\
    |_PER_FDEFAULT(MCASP,PDCLR,AMUTE)\
    |_PER_FDEFAULT(MCASP,PDCLR,ACLKX)\
    |_PER_FDEFAULT(MCASP,PDCLR,AHCLKX)\
    |_PER_FDEFAULT(MCASP,PDCLR,AFSX)\
    |_PER_FDEFAULT(MCASP,PDCLR,ACLKR)\
    |_PER_FDEFAULT(MCASP,PDCLR,AHCLKR)\
    |_PER_FDEFAULT(MCASP,PDCLR,AFSR)\
  )

  #define MCASP_PDCLR_RMK(afsr,ahclkr,aclkr,afsx,ahclkx,aclkx,amute,  \
                          axr3,axr2,axr1, axr0) \
  (Uint32)( \
     _PER_FMK(MCASP,PDCLR,AXR0,axr0)\
    |_PER_FMK(MCASP,PDCLR,AXR1,axr1)\
    |_PER_FMK(MCASP,PDCLR,AXR2,axr2)\
    |_PER_FMK(MCASP,PDCLR,AXR3,axr3)\
    |_PER_FMK(MCASP,PDCLR,AMUTE,amute)\
    |_PER_FMK(MCASP,PDCLR,ACLKX,aclkx)\
    |_PER_FMK(MCASP,PDCLR,AHCLKX,ahclkx)\
    |_PER_FMK(MCASP,PDCLR,AFSX,afsx)\
    |_PER_FMK(MCASP,PDCLR,ACLKR,aclkr)\
    |_PER_FMK(MCASP,PDCLR,AHCLKR,ahclkr)\
    |_PER_FMK(MCASP,PDCLR,AFSR,afsr)\
  )
#endif /* _MCASP_CHANNEL_CNT == 4 */

  #define _MCASP_PDCLR_FGET(N,FIELD)\
    _PER_FGET(_MCASP_PDCLR##N##_ADDR,MCASP,PDCLR,##FIELD)

  #define _MCASP_PDCLR_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_PDCLR##N##_ADDR,MCASP,PDCLR,##FIELD,field)

  #define _MCASP_PDCLR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_PDCLR##N##_ADDR,MCASP,PDCLR,##FIELD,##SYM)


  #define _MCASP_PDCLR0_FGET(FIELD) _MCASP_PDCLR_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDCLR1_FGET(FIELD) _MCASP_PDCLR_FGET(1,##FIELD)
#endif
 
  #define _MCASP_PDCLR0_FSET(FIELD,f) _MCASP_PDCLR_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDCLR1_FSET(FIELD,f) _MCASP_PDCLR_FSET(1,##FIELD,f)
#endif

  #define _MCASP_PDCLR0_FSETS(FIELD,SYM) _MCASP_PDCLR_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_PDCLR1_FSETS(FIELD,SYM) _MCASP_PDCLR_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     GBLCTL        |
* |___________________|
*
* GBLCTL  -  Global Control Register
*
* FIELDS (msb -> lsb)
* (rw)  XFRST
* (rw)  XSMRST
* (rw)  XSRCLR
* (rw)  XHCLKRST
* (rw)  XCLKRST
* (rw)  RFRST
* (rw)  RSMRST
* (rw)  RSRCLR
* (rw)  RHCLKRST
* (rw)  RCLKRST
*
\******************************************************************************/

  #define _MCASP_GBLCTL_OFFSET               17

  #define _MCASP_GBLCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_GBLCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_GBLCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_GBLCTL_OFFSET)
#endif

  #define _MCASP_GBLCTL_XFRST_MASK              0x00001000u
  #define _MCASP_GBLCTL_XFRST_SHIFT             0x0000000Cu
  #define  MCASP_GBLCTL_XFRST_DEFAULT           0x00000000u
  #define  MCASP_GBLCTL_XFRST_OF(x)             _VALUEOF(x)
  #define  MCASP_GBLCTL_XFRST_RESET             0x00000000u
  #define  MCASP_GBLCTL_XFRST_ACTIVE            0x00000001u


  #define _MCASP_GBLCTL_XSMRST_MASK              0x00000800u
  #define _MCASP_GBLCTL_XSMRST_SHIFT             0x0000000Bu
  #define  MCASP_GBLCTL_XSMRST_DEFAULT           0x00000000u
  #define  MCASP_GBLCTL_XSMRST_OF(x)             _VALUEOF(x)
  #define  MCASP_GBLCTL_XSMRST_RESET			0x00000000u
  #define  MCASP_GBLCTL_XSMRST_ACTIVE			0x00000001u


  #define _MCASP_GBLCTL_XSRCLR_MASK            0x00000400u
  #define _MCASP_GBLCTL_XSRCLR_SHIFT           0x0000000Au
  #define  MCASP_GBLCTL_XSRCLR_DEFAULT         0x00000000u
  #define  MCASP_GBLCTL_XSRCLR_OF(x)           _VALUEOF(x)
  #define  MCASP_GBLCTL_XSRCLR_CLEAR         0x00000000u
  #define  MCASP_GBLCTL_XSRCLR_ACTIVE          0x00000001u


  #define _MCASP_GBLCTL_XHCLKRST_MASK           0x00000200u
  #define _MCASP_GBLCTL_XHCLKRST_SHIFT          0x00000009u
  #define  MCASP_GBLCTL_XHCLKRST_DEFAULT        0x00000000u
  #define  MCASP_GBLCTL_XHCLKRST_OF(x)          _VALUEOF(x)
  #define  MCASP_GBLCTL_XHCLKRST_RESET		0x00000000u
  #define  MCASP_GBLCTL_XHCLKRST_ACTIVE		0x00000001u


  #define _MCASP_GBLCTL_XCLKRST_MASK              0x00000100u
  #define _MCASP_GBLCTL_XCLKRST_SHIFT             0x00000008u
  #define  MCASP_GBLCTL_XCLKRST_DEFAULT           0x00000000u
  #define  MCASP_GBLCTL_XCLKRST_OF(x)             _VALUEOF(x)
  #define  MCASP_GBLCTL_XCLKRST_RESET			0x00000000u
  #define  MCASP_GBLCTL_XCLKRST_ACTIVE		0x00000001u

  #define _MCASP_GBLCTL_RFRST_MASK              0x00000010u
  #define _MCASP_GBLCTL_RFRST_SHIFT             0x00000004u
  #define  MCASP_GBLCTL_RFRST_DEFAULT           0x00000000u
  #define  MCASP_GBLCTL_RFRST_OF(x)             _VALUEOF(x)
  #define  MCASP_GBLCTL_RFRST_RESET             0x00000000u
  #define  MCASP_GBLCTL_RFRST_ACTIVE            0x00000001u

  #define _MCASP_GBLCTL_RSMRST_MASK              0x00000008u
  #define _MCASP_GBLCTL_RSMRST_SHIFT             0x00000003u
  #define  MCASP_GBLCTL_RSMRST_DEFAULT           0x00000000u
  #define  MCASP_GBLCTL_RSMRST_OF(x)             _VALUEOF(x)
  #define  MCASP_GBLCTL_RSMRST_RESET		     0x00000000u
  #define  MCASP_GBLCTL_RSMRST_ACTIVE		     0x00000001u


  #define _MCASP_GBLCTL_RSRCLR_MASK             0x00000004u
  #define _MCASP_GBLCTL_RSRCLR_SHIFT            0x00000002u
  #define  MCASP_GBLCTL_RSRCLR_DEFAULT          0x00000000u
  #define  MCASP_GBLCTL_RSRCLR_OF(x)            _VALUEOF(x)
  #define  MCASP_GBLCTL_RSRCLR_CLEAR          0x00000000u
  #define  MCASP_GBLCTL_RSRCLR_ACTIVE           0x00000001u


  #define _MCASP_GBLCTL_RHCLKRST_MASK           0x00000002u
  #define _MCASP_GBLCTL_RHCLKRST_SHIFT          0x00000001u
  #define  MCASP_GBLCTL_RHCLKRST_DEFAULT        0x00000000u
  #define  MCASP_GBLCTL_RHCLKRST_OF(x)         _VALUEOF(x)
  #define  MCASP_GBLCTL_RHCLKRST_RESET	     0x00000000u
  #define  MCASP_GBLCTL_RHCLKRST_ACTIVE        0x00000001u


  #define _MCASP_GBLCTL_RCLKRST_MASK             0x00000001u
  #define _MCASP_GBLCTL_RCLKRST_SHIFT            0x00000000u
  #define  MCASP_GBLCTL_RCLKRST_DEFAULT          0x00000000u
  #define  MCASP_GBLCTL_RCLKRST_OF(x)            _VALUEOF(x)
  #define  MCASP_GBLCTL_RCLKRST_RESET	       0x00000000u
  #define  MCASP_GBLCTL_RCLKRST_ACTIVE	       0x00000001u


  #define  MCASP_GBLCTL_OF(x)                _VALUEOF(x)

  #define MCASP_GBLCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,GBLCTL,XFRST)\
    |_PER_FDEFAULT(MCASP,GBLCTL,XSMRST)\
    |_PER_FDEFAULT(MCASP,GBLCTL,XSRCLR)\
    |_PER_FDEFAULT(MCASP,GBLCTL,XHCLKRST)\
    |_PER_FDEFAULT(MCASP,GBLCTL,XCLKRST)\
    |_PER_FDEFAULT(MCASP,GBLCTL,RFRST)\
    |_PER_FDEFAULT(MCASP,GBLCTL,RSMRST)\
    |_PER_FDEFAULT(MCASP,GBLCTL,RSRCLR)\
    |_PER_FDEFAULT(MCASP,GBLCTL,RHCLKRST)\
    |_PER_FDEFAULT(MCASP,GBLCTL,RCLKRST)\
  )


  #define MCASP_GBLCTL_RMK(xfrst, xsmrst, xsrclr, xhclkrst, xclkrst, rfrst, rsmrst, rsrclr, rhclkrst, rclkrst) (Uint32)( \
     _PER_FMK(MCASP,GBLCTL,XFRST,xfrst)\
    |_PER_FMK(MCASP,GBLCTL,XSMRST,xsmrst)\
    |_PER_FMK(MCASP,GBLCTL,XSRCLR,xsrclr)\
    |_PER_FMK(MCASP,GBLCTL,XHCLKRST,xhclkrst)\
    |_PER_FMK(MCASP,GBLCTL,XCLKRST,xclkrst)\
    |_PER_FMK(MCASP,GBLCTL,RFRST,rfrst)\
    |_PER_FMK(MCASP,GBLCTL,RSMRST,rsmrst)\
    |_PER_FMK(MCASP,GBLCTL,RSRCLR,rsrclr)\
    |_PER_FMK(MCASP,GBLCTL,RHCLKRST,rhclkrst)\
    |_PER_FMK(MCASP,GBLCTL,RCLKRST,rclkrst)\
  )


  #define _MCASP_GBLCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_GBLCTL##N##_ADDR,MCASP,GBLCTL,##FIELD)

  #define _MCASP_GBLCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_GBLCTL##N##_ADDR,MCASP,GBLCTL,##FIELD,field)

  #define _MCASP_GBLCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_GBLCTL##N##_ADDR,MCASP,GBLCTL,##FIELD,##SYM)


  #define _MCASP_GBLCTL0_FGET(FIELD) _MCASP_GBLCTL_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_GBLCTL1_FGET(FIELD) _MCASP_GBLCTL_FGET(1,##FIELD)
#endif
 
  #define _MCASP_GBLCTL0_FSET(FIELD,f) _MCASP_GBLCTL_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_GBLCTL1_FSET(FIELD,f) _MCASP_GBLCTL_FSET(1,##FIELD,f)
#endif

  #define _MCASP_GBLCTL0_FSETS(FIELD,SYM) _MCASP_GBLCTL_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_GBLCTL1_FSETS(FIELD,SYM) _MCASP_GBLCTL_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     AMUTE         |
* |___________________|
*
* AMUTE  -  register name
*
* FIELDS (msb -> lsb)
* (rw)  XDMAERR  
* (rw)  RDMAERR  
* (rw)  XCKFAIL  
* (rw)  RCKFAIL
* (rw)  XSYNCERR 
* (rw)  RSYNCERR
* (rw)  XUNDRN
* (rw)  ROVRN  
* (r )  INSTAT
* (rw)  INEN
* (r )  INPOL
* (rw)  MUTEN
\******************************************************************************/

  #define _MCASP_AMUTE_OFFSET               18

  #define _MCASP_AMUTE0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_AMUTE_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AMUTE1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_AMUTE_OFFSET)
#endif
  
  #define _MCASP_AMUTE_XDMAERR_MASK              0x00001000u
  #define _MCASP_AMUTE_XDMAERR_SHIFT             0x0000000Cu
  #define  MCASP_AMUTE_XDMAERR_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_XDMAERR_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_XDMAERR_DISABLE          0x00000000u
  #define  MCASP_AMUTE_XDMAERR_ENABLE           0x00000001u

  #define _MCASP_AMUTE_RDMAERR_MASK              0x00000800u
  #define _MCASP_AMUTE_RDMAERR_SHIFT             0x0000000Bu
  #define  MCASP_AMUTE_RDMAERR_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_RDMAERR_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_RDMAERR_DISABLE          0x00000000u
  #define  MCASP_AMUTE_RDMAERR_ENABLE           0x00000001u

  #define _MCASP_AMUTE_XCKFAIL_MASK              0x00000400u
  #define _MCASP_AMUTE_XCKFAIL_SHIFT             0x0000000Au
  #define  MCASP_AMUTE_XCKFAIL_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_XCKFAIL_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_XCKFAIL_DISABLE          0x00000000u
  #define  MCASP_AMUTE_XCKFAIL_ENABLE           0x00000001u
  

  #define _MCASP_AMUTE_RCKFAIL_MASK              0x00000200u
  #define _MCASP_AMUTE_RCKFAIL_SHIFT             0x00000009u
  #define  MCASP_AMUTE_RCKFAIL_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_RCKFAIL_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_RCKFAIL_DISABLE          0x00000000u
  #define  MCASP_AMUTE_RCKFAIL_ENABLE           0x00000001u
  

  #define _MCASP_AMUTE_XSYNCERR_MASK              0x00000100u
  #define _MCASP_AMUTE_XSYNCERR_SHIFT             0x00000008u
  #define  MCASP_AMUTE_XSYNCERR_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_XSYNCERR_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_XSYNCERR_DISABLE          0x00000000u
  #define  MCASP_AMUTE_XSYNCERR_ENABLE           0x00000001u
  

  #define _MCASP_AMUTE_RSYNCERR_MASK              0x00000080u
  #define _MCASP_AMUTE_RSYNCERR_SHIFT             0x00000007u
  #define  MCASP_AMUTE_RSYNCERR_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_RSYNCERR_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_RSYNCERR_DISABLE          0x00000000u
  #define  MCASP_AMUTE_RSYNCERR_ENABLE           0x00000001u
  

  #define _MCASP_AMUTE_XUNDRN_MASK              0x00000040u
  #define _MCASP_AMUTE_XUNDRN_SHIFT             0x00000006u
  #define  MCASP_AMUTE_XUNDRN_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_XUNDRN_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_XUNDRN_DISABLE          0x00000000u
  #define  MCASP_AMUTE_XUNDRN_ENABLE           0x00000001u
  

  #define _MCASP_AMUTE_ROVRN_MASK              0x00000020u
  #define _MCASP_AMUTE_ROVRN_SHIFT             0x00000005u
  #define  MCASP_AMUTE_ROVRN_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_ROVRN_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_ROVRN_DISABLE          0x00000000u
  #define  MCASP_AMUTE_ROVRN_ENABLE           0x00000001u


  #define _MCASP_AMUTE_INSTAT_MASK              0x00000010u
  #define _MCASP_AMUTE_INSTAT_SHIFT             0x00000004u
  #define  MCASP_AMUTE_INSTAT_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_INSTAT_OF(x)             _VALUEOF(x)
   

  #define _MCASP_AMUTE_INEN_MASK              0x00000008u
  #define _MCASP_AMUTE_INEN_SHIFT             0x00000003u
  #define  MCASP_AMUTE_INEN_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_INEN_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_INEN_DISABLE          0x00000000u
  #define  MCASP_AMUTE_INEN_ENABLE           0x00000001u
  

  #define _MCASP_AMUTE_INPOL_MASK              0x00000004u
  #define _MCASP_AMUTE_INPOL_SHIFT             0x00000002u
  #define  MCASP_AMUTE_INPOL_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_INPOL_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_INPOL_ACTHIGH           0x00000000u
  #define  MCASP_AMUTE_INPOL_ACTLOW            0x00000001u


  #define _MCASP_AMUTE_MUTEN_MASK              0x00000003u
  #define _MCASP_AMUTE_MUTEN_SHIFT             0x00000000u
  #define  MCASP_AMUTE_MUTEN_DEFAULT           0x00000000u
  #define  MCASP_AMUTE_MUTEN_OF(x)             _VALUEOF(x)
  #define  MCASP_AMUTE_MUTEN_DISABLE          0x00000000u
  #define  MCASP_AMUTE_MUTEN_ERRHIGH         0x00000001u
  #define  MCASP_AMUTE_MUTEN_ERRLOW          0x00000002u 
  
  #define  MCASP_AMUTE_OF(x)                _VALUEOF(x)

  #define MCASP_AMUTE_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,AMUTE,XDMAERR)\
	| _PER_FDEFAULT(MCASP,AMUTE,RDMAERR)\
    | _PER_FDEFAULT(MCASP,AMUTE,XCKFAIL)\
	| _PER_FDEFAULT(MCASP,AMUTE,RCKFAIL)\
	| _PER_FDEFAULT(MCASP,AMUTE,XSYNCERR )\
	| _PER_FDEFAULT(MCASP,AMUTE,RSYNCERR)\
	| _PER_FDEFAULT(MCASP,AMUTE,XUNDRN)\
	| _PER_FDEFAULT(MCASP,AMUTE,ROVRN)\
	| _PER_FDEFAULT(MCASP,AMUTE,INSTAT)\
	| _PER_FDEFAULT(MCASP,AMUTE,INEN)\
	| _PER_FDEFAULT(MCASP,AMUTE,MUTEN)\
  )

  #define MCASP_AMUTE_RMK(xdmaerr,rdmaerr,xckfail, rckfail, xsyncerr, rsyncerr, xundrn, rovrn,inen, muten) (Uint32)( \
     _PER_FMK(MCASP,AMUTE,XDMAERR,xdmaerr)\
	| _PER_FMK(MCASP,AMUTE,RDMAERR,rdmaerr)\
      | _PER_FMK(MCASP,AMUTE,XCKFAIL,xckfail)\
	| _PER_FMK(MCASP,AMUTE,RCKFAIL,rckfail)\
	| _PER_FMK(MCASP,AMUTE,XSYNCERR ,xsyncerr)\
	| _PER_FMK(MCASP,AMUTE,RSYNCERR,rsyncerr)\
	| _PER_FMK(MCASP,AMUTE,XUNDRN,xundrn)\
	| _PER_FMK(MCASP,AMUTE,ROVRN,rovrn)\
	| _PER_FMK(MCASP,AMUTE,INEN,inen)\
	| _PER_FMK(MCASP,AMUTE,MUTEN,muten)\
  )


  #define _MCASP_AMUTE_FGET(N,FIELD)\
    _PER_FGET(_MCASP_AMUTE##N##_ADDR,MCASP,AMUTE,##FIELD)

  #define _MCASP_AMUTE_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_AMUTE##N##_ADDR,MCASP,AMUTE,##FIELD,field)

  #define _MCASP_AMUTE_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_AMUTE##N##_ADDR,MCASP,AMUTE,##FIELD,##SYM)

  #define _MCASP_AMUTE0_FGET(FIELD) _MCASP_AMUTE_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AMUTE1_FGET(FIELD) _MCASP_AMUTE_FGET(1,##FIELD)
#endif
 
  #define _MCASP_AMUTE0_FSET(FIELD,f) _MCASP_AMUTE_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AMUTE1_FSET(FIELD,f) _MCASP_AMUTE_FSET(1,##FIELD,f)
#endif

  #define _MCASP_AMUTE0_FSETS(FIELD,SYM) _MCASP_AMUTE_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AMUTE1_FSETS(FIELD,SYM) _MCASP_AMUTE_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |       DLBCTL      |
* |___________________|
*
* DLBCTL  -  Digital Loopback Control Register
*
* FIELDS (msb -> lsb)
* (rw)  MODE  
* (rw)  ORD 
* (rw)  DLBEN  
\******************************************************************************/

  #define _MCASP_DLBCTL_OFFSET               19

  #define _MCASP_DLBCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_DLBCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DLBCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_DLBCTL_OFFSET)
#endif

  #define _MCASP_DLBCTL_MODE_MASK              0x0000000Cu 
  #define _MCASP_DLBCTL_MODE_SHIFT             0x00000002u 
  #define  MCASP_DLBCTL_MODE_DEFAULT           0x00000000u
  #define  MCASP_DLBCTL_MODE_OF(x)             _VALUEOF(x)
  #define  MCASP_DLBCTL_MODE_XMTCLK            0x00000001u 

  #define _MCASP_DLBCTL_ORD_MASK              0x00000002u 
  #define _MCASP_DLBCTL_ORD_SHIFT             0x00000001u 
  #define  MCASP_DLBCTL_ORD_DEFAULT           0x00000000u
  #define  MCASP_DLBCTL_ORD_OF(x)             _VALUEOF(x)
  #define  MCASP_DLBCTL_ORD_XMTODD             0x00000000u 
  #define  MCASP_DLBCTL_ORD_XMTEVEN            0x00000001u 


  #define _MCASP_DLBCTL_DLBEN_MASK              0x00000001u 
  #define _MCASP_DLBCTL_DLBEN_SHIFT             0x00000000u 
  #define  MCASP_DLBCTL_DLBEN_DEFAULT           0x00000000u
  #define  MCASP_DLBCTL_DLBEN_OF(x)             _VALUEOF(x)
  #define  MCASP_DLBCTL_DLBEN_DISABLE           0x00000000u 
  #define  MCASP_DLBCTL_DLBEN_ENABLE            0x00000001u 

  #define  MCASP_DLBCTL_OF(x)                _VALUEOF(x)

  #define MCASP_DLBCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,DLBCTL,MODE)\
    |_PER_FDEFAULT(MCASP,DLBCTL,ORD)\
    |_PER_FDEFAULT(MCASP,DLBCTL,DLBEN)\
  )

  #define MCASP_DLBCTL_RMK(mode, ord, dlben) (Uint32)( \
     _PER_FMK(MCASP,DLBCTL,MODE,mode)\
    |_PER_FMK(MCASP,DLBCTL,ORD,ord)\
    |_PER_FMK(MCASP,DLBCTL,DLBEN,dlben)\
  )


  #define _MCASP_DLBCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_DLBCTL##N##_ADDR,MCASP,DLBCTL,##FIELD)

  #define _MCASP_DLBCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_DLBCTL##N##_ADDR,MCASP,DLBCTL,##FIELD,field)

  #define _MCASP_DLBCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_DLBCTL##N##_ADDR,MCASP,DLBCTL,##FIELD,##SYM)


  #define _MCASP_DLBCTL0_FGET(FIELD) _MCASP_DLBCTL_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DLBCTL1_FGET(FIELD) _MCASP_DLBCTL_FGET(1,##FIELD)
#endif
 
  #define _MCASP_DLBCTL0_FSET(FIELD,f) _MCASP_DLBCTL_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DLBCTL1_FSET(FIELD,f) _MCASP_DLBCTL_FSET(1,##FIELD,f)
#endif

  #define _MCASP_DLBCTL0_FSETS(FIELD,SYM) _MCASP_DLBCTL_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DLBCTL1_FSETS(FIELD,SYM) _MCASP_DLBCTL_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     DITCTL        |
* |___________________|
*
* DITCTL  -  Transmit DIT Control Register
*
* FIELDS (msb -> lsb)
* (rw)  VB  
* (rw)  VA
* (rw)  DITEN  
*
\******************************************************************************/

  #define _MCASP_DITCTL_OFFSET               20

  #define _MCASP_DITCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_DITCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DITCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_DITCTL_OFFSET)
#endif

  #define _MCASP_DITCTL_VB_MASK              0x00000008u
  #define _MCASP_DITCTL_VB_SHIFT             0x00000003u
  #define  MCASP_DITCTL_VB_DEFAULT           0x00000000u
  #define  MCASP_DITCTL_VB_OF(x)             _VALUEOF(x)
  #define  MCASP_DITCTL_VB_ZERO	           0x00000000u
  #define  MCASP_DITCTL_VB_ONE		   0x00000001u

  #define _MCASP_DITCTL_VA_MASK              0x00000004u
  #define _MCASP_DITCTL_VA_SHIFT             0x00000002u
  #define  MCASP_DITCTL_VA_DEFAULT           0x00000000u
  #define  MCASP_DITCTL_VA_OF(x)             _VALUEOF(x)
  #define  MCASP_DITCTL_VA_ZERO              0x00000000u
  #define  MCASP_DITCTL_VA_ONE	         0x00000001u

  #define _MCASP_DITCTL_DITEN_MASK           0x00000001u
  #define _MCASP_DITCTL_DITEN_SHIFT          0x00000000u
  #define  MCASP_DITCTL_DITEN_DEFAULT        0x00000000u
  #define  MCASP_DITCTL_DITEN_OF(x)          _VALUEOF(x)
  #define  MCASP_DITCTL_DITEN_TDM            0x00000000u
  #define  MCASP_DITCTL_DITEN_DIT            0x00000001u

  #define  MCASP_DITCTL_OF(x)                _VALUEOF(x)

  #define MCASP_DITCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,DITCTL,VB)\
    |_PER_FDEFAULT(MCASP,DITCTL,VA)\
    |_PER_FDEFAULT(MCASP,DITCTL,DITEN)\
  )

  #define MCASP_DITCTL_RMK(vb,va,diten) (Uint32)( \
     _PER_FMK(MCASP,DITCTL,VB,vb)\
    |_PER_FMK(MCASP,DITCTL,VA,va)\
    |_PER_FMK(MCASP,DITCTL,DITEN,diten)\
  )

  #define _MCASP_DITCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_DITCTL##N##_ADDR,MCASP,DITCTL,##FIELD)

  #define _MCASP_DITCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_DITCTL##N##_ADDR,MCASP,DITCTL,##FIELD,field)

  #define _MCASP_DITCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_DITCTL##N##_ADDR,MCASP,DITCTL,##FIELD,##SYM)

  #define _MCASP_DITCTL0_FGET(FIELD) _MCASP_DITCTL_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DITCTL1_FGET(FIELD) _MCASP_DITCTL_FGET(1,##FIELD)
#endif

  #define _MCASP_DITCTL0_FSET(FIELD,f) _MCASP_DITCTL_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DITCTL1_FSET(FIELD,f) _MCASP_DITCTL_FSET(1,##FIELD,f)
#endif

  #define _MCASP_DITCTL0_FSETS(FIELD,SYM) _MCASP_DITCTL_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DITCTL1_FSETS(FIELD,SYM) _MCASP_DITCTL_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     RGBLCTL       |
* |___________________|
*
* RGBLCTL  -  Global Control Register
*
* FIELDS (msb -> lsb)
* (r)   XFRST
* (r)   XSMRST
* (r)   XSRCLR
* (r)   XHCLKRST
* (r)   XCLKRST
* (rw)  RFRST
* (rw)  RSMRST
* (rw)  RSRCLR
* (rw)  RHCLKRST
* (rw)  RCLKRST
*
\******************************************************************************/

  #define _MCASP_RGBLCTL_OFFSET               24

  #define _MCASP_RGBLCTL0_ADDR		(_MCASP_BASE_PORT0+4*_MCASP_RGBLCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RGBLCTL1_ADDR		(_MCASP_BASE_PORT1+4*_MCASP_RGBLCTL_OFFSET)
#endif

  #define _MCASP_RGBLCTL_XFRST_MASK      0x00001000u
  #define _MCASP_RGBLCTL_XFRST_SHIFT     0x0000000Cu
  #define  MCASP_RGBLCTL_XFRST_DEFAULT   0x00000000u
  #define  MCASP_RGBLCTL_XFRST_OF(x)     _VALUEOF(x)
  #define  MCASP_RGBLCTL_XFRST_RESET     0x00000000u
  #define  MCASP_RGBLCTL_XFRST_ACTIVE    0x00000001u

  #define _MCASP_RGBLCTL_XSMRST_MASK     0x00000800u
  #define _MCASP_RGBLCTL_XSMRST_SHIFT    0x0000000Bu
  #define  MCASP_RGBLCTL_XSMRST_DEFAULT  0x00000000u
  #define  MCASP_RGBLCTL_XSMRST_OF(x)    _VALUEOF(x)
  #define  MCASP_RGBLCTL_XSMRST_RESET	 0x00000000u
  #define  MCASP_RGBLCTL_XSMRST_ACTIVE	 0x00000001u

  #define _MCASP_RGBLCTL_XSRCLR_MASK     0x00000400u
  #define _MCASP_RGBLCTL_XSRCLR_SHIFT    0x0000000Au
  #define  MCASP_RGBLCTL_XSRCLR_DEFAULT  0x00000000u
  #define  MCASP_RGBLCTL_XSRCLR_OF(x)    _VALUEOF(x)
  #define  MCASP_RGBLCTL_XSRCLR_CLEAR    0x00000000u
  #define  MCASP_RGBLCTL_XSRCLR_ACTIVE   0x00000001u

  #define _MCASP_RGBLCTL_XHCLKRST_MASK     0x00000200u
  #define _MCASP_RGBLCTL_XHCLKRST_SHIFT    0x00000009u
  #define  MCASP_RGBLCTL_XHCLKRST_DEFAULT  0x00000000u
  #define  MCASP_RGBLCTL_XHCLKRST_OF(x)    _VALUEOF(x)
  #define  MCASP_RGBLCTL_XHCLKRST_RESET	   0x00000000u
  #define  MCASP_RGBLCTL_XHCLKRST_ACTIVE   0x00000001u

  #define _MCASP_RGBLCTL_XCLKRST_MASK      0x00000100u
  #define _MCASP_RGBLCTL_XCLKRST_SHIFT     0x00000008u
  #define  MCASP_RGBLCTL_XCLKRST_DEFAULT   0x00000000u
  #define  MCASP_RGBLCTL_XCLKRST_OF(x)     _VALUEOF(x)
  #define  MCASP_RGBLCTL_XCLKRST_RESET	   0x00000000u
  #define  MCASP_RGBLCTL_XCLKRST_ACTIVE	   0x00000001u

  #define _MCASP_RGBLCTL_RFRST_MASK              0x00000010u
  #define _MCASP_RGBLCTL_RFRST_SHIFT             0x00000004u
  #define  MCASP_RGBLCTL_RFRST_DEFAULT           0x00000000u
  #define  MCASP_RGBLCTL_RFRST_OF(x)             _VALUEOF(x)
  #define  MCASP_RGBLCTL_RFRST_RESET             0x00000000u
  #define  MCASP_RGBLCTL_RFRST_ACTIVE            0x00000001u

  #define _MCASP_RGBLCTL_RSMRST_MASK              0x00000008u
  #define _MCASP_RGBLCTL_RSMRST_SHIFT             0x00000003u
  #define  MCASP_RGBLCTL_RSMRST_DEFAULT           0x00000000u
  #define  MCASP_RGBLCTL_RSMRST_OF(x)             _VALUEOF(x)
  #define  MCASP_RGBLCTL_RSMRST_RESET		      0x00000000u
  #define  MCASP_RGBLCTL_RSMRST_ACTIVE	      0x00000001u

  #define _MCASP_RGBLCTL_RSRCLR_MASK              0x00000004u
  #define _MCASP_RGBLCTL_RSRCLR_SHIFT             0x00000002u
  #define  MCASP_RGBLCTL_RSRCLR_DEFAULT           0x00000000u
  #define  MCASP_RGBLCTL_RSRCLR_OF(x)             _VALUEOF(x)
  #define  MCASP_RGBLCTL_RSRCLR_CLEAR           0x00000000u
  #define  MCASP_RGBLCTL_RSRCLR_ACTIVE            0x00000001u

  #define _MCASP_RGBLCTL_RHCLKRST_MASK              0x00000002u
  #define _MCASP_RGBLCTL_RHCLKRST_SHIFT             0x00000001u
  #define  MCASP_RGBLCTL_RHCLKRST_DEFAULT           0x00000000u
  #define  MCASP_RGBLCTL_RHCLKRST_OF(x)             _VALUEOF(x)
  #define  MCASP_RGBLCTL_RHCLKRST_RESET		    0x00000000u
  #define  MCASP_RGBLCTL_RHCLKRST_ACTIVE		    0x00000001u

  #define _MCASP_RGBLCTL_RCLKRST_MASK              0x00000001u
  #define _MCASP_RGBLCTL_RCLKRST_SHIFT             0x00000000u
  #define  MCASP_RGBLCTL_RCLKRST_DEFAULT           0x00000000u
  #define  MCASP_RGBLCTL_RCLKRST_OF(x)             _VALUEOF(x)
  #define  MCASP_RGBLCTL_RCLKRST_RESET		0x00000000u
  #define  MCASP_RGBLCTL_RCLKRST_ACTIVE		0x00000001u


  #define  MCASP_RGBLCTL_OF(x)                _VALUEOF(x)

  #define MCASP_RGBLCTL_DEFAULT (Uint32)( \
    _PER_FDEFAULT(MCASP,RGBLCTL,RFRST)\
    |_PER_FDEFAULT(MCASP,RGBLCTL,RSMRST)\
    |_PER_FDEFAULT(MCASP,RGBLCTL,RSRCLR)\
    |_PER_FDEFAULT(MCASP,RGBLCTL,RHCLKRST)\
    |_PER_FDEFAULT(MCASP,RGBLCTL,RCLKRST)\
  )


  #define MCASP_RGBLCTL_RMK(rfrst, rsmrst, rsrclr, rhclkrst, rclkrst) (Uint32)( \
    _PER_FMK(MCASP,RGBLCTL,RFRST,rfrst)\
    |_PER_FMK(MCASP,RGBLCTL,RSMRST,rsmrst)\
    |_PER_FMK(MCASP,RGBLCTL,RSRCLR,rsrclr)\
    |_PER_FMK(MCASP,RGBLCTL,RHCLKRST,rhclkrst)\
    |_PER_FMK(MCASP,RGBLCTL,RCLKRST,rclkrst)\
  )


  #define _MCASP_RGBLCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_RGBLCTL##N##_ADDR,MCASP,RGBLCTL,##FIELD)

  #define _MCASP_RGBLCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_RGBLCTL##N##_ADDR,MCASP,RGBLCTL,##FIELD,field)

  #define _MCASP_RGBLCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_RGBLCTL##N##_ADDR,MCASP,RGBLCTL,##FIELD,##SYM)

  #define _MCASP_RGBLCTL0_FGET(FIELD) _MCASP_RGBLCTL_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RGBLCTL1_FGET(FIELD) _MCASP_RGBLCTL_FGET(1,##FIELD)
#endif
 
  #define _MCASP_RGBLCTL0_FSET(FIELD,f) _MCASP_RGBLCTL_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RGBLCTL1_FSET(FIELD,f) _MCASP_RGBLCTL_FSET(1,##FIELD,f)
#endif

  #define _MCASP_RGBLCTL0_FSETS(FIELD,SYM) _MCASP_RGBLCTL_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RGBLCTL1_FSETS(FIELD,SYM) _MCASP_RGBLCTL_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     RMASK         |
* |___________________|
*
* RMASK		- Pin Data Output Register
*
* FIELDS (msb -> lsb)
* (rw)  RMASKn n:0 to 31  
*
\******************************************************************************/

  #define _MCASP_RMASK_OFFSET               25

  #define _MCASP_RMASK0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_RMASK_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RMASK1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_RMASK_OFFSET)
#endif

  #define _MCASP_RMASK_RMASK0_MASK     		0x00000001u
  #define _MCASP_RMASK_RMASK0_SHIFT       	0x00000000u
  #define  MCASP_RMASK_RMASK0_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK0_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK0_USEMASK	       0x00000000u
  #define  MCASP_RMASK_RMASK0_NOMASK            0x00000001u

  #define _MCASP_RMASK_RMASK1_MASK        	0x00000002u
  #define _MCASP_RMASK_RMASK1_SHIFT       	0x00000001u
  #define  MCASP_RMASK_RMASK1_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK1_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK1_USEMASK	        0x00000000u
  #define  MCASP_RMASK_RMASK1_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK2_MASK        	0x00000004u
  #define _MCASP_RMASK_RMASK2_SHIFT       	0x00000002u
  #define  MCASP_RMASK_RMASK2_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK2_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK2_USEMASK	       0x00000000u
  #define  MCASP_RMASK_RMASK2_NOMASK             0x00000001u

  #define _MCASP_RMASK_RMASK3_MASK        	0x00000008u
  #define _MCASP_RMASK_RMASK3_SHIFT       	0x00000003u
  #define  MCASP_RMASK_RMASK3_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK3_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK3_USEMASK	      0x00000000u
  #define  MCASP_RMASK_RMASK3_NOMASK            0x00000001u

  #define _MCASP_RMASK_RMASK4_MASK        	0x00000010u
  #define _MCASP_RMASK_RMASK4_SHIFT       	0x00000004u
  #define  MCASP_RMASK_RMASK4_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK4_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK4_USEMASK	       0x00000000u
  #define  MCASP_RMASK_RMASK4_NOMASK            0x00000001u

  #define _MCASP_RMASK_RMASK5_MASK        	0x00000020u
  #define _MCASP_RMASK_RMASK5_SHIFT       	0x00000005u
  #define  MCASP_RMASK_RMASK5_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK5_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK5_USEMASK	        0x00000000u
  #define  MCASP_RMASK_RMASK5_NOMASK            0x00000001u

  #define _MCASP_RMASK_RMASK6_MASK        	0x00000040u
  #define _MCASP_RMASK_RMASK6_SHIFT       	0x00000006u
  #define  MCASP_RMASK_RMASK6_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK6_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK6_USEMASK	      0x00000000u
  #define  MCASP_RMASK_RMASK6_NOMASK            0x00000001u

  #define _MCASP_RMASK_RMASK7_MASK        	0x00000080u
  #define _MCASP_RMASK_RMASK7_SHIFT       	0x00000007u
  #define  MCASP_RMASK_RMASK7_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK7_OF(x)   	       _VALUEOF(x)
  #define  MCASP_RMASK_RMASK7_USEMASK	      0x00000000u
  #define  MCASP_RMASK_RMASK7_NOMASK            0x00000001u

  #define _MCASP_RMASK_RMASK8_MASK        	0x00000100u
  #define _MCASP_RMASK_RMASK8_SHIFT       	0x00000008u
  #define  MCASP_RMASK_RMASK8_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK8_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK8_USEMASK	      0x00000000u
  #define  MCASP_RMASK_RMASK8_NOMASK            0x00000001u

  #define _MCASP_RMASK_RMASK9_MASK        	0x00000200u
  #define _MCASP_RMASK_RMASK9_SHIFT       	0x00000009u
  #define  MCASP_RMASK_RMASK9_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK9_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK9_USEMASK	      0x00000000u
  #define  MCASP_RMASK_RMASK9_NOMASK            0x00000001u

  #define _MCASP_RMASK_RMASK10_MASK        	0x00000400u
  #define _MCASP_RMASK_RMASK10_SHIFT       	0x0000000Au
  #define  MCASP_RMASK_RMASK10_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK10_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK10_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK10_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK11_MASK        	0x00000800u
  #define _MCASP_RMASK_RMASK11_SHIFT       	0x0000000Bu
  #define  MCASP_RMASK_RMASK11_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK11_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK11_USEMASK	      0x00000000u
  #define  MCASP_RMASK_RMASK11_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK12_MASK        	0x00001000u
  #define _MCASP_RMASK_RMASK12_SHIFT       	0x0000000Cu
  #define  MCASP_RMASK_RMASK12_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK12_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK12_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK12_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK13_MASK        	0x00002000u
  #define _MCASP_RMASK_RMASK13_SHIFT       	0x0000000Du
  #define  MCASP_RMASK_RMASK13_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK13_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK13_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK13_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK14_MASK        	0x00004000u
  #define _MCASP_RMASK_RMASK14_SHIFT       	0x0000000Eu
  #define  MCASP_RMASK_RMASK14_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK14_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK14_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK14_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK15_MASK        	0x00008000u
  #define _MCASP_RMASK_RMASK15_SHIFT       	0x0000000Fu
  #define  MCASP_RMASK_RMASK15_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK15_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK15_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK15_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK16_MASK        	0x00010000u
  #define _MCASP_RMASK_RMASK16_SHIFT       	0x00000010u
  #define  MCASP_RMASK_RMASK16_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK16_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK16_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK16_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK17_MASK        	0x00020000u
  #define _MCASP_RMASK_RMASK17_SHIFT       	0x00000011u
  #define  MCASP_RMASK_RMASK17_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK17_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK17_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK17_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK18_MASK        	0x00040000u
  #define _MCASP_RMASK_RMASK18_SHIFT       	0x00000012u
  #define  MCASP_RMASK_RMASK18_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK18_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK18_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK18_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK19_MASK        	0x00080000u
  #define _MCASP_RMASK_RMASK19_SHIFT       	0x00000013u
  #define  MCASP_RMASK_RMASK19_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK19_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK19_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK19_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK20_MASK        	0x00100000u
  #define _MCASP_RMASK_RMASK20_SHIFT       	0x00000014u
  #define  MCASP_RMASK_RMASK20_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK20_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK20_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK20_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK21_MASK        	0x00200000u
  #define _MCASP_RMASK_RMASK21_SHIFT       	0x00000015u
  #define  MCASP_RMASK_RMASK21_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK21_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK21_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK21_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK22_MASK        	0x00400000u
  #define _MCASP_RMASK_RMASK22_SHIFT       	0x00000016u
  #define  MCASP_RMASK_RMASK22_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK22_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK22_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK22_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK23_MASK        	0x00800000u
  #define _MCASP_RMASK_RMASK23_SHIFT       	0x00000017u
  #define  MCASP_RMASK_RMASK23_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK23_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK23_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK23_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK24_MASK        	0x01000000u
  #define _MCASP_RMASK_RMASK24_SHIFT       	0x00000018u
  #define  MCASP_RMASK_RMASK24_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK24_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK24_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK24_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK25_MASK        	0x02000000u
  #define _MCASP_RMASK_RMASK25_SHIFT       	0x00000019u
  #define  MCASP_RMASK_RMASK25_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK25_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK25_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK25_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK26_MASK        	0x04000000u
  #define _MCASP_RMASK_RMASK26_SHIFT       	0x0000001Au
  #define  MCASP_RMASK_RMASK26_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK26_OF(x)   	      _VALUEOF(x)
  #define  MCASP_RMASK_RMASK26_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK26_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK27_MASK        	0x08000000u
  #define _MCASP_RMASK_RMASK27_SHIFT       	0x0000001Bu
  #define  MCASP_RMASK_RMASK27_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK27_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK27_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK27_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK28_MASK        	0x10000000u
  #define _MCASP_RMASK_RMASK28_SHIFT       	0x0000001Cu
  #define  MCASP_RMASK_RMASK28_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK28_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK28_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK28_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK29_MASK        	0x20000000u
  #define _MCASP_RMASK_RMASK29_SHIFT       	0x0000001Du
  #define  MCASP_RMASK_RMASK29_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK29_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK29_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK29_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK30_MASK        	0x40000000u
  #define _MCASP_RMASK_RMASK30_SHIFT       	0x0000001Eu
  #define  MCASP_RMASK_RMASK30_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK30_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK30_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK30_NOMASK           0x00000001u

  #define _MCASP_RMASK_RMASK31_MASK        	0x80000000u
  #define _MCASP_RMASK_RMASK31_SHIFT       	0x0000001Fu
  #define  MCASP_RMASK_RMASK31_DEFAULT     	0x00000000u
  #define  MCASP_RMASK_RMASK31_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RMASK_RMASK31_USEMASK        	0x00000000u
  #define  MCASP_RMASK_RMASK31_NOMASK           0x00000001u



  #define  MCASP_RMASK_OF(x)                	_VALUEOF(x)

  #define MCASP_RMASK_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,RMASK,RMASK0)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK1)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK2)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK3)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK4)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK5)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK6)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK7)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK8)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK9)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK10)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK11)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK12)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK13)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK14)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK15)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK16)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK17)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK18)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK19)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK20)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK21)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK22)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK23)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK24)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK25)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK26)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK27)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK28)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK29)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK30)\
    |_PER_FDEFAULT(MCASP,RMASK,RMASK31)\
  )

  #define MCASP_RMASK_RMK(rmask31, rmask30,rmask29,rmask28,rmask27,rmask26,rmask25,\
    rmask24,rmask23,rmask22,rmask21,rmask20,rmask19,rmask18,rmask17,\
   rmask16,rmask15,rmask14,rmask13,rmask12,rmask11,rmask10,rmask9,\
   rmask8, rmask7, rmask6,  rmask5,rmask4, rmask3, rmask2, rmask1, rmask0 ) \
(Uint32)( \
     _PER_FMK(MCASP,RMASK,RMASK0,rmask0)\
    |_PER_FMK(MCASP,RMASK,RMASK1,rmask1)\
    |_PER_FMK(MCASP,RMASK,RMASK2,rmask2)\
    |_PER_FMK(MCASP,RMASK,RMASK3,rmask3)\
    |_PER_FMK(MCASP,RMASK,RMASK4,rmask4)\
    |_PER_FMK(MCASP,RMASK,RMASK5,rmask5)\
    |_PER_FMK(MCASP,RMASK,RMASK6,rmask6)\
    |_PER_FMK(MCASP,RMASK,RMASK7,rmask7)\
    |_PER_FMK(MCASP,RMASK,RMASK8,rmask8)\
    |_PER_FMK(MCASP,RMASK,RMASK9,rmask9)\
    |_PER_FMK(MCASP,RMASK,RMASK10,rmask10)\
    |_PER_FMK(MCASP,RMASK,RMASK11,rmask11)\
    |_PER_FMK(MCASP,RMASK,RMASK12,rmask12)\
    |_PER_FMK(MCASP,RMASK,RMASK13,rmask13)\
    |_PER_FMK(MCASP,RMASK,RMASK14,rmask14)\
    |_PER_FMK(MCASP,RMASK,RMASK15,rmask15)\
    |_PER_FMK(MCASP,RMASK,RMASK16,rmask16)\
    |_PER_FMK(MCASP,RMASK,RMASK17,rmask17)\
    |_PER_FMK(MCASP,RMASK,RMASK18,rmask18)\
    |_PER_FMK(MCASP,RMASK,RMASK19,rmask19)\
    |_PER_FMK(MCASP,RMASK,RMASK20,rmask20)\
    |_PER_FMK(MCASP,RMASK,RMASK21,rmask21)\
    |_PER_FMK(MCASP,RMASK,RMASK22,rmask22)\
    |_PER_FMK(MCASP,RMASK,RMASK23,rmask23)\
    |_PER_FMK(MCASP,RMASK,RMASK24,rmask24)\
    |_PER_FMK(MCASP,RMASK,RMASK25,rmask25)\
    |_PER_FMK(MCASP,RMASK,RMASK26,rmask26)\
    |_PER_FMK(MCASP,RMASK,RMASK27,rmask27)\
    |_PER_FMK(MCASP,RMASK,RMASK28,rmask28)\
    |_PER_FMK(MCASP,RMASK,RMASK29,rmask29)\
    |_PER_FMK(MCASP,RMASK,RMASK30,rmask30)\
    |_PER_FMK(MCASP,RMASK,RMASK31,rmask31)\
  )

  #define _MCASP_RMASK_FGET(N,FIELD)\
    _PER_FGET(_MCASP_RMASK##N##_ADDR,MCASP,RMASK,##FIELD)

  #define _MCASP_RMASK_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_RMASK##N##_ADDR,MCASP,RMASK,##FIELD,field)

  #define _MCASP_RMASK_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_RMASK##N##_ADDR,MCASP,RMASK,##FIELD,##SYM)

  #define _MCASP_RMASK0_FGET(FIELD) _MCASP_RMASK_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RMASK1_FGET(FIELD) _MCASP_RMASK_FGET(1,##FIELD)
#endif
 
  #define _MCASP_RMASK0_FSET(FIELD,f) _MCASP_RMASK_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RMASK1_FSET(FIELD,f) _MCASP_RMASK_FSET(1,##FIELD,f)
#endif

  #define _MCASP_RMASK0_FSETS(FIELD,SYM) _MCASP_RMASK_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RMASK1_FSETS(FIELD,SYM) _MCASP_RMASK_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     RFMT          |
* |___________________|
*
* RFMT		- Receive Bitstream Format Register
*
* FIELDS (msb -> lsb)
* (rw)  RDATDLY
* (rw)  RRVRS  
* (rw)  RPAD
* (rw)  RPBIT  
* (rw)  RSSZ
* (rw)  RBUSEL
* (rw)  RROT  
*
\******************************************************************************/

  #define _MCASP_RFMT_OFFSET               26

  #define _MCASP_RFMT0_ADDR					(_MCASP_BASE_PORT0+4*_MCASP_RFMT_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RFMT1_ADDR					(_MCASP_BASE_PORT1+4*_MCASP_RFMT_OFFSET)
#endif

  #define _MCASP_RFMT_RDATDLY_MASK              0x00030000u
  #define _MCASP_RFMT_RDATDLY_SHIFT             0x00000010u
  #define  MCASP_RFMT_RDATDLY_DEFAULT           0x00000000u
  #define  MCASP_RFMT_RDATDLY_OF(x)             _VALUEOF(x)
  #define  MCASP_RFMT_RDATDLY_0BIT              0x00000000u
  #define  MCASP_RFMT_RDATDLY_1BIT              0x00000001u
  #define  MCASP_RFMT_RDATDLY_2BIT              0x00000002u


  #define _MCASP_RFMT_RRVRS_MASK        	      0x00008000u
  #define _MCASP_RFMT_RRVRS_SHIFT       	      0x0000000Fu
  #define  MCASP_RFMT_RRVRS_DEFAULT             0x00000000u
  #define  MCASP_RFMT_RRVRS_OF(x)   	        _VALUEOF(x)
  #define  MCASP_RFMT_RRVRS_LSBFIRST            0x00000000u
  #define  MCASP_RFMT_RRVRS_MSBFIRST            0x00000001u

  #define _MCASP_RFMT_RPAD_MASK     		0x00006000u
  #define _MCASP_RFMT_RPAD_SHIFT          	0x0000000Du
  #define  MCASP_RFMT_RPAD_DEFAULT        	0x00000000u
  #define  MCASP_RFMT_RPAD_OF(x)          	_VALUEOF(x)
  #define  MCASP_RFMT_RPAD_ZERO            	0x00000000u
  #define  MCASP_RFMT_RPAD_ONE            	0x00000001u
  #define  MCASP_RFMT_RPAD_RPBIT          	0x00000002u

  #define _MCASP_RFMT_RPBIT_MASK           	0x00001F00u
  #define _MCASP_RFMT_RPBIT_SHIFT          	0x00000008u
  #define  MCASP_RFMT_RPBIT_DEFAULT        	0x00000000u
  #define  MCASP_RFMT_RPBIT_OF(x)          	_VALUEOF(x)

  #define _MCASP_RFMT_RSSZ_MASK           	0x000000F0u
  #define _MCASP_RFMT_RSSZ_SHIFT          	0x00000004u
  #define  MCASP_RFMT_RSSZ_DEFAULT        	0x00000000u
  #define  MCASP_RFMT_RSSZ_OF(x)          	_VALUEOF(x)
  #define  MCASP_RFMT_RSSZ_8BITS            	0x00000003u
  #define  MCASP_RFMT_RSSZ_12BITS            	0x00000005u
  #define  MCASP_RFMT_RSSZ_16BITS            	0x00000007u
  #define  MCASP_RFMT_RSSZ_20BITS            	0x00000009u
  #define  MCASP_RFMT_RSSZ_24BITS            	0x0000000Bu
  #define  MCASP_RFMT_RSSZ_28BITS            	0x0000000Du
  #define  MCASP_RFMT_RSSZ_32BITS            	0x0000000Fu

  #define _MCASP_RFMT_RBUSEL_MASK           	0x00000008u
  #define _MCASP_RFMT_RBUSEL_SHIFT          	0x00000003u
  #define  MCASP_RFMT_RBUSEL_DEFAULT        	0x00000000u
  #define  MCASP_RFMT_RBUSEL_OF(x)         	_VALUEOF(x)
  #define  MCASP_RFMT_RBUSEL_DAT            	0x00000000u
  #define  MCASP_RFMT_RBUSEL_CFG            	0x00000001u


  #define _MCASP_RFMT_RROT_MASK           	0x00000007u
  #define _MCASP_RFMT_RROT_SHIFT          	0x00000000u
  #define  MCASP_RFMT_RROT_DEFAULT        	0x00000000u
  #define  MCASP_RFMT_RROT_OF(x)         	_VALUEOF(x)
  #define  MCASP_RFMT_RROT_NONE            	0x00000000u
  #define  MCASP_RFMT_RROT_4BITS            	0x00000001u
  #define  MCASP_RFMT_RROT_8BITS            	0x00000002u
  #define  MCASP_RFMT_RROT_12BITS            	0x00000003u
  #define  MCASP_RFMT_RROT_16BITS            	0x00000004u
  #define  MCASP_RFMT_RROT_20BITS            	0x00000005u
  #define  MCASP_RFMT_RROT_24BITS            	0x00000006u
  #define  MCASP_RFMT_RROT_28BITS            	0x00000007u

  #define  MCASP_RFMT_OF(x)                	_VALUEOF(x)

  #define MCASP_RFMT_DEFAULT (Uint32)( \
  	 _PER_FDEFAULT(MCASP,RFMT,RDATDLY)\
    |_PER_FDEFAULT(MCASP,RFMT,RRVRS)\
    |_PER_FDEFAULT(MCASP,RFMT,RPAD)\
    |_PER_FDEFAULT(MCASP,RFMT,RPBIT)\
    |_PER_FDEFAULT(MCASP,RFMT,RSSZ)\
    |_PER_FDEFAULT(MCASP,RFMT,RBUSEL)\
    |_PER_FDEFAULT(MCASP,RFMT,RROT)\
    )

  #define MCASP_RFMT_RMK(rdatdly,rrvrs,rpad,rpbit,rssz,rbusel,rrot) (Uint32)( \
     _PER_FMK(MCASP,RFMT,RDATDLY,rdatdly)\
    |_PER_FMK(MCASP,RFMT,RRVRS,rrvrs)\
    |_PER_FMK(MCASP,RFMT,RPAD,rpad)\
    |_PER_FMK(MCASP,RFMT,RPBIT,rpbit)\
    |_PER_FMK(MCASP,RFMT,RSSZ,rssz)\
    |_PER_FMK(MCASP,RFMT,RBUSEL,rbusel)\
    |_PER_FMK(MCASP,RFMT,RROT,rrot)\
  )

  #define _MCASP_RFMT_FGET(N,FIELD)\
    _PER_FGET(_MCASP_RFMT##N##_ADDR,MCASP,RFMT,##FIELD)

  #define _MCASP_RFMT_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_RFMT##N##_ADDR,MCASP,RFMT,##FIELD,field)

  #define _MCASP_RFMT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_RFMT##N##_ADDR,MCASP,RFMT,##FIELD,##SYM)

  #define _MCASP_RFMT0_FGET(FIELD) _MCASP_RFMT_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RFMT1_FGET(FIELD) _MCASP_RFMT_FGET(1,##FIELD)
#endif
 
  #define _MCASP_RFMT0_FSET(FIELD,f) _MCASP_RFMT_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RFMT1_FSET(FIELD,f) _MCASP_RFMT_FSET(1,##FIELD,f)
#endif

  #define _MCASP_RFMT0_FSETS(FIELD,SYM) _MCASP_RFMT_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RFMT1_FSETS(FIELD,SYM) _MCASP_RFMT_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     AFSRCTL       |
* |___________________|
*
* AFSRCTL  -  Receive Frame Control Register
*
* FIELDS (msb -> lsb)
* (rw)  RMOD
* (rw)  FRWID
* (rw)  FSRM
* (rw)  FSRP
*
\******************************************************************************/

  #define _MCASP_AFSRCTL_OFFSET               27

  #define _MCASP_AFSRCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_AFSRCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AFSRCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_AFSRCTL_OFFSET)
#endif

  #define _MCASP_AFSRCTL_RMOD_MASK              0x0000FF80u
  #define _MCASP_AFSRCTL_RMOD_SHIFT             0x00000007u
  #define  MCASP_AFSRCTL_RMOD_DEFAULT           0x00000000u
  #define  MCASP_AFSRCTL_RMOD_OF(x)             _VALUEOF(x)
  #define  MCASP_AFSRCTL_RMOD_BURST             0x00000000u

  #define _MCASP_AFSRCTL_FRWID_MASK              0x00000010u
  #define _MCASP_AFSRCTL_FRWID_SHIFT             0x00000004u
  #define  MCASP_AFSRCTL_FRWID_DEFAULT           0x00000000u
  #define  MCASP_AFSRCTL_FRWID_OF(x)             _VALUEOF(x)
  #define  MCASP_AFSRCTL_FRWID_BIT               0x00000000u
  #define  MCASP_AFSRCTL_FRWID_WORD             0x00000001u
  

  #define _MCASP_AFSRCTL_FSRM_MASK              0x00000002u
  #define _MCASP_AFSRCTL_FSRM_SHIFT             0x00000001u
  #define  MCASP_AFSRCTL_FSRM_DEFAULT           0x00000000u
  #define  MCASP_AFSRCTL_FSRM_OF(x)             _VALUEOF(x)
  #define  MCASP_AFSRCTL_FSRM_EXTERNAL          0x00000000u
  #define  MCASP_AFSRCTL_FSRM_INTERNAL          0x00000001u
  

  #define _MCASP_AFSRCTL_FSRP_MASK              0x00000001u
  #define _MCASP_AFSRCTL_FSRP_SHIFT             0x00000000u
  #define  MCASP_AFSRCTL_FSRP_DEFAULT           0x00000000u
  #define  MCASP_AFSRCTL_FSRP_OF(x)             _VALUEOF(x)
  #define  MCASP_AFSRCTL_FSRP_ACTIVEHIGH        0x00000000u
  #define  MCASP_AFSRCTL_FSRP_ACTIVELOW         0x00000001u
  

  #define  MCASP_AFSRCTL_OF(x)                _VALUEOF(x)

  #define MCASP_AFSRCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,AFSRCTL,RMOD)\
	| _PER_FDEFAULT(MCASP,AFSRCTL,FRWID)\
	| _PER_FDEFAULT(MCASP,AFSRCTL,FSRM)\
	| _PER_FDEFAULT(MCASP,AFSRCTL,FSRP)\
  )

  #define MCASP_AFSRCTL_RMK(rmod, frwid, fsrm, fsrp) (Uint32)( \
     _PER_FMK(MCASP,AFSRCTL,RMOD,rmod)\
	| _PER_FMK(MCASP,AFSRCTL,FRWID,frwid)\
	| _PER_FMK(MCASP,AFSRCTL,FSRM,fsrm)\
	| _PER_FMK(MCASP,AFSRCTL,FSRP,fsrp)\
  )

  #define _MCASP_AFSRCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_AFSRCTL##N##_ADDR,MCASP,AFSRCTL,##FIELD)

  #define _MCASP_AFSRCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_AFSRCTL##N##_ADDR,MCASP,AFSRCTL,##FIELD,field)

  #define _MCASP_AFSRCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCAS_AFSRCTL##N##_ADDR,MCASP,AFSRCTL,##FIELD,##SYM)

  #define _MCASP_AFSRCTL0_FGET(FIELD) _MCASP_AFSRCTL_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AFSRCTL1_FGET(FIELD) _MCASP_AFSRCTL_FGET(1,##FIELD)
#endif
 
  #define _MCASP_AFSRCTL0_FSET(FIELD,f) _MCASP_AFSRCTL_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AFSRCTL1_FSET(FIELD,f) _MCASP_AFSRCTL_FSET(1,##FIELD,f)
#endif

  #define _MCASP_AFSRCTL0_FSETS(FIELD,SYM) _MCASP_AFSRCTL_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AFSRCTL1_FSETS(FIELD,SYM) _MCASP_AFSRCTL_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     ACLKRCTL      |
* |___________________|
*
* ACLKRCTL  -  Receive Clock Control Register
*
*  FIELDS (msb -> lsb)
* (rw)  CLKRP  
* (rw)  CLKRM  
* (rw)  CLKRDIV
*
\******************************************************************************/

  #define _MCASP_ACLKRCTL_OFFSET               28

  #define _MCASP_ACLKRCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_ACLKRCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_ACLKRCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_ACLKRCTL_OFFSET)
#endif

  #define _MCASP_ACLKRCTL_CLKRP_MASK              0x00000080u
  #define _MCASP_ACLKRCTL_CLKRP_SHIFT             0x00000007u
  #define  MCASP_ACLKRCTL_CLKRP_DEFAULT           0x00000000u
  #define  MCASP_ACLKRCTL_CLKRP_OF(x)             _VALUEOF(x)
  #define  MCASP_ACLKRCTL_CLKRP_RISING            0x00000001u
  #define  MCASP_ACLKRCTL_CLKRP_FALLING           0x00000000u
  

  #define _MCASP_ACLKRCTL_CLKRM_MASK              0x00000020u
  #define _MCASP_ACLKRCTL_CLKRM_SHIFT             0x00000005u
  #define  MCASP_ACLKRCTL_CLKRM_DEFAULT           0x00000001u
  #define  MCASP_ACLKRCTL_CLKRM_OF(x)             _VALUEOF(x)
  #define  MCASP_ACLKRCTL_CLKRM_EXTERNAL            0x00000000u
  #define  MCASP_ACLKRCTL_CLKRM_INTERNAL            0x00000001u
  

  #define _MCASP_ACLKRCTL_CLKRDIV_MASK              0x0000001Fu
  #define _MCASP_ACLKRCTL_CLKRDIV_SHIFT             0x00000000u
  #define  MCASP_ACLKRCTL_CLKRDIV_DEFAULT           0x00000000u
  #define  MCASP_ACLKRCTL_CLKRDIV_OF(x)             _VALUEOF(x)

  #define  MCASP_ACLKRCTL_OF(x)                _VALUEOF(x)

  #define MCASP_ACLKRCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,ACLKRCTL,CLKRP)\
	| _PER_FDEFAULT(MCASP,ACLKRCTL,CLKRM)\
	| _PER_FDEFAULT(MCASP,ACLKRCTL,CLKRDIV)\
  )

  #define MCASP_ACLKRCTL_RMK(clkrp, clkrm, clkrdiv) (Uint32)( \
     _PER_FMK(MCASP,ACLKRCTL,CLKRP,clkrp)\
	| _PER_FMK(MCASP,ACLKRCTL,CLKRM,clkrm)\
	| _PER_FMK(MCASP,ACLKRCTL,CLKRDIV,clkrdiv)\
  )


  #define _MCASP_ACLKRCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_ACLKRCTL##N##_ADDR,MCASP,ACLKRCTL,##FIELD)

  #define _MCASP_ACLKRCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_ACLKRCTL##N##_ADDR,MCASP,ACLKRCTL,##FIELD,field)

  #define _MCASP_ACLKRCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_ACLKRCTL##N##_ADDR,MCASP,ACLKRCTL,##FIELD,##SYM)

  #define _MCASP_ACLKRCTL0_FGET(FIELD) _MCASP_ACLKRCTL_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_ACLKRCTL1_FGET(FIELD) _MCASP_ACLKRCTL_FGET(1,##FIELD)
#endif

  #define _MCASP_ACLKRCTL0_FSET(FIELD,f) _MCASP_ACLKRCTL_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_ACLKRCTL1_FSET(FIELD,f) _MCASP_ACLKRCTL_FSET(1,##FIELD,f)
#endif

  #define _MCASP_ACLKRCTL0_FSETS(FIELD,SYM) _MCASP_ACLKRCTL_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_ACLKRCTL1_FSETS(FIELD,SYM) _MCASP_ACLKRCTL_FSETS(1,##FIELD,##SYM)
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     AHCLKRCTL     |
* |___________________|
*
* AHCLKRCTL  -  High Frequency Receive Clock Control Register
*
* FIELDS (msb -> lsb)
* (rw)  HCLKRM 
* (rw)  HCLKRP
* (rw)  HCLKRDIV 
*
\******************************************************************************/

  #define _MCASP_AHCLKRCTL_OFFSET                   29

  #define _MCASP_AHCLKRCTL0_ADDR	  	    (_MCASP_BASE_PORT0+4*_MCASP_AHCLKRCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AHCLKRCTL1_ADDR		    (_MCASP_BASE_PORT1+4*_MCASP_AHCLKRCTL_OFFSET)
#endif
 
  #define _MCASP_AHCLKRCTL_HCLKRM_MASK              0x00008000u
  #define _MCASP_AHCLKRCTL_HCLKRM_SHIFT             0x0000000Fu
  #define  MCASP_AHCLKRCTL_HCLKRM_DEFAULT           0x00000001u
  #define  MCASP_AHCLKRCTL_HCLKRM_OF(x)             _VALUEOF(x)
  #define  MCASP_AHCLKRCTL_HCLKRM_EXTERNAL          0x00000000u
  #define  MCASP_AHCLKRCTL_HCLKRM_INTERNAL     	    0x00000001u

  #define _MCASP_AHCLKRCTL_HCLKRP_MASK              0x00004000u
  #define _MCASP_AHCLKRCTL_HCLKRP_SHIFT             0x0000000Eu
  #define  MCASP_AHCLKRCTL_HCLKRP_DEFAULT           0x00000000u
  #define  MCASP_AHCLKRCTL_HCLKRP_OF(x)             _VALUEOF(x)
  #define  MCASP_AHCLKRCTL_HCLKRP_RISING            0x00000000u
  #define  MCASP_AHCLKRCTL_HCLKRP_FALLING           0x00000001u

  #define _MCASP_AHCLKRCTL_HCLKRDIV_MASK            0x00000FFFu
  #define _MCASP_AHCLKRCTL_HCLKRDIV_SHIFT           0x00000000u
  #define  MCASP_AHCLKRCTL_HCLKRDIV_DEFAULT         0x00000000u
  #define  MCASP_AHCLKRCTL_HCLKRDIV_OF(x)           _VALUEOF(x)


  #define  MCASP_AHCLKRCTL_OF(x)                _VALUEOF(x)

  #define MCASP_AHCLKRCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,AHCLKRCTL,HCLKRM)\
    | _PER_FDEFAULT(MCASP,AHCLKRCTL,HCLKRP)\
	| _PER_FDEFAULT(MCASP,AHCLKRCTL,HCLKRDIV)\
  )

  #define MCASP_AHCLKRCTL_RMK(hclkrm, hclkrp, hclkrdiv) (Uint32)( \
     _PER_FMK(MCASP,AHCLKRCTL,HCLKRM,hclkrm)\
	| _PER_FMK(MCASP,AHCLKRCTL,HCLKRP,hclkrp)\
	| _PER_FMK(MCASP,AHCLKRCTL,HCLKRDIV,hclkrdiv)\
  )

  #define _MCASP_AHCLKRCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_AHCLKRCTL##N##_ADDR,MCASP,AHCLKRCTL,##FIELD)

  #define _MCASP_AHCLKRCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_AHCLKRCTL##N##_ADDR,MCASP,AHCLKRCTL,##FIELD,field)

  #define _MCASP_AHCLKRCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_AHCLKRCTL##N##_ADDR,MCASP,AHCLKRCTL,##FIELD,##SYM)

 #define _MCASP_AHCLKRCTL0_FGET(FIELD) _MCASP_AHCLKRCTL_FGET(0,##FIELD)
#if (_MCASP_PORT_CNT > 1)
 #define _MCASP_AHCLKRCTL1_FGET(FIELD) _MCASP_AHCLKRCTL_FGET(1,##FIELD)
#endif

  #define _MCASP_AHCLKRCTL0_FSET(FIELD,f) _MCASP_AHCLKRCTL_FSET(0,##FIELD,f)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AHCLKRCTL1_FSET(FIELD,f) _MCASP_AHCLKRCTL_FSET(1,##FIELD,f)
#endif

  #define _MCASP_AHCLKRCTL0_FSETS(FIELD,SYM) _MCASP_AHCLKRCTL_FSETS(0,##FIELD,##SYM)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AHCLKRCTL1_FSETS(FIELD,SYM) _MCASP_AHCLKRCTL_FSETS(1,##FIELD,##SYM)
#endif

/******************************************************************************\
* 
* _____________________
* |                   |
* |    R  T  D  M     |
* |___________________|
*
* RTDM  -  Receive TDM register
*
* FIELDS (msb -> lsb)
* (rw)  RTDMS0
* (rw)  RTDMS1
*   .
*   .
*   .
* (rw)  RTDMS31
*
\******************************************************************************/

  #define _MCASP_RTDM_OFFSET               30

  #define _MCASP_RTDM0_ADDR			(_MCASP_BASE_PORT0+4*_MCASP_RTDM_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RTDM1_ADDR			(_MCASP_BASE_PORT1+4*_MCASP_RTDM_OFFSET)
#endif

  #define _MCASP_RTDM_RTDMS31_MASK              0x80000000u
  #define _MCASP_RTDM_RTDMS31_SHIFT             0x0000001Fu
  #define  MCASP_RTDM_RTDMS31_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS31_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS31_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS31_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS30_MASK              0x40000000u
  #define _MCASP_RTDM_RTDMS30_SHIFT             0x0000001Eu
  #define  MCASP_RTDM_RTDMS30_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS30_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS30_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS30_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS29_MASK              0x20000000u
  #define _MCASP_RTDM_RTDMS29_SHIFT             0x0000001Du
  #define  MCASP_RTDM_RTDMS29_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS29_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS29_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS29_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS28_MASK              0x10000000u
  #define _MCASP_RTDM_RTDMS28_SHIFT             0x0000001Cu
  #define  MCASP_RTDM_RTDMS28_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS28_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS28_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS28_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS27_MASK              0x08000000u
  #define _MCASP_RTDM_RTDMS27_SHIFT             0x0000001Bu
  #define  MCASP_RTDM_RTDMS27_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS27_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS27_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS27_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS26_MASK              0x04000000u
  #define _MCASP_RTDM_RTDMS26_SHIFT             0x0000001Au
  #define  MCASP_RTDM_RTDMS26_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS26_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS26_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS26_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS25_MASK              0x02000000u
  #define _MCASP_RTDM_RTDMS25_SHIFT             0x00000019u
  #define  MCASP_RTDM_RTDMS25_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS25_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS25_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS25_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS24_MASK              0x01000000u
  #define _MCASP_RTDM_RTDMS24_SHIFT             0x00000018u
  #define  MCASP_RTDM_RTDMS24_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS24_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS24_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS24_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS23_MASK              0x00800000u
  #define _MCASP_RTDM_RTDMS23_SHIFT             0x00000017u
  #define  MCASP_RTDM_RTDMS23_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS23_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS23_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS23_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS22_MASK              0x00400000u
  #define _MCASP_RTDM_RTDMS22_SHIFT             0x00000016u
  #define  MCASP_RTDM_RTDMS22_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS22_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS22_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS22_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS21_MASK              0x00200000u
  #define _MCASP_RTDM_RTDMS21_SHIFT             0x00000015u
  #define  MCASP_RTDM_RTDMS21_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS21_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS21_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS21_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS20_MASK              0x00100000u
  #define _MCASP_RTDM_RTDMS20_SHIFT             0x00000014u
  #define  MCASP_RTDM_RTDMS20_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS20_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS20_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS20_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS19_MASK              0x00080000u
  #define _MCASP_RTDM_RTDMS19_SHIFT             0x00000013u
  #define  MCASP_RTDM_RTDMS19_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS19_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS19_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS19_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS18_MASK              0x00040000u
  #define _MCASP_RTDM_RTDMS18_SHIFT             0x00000012u
  #define  MCASP_RTDM_RTDMS18_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS18_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS18_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS18_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS17_MASK              0x00020000u
  #define _MCASP_RTDM_RTDMS17_SHIFT             0x00000011u
  #define  MCASP_RTDM_RTDMS17_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS17_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS17_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS17_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS16_MASK              0x00010000u
  #define _MCASP_RTDM_RTDMS16_SHIFT             0x00000010u
  #define  MCASP_RTDM_RTDMS16_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS16_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS16_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS16_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS15_MASK              0x00008000u
  #define _MCASP_RTDM_RTDMS15_SHIFT             0x0000000Fu
  #define  MCASP_RTDM_RTDMS15_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS15_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS15_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS15_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS14_MASK              0x00004000u
  #define _MCASP_RTDM_RTDMS14_SHIFT             0x0000000Eu
  #define  MCASP_RTDM_RTDMS14_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS14_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS14_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS14_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS13_MASK              0x00002000u
  #define _MCASP_RTDM_RTDMS13_SHIFT             0x0000000Du
  #define  MCASP_RTDM_RTDMS13_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS13_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS13_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS13_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS12_MASK              0x00001000u
  #define _MCASP_RTDM_RTDMS12_SHIFT             0x0000000Cu
  #define  MCASP_RTDM_RTDMS12_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS12_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS12_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS12_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS11_MASK              0x00000800u
  #define _MCASP_RTDM_RTDMS11_SHIFT             0x0000000Bu
  #define  MCASP_RTDM_RTDMS11_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS11_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS11_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS11_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS10_MASK              0x00000400u
  #define _MCASP_RTDM_RTDMS10_SHIFT             0x0000000Au
  #define  MCASP_RTDM_RTDMS10_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS10_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS10_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS10_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS9_MASK              0x00000200u
  #define _MCASP_RTDM_RTDMS9_SHIFT             0x00000009u
  #define  MCASP_RTDM_RTDMS9_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS9_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS9_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS9_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS8_MASK              0x00000100u
  #define _MCASP_RTDM_RTDMS8_SHIFT             0x00000008u
  #define  MCASP_RTDM_RTDMS8_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS8_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS8_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS8_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS7_MASK              0x00000080u
  #define _MCASP_RTDM_RTDMS7_SHIFT             0x00000007u
  #define  MCASP_RTDM_RTDMS7_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS7_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS7_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS7_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS6_MASK              0x00000040u
  #define _MCASP_RTDM_RTDMS6_SHIFT             0x00000006u
  #define  MCASP_RTDM_RTDMS6_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS6_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS6_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS6_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS5_MASK              0x00000020u
  #define _MCASP_RTDM_RTDMS5_SHIFT             0x00000005u
  #define  MCASP_RTDM_RTDMS5_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS5_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS5_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS5_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS4_MASK              0x00000010u
  #define _MCASP_RTDM_RTDMS4_SHIFT             0x00000004u
  #define  MCASP_RTDM_RTDMS4_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS4_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS4_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS4_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS3_MASK              0x00000008u
  #define _MCASP_RTDM_RTDMS3_SHIFT             0x00000003u
  #define  MCASP_RTDM_RTDMS3_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS3_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS3_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS3_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS2_MASK              0x00000004u
  #define _MCASP_RTDM_RTDMS2_SHIFT             0x00000002u
  #define  MCASP_RTDM_RTDMS2_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS2_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS2_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS2_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS1_MASK              0x00000002u
  #define _MCASP_RTDM_RTDMS1_SHIFT             0x00000001u
  #define  MCASP_RTDM_RTDMS1_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS1_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS1_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS1_ACTIVE            0x00000001u
  
  #define _MCASP_RTDM_RTDMS0_MASK              0x00000001u
  #define _MCASP_RTDM_RTDMS0_SHIFT             0x00000000u
  #define  MCASP_RTDM_RTDMS0_DEFAULT           0x00000000u
  #define  MCASP_RTDM_RTDMS0_OF(x)             _VALUEOF(x)
  #define  MCASP_RTDM_RTDMS0_INACTIVE          0x00000000u
  #define  MCASP_RTDM_RTDMS0_ACTIVE            0x00000001u
  
  #define  MCASP_RTDM_OF(x)                _VALUEOF(x)

  #define MCASP_RTDM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,RTDM,RTDMS31)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS30)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS29)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS28)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS27)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS26)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS25)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS24)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS23)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS22)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS21)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS20)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS19)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS18)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS17)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS16)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS15)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS14)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS13)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS12)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS11)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS10)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS9)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS8)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS7)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS6)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS5)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS4)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS3)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS2)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS1)\
	| _PER_FDEFAULT(MCASP,RTDM,RTDMS0)\
  )

  #define MCASP_RTDM_RMK(rtdms31, rtdms30, rtdms29, rtdms28, rtdms27, rtdms26, rtdms25, rtdms24, rtdms23, rtdms22, rtdms21, rtdms20, rtdms19, rtdms18, rtdms17, rtdms16, rtdms15, rtdms14, rtdms13, rtdms12, rtdms11, rtdms10, rtdms9, rtdms8, rtdms7, rtdms6, rtdms5, rtdms4, rtdms3, rtdms2, rtdms1, rtdms0) (Uint32)( \
     _PER_FMK(MCASP,RTDM,RTDMS31,rtdms31)\
	| _PER_FMK(MCASP,RTDM,RTDMS30,rtdms30)\
	| _PER_FMK(MCASP,RTDM,RTDMS29,rtdms29)\
	| _PER_FMK(MCASP,RTDM,RTDMS28,rtdms28)\
	| _PER_FMK(MCASP,RTDM,RTDMS27,rtdms27)\
	| _PER_FMK(MCASP,RTDM,RTDMS26,rtdms26)\
	| _PER_FMK(MCASP,RTDM,RTDMS25,rtdms25)\
	| _PER_FMK(MCASP,RTDM,RTDMS24,rtdms24)\
	| _PER_FMK(MCASP,RTDM,RTDMS23,rtdms23)\
	| _PER_FMK(MCASP,RTDM,RTDMS22,rtdms22)\
	| _PER_FMK(MCASP,RTDM,RTDMS21,rtdms21)\
	| _PER_FMK(MCASP,RTDM,RTDMS20,rtdms20)\
	| _PER_FMK(MCASP,RTDM,RTDMS19,rtdms19)\
	| _PER_FMK(MCASP,RTDM,RTDMS18,rtdms18)\
	| _PER_FMK(MCASP,RTDM,RTDMS17,rtdms17)\
	| _PER_FMK(MCASP,RTDM,RTDMS16,rtdms16)\
	| _PER_FMK(MCASP,RTDM,RTDMS15,rtdms15)\
	| _PER_FMK(MCASP,RTDM,RTDMS14,rtdms14)\
	| _PER_FMK(MCASP,RTDM,RTDMS13,rtdms13)\
	| _PER_FMK(MCASP,RTDM,RTDMS12,rtdms12)\
	| _PER_FMK(MCASP,RTDM,RTDMS11,rtdms11)\
	| _PER_FMK(MCASP,RTDM,RTDMS10,rtdms10)\
	| _PER_FMK(MCASP,RTDM,RTDMS9,rtdms9)\
	| _PER_FMK(MCASP,RTDM,RTDMS8,rtdms8)\
	| _PER_FMK(MCASP,RTDM,RTDMS7,rtdms7)\
	| _PER_FMK(MCASP,RTDM,RTDMS6,rtdms6)\
	| _PER_FMK(MCASP,RTDM,RTDMS5,rtdms5)\
	| _PER_FMK(MCASP,RTDM,RTDMS4,rtdms4)\
	| _PER_FMK(MCASP,RTDM,RTDMS3,rtdms3)\
	| _PER_FMK(MCASP,RTDM,RTDMS2,rtdms2)\
	| _PER_FMK(MCASP,RTDM,RTDMS1,rtdms1)\
	| _PER_FMK(MCASP,RTDM,RTDMS0,rtdms0)\
  )


  #define _MCASP_RTDM_FGET(N,FIELD)\
    _PER_FGET(_MCASP_RTDM##N##_ADDR,MCASP,RTDM,##FIELD)

  #define _MCASP_RTDM_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_RTDM##N##_ADDR,MCASP,RTDM,##FIELD,field)

  #define _MCASP_RTDM_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_RTDM##N##_ADDR,MCASP,RTDM,##FIELD,##SYM)

  #define _MCASP_RTDM0_FGET(FIELD) _MCASP_RTDM_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RTDM1_FGET(FIELD) _MCASP_RTDM_FGET(1,##FIELD) 
#endif

  #define _MCASP_RTDM0_FSET(FIELD,f) _MCASP_RTDM_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RTDM1_FSET(FIELD,f) _MCASP_RTDM_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_RTDM0_FSETS(FIELD,SYM) _MCASP_RTDM_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RTDM1_FSETS(FIELD,SYM) _MCASP_RTDM_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     RINTCTL       |
* |___________________|
*
* RINTCTL  -  Receiver Interrupt Control Register
*
* FIELDS (msb -> lsb)
* (rw)  RSTAFRM  
* (rw)  RDATA  
* (rw)  RLAST  
* (rw)  RDMAERR  
* (rw)  RCKFAIL  
* (rw)  RSYNCERR  
* (rw)  ROVRN  
*
\******************************************************************************/

  #define _MCASP_RINTCTL_OFFSET               31

  #define _MCASP_RINTCTL0_ADDR			(_MCASP_BASE_PORT0+4*_MCASP_RINTCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RINTCTL1_ADDR			(_MCASP_BASE_PORT1+4*_MCASP_RINTCTL_OFFSET)
#endif

  #define _MCASP_RINTCTL_RSTAFRM_MASK           0x00000080u
  #define _MCASP_RINTCTL_RSTAFRM_SHIFT          0x00000007u
  #define  MCASP_RINTCTL_RSTAFRM_DEFAULT        0x00000000u
  #define  MCASP_RINTCTL_RSTAFRM_OF(x)          _VALUEOF(x)
  #define  MCASP_RINTCTL_RSTAFRM_DISABLE        0x00000000u
  #define  MCASP_RINTCTL_RSTAFRM_ENABLE         0x00000001u


  #define _MCASP_RINTCTL_RDATA_MASK              0x00000020u
  #define _MCASP_RINTCTL_RDATA_SHIFT             0x00000005u
  #define  MCASP_RINTCTL_RDATA_DEFAULT           0x00000000u
  #define  MCASP_RINTCTL_RDATA_OF(x)             _VALUEOF(x)
  #define  MCASP_RINTCTL_RDATA_DISABLE           0x00000000u
  #define  MCASP_RINTCTL_RDATA_ENABLE            0x00000001u


  #define _MCASP_RINTCTL_RLAST_MASK              0x00000010u
  #define _MCASP_RINTCTL_RLAST_SHIFT             0x00000004u
  #define  MCASP_RINTCTL_RLAST_DEFAULT           0x00000000u
  #define  MCASP_RINTCTL_RLAST_OF(x)             _VALUEOF(x)
  #define  MCASP_RINTCTL_RLAST_DISABLE           0x00000000u
  #define  MCASP_RINTCTL_RLAST_ENABLE            0x00000001u

  #define _MCASP_RINTCTL_RDMAERR_MASK            0x0000008u
  #define _MCASP_RINTCTL_RDMAERR_SHIFT           0x00000003u
  #define  MCASP_RINTCTL_RDMAERR_DEFAULT         0x00000000u
  #define  MCASP_RINTCTL_RDMAERR_OF(x)           _VALUEOF(x)
  #define  MCASP_RINTCTL_RDMAERR_DISABLE         0x00000000u
  #define  MCASP_RINTCTL_RDMAERR_ENABLE          0x00000001u

  #define _MCASP_RINTCTL_RCKFAIL_MASK            0x00000004u
  #define _MCASP_RINTCTL_RCKFAIL_SHIFT           0x00000002u
  #define  MCASP_RINTCTL_RCKFAIL_DEFAULT         0x00000000u
  #define  MCASP_RINTCTL_RCKFAIL_OF(x)           _VALUEOF(x)
  #define  MCASP_RINTCTL_RCKFAIL_DISABLE         0x00000000u
  #define  MCASP_RINTCTL_RCKFAIL_ENABLE          0x00000001u


  #define _MCASP_RINTCTL_RSYNCERR_MASK           0x00000002u
  #define _MCASP_RINTCTL_RSYNCERR_SHIFT          0x00000001u
  #define  MCASP_RINTCTL_RSYNCERR_DEFAULT        0x00000000u
  #define  MCASP_RINTCTL_RSYNCERR_OF(x)          _VALUEOF(x)
  #define  MCASP_RINTCTL_RSYNCERR_DISABLE        0x00000000u
  #define  MCASP_RINTCTL_RSYNCERR_ENABLE         0x00000001u


  #define _MCASP_RINTCTL_ROVRN_MASK              0x00000001u
  #define _MCASP_RINTCTL_ROVRN_SHIFT             0x00000000u
  #define  MCASP_RINTCTL_ROVRN_DEFAULT           0x00000000u
  #define  MCASP_RINTCTL_ROVRN_OF(x)             _VALUEOF(x)
  #define  MCASP_RINTCTL_ROVRN_DISABLE           0x00000000u
  #define  MCASP_RINTCTL_ROVRN_ENABLE            0x00000001u


  #define  MCASP_RINTCTL_OF(x)                  _VALUEOF(x)


  #define MCASP_RINTCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,RINTCTL,RSTAFRM)\
    |_PER_FDEFAULT(MCASP,RINTCTL,RDATA)\
    |_PER_FDEFAULT(MCASP,RINTCTL,RLAST)\
    |_PER_FDEFAULT(MCASP,RINTCTL,RDMAERR)\
    |_PER_FDEFAULT(MCASP,RINTCTL,RCKFAIL)\
    |_PER_FDEFAULT(MCASP,RINTCTL,RSYNCERR)\
    |_PER_FDEFAULT(MCASP,RINTCTL,ROVRN)\
  )


  #define MCASP_RINTCTL_RMK(rstafrm, rdata, rlast, rdmaerr, rckfail,rsyncerr, rovrn) (Uint32)( \
     _PER_FMK(MCASP,RINTCTL,RSTAFRM,rstafrm)\
    |_PER_FMK(MCASP,RINTCTL,RDATA,rdata)\
    |_PER_FMK(MCASP,RINTCTL,RLAST,rlast)\
    |_PER_FMK(MCASP,RINTCTL,RDMAERR,rdmaerr)\
    |_PER_FMK(MCASP,RINTCTL,RCKFAIL,rckfail)\
    |_PER_FMK(MCASP,RINTCTL,RSYNCERR,rsyncerr)\
    |_PER_FMK(MCASP,RINTCTL,ROVRN,rovrn)\
  )


  #define _MCASP_RINTCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_RINTCTL##N##_ADDR,MCASP,RINTCTL,##FIELD)

  #define _MCASP_RINTCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_RINTCTL##N##_ADDR,MCASP,RINTCTL,##FIELD,field)

  #define _MCASP_RINTCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_RINTCTL##N##_ADDR,MCASP,RINTCTL,##FIELD,##SYM)

  #define _MCASP_RINTCTL0_FGET(FIELD) _MCASP_RINTCTL_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RINTCTL1_FGET(FIELD) _MCASP_RINTCTL_FGET(1,##FIELD) 
#endif

  #define _MCASP_RINTCTL0_FSET(FIELD,f) _MCASP_RINTCTL_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RINTCTL1_FSET(FIELD,f) _MCASP_RINTCTL_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_RINTCTL0_FSETS(FIELD,SYM) _MCASP_RINTCTL_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RINTCTL1_FSETS(FIELD,SYM) _MCASP_RINTCTL_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |       RSTAT       |
* |___________________|
*
* RSTAT  -  Receiver Status Register
*
* FIELDS (msb -> lsb)
* (r)  RERR  
* (r)  RDMAERR  
* (r)  RSTAFRM  
* (r)  RDAT  
* (r)  RLAST 
* (r)  RTDMSLOT  
* (r)  RCKFAIL  
* (r)  RSYNCERR  
* (r)  ROVRN 
*
\******************************************************************************/

  #define _MCASP_RSTAT_OFFSET               32

  #define _MCASP_RSTAT0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_RSTAT_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RSTAT1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_RSTAT_OFFSET)
#endif

  #define _MCASP_RSTAT_RERR_MASK              0x00000100u
  #define _MCASP_RSTAT_RERR_SHIFT             0x00000008u
  #define  MCASP_RSTAT_RERR_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_RERR_OF(x)             _VALUEOF(x)

  #define _MCASP_RSTAT_RDMAERR_MASK              0x00000080u
  #define _MCASP_RSTAT_RDMAERR_SHIFT             0x00000007u
  #define  MCASP_RSTAT_RDMAERR_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_RDMAERR_OF(x)             _VALUEOF(x)

  #define _MCASP_RSTAT_RSTAFRM_MASK              0x00000040u
  #define _MCASP_RSTAT_RSTAFRM_SHIFT             0x00000006u
  #define  MCASP_RSTAT_RSTAFRM_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_RSTAFRM_OF(x)             _VALUEOF(x)
  #define  MCASP_RSTAT_RSTAFRM_0                 0x00000000u
  #define  MCASP_RSTAT_RSTAFRM_1                 0x00000001u
  #define  MCASP_RSTAT_RSTAFRM_NO                0x00000000u
  #define  MCASP_RSTAT_RSTAFRM_YES               0x00000001u


  #define _MCASP_RSTAT_RDATA_MASK              0x00000020u
  #define _MCASP_RSTAT_RDATA_SHIFT             0x00000005u
  #define  MCASP_RSTAT_RDATA_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_RDATA_OF(x)             _VALUEOF(x)
  #define  MCASP_RSTAT_RDATA_0                0x00000000u
  #define  MCASP_RSTAT_RDATA_1               0x00000001u
  #define  MCASP_RSTAT_RDATA_NO                0x00000000u
  #define  MCASP_RSTAT_RDATA_YES              0x00000001u


  #define _MCASP_RSTAT_RLAST_MASK              0x00000010u
  #define _MCASP_RSTAT_RLAST_SHIFT             0x00000004u
  #define  MCASP_RSTAT_RLAST_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_RLAST_OF(x)             _VALUEOF(x)
  #define  MCASP_RSTAT_RLAST_0                 0x00000000u
  #define  MCASP_RSTAT_RLAST_1                 0x00000001u
  #define  MCASP_RSTAT_RLAST_NO                0x00000000u
  #define  MCASP_RSTAT_RLAST_YES               0x00000001u

  #define _MCASP_RSTAT_RTDMSLOT_MASK              0x00000008u
  #define _MCASP_RSTAT_RTDMSLOT_SHIFT             0x00000003u
  #define  MCASP_RSTAT_RTDMSLOT_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_RTDMSLOT_OF(x)             _VALUEOF(x)


  #define _MCASP_RSTAT_RCKFAIL_MASK              0x00000004u
  #define _MCASP_RSTAT_RCKFAIL_SHIFT             0x00000002u
  #define  MCASP_RSTAT_RCKFAIL_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_RCKFAIL_OF(x)             _VALUEOF(x)
  #define  MCASP_RSTAT_RCKFAIL_0                 0x00000000u
  #define  MCASP_RSTAT_RCKFAIL_1                 0x00000001u
  #define  MCASP_RSTAT_RCKFAIL_NO                0x00000000u
  #define  MCASP_RSTAT_RCKFAIL_YES               0x00000001u


  #define _MCASP_RSTAT_RSYNCERR_MASK              0x00000002u
  #define _MCASP_RSTAT_RSYNCERR_SHIFT             0x00000001u
  #define  MCASP_RSTAT_RSYNCERR_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_RSYNCERR_OF(x)             _VALUEOF(x)
  #define  MCASP_RSTAT_RSYNCERR_0                 0x00000000u
  #define  MCASP_RSTAT_RSYNCERR_1                 0x00000001u
  #define  MCASP_RSTAT_RSYNCERR_NO                0x00000000u
  #define  MCASP_RSTAT_RSYNCERR_YES               0x00000001u

  #define _MCASP_RSTAT_ROVRN_MASK              0x00000001u
  #define _MCASP_RSTAT_ROVRN_SHIFT             0x00000000u
  #define  MCASP_RSTAT_ROVRN_DEFAULT           0x00000000u
  #define  MCASP_RSTAT_ROVRN_OF(x)             _VALUEOF(x)
  #define  MCASP_RSTAT_ROVRN_0                 0x00000000u 
  #define  MCASP_RSTAT_ROVRN_1                 0x00000001u 
  #define  MCASP_RSTAT_ROVRN_NO                0x00000000u 
  #define  MCASP_RSTAT_ROVRN_YES               0x00000001u 

  #define  MCASP_RSTAT_OF(x)                _VALUEOF(x)

  #define MCASP_RSTAT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,RSTAT,RERR)\
	| _PER_FDEFAULT(MCASP,RSTAT,RDMAERR)\
	| _PER_FDEFAULT(MCASP,RSTAT,RSTAFRM)\
	| _PER_FDEFAULT(MCASP,RSTAT,RDATA)\
	| _PER_FDEFAULT(MCASP,RSTAT,RLAST)\
	| _PER_FDEFAULT(MCASP,RSTAT,RTDMSLOT)\
	| _PER_FDEFAULT(MCASP,RSTAT,RCKFAIL)\
	| _PER_FDEFAULT(MCASP,RSTAT,RSYNCERR)\
	| _PER_FDEFAULT(MCASP,RSTAT,ROVRN)\
  )

  #define MCASP_RSTAT_RMK(rerr, rdmaerr, rstafrm, rdata, rlast, rtdmslot, rckfail, rsyncerr, rovrn) (Uint32)( \
     _PER_FMK(MCASP,RSTAT,RERR,rerr)\
	| _PER_FMK(MCASP,RSTAT,RDMAERR,rdmaerr)\
	| _PER_FMK(MCASP,RSTAT,RSTAFRM,rstafrm)\
	| _PER_FMK(MCASP,RSTAT,RDATA,rdata)\
	| _PER_FMK(MCASP,RSTAT,RLAST,rlast)\
	| _PER_FMK(MCASP,RSTAT,RTDMSLOT,rtdmslot)\
	| _PER_FMK(MCASP,RSTAT,RCKFAIL,rckfail)\
	| _PER_FMK(MCASP,RSTAT,RSYNCERR,rsyncerr)\
	| _PER_FMK(MCASP,RSTAT,ROVRN,rovrn)\
  )

  #define _MCASP_RSTAT_FGET(N,FIELD)\
    _PER_FGET(_MCASP_RSTAT##N##_ADDR,MCASP,RSTAT,##FIELD)

  #define _MCASP_RSTAT_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_RSTAT##N##_ADDR,MCASP,RSTAT,##FIELD,field)

  #define _MCASP_RSTAT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_RSTAT##N##_ADDR,MCASP,RSTAT,##FIELD,##SYM)

  #define _MCASP_RSTAT0_FGET(FIELD) _MCASP_RSTAT_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RSTAT1_FGET(FIELD) _MCASP_RSTAT_FGET(1,##FIELD) 
#endif

  #define _MCASP_RSTAT0_FSET(FIELD,f) _MCASP_RSTAT_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RSTAT1_FSET(FIELD,f) _MCASP_RSTAT_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_RSTAT0_FSETS(FIELD,SYM) _MCASP_RSTAT_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RSTAT1_FSETS(FIELD,SYM) _MCASP_RSTAT_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     RSLOT         |
* |___________________|
*
* RSLOT0    -  Receiver TDM Slot Counter MCASP0
* RSLOT1    -  Receiver TDM Slot Counter MCASP1
*
* FIELDS (msb -> lsb)
* (r )  RSLOTCNT  
*
\******************************************************************************/

  #define _MCASP_RSLOT_OFFSET               33

  #define _MCASP_RSLOT0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_RSLOT_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RSLOT1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_RSLOT_OFFSET)
#endif


  #define _MCASP_RSLOT_RSLOTCNT_MASK              0x000003FFu
  #define _MCASP_RSLOT_RSLOTCNT_SHIFT             0x00000000u
  #define  MCASP_RSLOT_RSLOTCNT_DEFAULT           0x00000000u
  #define  MCASP_RSLOT_RSLOTCNT_OF(x)             _VALUEOF(x)

  #define  MCASP_RSLOT_OF(x)                _VALUEOF(x)

  #define MCASP_RSLOT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,RSLOT,RSLOTCNT)\
  )

  #define MCASP_RSLOT_RMK(rslotcnt) (Uint32)( \
     _PER_FMK(MCASP,RSLOT,RSLOTCNT,rslotcnt)\
  )


  #define _MCASP_RSLOT_FGET(N,FIELD)\
    _PER_FGET(_MCASP_RSLOT##N##_ADDR,MCASP,RSLOT,##FIELD)

  #define _MCASP_RSLOT_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_RSLOT##N##_ADDR,MCASP,RSLOT,##FIELD,field)

  #define _MCASP_RSLOT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_RSLOT##N##_ADDR,MCASP,RSLOT,##FIELD,##SYM)

  #define _MCASP_RSLOT0_FGET(FIELD) _MCASP_RSLOT_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RSLOT1_FGET(FIELD) _MCASP_RSLOT_FGET(1,##FIELD) 
#endif

  #define _MCASP_RSLOT0_FSET(FIELD,f) _MCASP_RSLOT_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RSLOT1_FSET(FIELD,f) _MCASP_RSLOT_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_RSLOT0_FSETS(FIELD,SYM) _MCASP_RSLOT_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RSLOT1_FSETS(FIELD,SYM) _MCASP_RSLOT_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     RCLKCHK       |
* |___________________|
*
* RCLKCHK  -  Receiver Clock Check Control Register 
*
* FIELDS (msb -> lsb)
* (r )  RCNT  
* (rw)  RMAX  
* (rw)  RMIN  
* (rw)  RPS  
\******************************************************************************/

  #define _MCASP_RCLKCHK_OFFSET               34

  #define _MCASP_RCLKCHK0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_RCLKCHK_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RCLKCHK1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_RCLKCHK_OFFSET)
#endif

  #define _MCASP_RCLKCHK_RCNT_MASK              0xFF000000u
  #define _MCASP_RCLKCHK_RCNT_SHIFT             0x00000018u
  #define  MCASP_RCLKCHK_RCNT_DEFAULT           0x00000000u 
  #define  MCASP_RCLKCHK_RCNT_OF(x)             _VALUEOF(x)


  #define _MCASP_RCLKCHK_RMAX_MASK              0x00FF0000u
  #define _MCASP_RCLKCHK_RMAX_SHIFT             0x00000010u
  #define  MCASP_RCLKCHK_RMAX_DEFAULT           0x00000000u 
  #define  MCASP_RCLKCHK_RMAX_OF(x)             _VALUEOF(x)


  #define _MCASP_RCLKCHK_RMIN_MASK              0x0000FF00u
  #define _MCASP_RCLKCHK_RMIN_SHIFT             0x00000008u
  #define  MCASP_RCLKCHK_RMIN_DEFAULT           0x00000000u 
  #define  MCASP_RCLKCHK_RMIN_OF(x)             _VALUEOF(x)


  #define _MCASP_RCLKCHK_RPS_MASK              0x0000000Fu
  #define _MCASP_RCLKCHK_RPS_SHIFT             0x00000000u
  #define  MCASP_RCLKCHK_RPS_DEFAULT           0x00000000u 
  #define  MCASP_RCLKCHK_RPS_OF(x)             _VALUEOF(x)
  #define  MCASP_RCLKCHK_RPS_DIVBY1            0x00000000u
  #define  MCASP_RCLKCHK_RPS_DIVBY2            0x00000001u
  #define  MCASP_RCLKCHK_RPS_DIVBY4            0x00000002u
  #define  MCASP_RCLKCHK_RPS_DIVBY8            0x00000003u 
  #define  MCASP_RCLKCHK_RPS_DIVBY16           0x00000004u 
  #define  MCASP_RCLKCHK_RPS_DIVBY32           0x00000005u 
  #define  MCASP_RCLKCHK_RPS_DIVBY64           0x00000006u 
  #define  MCASP_RCLKCHK_RPS_DIVBY128          0x00000007u 
  #define  MCASP_RCLKCHK_RPS_DIVBY256          0x00000008u 


  #define  MCASP_RCLKCHK_OF(x)                _VALUEOF(x)

  #define MCASP_RCLKCHK_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,RCLKCHK,RCNT)\
	| _PER_FDEFAULT(MCASP,RCLKCHK,RMAX)\
	| _PER_FDEFAULT(MCASP,RCLKCHK,RMIN)\
	| _PER_FDEFAULT(MCASP,RCLKCHK,RPS)\
  )

  #define MCASP_RCLKCHK_RMK(rcnt, rmax, rmin, rps) (Uint32)( \
     _PER_FMK(MCASP,RCLKCHK,RCNT,rcnt)\
	| _PER_FMK(MCASP,RCLKCHK,RMAX,rmax)\
	| _PER_FMK(MCASP,RCLKCHK,RMIN,rmin)\
	| _PER_FMK(MCASP,RCLKCHK,RPS,rps)\
  )

  #define _MCASP_RCLKCHK_FGET(N,FIELD)\
    _PER_FGET(_MCASP_RCLKCHK##N##_ADDR,MCASP,RCLKCHK,##FIELD)

  #define _MCASP_RCLKCHK_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_RCLKCHK##N##_ADDR,MCASP,RCLKCHK,##FIELD,field)

  #define _MCASP_RCLKCHK_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_RCLKCHK##N##_ADDR,MCASP,RCLKCHK,##FIELD,##SYM)

  #define _MCASP_RCLKCHK0_FGET(FIELD) _MCASP_RCLKCHK_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RCLKCHK1_FGET(FIELD) _MCASP_RCLKCHK_FGET(1,##FIELD) 
#endif

  #define _MCASP_RCLKCHK0_FSET(FIELD,f) _MCASP_RCLKCHK_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RCLKCHK1_FSET(FIELD,f) _MCASP_RCLKCHK_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_RCLKCHK0_FSETS(FIELD,SYM) _MCASP_RCLKCHK_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RCLKCHK1_FSETS(FIELD,SYM) _MCASP_RCLKCHK_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     XGBLCTL       |
* |___________________|
*
* XGBLCTL  -  Global Control Register
*
* FIELDS (msb -> lsb)
* (rw)  XFRST
* (rw)  XSMRST
* (rw)  XSRCLR
* (rw)  XHCLKRST
* (rw)  XCLKRST
* (rw)  RFRST
* (rw)  RSMRST
* (rw)  RSRCLR
* (rw)  RHCLKRST
* (rw)  RCLKRST
*
\******************************************************************************/

  #define _MCASP_XGBLCTL_OFFSET             40

  #define _MCASP_XGBLCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_XGBLCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XGBLCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_XGBLCTL_OFFSET)
#endif

  #define _MCASP_XGBLCTL_XFRST_MASK              0x00001000u
  #define _MCASP_XGBLCTL_XFRST_SHIFT             0x0000000Cu
  #define  MCASP_XGBLCTL_XFRST_DEFAULT           0x00000000u
  #define  MCASP_XGBLCTL_XFRST_OF(x)             _VALUEOF(x)
  #define  MCASP_XGBLCTL_XFRST_RESET             0x00000000u
  #define  MCASP_XGBLCTL_XFRST_ACTIVE            0x00000001u

  #define _MCASP_XGBLCTL_XSMRST_MASK              0x00000800u
  #define _MCASP_XGBLCTL_XSMRST_SHIFT             0x0000000Bu
  #define  MCASP_XGBLCTL_XSMRST_DEFAULT           0x00000000u
  #define  MCASP_XGBLCTL_XSMRST_OF(x)            _VALUEOF(x)
  #define  MCASP_XGBLCTL_XSMRST_RESET		0x00000000u
  #define  MCASP_XGBLCTL_XSMRST_ACTIVE		0x00000001u

  #define _MCASP_XGBLCTL_XSRCLR_MASK              0x00000400u
  #define _MCASP_XGBLCTL_XSRCLR_SHIFT             0x0000000Au
  #define  MCASP_XGBLCTL_XSRCLR_DEFAULT           0x00000000u
  #define  MCASP_XGBLCTL_XSRCLR_OF(x)             _VALUEOF(x)
  #define  MCASP_XGBLCTL_XSRCLR_CLEAR           0x00000000u
  #define  MCASP_XGBLCTL_XSRCLR_ACTIVE            0x00000001u

  #define _MCASP_XGBLCTL_XHCLKRST_MASK              0x00000200u
  #define _MCASP_XGBLCTL_XHCLKRST_SHIFT             0x00000009u
  #define  MCASP_XGBLCTL_XHCLKRST_DEFAULT           0x00000000u
  #define  MCASP_XGBLCTL_XHCLKRST_OF(x)             _VALUEOF(x)
  #define  MCASP_XGBLCTL_XHCLKRST_RESET				0x00000000u
  #define  MCASP_XGBLCTL_XHCLKRST_ACTIVE			0x00000001u

  #define _MCASP_XGBLCTL_XCLKRST_MASK              0x00000100u
  #define _MCASP_XGBLCTL_XCLKRST_SHIFT             0x00000008u
  #define  MCASP_XGBLCTL_XCLKRST_DEFAULT           0x00000000u
  #define  MCASP_XGBLCTL_XCLKRST_OF(x)             _VALUEOF(x)
  #define  MCASP_XGBLCTL_XCLKRST_RESET			0x00000000u
  #define  MCASP_XGBLCTL_XCLKRST_ACTIVE			0x00000001u

  #define _MCASP_XGBLCTL_RFRST_MASK           0x00000010u
  #define _MCASP_XGBLCTL_RFRST_SHIFT          0x00000004u
  #define  MCASP_XGBLCTL_RFRST_DEFAULT        0x00000000u
  #define  MCASP_XGBLCTL_RFRST_OF(x)          _VALUEOF(x)
  #define  MCASP_XGBLCTL_RFRST_RESET          0x00000000u
  #define  MCASP_XGBLCTL_RFRST_ACTIVE         0x00000001u

  #define _MCASP_XGBLCTL_RSMRST_MASK          0x00000008u
  #define _MCASP_XGBLCTL_RSMRST_SHIFT         0x00000003u
  #define  MCASP_XGBLCTL_RSMRST_DEFAULT       0x00000000u
  #define  MCASP_XGBLCTL_RSMRST_OF(x)         _VALUEOF(x)
  #define  MCASP_XGBLCTL_RSMRST_RESET	      0x00000000u
  #define  MCASP_XGBLCTL_RSMRST_ACTIVE	      0x00000001u

  #define _MCASP_XGBLCTL_RSRCLR_MASK          0x00000004u
  #define _MCASP_XGBLCTL_RSRCLR_SHIFT         0x00000002u
  #define  MCASP_XGBLCTL_RSRCLR_DEFAULT       0x00000000u
  #define  MCASP_XGBLCTL_RSRCLR_OF(x)         _VALUEOF(x)
  #define  MCASP_XGBLCTL_RSRCLR_CLEAR         0x00000000u
  #define  MCASP_XGBLCTL_RSRCLR_ACTIVE        0x00000001u

  #define _MCASP_XGBLCTL_RHCLKRST_MASK        0x00000002u
  #define _MCASP_XGBLCTL_RHCLKRST_SHIFT       0x00000001u
  #define  MCASP_XGBLCTL_RHCLKRST_DEFAULT     0x00000000u
  #define  MCASP_XGBLCTL_RHCLKRST_OF(x)       _VALUEOF(x)
  #define  MCASP_XGBLCTL_RHCLKRST_RESET	      0x00000000u
  #define  MCASP_XGBLCTL_RHCLKRST_ACTIVE      0x00000001u

  #define _MCASP_XGBLCTL_RCLKRST_MASK         0x00000001u
  #define _MCASP_XGBLCTL_RCLKRST_SHIFT        0x00000000u
  #define  MCASP_XGBLCTL_RCLKRST_DEFAULT      0x00000000u
  #define  MCASP_XGBLCTL_RCLKRST_OF(x)        _VALUEOF(x)
  #define  MCASP_XGBLCTL_RCLKRST_RESET	      0x00000000u
  #define  MCASP_XGBLCTL_RCLKRST_ACTIVE	      0x00000001u

  #define  MCASP_XGBLCTL_OF(x)                _VALUEOF(x)

  #define MCASP_XGBLCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,XGBLCTL,XFRST)\
    |_PER_FDEFAULT(MCASP,XGBLCTL,XSMRST)\
    |_PER_FDEFAULT(MCASP,XGBLCTL,XSRCLR)\
    |_PER_FDEFAULT(MCASP,XGBLCTL,xXHCLKRST)\
    |_PER_FDEFAULT(MCASP,XGBLCTL,XCLKRST)\
  )


  #define MCASP_XGBLCTL_RMK(xfrst, xsmrst, xsrclr, xhclkrst, xclkrst) (Uint32)( \
     _PER_FMK(MCASP,XGBLCTL,XFRST,xfrst)\
    |_PER_FMK(MCASP,XGBLCTL,XSMRST,xsmrst)\
    |_PER_FMK(MCASP,XGBLCTL,XSRCLR,xsrclr)\
    |_PER_FMK(MCASP,XGBLCTL,XHCLKRST,xhclkrst)\
    |_PER_FMK(MCASP,XGBLCTL,XCLKRST,xclkrst)\
  )


  #define _MCASP_XGBLCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_XGBLCTL##N##_ADDR,MCASP,XGBLCTL,##FIELD)

  #define _MCASP_XGBLCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_XGBLCTL##N##_ADDR,MCASP,XGBLCTL,##FIELD,field)

  #define _MCASP_XGBLCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_XGBLCTL##N##_ADDR,MCASP,XGBLCTL,##FIELD,##SYM)

  #define _MCASP_XGBLCTL0_FGET(FIELD) _MCASP_XGBLCTL_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XGBLCTL1_FGET(FIELD) _MCASP_XGBLCTL_FGET(1,##FIELD)  
#endif

  #define _MCASP_XGBLCTL0_FSET(FIELD,f) _MCASP_XGBLCTL_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XGBLCTL1_FSET(FIELD,f) _MCASP_XGBLCTL_FSET(1,##FIELD,f)  
#endif

  #define _MCASP_XGBLCTL0_FSETS(FIELD,SYM) _MCASP_XGBLCTL_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XGBLCTL1_FSETS(FIELD,SYM) _MCASP_XGBLCTL_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     XMASK         |
* |___________________|
*
* XMASK		- Pin Data Output Register
*
* FIELDS (msb -> lsb)
* (rw)  XMASKn n:0 to 31  
*
\******************************************************************************/

  #define _MCASP_XMASK_OFFSET               41

  #define _MCASP_XMASK0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_XMASK_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XMASK1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_XMASK_OFFSET)
#endif

  #define _MCASP_XMASK_XMASK0_MASK        	0x00000001u
  #define _MCASP_XMASK_XMASK0_SHIFT       	0x00000000u
  #define  MCASP_XMASK_XMASK0_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK0_OF(x)   	    _VALUEOF(x)
  #define  MCASP_XMASK_XMASK0_USEMASK	    0x00000000u
  #define  MCASP_XMASK_XMASK0_NOMASK        0x00000001u

  #define _MCASP_XMASK_XMASK1_MASK        	0x00000002u
  #define _MCASP_XMASK_XMASK1_SHIFT       	0x00000001u
  #define  MCASP_XMASK_XMASK1_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK1_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK1_USEMASK	        	0x00000000u
  #define  MCASP_XMASK_XMASK1_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK2_MASK        	0x00000004u
  #define _MCASP_XMASK_XMASK2_SHIFT       	0x00000002u
  #define  MCASP_XMASK_XMASK2_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK2_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK2_USEMASK	        	0x00000000u
  #define  MCASP_XMASK_XMASK2_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK3_MASK        	0x00000008u
  #define _MCASP_XMASK_XMASK3_SHIFT       	0x00000003u
  #define  MCASP_XMASK_XMASK3_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK3_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK3_USEMASK	        	0x00000000u
  #define  MCASP_XMASK_XMASK3_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK4_MASK        	0x00000010u
  #define _MCASP_XMASK_XMASK4_SHIFT       	0x00000004u
  #define  MCASP_XMASK_XMASK4_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK4_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK4_USEMASK	       	0x00000000u
  #define  MCASP_XMASK_XMASK4_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK5_MASK        	0x00000020u
  #define _MCASP_XMASK_XMASK5_SHIFT       	0x00000005u
  #define  MCASP_XMASK_XMASK5_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK5_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK5_USEMASK	       	0x00000000u
  #define  MCASP_XMASK_XMASK5_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK6_MASK        	0x00000040u
  #define _MCASP_XMASK_XMASK6_SHIFT       	0x00000006u
  #define  MCASP_XMASK_XMASK6_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK6_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK6_USEMASK	       	0x00000000u
  #define  MCASP_XMASK_XMASK6_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK7_MASK        	0x00000080u
  #define _MCASP_XMASK_XMASK7_SHIFT       	0x00000007u
  #define  MCASP_XMASK_XMASK7_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK7_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK7_USEMASK	       	0x00000000u
  #define  MCASP_XMASK_XMASK7_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK8_MASK        	0x00000100u
  #define _MCASP_XMASK_XMASK8_SHIFT       	0x00000008u
  #define  MCASP_XMASK_XMASK8_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK8_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK8_USEMASK	       	0x00000000u
  #define  MCASP_XMASK_XMASK8_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK9_MASK        	0x00000200u
  #define _MCASP_XMASK_XMASK9_SHIFT       	0x00000009u
  #define  MCASP_XMASK_XMASK9_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK9_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK9_USEMASK	       	0x00000000u
  #define  MCASP_XMASK_XMASK9_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK10_MASK        	0x00000400u
  #define _MCASP_XMASK_XMASK10_SHIFT       	0x0000000Au
  #define  MCASP_XMASK_XMASK10_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK10_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK10_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK10_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK11_MASK        	0x00000800u
  #define _MCASP_XMASK_XMASK11_SHIFT       	0x0000000Bu
  #define  MCASP_XMASK_XMASK11_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK11_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK11_USEMASK	       	0x00000000u
  #define  MCASP_XMASK_XMASK11_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK12_MASK        	0x00001000u
  #define _MCASP_XMASK_XMASK12_SHIFT       	0x0000000Cu
  #define  MCASP_XMASK_XMASK12_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK12_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK12_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK12_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK13_MASK        	0x00002000u
  #define _MCASP_XMASK_XMASK13_SHIFT       	0x0000000Du
  #define  MCASP_XMASK_XMASK13_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK13_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK13_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK13_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK14_MASK        	0x00004000u
  #define _MCASP_XMASK_XMASK14_SHIFT       	0x0000000Eu
  #define  MCASP_XMASK_XMASK14_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK14_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK14_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK14_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK15_MASK        	0x00008000u
  #define _MCASP_XMASK_XMASK15_SHIFT       	0x0000000Fu
  #define  MCASP_XMASK_XMASK15_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK15_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK15_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK15_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK16_MASK        	0x00010000u
  #define _MCASP_XMASK_XMASK16_SHIFT       	0x00000010u
  #define  MCASP_XMASK_XMASK16_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK16_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK16_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK16_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK17_MASK        	0x00020000u
  #define _MCASP_XMASK_XMASK17_SHIFT       	0x00000011u
  #define  MCASP_XMASK_XMASK17_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK17_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK17_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK17_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK18_MASK        	0x00040000u
  #define _MCASP_XMASK_XMASK18_SHIFT       	0x00000012u
  #define  MCASP_XMASK_XMASK18_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK18_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK18_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK18_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK19_MASK        	0x00080000u
  #define _MCASP_XMASK_XMASK19_SHIFT       	0x00000013u
  #define  MCASP_XMASK_XMASK19_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK19_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK19_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK19_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK20_MASK        	0x00100000u
  #define _MCASP_XMASK_XMASK20_SHIFT       	0x00000014u
  #define  MCASP_XMASK_XMASK20_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK20_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK20_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK20_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK21_MASK        	0x00200000u
  #define _MCASP_XMASK_XMASK21_SHIFT       	0x00000015u
  #define  MCASP_XMASK_XMASK21_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK21_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK21_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK21_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK22_MASK        	0x00400000u
  #define _MCASP_XMASK_XMASK22_SHIFT       	0x00000016u
  #define  MCASP_XMASK_XMASK22_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK22_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK22_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK22_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK23_MASK        	0x00800000u
  #define _MCASP_XMASK_XMASK23_SHIFT       	0x00000017u
  #define  MCASP_XMASK_XMASK23_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK23_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK23_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK23_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK24_MASK        	0x01000000u
  #define _MCASP_XMASK_XMASK24_SHIFT       	0x00000018u
  #define  MCASP_XMASK_XMASK24_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK24_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK24_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK24_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK25_MASK        	0x02000000u
  #define _MCASP_XMASK_XMASK25_SHIFT       	0x00000019u
  #define  MCASP_XMASK_XMASK25_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK25_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK25_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK25_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK26_MASK        	0x04000000u
  #define _MCASP_XMASK_XMASK26_SHIFT       	0x0000001Au
  #define  MCASP_XMASK_XMASK26_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK26_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK26_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK26_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK27_MASK        	0x08000000u
  #define _MCASP_XMASK_XMASK27_SHIFT       	0x0000001Bu
  #define  MCASP_XMASK_XMASK27_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK27_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK27_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK27_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK28_MASK        	0x10000000u
  #define _MCASP_XMASK_XMASK28_SHIFT       	0x0000001Cu
  #define  MCASP_XMASK_XMASK28_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK28_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK28_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK28_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK29_MASK        	0x20000000u
  #define _MCASP_XMASK_XMASK29_SHIFT       	0x0000001Du
  #define  MCASP_XMASK_XMASK29_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK29_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK29_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK29_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK30_MASK        	0x40000000u
  #define _MCASP_XMASK_XMASK30_SHIFT       	0x0000001Eu
  #define  MCASP_XMASK_XMASK30_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK30_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK30_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK30_NOMASK            	0x00000001u

  #define _MCASP_XMASK_XMASK31_MASK        	0x80000000u
  #define _MCASP_XMASK_XMASK31_SHIFT       	0x0000001Fu
  #define  MCASP_XMASK_XMASK31_DEFAULT     	0x00000000u
  #define  MCASP_XMASK_XMASK31_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XMASK_XMASK31_USEMASK        	0x00000000u
  #define  MCASP_XMASK_XMASK31_NOMASK            	0x00000001u

  #define  MCASP_XMASK_OF(x)                	_VALUEOF(x)

  #define MCASP_XMASK_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,XMASK,XMASK0)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK1)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK2)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK3)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK4)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK5)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK6)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK7)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK8)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK9)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK10)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK11)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK12)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK13)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK14)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK15)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK16)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK17)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK18)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK19)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK20)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK21)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK22)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK23)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK24)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK25)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK26)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK27)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK28)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK29)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK30)\
    |_PER_FDEFAULT(MCASP,XMASK,XMASK31)\
  )

  #define MCASP_XMASK_RMK(xmask31, xmask30,xmask29,xmask28,xmask27,xmask26,xmask25,\
    xmask24,xmask23,xmask22,xmask21,xmask20,xmask19,xmask18,xmask17,\
   xmask16,xmask15,xmask14,xmask13,xmask12,xmask11,xmask10,xmask9,\
   xmask8, xmask7, xmask6,  xmask5,xmask4, xmask3, xmask2, xmask1, xmask0 ) \
 (Uint32)( \
     _PER_FMK(MCASP,XMASK,XMASK0,xmask0)\
    |_PER_FMK(MCASP,XMASK,XMASK1,xmask1)\
    |_PER_FMK(MCASP,XMASK,XMASK2,xmask2)\
    |_PER_FMK(MCASP,XMASK,XMASK3,xmask3)\
    |_PER_FMK(MCASP,XMASK,XMASK4,xmask4)\
    |_PER_FMK(MCASP,XMASK,XMASK5,xmask5)\
    |_PER_FMK(MCASP,XMASK,XMASK6,xmask6)\
    |_PER_FMK(MCASP,XMASK,XMASK7,xmask7)\
    |_PER_FMK(MCASP,XMASK,XMASK8,xmask8)\
    |_PER_FMK(MCASP,XMASK,XMASK9,xmask9)\
    |_PER_FMK(MCASP,XMASK,XMASK10,xmask10)\
    |_PER_FMK(MCASP,XMASK,XMASK11,xmask11)\
    |_PER_FMK(MCASP,XMASK,XMASK12,xmask12)\
    |_PER_FMK(MCASP,XMASK,XMASK13,xmask13)\
    |_PER_FMK(MCASP,XMASK,XMASK14,xmask14)\
    |_PER_FMK(MCASP,XMASK,XMASK15,xmask15)\
    |_PER_FMK(MCASP,XMASK,XMASK16,xmask16)\
    |_PER_FMK(MCASP,XMASK,XMASK17,xmask17)\
    |_PER_FMK(MCASP,XMASK,XMASK18,xmask18)\
    |_PER_FMK(MCASP,XMASK,XMASK19,xmask19)\
    |_PER_FMK(MCASP,XMASK,XMASK20,xmask20)\
    |_PER_FMK(MCASP,XMASK,XMASK21,xmask21)\
    |_PER_FMK(MCASP,XMASK,XMASK22,xmask22)\
    |_PER_FMK(MCASP,XMASK,XMASK23,xmask23)\
    |_PER_FMK(MCASP,XMASK,XMASK24,xmask24)\
    |_PER_FMK(MCASP,XMASK,XMASK25,xmask25)\
    |_PER_FMK(MCASP,XMASK,XMASK26,xmask26)\
    |_PER_FMK(MCASP,XMASK,XMASK27,xmask27)\
    |_PER_FMK(MCASP,XMASK,XMASK28,xmask28)\
    |_PER_FMK(MCASP,XMASK,XMASK29,xmask29)\
    |_PER_FMK(MCASP,XMASK,XMASK30,xmask30)\
    |_PER_FMK(MCASP,XMASK,XMASK31,xmask31)\
  )

  #define _MCASP_XMASK_FGET(N,FIELD)\
    _PER_FGET(_MCASP_XMASK##N##_ADDR,MCASP,XMASK,##FIELD)

  #define _MCASP_XMASK_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_XMASK##N##_ADDR,MCASP,XMASK,##FIELD,field)

  #define _MCASP_XMASK_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_XMASK##N##_ADDR,MCASP,XMASK,##FIELD,##SYM)

  #define _MCASP_XMASK0_FGET(FIELD) _MCASP_XMASK_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XMASK1_FGET(FIELD) _MCASP_XMASK_FGET(1,##FIELD) 
#endif

  #define _MCASP_XMASK0_FSET(FIELD,f) _MCASP_XMASK_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XMASK1_FSET(FIELD,f) _MCASP_XMASK_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_XMASK0_FSETS(FIELD,SYM) _MCASP_XMASK_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XMASK1_FSETS(FIELD,SYM) _MCASP_XMASK_FSETS(1,##FIELD,##SYM) 
#endif

 
/******************************************************************************\
* 
* _____________________
* |                   |
* |     XFMT          |
* |___________________|
*
* XFMT		- Transmit Bitstream Format Register
*
* FIELDS (msb -> lsb)
* (rw)  XDATDLY
* (rw)  XRVRS  
* (rw)  XPAD
* (rw)  XPBIT  
* (rw)  XSSZ
* (rw)  XBUSEL
* (rw)  XROT  
*
\******************************************************************************/

  #define _MCASP_XFMT_OFFSET               42

  #define _MCASP_XFMT0_ADDR					(_MCASP_BASE_PORT0+4*_MCASP_XFMT_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XFMT1_ADDR					(_MCASP_BASE_PORT1+4*_MCASP_XFMT_OFFSET)
#endif

  #define _MCASP_XFMT_XDATDLY_MASK              0x00030000u
  #define _MCASP_XFMT_XDATDLY_SHIFT             0x00000010u
  #define  MCASP_XFMT_XDATDLY_DEFAULT           0x00000000u
  #define  MCASP_XFMT_XDATDLY_OF(x)             _VALUEOF(x)
  #define  MCASP_XFMT_XDATDLY_0BIT              0x00000000u
  #define  MCASP_XFMT_XDATDLY_1BIT              0x00000001u
  #define  MCASP_XFMT_XDATDLY_2BIT              0x00000002u


  #define _MCASP_XFMT_XRVRS_MASK                0x00008000u
  #define _MCASP_XFMT_XRVRS_SHIFT       	      0x0000000Fu
  #define  MCASP_XFMT_XRVRS_DEFAULT     	      0x00000000u
  #define  MCASP_XFMT_XRVRS_OF(x)   	        _VALUEOF(x)
  #define  MCASP_XFMT_XRVRS_LSBFIRST            0x00000000u
  #define  MCASP_XFMT_XRVRS_MSBFIRST            0x00000001u

  #define _MCASP_XFMT_XPAD_MASK     		0x00006000u
  #define _MCASP_XFMT_XPAD_SHIFT          	0x0000000Du
  #define  MCASP_XFMT_XPAD_DEFAULT        	0x00000000u
  #define  MCASP_XFMT_XPAD_OF(x)          	_VALUEOF(x)
  #define  MCASP_XFMT_XPAD_ZERO            	0x00000000u
  #define  MCASP_XFMT_XPAD_ONE            	0x00000001u
  #define  MCASP_XFMT_XPAD_XPBIT          	0x00000002u

  #define _MCASP_XFMT_XPBIT_MASK           	0x00001F00u
  #define _MCASP_XFMT_XPBIT_SHIFT          	0x00000008u
  #define  MCASP_XFMT_XPBIT_DEFAULT        	0x00000000u
  #define  MCASP_XFMT_XPBIT_OF(x)          	_VALUEOF(x)

  #define _MCASP_XFMT_XSSZ_MASK           	0x000000F0u
  #define _MCASP_XFMT_XSSZ_SHIFT          	0x00000004u
  #define  MCASP_XFMT_XSSZ_DEFAULT        	0x00000000u
  #define  MCASP_XFMT_XSSZ_OF(x)          	_VALUEOF(x)
  #define  MCASP_XFMT_XSSZ_8BITS            	0x00000003u
  #define  MCASP_XFMT_XSSZ_12BITS            	0x00000005u
  #define  MCASP_XFMT_XSSZ_16BITS            	0x00000007u
  #define  MCASP_XFMT_XSSZ_20BITS            	0x00000009u
  #define  MCASP_XFMT_XSSZ_24BITS            	0x0000000Bu
  #define  MCASP_XFMT_XSSZ_28BITS            	0x0000000Du
  #define  MCASP_XFMT_XSSZ_32BITS            	0x0000000Fu

  #define _MCASP_XFMT_XBUSEL_MASK           	0x00000008u
  #define _MCASP_XFMT_XBUSEL_SHIFT          	0x00000003u
  #define  MCASP_XFMT_XBUSEL_DEFAULT        	0x00000000u
  #define  MCASP_XFMT_XBUSEL_OF(x)         	_VALUEOF(x)
  #define  MCASP_XFMT_XBUSEL_DAT            	0x00000000u
  #define  MCASP_XFMT_XBUSEL_CFG            	0x00000001u

  #define _MCASP_XFMT_XROT_MASK           	0x00000007u
  #define _MCASP_XFMT_XROT_SHIFT          	0x00000000u
  #define  MCASP_XFMT_XROT_DEFAULT        	0x00000000u
  #define  MCASP_XFMT_XROT_OF(x)                _VALUEOF(x)
  #define  MCASP_XFMT_XROT_NONE            	0x00000000u
  #define  MCASP_XFMT_XROT_4BITS            	0x00000001u
  #define  MCASP_XFMT_XROT_8BITS            	0x00000002u
  #define  MCASP_XFMT_XROT_12BITS            	0x00000003u
  #define  MCASP_XFMT_XROT_16BITS            	0x00000004u
  #define  MCASP_XFMT_XROT_20BITS            	0x00000005u
  #define  MCASP_XFMT_XROT_24BITS            	0x00000006u
  #define  MCASP_XFMT_XROT_28BITS            	0x00000007u

  #define  MCASP_XFMT_OF(x)                	_VALUEOF(x)

  #define MCASP_XFMT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,XFMT,XDATDLY)\
    |_PER_FDEFAULT(MCASP,XFMT,XRVRS)\
    |_PER_FDEFAULT(MCASP,XFMT,XPAD)\
    |_PER_FDEFAULT(MCASP,XFMT,XPBIT)\
    |_PER_FDEFAULT(MCASP,XFMT,XSSZ)\
    |_PER_FDEFAULT(MCASP,XFMT,XBUSEL)\
    |_PER_FDEFAULT(MCASP,XFMT,XROT)\
  )

  #define MCASP_XFMT_RMK(xdatdly,xrvrs,xpad,xpbit,xssz,xbusel,xrot) (Uint32)( \
     _PER_FMK(MCASP,XFMT,XDATDLY,xdatdly)\
    |_PER_FMK(MCASP,XFMT,XRVRS,xrvrs)\
    |_PER_FMK(MCASP,XFMT,XPAD,xpad)\
    |_PER_FMK(MCASP,XFMT,XPBIT,xpbit)\
    |_PER_FMK(MCASP,XFMT,XSSZ,xssz)\
    |_PER_FMK(MCASP,XFMT,XBUSEL,xbusel)\
    |_PER_FMK(MCASP,XFMT,XROT,xrot)\
  )

  #define _MCASP_XFMT_FGET(N,FIELD)\
    _PER_FGET(_MCASP_XFMT##N##_ADDR,MCASP,XFMT,##FIELD)

  #define _MCASP_XFMT_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_XFMT##N##_ADDR,MCASP,XFMT,##FIELD,field)

  #define _MCASP_XFMT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_XFMT##N##_ADDR,MCASP,XFMT,##FIELD,##SYM)

  #define _MCASP_XFMT0_FGET(FIELD) _MCASP_XFMT_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XFMT1_FGET(FIELD) _MCASP_XFMT_FGET(1,##FIELD) 
#endif

  #define _MCASP_XFMT0_FSET(FIELD,f) _MCASP_XFMT_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XFMT1_FSET(FIELD,f) _MCASP_XFMT_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_XFMT0_FSETS(FIELD,SYM) _MCASP_XFMT_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XFMT1_FSETS(FIELD,SYM) _MCASP_XFMT_FSETS(1,##FIELD,##SYM) 
#endif
 

/******************************************************************************\
* 
* _____________________
* |                   |
* |     AFSXCTL       |
* |___________________|
*
* AFSXCTL  -  Transmit Frame Control Register
*
* FIELDS (msb -> lsb)
* (rw)  XMOD
* (rw)  FXWID
* (rw)  FSXM
* (rw)  FSXP
*
\******************************************************************************/

  #define _MCASP_AFSXCTL_OFFSET             43

  #define _MCASP_AFSXCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_AFSXCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AFSXCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_AFSXCTL_OFFSET)
#endif

  #define _MCASP_AFSXCTL_XMOD_MASK              0x0000FF80u
  #define _MCASP_AFSXCTL_XMOD_SHIFT             0x00000007u
  #define  MCASP_AFSXCTL_XMOD_DEFAULT           0x00000000u
  #define  MCASP_AFSXCTL_XMOD_OF(x)             _VALUEOF(x)
  #define  MCASP_AFSXCTL_XMOD_BURST             0x00000000u

  #define _MCASP_AFSXCTL_FXWID_MASK              0x00000010u
  #define _MCASP_AFSXCTL_FXWID_SHIFT             0x00000004u
  #define  MCASP_AFSXCTL_FXWID_DEFAULT           0x00000000u
  #define  MCASP_AFSXCTL_FXWID_OF(x)             _VALUEOF(x)
  #define  MCASP_AFSXCTL_FXWID_BIT              0x00000000u
  #define  MCASP_AFSXCTL_FXWID_WORD             0x00000001u

  #define _MCASP_AFSXCTL_FSXM_MASK              0x00000002u
  #define _MCASP_AFSXCTL_FSXM_SHIFT             0x00000001u
  #define  MCASP_AFSXCTL_FSXM_DEFAULT           0x00000000u
  #define  MCASP_AFSXCTL_FSXM_OF(x)             _VALUEOF(x)
  #define  MCASP_AFSXCTL_FSXM_EXTERNAL          0x00000000u
  #define  MCASP_AFSXCTL_FSXM_INTERNAL          0x00000001u
  

  #define _MCASP_AFSXCTL_FSXP_MASK              0x00000001u
  #define _MCASP_AFSXCTL_FSXP_SHIFT             0x00000000u
  #define  MCASP_AFSXCTL_FSXP_DEFAULT           0x00000000u
  #define  MCASP_AFSXCTL_FSXP_OF(x)             _VALUEOF(x)
  #define  MCASP_AFSXCTL_FSXP_ACTIVEHIGH        0x00000000u
  #define  MCASP_AFSXCTL_FSXP_ACTIVELOW         0x00000001u
  

  #define  MCASP_AFSXCTL_OF(x)                _VALUEOF(x)

  #define MCASP_AFSXCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,AFSXCTL,XMOD)\
	| _PER_FDEFAULT(MCASP,AFSXCTL,FXWID)\
	| _PER_FDEFAULT(MCASP,AFSXCTL,FSXM)\
	| _PER_FDEFAULT(MCASP,AFSXCTL,FSXP)\
  )

  #define MCASP_AFSXCTL_RMK(xmod, fxwid, fsxm, fsxp) (Uint32)( \
     _PER_FMK(MCASP,AFSXCTL,XMOD,xmod)\
	| _PER_FMK(MCASP,AFSXCTL,FXWID,fxwid)\
	| _PER_FMK(MCASP,AFSXCTL,FSXM,fsxm)\
	| _PER_FMK(MCASP,AFSXCTL,FSXP,fsxp)\
  )

  #define _MCASP_AFSXCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_AFSXCTL##N##_ADDR,MCASP,AFSXCTL,##FIELD)

  #define _MCASP_AFSXCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_AFSXCTL##N##_ADDR,MCASP,AFSXCTL,##FIELD,field)

  #define _MCASP_AFSXCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_AFSXCTL##N##_ADDR,MCASP,AFSXCTL,##FIELD,##SYM)

  #define _MCASP_AFSXCTL0_FGET(FIELD) _MCASP_AFSXCTL_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AFSXCTL1_FGET(FIELD) _MCASP_AFSXCTL_FGET(1,##FIELD) 
#endif

  #define _MCASP_AFSXCTL0_FSET(FIELD,f) _MCASP_AFSXCTL_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AFSXCTL1_FSET(FIELD,f) _MCASP_AFSXCTL_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_AFSXCTL0_FSETS(FIELD,SYM) _MCASP_AFSXCTL_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AFSXCTL1_FSETS(FIELD,SYM) _MCASP_AFSXCTL_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     ACLKXCTL      |
* |___________________|
*
* ACLKXCTL  -  Transmit Clock Control Register
*
* FIELDS (msb -> lsb)
* (rw)  CLKXP  
* (rw)  ASYNC  
* (rw)  CLKXM  
* (rw)  CLKXDIV
*
*
\******************************************************************************/

  #define _MCASP_ACLKXCTL_OFFSET               44

  #define _MCASP_ACLKXCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_ACLKXCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_ACLKXCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_ACLKXCTL_OFFSET)
#endif


  #define _MCASP_ACLKXCTL_CLKXP_MASK              0x00000080u
  #define _MCASP_ACLKXCTL_CLKXP_SHIFT             0x00000007u
  #define  MCASP_ACLKXCTL_CLKXP_DEFAULT           0x00000000u
  #define  MCASP_ACLKXCTL_CLKXP_OF(x)             _VALUEOF(x)
  #define  MCASP_ACLKXCTL_CLKXP_RISING            0x00000000u
  #define  MCASP_ACLKXCTL_CLKXP_FALLING           0x00000001u
  

  #define _MCASP_ACLKXCTL_ASYNC_MASK              0x00000040u
  #define _MCASP_ACLKXCTL_ASYNC_SHIFT             0x00000006u
  #define  MCASP_ACLKXCTL_ASYNC_DEFAULT           0x00000001u
  #define  MCASP_ACLKXCTL_ASYNC_OF(x)             _VALUEOF(x)
  #define  MCASP_ACLKXCTL_ASYNC_SYNC              0x00000000u
  #define  MCASP_ACLKXCTL_ASYNC_ASYNC             0x00000001u
  

  #define _MCASP_ACLKXCTL_CLKXM_MASK              0x00000020u
  #define _MCASP_ACLKXCTL_CLKXM_SHIFT             0x00000005u
  #define  MCASP_ACLKXCTL_CLKXM_DEFAULT           0x00000001u
  #define  MCASP_ACLKXCTL_CLKXM_OF(x)             _VALUEOF(x)
  #define  MCASP_ACLKXCTL_CLKXM_EXTERNAL          0x00000000u
  #define  MCASP_ACLKXCTL_CLKXM_INTERNAL            0x00000001u
  

  #define _MCASP_ACLKXCTL_CLKXDIV_MASK              0x0000001Fu
  #define _MCASP_ACLKXCTL_CLKXDIV_SHIFT             0x00000000u
  #define  MCASP_ACLKXCTL_CLKXDIV_DEFAULT           0x00000000u
  #define  MCASP_ACLKXCTL_CLKXDIV_OF(x)             _VALUEOF(x)

  #define  MCASP_ACLKXCTL_OF(x)                _VALUEOF(x)

  #define MCASP_ACLKXCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,ACLKXCTL,CLKXP)\
	| _PER_FDEFAULT(MCASP,ACLKXCTL,ASYNC)\
	| _PER_FDEFAULT(MCASP,ACLKXCTL,CLKXM)\
	| _PER_FDEFAULT(MCASP,ACLKXCTL,CLKXDIV)\
  )

  #define MCASP_ACLKXCTL_RMK(clkxp, async, clkxm, clkxdiv) (Uint32)( \
     _PER_FMK(MCASP,ACLKXCTL,CLKXP,clkxp)\
	| _PER_FMK(MCASP,ACLKXCTL,ASYNC,async)\
	| _PER_FMK(MCASP,ACLKXCTL,CLKXM,clkxm)\
	| _PER_FMK(MCASP,ACLKXCTL,CLKXDIV,clkxdiv)\
  )


  #define _MCASP_ACLKXCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_ACLKXCTL##N##_ADDR,MCASP,ACLKXCTL,##FIELD)

  #define _MCASP_ACLKXCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_ACLKXCTL##N##_ADDR,MCASP,ACLKXCTL,##FIELD,field)

  #define _MCASP_ACLKXCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_ACLKXCTL##N##_ADDR,MCASP,ACLKXCTL,##FIELD,##SYM)

  #define _MCASP_ACLKXCTL0_FGET(FIELD) _MCASP_ACLKXCTL_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_ACLKXCTL1_FGET(FIELD) _MCASP_ACLKXCTL_FGET(1,##FIELD) 
#endif

  #define _MCASP_ACLKXCTL0_FSET(FIELD,f) _MCASP_ACLKXCTL_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_ACLKXCTL1_FSET(FIELD,f) _MCASP_ACLKXCTL_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_ACLKXCTL0_FSETS(FIELD,SYM) _MCASP_ACLKXCTL_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_ACLKXCTL1_FSETS(FIELD,SYM) _MCASP_ACLKXCTL_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     AHCLKXCTL     |
* |___________________|
*
* AHCLKXCTL  -  High Frequency Transmit Clock Control Register
*
* FIELDS (msb -> lsb)
* (rw)  HCLKXM 
* (rw)  HCLKXDIV 
*
\******************************************************************************/

  #define _MCASP_AHCLKXCTL_OFFSET           45

  #define _MCASP_AHCLKXCTL0_ADDR			(_MCASP_BASE_PORT0+4*_MCASP_AHCLKXCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AHCLKXCTL1_ADDR			(_MCASP_BASE_PORT1+4*_MCASP_AHCLKXCTL_OFFSET)
#endif

  #define _MCASP_AHCLKXCTL_HCLKXM_MASK              0x00008000u
  #define _MCASP_AHCLKXCTL_HCLKXM_SHIFT             0x0000000Fu
  #define  MCASP_AHCLKXCTL_HCLKXM_DEFAULT           0x00000001u
  #define  MCASP_AHCLKXCTL_HCLKXM_OF(x)             _VALUEOF(x)
  #define  MCASP_AHCLKXCTL_HCLKXM_EXTERNAL            0x00000000u
  #define  MCASP_AHCLKXCTL_HCLKXM_INTERNAL        0x00000001u

  #define _MCASP_AHCLKXCTL_HCLKXP_MASK              0x00004000u
  #define _MCASP_AHCLKXCTL_HCLKXP_SHIFT             0x0000000Eu
  #define  MCASP_AHCLKXCTL_HCLKXP_DEFAULT           0x00000000u
  #define  MCASP_AHCLKXCTL_HCLKXP_OF(x)             _VALUEOF(x)
  #define  MCASP_AHCLKXCTL_HCLKXP_RISING         0x00000000u
  #define  MCASP_AHCLKXCTL_HCLKXP_FALLING		  0x00000001u

  #define _MCASP_AHCLKXCTL_HCLKXDIV_MASK              0x00000FFFu
  #define _MCASP_AHCLKXCTL_HCLKXDIV_SHIFT             0x00000000u
  #define  MCASP_AHCLKXCTL_HCLKXDIV_DEFAULT           0x00000000u
  #define  MCASP_AHCLKXCTL_HCLKXDIV_OF(x)             _VALUEOF(x)


  #define  MCASP_AHCLKXCTL_OF(x)                _VALUEOF(x)

  #define MCASP_AHCLKXCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,AHCLKXCTL,HCLKXM)\
	| _PER_FDEFAULT(MCASP,AHCLKXCTL,HCLKXP)\
	| _PER_FDEFAULT(MCASP,AHCLKXCTL,HCLKXDIV)\
  )

  #define MCASP_AHCLKXCTL_RMK(hclkxm,hclkxp,hclkxdiv) (Uint32)( \
     _PER_FMK(MCASP,AHCLKXCTL,HCLKXM,hclkxm)\
	| _PER_FMK(MCASP,AHCLKXCTL,HCLKXP,hclkxp)\
	| _PER_FMK(MCASP,AHCLKXCTL,HCLKXDIV,hclkxdiv)\
  )

  #define _MCASP_AHCLKXCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_AHCLKXCTL##N##_ADDR,MCASP,AHCLKXCTL,##FIELD)

  #define _MCASP_AHCLKXCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_AHCLKXCTL##N##_ADDR,MCASP,AHCLKXCTL,##FIELD,field)

  #define _MCASP_AHCLKXCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_AHCLKXCTL##N##_ADDR,MCASP,AHCLKXCTL,##FIELD,##SYM)

  #define _MCASP_AHCLKXCTL0_FGET(FIELD) _MCASP_AHCLKXCTL_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AHCLKXCTL1_FGET(FIELD) _MCASP_AHCLKXCTL_FGET(1,##FIELD) 
#endif

  #define _MCASP_AHCLKXCTL0_FSET(FIELD,f) _MCASP_AHCLKXCTL_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AHCLKXCTL1_FSET(FIELD,f) _MCASP_AHCLKXCTL_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_AHCLKXCTL0_FSETS(FIELD,SYM) _MCASP_AHCLKXCTL_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_AHCLKXCTL1_FSETS(FIELD,SYM) _MCASP_AHCLKXCTL_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |    X  T  D  M     |
* |___________________|
*
* XTDM  -  Transmit TDM register
*
* FIELDS (msb -> lsb)
* (rw)  XTDMS0
* (rw)  XTDMS1
*   .
*   .
*   .
* (rw)  XTDMS31
*
\******************************************************************************/

  #define _MCASP_XTDM_OFFSET               46

  #define _MCASP_XTDM0_ADDR					(_MCASP_BASE_PORT0+4*_MCASP_XTDM_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XTDM1_ADDR					(_MCASP_BASE_PORT1+4*_MCASP_XTDM_OFFSET)
#endif

  #define _MCASP_XTDM_XTDMS31_MASK              0x80000000u
  #define _MCASP_XTDM_XTDMS31_SHIFT             0x0000001Fu
  #define  MCASP_XTDM_XTDMS31_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS31_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS31_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS31_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS30_MASK              0x40000000u
  #define _MCASP_XTDM_XTDMS30_SHIFT             0x0000001Eu
  #define  MCASP_XTDM_XTDMS30_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS30_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS30_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS30_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS29_MASK              0x20000000u
  #define _MCASP_XTDM_XTDMS29_SHIFT             0x0000001Du
  #define  MCASP_XTDM_XTDMS29_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS29_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS29_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS29_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS28_MASK              0x10000000u
  #define _MCASP_XTDM_XTDMS28_SHIFT             0x0000001Cu
  #define  MCASP_XTDM_XTDMS28_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS28_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS28_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS28_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS27_MASK              0x08000000u
  #define _MCASP_XTDM_XTDMS27_SHIFT             0x0000001Bu
  #define  MCASP_XTDM_XTDMS27_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS27_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS27_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS27_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS26_MASK              0x04000000u
  #define _MCASP_XTDM_XTDMS26_SHIFT             0x0000001Au
  #define  MCASP_XTDM_XTDMS26_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS26_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS26_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS26_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS25_MASK              0x02000000u
  #define _MCASP_XTDM_XTDMS25_SHIFT             0x00000019u
  #define  MCASP_XTDM_XTDMS25_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS25_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS25_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS25_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS24_MASK              0x01000000u
  #define _MCASP_XTDM_XTDMS24_SHIFT             0x00000018u
  #define  MCASP_XTDM_XTDMS24_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS24_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS24_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS24_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS23_MASK              0x00800000u
  #define _MCASP_XTDM_XTDMS23_SHIFT             0x00000017u
  #define  MCASP_XTDM_XTDMS23_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS23_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS23_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS23_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS22_MASK              0x00400000u
  #define _MCASP_XTDM_XTDMS22_SHIFT             0x00000016u
  #define  MCASP_XTDM_XTDMS22_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS22_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS22_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS22_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS21_MASK              0x00200000u
  #define _MCASP_XTDM_XTDMS21_SHIFT             0x00000015u
  #define  MCASP_XTDM_XTDMS21_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS21_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS21_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS21_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS20_MASK              0x00100000u
  #define _MCASP_XTDM_XTDMS20_SHIFT             0x00000014u
  #define  MCASP_XTDM_XTDMS20_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS20_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS20_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS20_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS19_MASK              0x00080000u
  #define _MCASP_XTDM_XTDMS19_SHIFT             0x00000013u
  #define  MCASP_XTDM_XTDMS19_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS19_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS19_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS19_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS18_MASK              0x00040000u
  #define _MCASP_XTDM_XTDMS18_SHIFT             0x00000012u
  #define  MCASP_XTDM_XTDMS18_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS18_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS18_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS18_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS17_MASK              0x00020000u
  #define _MCASP_XTDM_XTDMS17_SHIFT             0x00000011u
  #define  MCASP_XTDM_XTDMS17_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS17_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS17_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS17_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS16_MASK              0x00010000u
  #define _MCASP_XTDM_XTDMS16_SHIFT             0x00000010u
  #define  MCASP_XTDM_XTDMS16_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS16_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS16_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS16_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS15_MASK              0x00008000u
  #define _MCASP_XTDM_XTDMS15_SHIFT             0x0000000Fu
  #define  MCASP_XTDM_XTDMS15_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS15_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS15_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS15_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS14_MASK              0x00004000u
  #define _MCASP_XTDM_XTDMS14_SHIFT             0x0000000Eu
  #define  MCASP_XTDM_XTDMS14_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS14_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS14_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS14_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS13_MASK              0x00002000u
  #define _MCASP_XTDM_XTDMS13_SHIFT             0x0000000Du
  #define  MCASP_XTDM_XTDMS13_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS13_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS13_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS13_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS12_MASK              0x00001000u
  #define _MCASP_XTDM_XTDMS12_SHIFT             0x0000000Cu
  #define  MCASP_XTDM_XTDMS12_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS12_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS12_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS12_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS11_MASK              0x00000800u
  #define _MCASP_XTDM_XTDMS11_SHIFT             0x0000000Bu
  #define  MCASP_XTDM_XTDMS11_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS11_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS11_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS11_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS10_MASK              0x00000400u
  #define _MCASP_XTDM_XTDMS10_SHIFT             0x0000000Au
  #define  MCASP_XTDM_XTDMS10_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS10_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS10_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS10_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS9_MASK              0x00000200u
  #define _MCASP_XTDM_XTDMS9_SHIFT             0x00000009u
  #define  MCASP_XTDM_XTDMS9_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS9_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS9_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS9_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS8_MASK              0x00000100u
  #define _MCASP_XTDM_XTDMS8_SHIFT             0x00000008u
  #define  MCASP_XTDM_XTDMS8_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS8_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS8_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS8_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS7_MASK              0x00000080u
  #define _MCASP_XTDM_XTDMS7_SHIFT             0x00000007u
  #define  MCASP_XTDM_XTDMS7_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS7_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS7_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS7_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS6_MASK              0x00000040u
  #define _MCASP_XTDM_XTDMS6_SHIFT             0x00000006u
  #define  MCASP_XTDM_XTDMS6_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS6_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS6_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS6_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS5_MASK              0x00000020u
  #define _MCASP_XTDM_XTDMS5_SHIFT             0x00000005u
  #define  MCASP_XTDM_XTDMS5_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS5_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS5_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS5_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS4_MASK              0x00000010u
  #define _MCASP_XTDM_XTDMS4_SHIFT             0x00000004u
  #define  MCASP_XTDM_XTDMS4_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS4_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS4_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS4_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS3_MASK              0x00000008u
  #define _MCASP_XTDM_XTDMS3_SHIFT             0x00000003u
  #define  MCASP_XTDM_XTDMS3_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS3_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS3_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS3_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS2_MASK              0x00000004u
  #define _MCASP_XTDM_XTDMS2_SHIFT             0x00000002u
  #define  MCASP_XTDM_XTDMS2_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS2_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS2_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS2_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS1_MASK              0x00000002u
  #define _MCASP_XTDM_XTDMS1_SHIFT             0x00000001u
  #define  MCASP_XTDM_XTDMS1_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS1_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS1_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS1_ACTIVE            0x00000001u
  

  #define _MCASP_XTDM_XTDMS0_MASK              0x00000001u
  #define _MCASP_XTDM_XTDMS0_SHIFT             0x00000000u
  #define  MCASP_XTDM_XTDMS0_DEFAULT           0x00000000u
  #define  MCASP_XTDM_XTDMS0_OF(x)             _VALUEOF(x)
  #define  MCASP_XTDM_XTDMS0_INACTIVE          0x00000000u
  #define  MCASP_XTDM_XTDMS0_ACTIVE            0x00000001u
  

  #define  MCASP_XTDM_OF(x)                _VALUEOF(x)

  #define MCASP_XTDM_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,XTDM,XTDMS31)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS30)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS29)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS28)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS27)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS26)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS25)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS24)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS23)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS22)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS21)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS20)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS19)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS18)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS17)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS16)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS15)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS14)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS13)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS12)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS11)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS10)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS9)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS8)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS7)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS6)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS5)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS4)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS3)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS2)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS1)\
	| _PER_FDEFAULT(MCASP,XTDM,XTDMS0)\
  )

  #define MCASP_XTDM_RMK(xtdms31, xtdms30, xtdms29, xtdms28, xtdms27, xtdms26, xtdms25, xtdms24, xtdms23, xtdms22, xtdms21, xtdms20, xtdms19, xtdms18, xtdms17, xtdms16, xtdms15, xtdms14, xtdms13, xtdms12, xtdms11, xtdms10, xtdms9, xtdms8, xtdms7, xtdms6, xtdms5, xtdms4, xtdms3, xtdms2, xtdms1, xtdms0) (Uint32)( \
     _PER_FMK(MCASP,XTDM,XTDMS31,xtdms31)\
	| _PER_FMK(MCASP,XTDM,XTDMS30,xtdms30)\
	| _PER_FMK(MCASP,XTDM,XTDMS29,xtdms29)\
	| _PER_FMK(MCASP,XTDM,XTDMS28,xtdms28)\
	| _PER_FMK(MCASP,XTDM,XTDMS27,xtdms27)\
	| _PER_FMK(MCASP,XTDM,XTDMS26,xtdms26)\
	| _PER_FMK(MCASP,XTDM,XTDMS25,xtdms25)\
	| _PER_FMK(MCASP,XTDM,XTDMS24,xtdms24)\
	| _PER_FMK(MCASP,XTDM,XTDMS23,xtdms23)\
	| _PER_FMK(MCASP,XTDM,XTDMS22,xtdms22)\
	| _PER_FMK(MCASP,XTDM,XTDMS21,xtdms21)\
	| _PER_FMK(MCASP,XTDM,XTDMS20,xtdms20)\
	| _PER_FMK(MCASP,XTDM,XTDMS19,xtdms19)\
	| _PER_FMK(MCASP,XTDM,XTDMS18,xtdms18)\
	| _PER_FMK(MCASP,XTDM,XTDMS17,xtdms17)\
	| _PER_FMK(MCASP,XTDM,XTDMS16,xtdms16)\
	| _PER_FMK(MCASP,XTDM,XTDMS15,xtdms15)\
	| _PER_FMK(MCASP,XTDM,XTDMS14,xtdms14)\
	| _PER_FMK(MCASP,XTDM,XTDMS13,xtdms13)\
	| _PER_FMK(MCASP,XTDM,XTDMS12,xtdms12)\
	| _PER_FMK(MCASP,XTDM,XTDMS11,xtdms11)\
	| _PER_FMK(MCASP,XTDM,XTDMS10,xtdms10)\
	| _PER_FMK(MCASP,XTDM,XTDMS9,xtdms9)\
	| _PER_FMK(MCASP,XTDM,XTDMS8,xtdms8)\
	| _PER_FMK(MCASP,XTDM,XTDMS7,xtdms7)\
	| _PER_FMK(MCASP,XTDM,XTDMS6,xtdms6)\
	| _PER_FMK(MCASP,XTDM,XTDMS5,xtdms5)\
	| _PER_FMK(MCASP,XTDM,XTDMS4,xtdms4)\
	| _PER_FMK(MCASP,XTDM,XTDMS3,xtdms3)\
	| _PER_FMK(MCASP,XTDM,XTDMS2,xtdms2)\
	| _PER_FMK(MCASP,XTDM,XTDMS1,xtdms1)\
	| _PER_FMK(MCASP,XTDM,XTDMS0,xtdms0)\
  )


  #define _MCASP_XTDM_FGET(N,FIELD)\
    _PER_FGET(_MCASP_XTDM##N##_ADDR,MCASP,XTDM,##FIELD)

  #define _MCASP_XTDM_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_XTDM##N##_ADDR,MCASP,XTDM,##FIELD,field)

  #define _MCASP_XTDM_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_XTDM##N##_ADDR,MCASP,XTDM,##FIELD,##SYM)

  #define _MCASP_XTDM0_FGET(FIELD) _MCASP_XTDM_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XTDM1_FGET(FIELD) _MCASP_XTDM_FGET(1,##FIELD) 
#endif

  #define _MCASP_XTDM0_FSET(FIELD,f) _MCASP_XTDM_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XTDM1_FSET(FIELD,f) _MCASP_XTDM_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_XTDM0_FSETS(FIELD,SYM) _MCASP_XTDM_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XTDM1_FSETS(FIELD,SYM) _MCASP_XTDM_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     XINTCTL       |
* |___________________|
*
* XINTCTL  -  Transmitter Interrupt Control Register
*
* FIELDS (msb -> lsb)
* (rw)  XSTAFRM  
* (rw)  XDATA 
* (rw)  XLAST  
* (rw)  XDMAERR
* (rw)  XCKFAIL  
* (rw)  XSYNCERR  
* (rw)  XUNDRN  
*
\******************************************************************************/

  #define _MCASP_XINTCTL_OFFSET             47

  #define _MCASP_XINTCTL0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_XINTCTL_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XINTCTL1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_XINTCTL_OFFSET)
#endif

  #define _MCASP_XINTCTL_XSTAFRM_MASK              0x00000080u
  #define _MCASP_XINTCTL_XSTAFRM_SHIFT             0x00000007u
  #define  MCASP_XINTCTL_XSTAFRM_DEFAULT           0x00000000u
  #define  MCASP_XINTCTL_XSTAFRM_OF(x)             _VALUEOF(x)
  #define  MCASP_XINTCTL_XSTAFRM_DISABLE          0x00000000u
  #define  MCASP_XINTCTL_XSTAFRM_ENABLE           0x00000001u


  #define _MCASP_XINTCTL_XDATA_MASK              0x00000020u
  #define _MCASP_XINTCTL_XDATA_SHIFT             0x00000005u
  #define  MCASP_XINTCTL_XDATA_DEFAULT           0x00000000u
  #define  MCASP_XINTCTL_XDATA_OF(x)             _VALUEOF(x)
  #define  MCASP_XINTCTL_XDATA_DISABLE          0x00000000u
  #define  MCASP_XINTCTL_XDATA_ENABLE           0x00000001u


  #define _MCASP_XINTCTL_XLAST_MASK              0x00000010u
  #define _MCASP_XINTCTL_XLAST_SHIFT             0x00000004u
  #define  MCASP_XINTCTL_XLAST_DEFAULT           0x00000000u
  #define  MCASP_XINTCTL_XLAST_OF(x)             _VALUEOF(x)
  #define  MCASP_XINTCTL_XLAST_DISABLE          0x00000000u
  #define  MCASP_XINTCTL_XLAST_ENABLE           0x00000001u


  #define _MCASP_XINTCTL_XDMAERR_MASK              0x00000008u
  #define _MCASP_XINTCTL_XDMAERR_SHIFT             0x00000003u
  #define  MCASP_XINTCTL_XDMAERR_DEFAULT           0x00000000u
  #define  MCASP_XINTCTL_XDMAERR_OF(x)             _VALUEOF(x)
  #define  MCASP_XINTCTL_XDMAERR_DISABLE        0x00000000u
  #define  MCASP_XINTCTL_XDMAERR_ENABLE          0x00000001u


  #define _MCASP_XINTCTL_XCKFAIL_MASK              0x00000004u
  #define _MCASP_XINTCTL_XCKFAIL_SHIFT             0x00000002u
  #define  MCASP_XINTCTL_XCKFAIL_DEFAULT           0x00000000u
  #define  MCASP_XINTCTL_XCKFAIL_OF(x)             _VALUEOF(x)
  #define  MCASP_XINTCTL_XCKFAIL_DISABLE          0x00000000u
  #define  MCASP_XINTCTL_XCKFAIL_ENABLE           0x00000001u


  #define _MCASP_XINTCTL_XSYNCERR_MASK              0x00000002u
  #define _MCASP_XINTCTL_XSYNCERR_SHIFT             0x00000001u
  #define  MCASP_XINTCTL_XSYNCERR_DEFAULT           0x00000000u
  #define  MCASP_XINTCTL_XSYNCERR_OF(x)             _VALUEOF(x)
  #define  MCASP_XINTCTL_XSYNCERR_DISABLE          0x00000000u
  #define  MCASP_XINTCTL_XSYNCERR_ENABLE           0x00000001u


  #define _MCASP_XINTCTL_XUNDRN_MASK              0x00000001u
  #define _MCASP_XINTCTL_XUNDRN_SHIFT             0x00000000u
  #define  MCASP_XINTCTL_XUNDRN_DEFAULT           0x00000000u
  #define  MCASP_XINTCTL_XUNDRN_OF(x)             _VALUEOF(x)
  #define  MCASP_XINTCTL_XUNDRN_DISABLE          0x00000000u
  #define  MCASP_XINTCTL_XUNDRN_ENABLE           0x00000001u


  #define  MCASP_XINTCTL_OF(x)                _VALUEOF(x)



  #define MCASP_XINTCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,XINTCTL,XSTAFRM)\
    |_PER_FDEFAULT(MCASP,XINTCTL,XDATA)\
    |_PER_FDEFAULT(MCASP,XINTCTL,XLAST)\
    |_PER_FDEFAULT(MCASP,XINTCTL,XDMAERR)\
    |_PER_FDEFAULT(MCASP,XINTCTL,XCKFAIL)\
    |_PER_FDEFAULT(MCASP,XINTCTL,XSYNCERR)\
    |_PER_FDEFAULT(MCASP,XINTCTL,XUNDRN)\
  )


  #define MCASP_XINTCTL_RMK(xstafrm, xdata, xlast, xdmaerr, xckfail, xsyncerr, xundrn) (Uint32)( \
     _PER_FMK(MCASP,XINTCTL,XSTAFRM,xstafrm)\
    |_PER_FMK(MCASP,XINTCTL,XDATA,xdata)\
    |_PER_FMK(MCASP,XINTCTL,XLAST,xlast)\
    |_PER_FMK(MCASP,XINTCTL,XDMAERR,xdmaerr)\
    |_PER_FMK(MCASP,XINTCTL,XCKFAIL,xckfail)\
    |_PER_FMK(MCASP,XINTCTL,XSYNCERR,xsyncerr)\
    |_PER_FMK(MCASP,XINTCTL,XUNDRN,xundrn)\
  )


  #define _MCASP_XINTCTL_FGET(N,FIELD)\
    _PER_FGET(_MCASP_XINTCTL##N##_ADDR,MCASP,XINTCTL,##FIELD)

  #define _MCASP_XINTCTL_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_XINTCTL##N##_ADDR,MCASP,XINTCTL,##FIELD,field)

  #define _MCASP_XINTCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_XINTCTL##N##_ADDR,MCASP,XINTCTL,##FIELD,##SYM)

  #define _MCASP_XINTCTL0_FGET(FIELD) _MCASP_XINTCTL_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XINTCTL1_FGET(FIELD) _MCASP_XINTCTL_FGET(1,##FIELD) 
#endif

  #define _MCASP_XINTCTL0_FSET(FIELD,f) _MCASP_XINTCTL_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XINTCTL1_FSET(FIELD,f) _MCASP_XINTCTL_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_XINTCTL0_FSETS(FIELD,SYM) _MCASP_XINTCTL_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XINTCTL1_FSETS(FIELD,SYM) _MCASP_XINTCTL_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |       XSTAT       |
* |___________________|
*
* XSTAT  -  Transmitter Status Register
*
* FIELDS (msb -> lsb)
* (r)  XERR  
* (r)  XDMAERR  
* (r)  XSTAFRM  
* (r)  XDATA  
* (r)  XLAST 
* (r)  XTDMSLOT  
* (r)  XCKFAIL  
* (r)  XSYNCERR  
* (r)  XUNDRN  
*
\******************************************************************************/

  #define _MCASP_XSTAT_OFFSET               48

  #define _MCASP_XSTAT0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_XSTAT_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XSTAT1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_XSTAT_OFFSET)
#endif

  #define _MCASP_XSTAT_XERR_MASK              0x00000100u
  #define _MCASP_XSTAT_XERR_SHIFT             0x00000008u
  #define  MCASP_XSTAT_XERR_DEFAULT           0x00000000u
  #define  MCASP_XSTAT_XERR_OF(x)             _VALUEOF(x)

  #define _MCASP_XSTAT_XDMAERR_MASK              0x0000080u
  #define _MCASP_XSTAT_XDMAERR_SHIFT             0x00000007u
  #define  MCASP_XSTAT_XDMAERR_DEFAULT           0x00000000u
  #define  MCASP_XSTAT_XDMAERR_OF(x)             _VALUEOF(x)

  #define _MCASP_XSTAT_XSTAFRM_MASK              0x00000040u
  #define _MCASP_XSTAT_XSTAFRM_SHIFT             0x00000006u
  #define  MCASP_XSTAT_XSTAFRM_DEFAULT           0x00000000u
  #define  MCASP_XSTAT_XSTAFRM_OF(x)             _VALUEOF(x)
  #define  MCASP_XSTAT_XSTAFRM_NO                0x00000000u
  #define  MCASP_XSTAT_XSTAFRM_YES               0x00000001u
  #define  MCASP_XSTAT_XSTAFRM_0                 0x00000000u
  #define  MCASP_XSTAT_XSTAFRM_1                 0x00000001u


  #define _MCASP_XSTAT_XDATA_MASK              0x00000020u
  #define _MCASP_XSTAT_XDATA_SHIFT             0x00000005u
  #define  MCASP_XSTAT_XDATA_DEFAULT           0x00000000u
  #define  MCASP_XSTAT_XDATA_OF(x)             _VALUEOF(x)
  #define  MCASP_XSTAT_XDATA_NO                0x00000000u
  #define  MCASP_XSTAT_XDATA_YES               0x00000001u
  #define  MCASP_XSTAT_XDATA_0                 0x00000000u
  #define  MCASP_XSTAT_XDATA_1                 0x00000001u

  #define _MCASP_XSTAT_XLAST_MASK              0x00000010u
  #define _MCASP_XSTAT_XLAST_SHIFT             0x00000004u
  #define  MCASP_XSTAT_XLAST_DEFAULT           0x00000000u
  #define  MCASP_XSTAT_XLAST_OF(x)             _VALUEOF(x)
  #define  MCASP_XSTAT_XLAST_NO                0x00000000u
  #define  MCASP_XSTAT_XLAST_YES               0x00000001u
  #define  MCASP_XSTAT_XLAST_0                 0x00000000u
  #define  MCASP_XSTAT_XLAST_1                 0x00000001u


  #define _MCASP_XSTAT_XTDMSLOT_MASK            0x00000008u
  #define _MCASP_XSTAT_XTDMSLOT_SHIFT           0x00000003u
  #define  MCASP_XSTAT_XTDMSLOT_DEFAULT         0x00000000u
  #define  MCASP_XSTAT_XTDMSLOT_OF(x)             _VALUEOF(x)


  #define _MCASP_XSTAT_XCKFAIL_MASK              0x00000004u
  #define _MCASP_XSTAT_XCKFAIL_SHIFT             0x00000002u
  #define  MCASP_XSTAT_XCKFAIL_DEFAULT           0x00000000u
  #define  MCASP_XSTAT_XCKFAIL_OF(x)             _VALUEOF(x)
  #define  MCASP_XSTAT_XCKFAIL_NO                0x00000000u
  #define  MCASP_XSTAT_XCKFAIL_YES               0x00000001u
  #define  MCASP_XSTAT_XCKFAIL_0                 0x00000000u
  #define  MCASP_XSTAT_XCKFAIL_1                 0x00000001u


  #define _MCASP_XSTAT_XSYNCERR_MASK              0x00000002u
  #define _MCASP_XSTAT_XSYNCERR_SHIFT             0x00000001u
  #define  MCASP_XSTAT_XSYNCERR_DEFAULT           0x00000000u
  #define  MCASP_XSTAT_XSYNCERR_OF(x)             _VALUEOF(x)
  #define  MCASP_XSTAT_XSYNCERR_NO                0x00000000u
  #define  MCASP_XSTAT_XSYNCERR_YES               0x00000001u
  #define  MCASP_XSTAT_XSYNCERR_0                 0x00000000u
  #define  MCASP_XSTAT_XSYNCERR_1                 0x00000001u


  #define _MCASP_XSTAT_XUNDRN_MASK              0x00000001u
  #define _MCASP_XSTAT_XUNDRN_SHIFT             0x00000000u
  #define  MCASP_XSTAT_XUNDRN_DEFAULT           0x00000000u
  #define  MCASP_XSTAT_XUNDRN_OF(x)             _VALUEOF(x)
  #define  MCASP_XSTAT_XUNDRN_NO                0x00000000u 
  #define  MCASP_XSTAT_XUNDRN_YES               0x00000001u 
  #define  MCASP_XSTAT_XUNDRN_0                0x00000000u 
  #define  MCASP_XSTAT_XUNDRN_1               0x00000001u 


  #define  MCASP_XSTAT_OF(x)                _VALUEOF(x)

  #define MCASP_XSTAT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,XSTAT,XERR)\
    | _PER_FDEFAULT(MCASP,XSTAT,XDMAERR)\
	| _PER_FDEFAULT(MCASP,XSTAT,XSTAFRM)\
	| _PER_FDEFAULT(MCASP,XSTAT,XDATA)\
	| _PER_FDEFAULT(MCASP,XSTAT,XLAST)\
	| _PER_FDEFAULT(MCASP,XSTAT,XTDMSLOT)\
	| _PER_FDEFAULT(MCASP,XSTAT,XCKFAIL)\
	| _PER_FDEFAULT(MCASP,XSTAT,XSYNCERR)\
	| _PER_FDEFAULT(MCASP,XSTAT,XUNDRN)\
  )

  #define MCASP_XSTAT_RMK(xerr, xdmaerr, xstafrm, xdata, xlast, xtdmslot, xckfail, xsyncerr, xundrn) (Uint32)( \
     _PER_FMK(MCASP,XSTAT,XERR,xerr)\
    | _PER_FMK(MCASP,XSTAT,XDMAERR,xdmaerr)\
	| _PER_FMK(MCASP,XSTAT,XSTAFRM,xstafrm)\
	| _PER_FMK(MCASP,XSTAT,XDATA,xdata)\
	| _PER_FMK(MCASP,XSTAT,XLAST,xlast)\
	| _PER_FMK(MCASP,XSTAT,XTDMSLOT,xtdmslot)\
	| _PER_FMK(MCASP,XSTAT,XCKFAIL,xckfail)\
	| _PER_FMK(MCASP,XSTAT,XSYNCERR,xsyncerr)\
	| _PER_FMK(MCASP,XSTAT,XUNDRN,xundrn)\
  )

  #define _MCASP_XSTAT_FGET(N,FIELD)\
    _PER_FGET(_MCASP_XSTAT##N##_ADDR,MCASP,XSTAT,##FIELD)

  #define _MCASP_XSTAT_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_XSTAT##N##_ADDR,MCASP,XSTAT,##FIELD,field)

  #define _MCASP_XSTAT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_XSTAT##N##_ADDR,MCASP,XSTAT,##FIELD,##SYM)

  #define _MCASP_XSTAT0_FGET(FIELD) _MCASP_XSTAT_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XSTAT1_FGET(FIELD) _MCASP_XSTAT_FGET(1,##FIELD) 
#endif

  #define _MCASP_XSTAT0_FSET(FIELD,f) _MCASP_XSTAT_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XSTAT1_FSET(FIELD,f) _MCASP_XSTAT_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_XSTAT0_FSETS(FIELD,SYM) _MCASP_XSTAT_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XSTAT1_FSETS(FIELD,SYM) _MCASP_XSTAT_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     XSLOT         |
* |___________________|
*
* XSLOT  -  Transmitter TDM Slot Counter
*
* FIELDS (msb -> lsb)
* (r )  XSLOTCNT  
*
\******************************************************************************/

  #define _MCASP_XSLOT_OFFSET               49

  #define _MCASP_XSLOT0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_XSLOT_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XSLOT1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_XSLOT_OFFSET)
#endif

  #define _MCASP_XSLOT_XSLOTCNT_MASK              0x000003FFu
  #define _MCASP_XSLOT_XSLOTCNT_SHIFT             0x00000000u
  #define  MCASP_XSLOT_XSLOTCNT_DEFAULT           0x0000017Fu /*383*/
  #define  MCASP_XSLOT_XSLOTCNT_OF(x)             _VALUEOF(x)

  #define  MCASP_XSLOT_OF(x)                _VALUEOF(x)

  #define MCASP_XSLOT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,XSLOT,XSLOTCNT)\
  )

  #define MCASP_XSLOT_RMK(xslotcnt) (Uint32)( \
     _PER_FMK(MCASP,XSLOT,XSLOTCNT,xslotcnt)\
  )

  #define _MCASP_XSLOT_FGET(N,FIELD)\
    _PER_FGET(_MCASP_XSLOT##N##_ADDR,MCASP,XSLOT,##FIELD)

  #define _MCASP_XSLOT_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_XSLOT##N##_ADDR,MCASP,XSLOT,##FIELD,field)

  #define _MCASP_XSLOT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_XSLOT##N##_ADDR,MCASP,XSLOT,##FIELD,##SYM)

  #define _MCASP_XSLOT0_FGET(FIELD) _MCASP_XSLOT_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XSLOT1_FGET(FIELD) _MCASP_XSLOT_FGET(1,##FIELD) 
#endif

  #define _MCASP_XSLOT0_FSET(FIELD,f) _MCASP_XSLOT_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XSLOT1_FSET(FIELD,f) _MCASP_XSLOT_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_XSLOT0_FSETS(FIELD,SYM) _MCASP_XSLOT_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XSLOT1_FSETS(FIELD,SYM) _MCASP_XSLOT_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
* 
* _____________________
* |                   |
* |     XCLKCHK       |
* |___________________|
*
* XCLKCHK  -  Transmit Clock Check Control Register
*
* FIELDS (msb -> lsb)
* (r )  XCNT  
* (rw)  XMAX  
* (rw)  XMIN  
* (rw)  XFAILSW  
* (rw)  XPS  
\******************************************************************************/

  #define _MCASP_XCLKCHK_OFFSET             50

  #define _MCASP_XCLKCHK0_ADDR				(_MCASP_BASE_PORT0+4*_MCASP_XCLKCHK_OFFSET)
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XCLKCHK1_ADDR				(_MCASP_BASE_PORT1+4*_MCASP_XCLKCHK_OFFSET)
#endif

  #define _MCASP_XCLKCHK_XCNT_MASK              0xFF000000u
  #define _MCASP_XCLKCHK_XCNT_SHIFT             0x00000018u
  #define  MCASP_XCLKCHK_XCNT_DEFAULT           0x00000000u 
  #define  MCASP_XCLKCHK_XCNT_OF(x)             _VALUEOF(x)


  #define _MCASP_XCLKCHK_XMAX_MASK              0x00FF0000u
  #define _MCASP_XCLKCHK_XMAX_SHIFT             0x00000010u
  #define  MCASP_XCLKCHK_XMAX_DEFAULT           0x00000000u 
  #define  MCASP_XCLKCHK_XMAX_OF(x)             _VALUEOF(x)

  #define _MCASP_XCLKCHK_XMIN_MASK              0x0000FF00u
  #define _MCASP_XCLKCHK_XMIN_SHIFT             0x00000008u
  #define  MCASP_XCLKCHK_XMIN_DEFAULT           0x00000000u 
  #define  MCASP_XCLKCHK_XMIN_OF(x)             _VALUEOF(x)

  #define _MCASP_XCLKCHK_XCKFAILSW_MASK              0x00000080u
  #define _MCASP_XCLKCHK_XCKFAILSW_SHIFT             0x00000007u
  #define  MCASP_XCLKCHK_XCKFAILSW_DEFAULT           0x00000000u 
  #define  MCASP_XCLKCHK_XCKFAILSW_OF(x)             _VALUEOF(x)
  #define  MCASP_XCLKCHK_XCKFAILSW_DISABLE          0x00000000u
  #define  MCASP_XCLKCHK_XCKFAILSW_ENABLE           0x00000001u


  #define _MCASP_XCLKCHK_XPS_MASK              0x0000000Fu
  #define _MCASP_XCLKCHK_XPS_SHIFT             0x00000000u
  #define  MCASP_XCLKCHK_XPS_DEFAULT           0x00000000u 
  #define  MCASP_XCLKCHK_XPS_OF(x)             _VALUEOF(x)
  #define  MCASP_XCLKCHK_XPS_DIVBY1            0x00000000u
  #define  MCASP_XCLKCHK_XPS_DIVBY2            0x00000001u
  #define  MCASP_XCLKCHK_XPS_DIVBY4            0x00000002u
  #define  MCASP_XCLKCHK_XPS_DIVBY8            0x00000003u 
  #define  MCASP_XCLKCHK_XPS_DIVBY16           0x00000004u 
  #define  MCASP_XCLKCHK_XPS_DIVBY32           0x00000005u 
  #define  MCASP_XCLKCHK_XPS_DIVBY64           0x00000006u 
  #define  MCASP_XCLKCHK_XPS_DIVBY128          0x00000007u 
  #define  MCASP_XCLKCHK_XPS_DIVBY256          0x00000008u 


  #define  MCASP_XCLKCHK_OF(x)                _VALUEOF(x)

  #define MCASP_XCLKCHK_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,XCLKCHK,XCNT)\
	| _PER_FDEFAULT(MCASP,XCLKCHK,XMAX)\
	| _PER_FDEFAULT(MCASP,XCLKCHK,XMIN)\
	| _PER_FDEFAULT(MCASP,XCLKCHK,XCKFAILSW)\
	| _PER_FDEFAULT(MCASP,XCLKCHK,XPS)\
  )

  #define MCASP_XCLKCHK_RMK(xcnt, xmax, xmin, xckfailsw, xps) (Uint32)( \
     _PER_FMK(MCASP,XCLKCHK,XCNT,xcnt)\
	| _PER_FMK(MCASP,XCLKCHK,XMAX,xmax)\
	| _PER_FMK(MCASP,XCLKCHK,XMIN,xmin)\
	| _PER_FMK(MCASP,XCLKCHK,XCKFAILSW,xckfailsw)\
	| _PER_FMK(MCASP,XCLKCHK,XPS,xps)\
  )

  #define _MCASP_XCLKCHK_FGET(N,FIELD)\
    _PER_FGET(_MCASP_XCLKCHK##N##_ADDR,MCASP,XCLKCHK,##FIELD)

  #define _MCASP_XCLKCHK_FSET(N,FIELD,field)\
    _PER_FSET(_MCASP_XCLKCHK##N##_ADDR,MCASP,XCLKCHK,##FIELD,field)

  #define _MCASP_XCLKCHK_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_XCLKCHK##N##_ADDR,MCASP,XCLKCHK,##FIELD,##SYM)

  #define _MCASP_XCLKCHK0_FGET(FIELD) _MCASP_XCLKCHK_FGET(0,##FIELD) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XCLKCHK1_FGET(FIELD) _MCASP_XCLKCHK_FGET(1,##FIELD) 
#endif

  #define _MCASP_XCLKCHK0_FSET(FIELD,f) _MCASP_XCLKCHK_FSET(0,##FIELD,f) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XCLKCHK1_FSET(FIELD,f) _MCASP_XCLKCHK_FSET(1,##FIELD,f) 
#endif

  #define _MCASP_XCLKCHK0_FSETS(FIELD,SYM) _MCASP_XCLKCHK_FSETS(0,##FIELD,##SYM) 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XCLKCHK1_FSETS(FIELD,SYM) _MCASP_XCLKCHK_FSETS(1,##FIELD,##SYM) 
#endif


/******************************************************************************\
*  
* _____________________
* |                   |
* |       DITCSR      |
* |_______n: 0-15_____|
*
* DITCSR  -  Channel Status Register File
*
* FIELDS (msb -> lsb)
* (rw)  DITCSRA0	- Left (even TDM slot)  
* (rw)  DITCSRA1  
* (rw)  DITCSRA2  
* (rw)  DITCSRA3  
* (rw)  DITCSRA4  
* (rw)  DITCSRA5  
* (rw)  DITCSRB0  	- Right (odd TDM slot)
* (rw)  DITCSRB1  
* (rw)  DITCSRB2  
* (rw)  DITCSRB3  
* (rw)  DITCSRB4  
* (rw)  DITCSRB5  
*
\******************************************************************************/

  #define _MCASP_DITCSRA0_OFFSET               64
  #define _MCASP_DITCSRA1_OFFSET               65
  #define _MCASP_DITCSRA2_OFFSET               66
  #define _MCASP_DITCSRA3_OFFSET               67
  #define _MCASP_DITCSRA4_OFFSET               68
  #define _MCASP_DITCSRA5_OFFSET               69

  #define _MCASP_DITCSRB0_OFFSET               70
  #define _MCASP_DITCSRB1_OFFSET               71
  #define _MCASP_DITCSRB2_OFFSET               72
  #define _MCASP_DITCSRB3_OFFSET               73
  #define _MCASP_DITCSRB4_OFFSET               74
  #define _MCASP_DITCSRB5_OFFSET               75

/* registers for MCASP0 */  
  #define _MCASP_DITCSR0_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRA0_OFFSET)
  #define _MCASP_DITCSRA00_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRA0_OFFSET)
  #define _MCASP_DITCSRA10_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRA1_OFFSET)
  #define _MCASP_DITCSRA20_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRA2_OFFSET)
  #define _MCASP_DITCSRA30_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRA3_OFFSET)
  #define _MCASP_DITCSRA40_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRA4_OFFSET)
  #define _MCASP_DITCSRA50_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRA5_OFFSET)

  #define _MCASP_DITCSRB00_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRB0_OFFSET)
  #define _MCASP_DITCSRB10_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRB1_OFFSET)
  #define _MCASP_DITCSRB20_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRB2_OFFSET)
  #define _MCASP_DITCSRB30_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRB3_OFFSET)
  #define _MCASP_DITCSRB40_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRB4_OFFSET)
  #define _MCASP_DITCSRB50_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITCSRB5_OFFSET)

/* registers for MCASP1 */   
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DITCSR1_ADDR                  (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRA0_OFFSET)
  #define _MCASP_DITCSRA01_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRA0_OFFSET)
  #define _MCASP_DITCSRA11_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRA1_OFFSET)
  #define _MCASP_DITCSRA21_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRA2_OFFSET)
  #define _MCASP_DITCSRA31_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRA3_OFFSET)
  #define _MCASP_DITCSRA41_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRA4_OFFSET)
  #define _MCASP_DITCSRA51_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRA5_OFFSET)

  #define _MCASP_DITCSRB01_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRB0_OFFSET)
  #define _MCASP_DITCSRB11_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRB1_OFFSET)
  #define _MCASP_DITCSRB21_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRB2_OFFSET)
  #define _MCASP_DITCSRB31_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRB3_OFFSET)
  #define _MCASP_DITCSRB41_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRB4_OFFSET)
  #define _MCASP_DITCSRB51_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITCSRB5_OFFSET)
#endif


/******************************************************************************\
*  
* _____________________
* |                   |
* |       DITUDR      |
* |_______n: 0-15_____|
*
* DITUDR  -  User Data Register File
*
* FIELDS (msb -> lsb)
* (rw)  DITUDRA0	- Left (even TDM slot)  
* (rw)  DITUDRA1  
* (rw)  DITUDRA2  
* (rw)  DITUDRA3  
* (rw)  DITUDRA4  
* (rw)  DITUDRA5  
* (rw)  DITUDRB0  	- Right (odd TDM slot)
* (rw)  DITUDRB1  
* (rw)  DITUDRB2  
* (rw)  DITUDRB3  
* (rw)  DITUDRB4  
* (rw)  DITUDRB5  
*
\******************************************************************************/

  #define _MCASP_DITUDRA0_OFFSET               76
  #define _MCASP_DITUDRA1_OFFSET               77
  #define _MCASP_DITUDRA2_OFFSET               78
  #define _MCASP_DITUDRA3_OFFSET               79
  #define _MCASP_DITUDRA4_OFFSET               80
  #define _MCASP_DITUDRA5_OFFSET               81

  #define _MCASP_DITUDRB0_OFFSET               82
  #define _MCASP_DITUDRB1_OFFSET               83
  #define _MCASP_DITUDRB2_OFFSET               84
  #define _MCASP_DITUDRB3_OFFSET               85
  #define _MCASP_DITUDRB4_OFFSET               86
  #define _MCASP_DITUDRB5_OFFSET               87

  #define _MCASP_DITUDR0_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRA0_OFFSET)
  /* registers for MCASP0 */ 
  #define _MCASP_DITUDRA00_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRA0_OFFSET)
  #define _MCASP_DITUDRA10_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRA1_OFFSET)
  #define _MCASP_DITUDRA20_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRA2_OFFSET)
  #define _MCASP_DITUDRA30_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRA3_OFFSET)
  #define _MCASP_DITUDRA40_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRA4_OFFSET)
  #define _MCASP_DITUDRA50_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRA5_OFFSET)

  #define _MCASP_DITUDRB00_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRB0_OFFSET)
  #define _MCASP_DITUDRB10_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRB1_OFFSET)
  #define _MCASP_DITUDRB20_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRB2_OFFSET)
  #define _MCASP_DITUDRB30_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRB3_OFFSET)
  #define _MCASP_DITUDRB40_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRB4_OFFSET)
  #define _MCASP_DITUDRB50_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_DITUDRB5_OFFSET)

/* registers for MCASP1 */ 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_DITUDR1_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRA0_OFFSET)
  #define _MCASP_DITUDRA01_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRA0_OFFSET)
  #define _MCASP_DITUDRA11_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRA1_OFFSET)
  #define _MCASP_DITUDRA21_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRA2_OFFSET)
  #define _MCASP_DITUDRA31_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRA3_OFFSET)
  #define _MCASP_DITUDRA41_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRA4_OFFSET)
  #define _MCASP_DITUDRA51_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRA5_OFFSET)
  #define _MCASP_DITUDRB01_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRB0_OFFSET)
  #define _MCASP_DITUDRB11_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRB1_OFFSET)
  #define _MCASP_DITUDRB21_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRB2_OFFSET)
  #define _MCASP_DITUDRB31_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRB3_OFFSET)
  #define _MCASP_DITUDRB41_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRB4_OFFSET)
  #define _MCASP_DITUDRB51_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_DITUDRB5_OFFSET)
#endif


/******************************************************************************\
*  
* _____________________
* |                   |
* |       SRCTL       |
* |_______n: 0-15_____|
*
* SRCTL  -  Serializer Control Registers
*
* FIELDS (msb -> lsb)
* (r )  RRDY  
* (r )  XRDY  
* (rw)  DISMOD  
* (rw)  SRMOD 
*
\******************************************************************************/

  #define _MCASP_SRCTL0_OFFSET               96
  #define _MCASP_SRCTL1_OFFSET               97
  #define _MCASP_SRCTL2_OFFSET               98
  #define _MCASP_SRCTL3_OFFSET               99
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL4_OFFSET               100
  #define _MCASP_SRCTL5_OFFSET               101
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL6_OFFSET               102
  #define _MCASP_SRCTL7_OFFSET               103
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL8_OFFSET               104
  #define _MCASP_SRCTL9_OFFSET               105
  #define _MCASP_SRCTL10_OFFSET              106
  #define _MCASP_SRCTL11_OFFSET              107
  #define _MCASP_SRCTL12_OFFSET              108
  #define _MCASP_SRCTL13_OFFSET              109
  #define _MCASP_SRCTL14_OFFSET              110
  #define _MCASP_SRCTL15_OFFSET              111
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_SRCTL0_ADDR                  (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL0_OFFSET)
 /* registers for MCASP0 */ 

  #define _MCASP_SRCTL00_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL0_OFFSET)
  #define _MCASP_SRCTL10_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL1_OFFSET)
  #define _MCASP_SRCTL20_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL2_OFFSET)
  #define _MCASP_SRCTL30_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL3_OFFSET)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL40_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL4_OFFSET)
  #define _MCASP_SRCTL50_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL5_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL60_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL6_OFFSET)
  #define _MCASP_SRCTL70_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL7_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL80_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL8_OFFSET)
  #define _MCASP_SRCTL90_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL9_OFFSET)
  #define _MCASP_SRCTL100_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL10_OFFSET)
  #define _MCASP_SRCTL110_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL11_OFFSET)
  #define _MCASP_SRCTL120_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL12_OFFSET)
  #define _MCASP_SRCTL130_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL13_OFFSET)
  #define _MCASP_SRCTL140_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL14_OFFSET)
  #define _MCASP_SRCTL150_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_SRCTL15_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 16 */

/* registers for MCASP1 */ 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_SRCTL1_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL0_OFFSET)
  #define _MCASP_SRCTL01_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL0_OFFSET)
  #define _MCASP_SRCTL11_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL1_OFFSET)
  #define _MCASP_SRCTL21_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL2_OFFSET)
  #define _MCASP_SRCTL31_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL3_OFFSET)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

 #if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL41_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL4_OFFSET)
  #define _MCASP_SRCTL51_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL5_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 6 */

 #if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL61_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL6_OFFSET)
  #define _MCASP_SRCTL71_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL7_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 8 */

 #if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL81_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL8_OFFSET)
  #define _MCASP_SRCTL91_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL9_OFFSET)
  #define _MCASP_SRCTL101_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL10_OFFSET)
  #define _MCASP_SRCTL111_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL11_OFFSET)
  #define _MCASP_SRCTL121_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL12_OFFSET)
  #define _MCASP_SRCTL131_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL13_OFFSET)
  #define _MCASP_SRCTL141_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL14_OFFSET)
  #define _MCASP_SRCTL151_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_SRCTL15_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 16 */
#endif

  #define _MCASP_SRCTL_RRDY_MASK              0x00000020u
  #define _MCASP_SRCTL_RRDY_SHIFT             0x00000005u
  #define  MCASP_SRCTL_RRDY_DEFAULT           0x00000000u
  #define  MCASP_SRCTL_RRDY_OF(x)             _VALUEOF(x)
  
  #define _MCASP_SRCTL_XRDY_MASK              0x00000010u
  #define _MCASP_SRCTL_XRDY_SHIFT             0x00000004u
  #define  MCASP_SRCTL_XRDY_DEFAULT           0x00000000u
  #define  MCASP_SRCTL_XRDY_OF(x)             _VALUEOF(x)
  
  
  #define _MCASP_SRCTL_DISMOD_MASK              0x0000000Cu
  #define _MCASP_SRCTL_DISMOD_SHIFT             0x00000002u
  #define  MCASP_SRCTL_DISMOD_DEFAULT           0x00000000u
  #define  MCASP_SRCTL_DISMOD_OF(x)             _VALUEOF(x)
  #define  MCASP_SRCTL_DISMOD_LOW               0x00000002u
  #define  MCASP_SRCTL_DISMOD_HIGH              0x00000003u
  #define  MCASP_SRCTL_DISMOD_3STATE            0x00000000u


  #define _MCASP_SRCTL_SRMOD_MASK              0x00000003u
  #define _MCASP_SRCTL_SRMOD_SHIFT             0x00000000u
  #define  MCASP_SRCTL_SRMOD_DEFAULT           0x00000000u
  #define  MCASP_SRCTL_SRMOD_OF(x)             _VALUEOF(x)
  #define  MCASP_SRCTL_SRMOD_INACTIVE          0x00000000u
  #define  MCASP_SRCTL_SRMOD_XMT               0x00000001u
  #define  MCASP_SRCTL_SRMOD_RCV               0x00000002u

  #define  MCASP_SRCTL_OF(x)                _VALUEOF(x)

  #define MCASP_SRCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(MCASP,SRCTL,RRDY)\
| _PER_FDEFAULT(MCASP,SRCTL,XRDY)\
| _PER_FDEFAULT(MCASP,SRCTL,DISMOD)\
| _PER_FDEFAULT(MCASP,SRCTL,SRMOD)\
  )

  #define MCASP_SRCTL_RMK(dismod, srmod) (Uint32)( \
     	  _PER_FMK(MCASP,SRCTL,DISMOD,dismod)\
	| _PER_FMK(MCASP,SRCTL,SRMOD,srmod)\
  )


  #define _MCASP_SRCTL_FGET(M,N,FIELD)\
    _PER_FGET(_MCASP_SRCTL##M##N##_ADDR,MCASP,SRCTL,##FIELD)

  #define _MCASP_SRCTL_FSET(M,N,FIELD,f)\
    _PER_FSET(_MCASP_SRCTL##M##N##_ADDR,MCASP,SRCTL,##FIELD,f)

  #define _MCASP_SRCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCASP_SRCTL##M##N##_ADDR,MCASP,SRCTL,##FIELD,##SYM)

  #define _MCASP_SRCTL00_FGET(FIELD)  _MCASP_SRCTL_FGET(0,0,##FIELD)
  #define _MCASP_SRCTL10_FGET(FIELD)  _MCASP_SRCTL_FGET(1,0,##FIELD)
  #define _MCASP_SRCTL20_FGET(FIELD)  _MCASP_SRCTL_FGET(2,0,##FIELD)
  #define _MCASP_SRCTL30_FGET(FIELD)  _MCASP_SRCTL_FGET(3,0,##FIELD)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL40_FGET(FIELD)  _MCASP_SRCTL_FGET(4,0,##FIELD)
  #define _MCASP_SRCTL50_FGET(FIELD)  _MCASP_SRCTL_FGET(5,0,##FIELD)
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL60_FGET(FIELD)  _MCASP_SRCTL_FGET(6,0,##FIELD)
  #define _MCASP_SRCTL70_FGET(FIELD)  _MCASP_SRCTL_FGET(7,0,##FIELD)
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL80_FGET(FIELD)  _MCASP_SRCTL_FGET(8,0,##FIELD)
  #define _MCASP_SRCTL90_FGET(FIELD)  _MCASP_SRCTL_FGET(9,0,##FIELD)
  #define _MCASP_SRCTL100_FGET(FIELD) _MCASP_SRCTL_FGET(10,0,##FIELD)
  #define _MCASP_SRCTL110_FGET(FIELD) _MCASP_SRCTL_FGET(11,0,##FIELD)
  #define _MCASP_SRCTL120_FGET(FIELD) _MCASP_SRCTL_FGET(12,0,##FIELD)
  #define _MCASP_SRCTL130_FGET(FIELD) _MCASP_SRCTL_FGET(13,0,##FIELD)
  #define _MCASP_SRCTL140_FGET(FIELD) _MCASP_SRCTL_FGET(14,0,##FIELD)
  #define _MCASP_SRCTL150_FGET(FIELD) _MCASP_SRCTL_FGET(15,0,##FIELD)
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_SRCTL00_FSET(FIELD,f)  _MCASP_SRCTL_FSET(0,0,##FIELD,f)
  #define _MCASP_SRCTL10_FSET(FIELD,f)  _MCASP_SRCTL_FSET(1,0,##FIELD,f)
  #define _MCASP_SRCTL20_FSET(FIELD,f)  _MCASP_SRCTL_FSET(2,0,##FIELD,f)
  #define _MCASP_SRCTL30_FSET(FIELD,f)  _MCASP_SRCTL_FSET(3,0,##FIELD,f)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL40_FSET(FIELD,f)  _MCASP_SRCTL_FSET(4,0,##FIELD,f)
  #define _MCASP_SRCTL50_FSET(FIELD,f)  _MCASP_SRCTL_FSET(5,0,##FIELD,f)
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL60_FSET(FIELD,f)  _MCASP_SRCTL_FSET(6,0,##FIELD,f)
  #define _MCASP_SRCTL70_FSET(FIELD,f)  _MCASP_SRCTL_FSET(7,0,##FIELD,f)
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL80_FSET(FIELD,f)  _MCASP_SRCTL_FSET(8,0,##FIELD,f)
  #define _MCASP_SRCTL90_FSET(FIELD,f)  _MCASP_SRCTL_FSET(9,0,##FIELD,f)
  #define _MCASP_SRCTL100_FSET(FIELD,f) _MCASP_SRCTL_FSET(10,0,##FIELD,f)
  #define _MCASP_SRCTL110_FSET(FIELD,f) _MCASP_SRCTL_FSET(11,0,##FIELD,f)
  #define _MCASP_SRCTL120_FSET(FIELD,f) _MCASP_SRCTL_FSET(12,0,##FIELD,f)
  #define _MCASP_SRCTL130_FSET(FIELD,f) _MCASP_SRCTL_FSET(13,0,##FIELD,f)
  #define _MCASP_SRCTL140_FSET(FIELD,f) _MCASP_SRCTL_FSET(14,0,##FIELD,f)
  #define _MCASP_SRCTL150_FSET(FIELD,f) _MCASP_SRCTL_FSET(15,0,##FIELD,f)
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_SRCTL00_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(0,0,##FIELD,##SYM)
  #define _MCASP_SRCTL10_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(1,0,##FIELD,##SYM)
  #define _MCASP_SRCTL20_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(2,0,##FIELD,##SYM)
  #define _MCASP_SRCTL30_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(3,0,##FIELD,##SYM)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL40_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(4,0,##FIELD,##SYM)
  #define _MCASP_SRCTL50_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(5,0,##FIELD,##SYM)
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL60_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(6,0,##FIELD,##SYM)
  #define _MCASP_SRCTL70_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(7,0,##FIELD,##SYM)
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL80_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(8,0,##FIELD,##SYM)
  #define _MCASP_SRCTL90_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(9,0,##FIELD,##SYM)
  #define _MCASP_SRCTL100_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(10,0,##FIELD,##SYM)
  #define _MCASP_SRCTL110_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(11,0,##FIELD,##SYM)
  #define _MCASP_SRCTL120_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(12,0,##FIELD,##SYM)
  #define _MCASP_SRCTL130_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(13,0,##FIELD,##SYM)
  #define _MCASP_SRCTL140_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(14,0,##FIELD,##SYM)
  #define _MCASP_SRCTL150_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(15,0,##FIELD,##SYM)
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_SRCTL01_FGET(FIELD)  _MCASP_SRCTL_FGET(0,1,##FIELD)
  #define _MCASP_SRCTL11_FGET(FIELD)  _MCASP_SRCTL_FGET(1,1,##FIELD)
  #define _MCASP_SRCTL21_FGET(FIELD)  _MCASP_SRCTL_FGET(2,1,##FIELD)
  #define _MCASP_SRCTL31_FGET(FIELD)  _MCASP_SRCTL_FGET(3,1,##FIELD)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

 #if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL41_FGET(FIELD)  _MCASP_SRCTL_FGET(4,1,##FIELD)
  #define _MCASP_SRCTL51_FGET(FIELD)  _MCASP_SRCTL_FGET(5,1,##FIELD)
 #endif /* _MCASP_CHANNEL_CNT == 6 */

 #if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL61_FGET(FIELD)  _MCASP_SRCTL_FGET(6,1,##FIELD)
  #define _MCASP_SRCTL71_FGET(FIELD)  _MCASP_SRCTL_FGET(7,1,##FIELD)
 #endif /* _MCASP_CHANNEL_CNT == 8 */

 #if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL81_FGET(FIELD)  _MCASP_SRCTL_FGET(8,1,##FIELD)
  #define _MCASP_SRCTL91_FGET(FIELD)  _MCASP_SRCTL_FGET(9,1,##FIELD)
  #define _MCASP_SRCTL101_FGET(FIELD) _MCASP_SRCTL_FGET(10,1,##FIELD)
  #define _MCASP_SRCTL111_FGET(FIELD) _MCASP_SRCTL_FGET(11,1,##FIELD)
  #define _MCASP_SRCTL121_FGET(FIELD) _MCASP_SRCTL_FGET(12,1,##FIELD)
  #define _MCASP_SRCTL131_FGET(FIELD) _MCASP_SRCTL_FGET(13,1,##FIELD)
  #define _MCASP_SRCTL141_FGET(FIELD) _MCASP_SRCTL_FGET(14,1,##FIELD)
  #define _MCASP_SRCTL151_FGET(FIELD) _MCASP_SRCTL_FGET(15,1,##FIELD)
 #endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_SRCTL01_FSET(FIELD,f)  _MCASP_SRCTL_FSET(0,1,##FIELD,f)
  #define _MCASP_SRCTL11_FSET(FIELD,f)  _MCASP_SRCTL_FSET(1,1,##FIELD,f)
  #define _MCASP_SRCTL21_FSET(FIELD,f)  _MCASP_SRCTL_FSET(2,1,##FIELD,f)
  #define _MCASP_SRCTL31_FSET(FIELD,f)  _MCASP_SRCTL_FSET(3,1,##FIELD,f)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

 #if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL41_FSET(FIELD,f)  _MCASP_SRCTL_FSET(4,1,##FIELD,f)
  #define _MCASP_SRCTL51_FSET(FIELD,f)  _MCASP_SRCTL_FSET(5,1,##FIELD,f)
 #endif /* _MCASP_CHANNEL_CNT == 6 */

 #if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL61_FSET(FIELD,f)  _MCASP_SRCTL_FSET(6,1,##FIELD,f)
  #define _MCASP_SRCTL71_FSET(FIELD,f)  _MCASP_SRCTL_FSET(7,1,##FIELD,f)
 #endif /* _MCASP_CHANNEL_CNT == 8 */

 #if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL81_FSET(FIELD,f)  _MCASP_SRCTL_FSET(8,1,##FIELD,f)
  #define _MCASP_SRCTL91_FSET(FIELD,f)  _MCASP_SRCTL_FSET(9,1,##FIELD,f)
  #define _MCASP_SRCTL101_FSET(FIELD,f) _MCASP_SRCTL_FSET(10,1,##FIELD,f)
  #define _MCASP_SRCTL111_FSET(FIELD,f) _MCASP_SRCTL_FSET(11,1,##FIELD,f)
  #define _MCASP_SRCTL121_FSET(FIELD,f) _MCASP_SRCTL_FSET(12,1,##FIELD,f)
  #define _MCASP_SRCTL131_FSET(FIELD,f) _MCASP_SRCTL_FSET(13,1,##FIELD,f)
  #define _MCASP_SRCTL141_FSET(FIELD,f) _MCASP_SRCTL_FSET(14,1,##FIELD,f)
  #define _MCASP_SRCTL151_FSET(FIELD,f) _MCASP_SRCTL_FSET(15,1,##FIELD,f)
 #endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_SRCTL01_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(0,1,##FIELD,##SYM)
  #define _MCASP_SRCTL11_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(1,1,##FIELD,##SYM)
  #define _MCASP_SRCTL21_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(2,1,##FIELD,##SYM)
  #define _MCASP_SRCTL31_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(3,1,##FIELD,##SYM)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

 #if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_SRCTL41_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(4,1,##FIELD,##SYM)
  #define _MCASP_SRCTL51_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(5,1,##FIELD,##SYM)
 #endif /* _MCASP_CHANNEL_CNT == 6 */

 #if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_SRCTL61_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(6,1,##FIELD,##SYM)
  #define _MCASP_SRCTL71_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(7,1,##FIELD,##SYM)
 #endif /* _MCASP_CHANNEL_CNT == 8 */

 #if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_SRCTL81_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(8,1,##FIELD,##SYM)
  #define _MCASP_SRCTL91_FSETS(FIELD,SYM)  _MCASP_SRCTL_FSETS(9,1,##FIELD,##SYM)
  #define _MCASP_SRCTL101_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(10,1,##FIELD,##SYM)
  #define _MCASP_SRCTL111_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(11,1,##FIELD,##SYM)
  #define _MCASP_SRCTL121_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(12,1,##FIELD,##SYM)
  #define _MCASP_SRCTL131_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(13,1,##FIELD,##SYM)
  #define _MCASP_SRCTL141_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(14,1,##FIELD,##SYM)
  #define _MCASP_SRCTL151_FSETS(FIELD,SYM) _MCASP_SRCTL_FSETS(15,1,##FIELD,##SYM)
 #endif /* _MCASP_CHANNEL_CNT == 16 */                              
#endif


/******************************************************************************\
*  
* _____________________
* |                   |
* |       XBUF        |
* |_______n: 0-15_____|
*
* XBUF  -  Transmit Buffer for Serializers
*
*
\******************************************************************************/
  
  #define _MCASP_XBUF0_ADDR                 0x3C000000u
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XBUF1_ADDR                 0x3C100000u
#endif

  #define _MCASP_XBUF0_OFFSET               128
  #define _MCASP_XBUF1_OFFSET               129
  #define _MCASP_XBUF2_OFFSET               130
  #define _MCASP_XBUF3_OFFSET               131
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_XBUF4_OFFSET               132
  #define _MCASP_XBUF5_OFFSET               133
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_XBUF6_OFFSET               134
  #define _MCASP_XBUF7_OFFSET               135
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_XBUF8_OFFSET               136
  #define _MCASP_XBUF9_OFFSET               137
  #define _MCASP_XBUF10_OFFSET              138
  #define _MCASP_XBUF11_OFFSET              139
  #define _MCASP_XBUF12_OFFSET              140
  #define _MCASP_XBUF13_OFFSET              141
  #define _MCASP_XBUF14_OFFSET              142
  #define _MCASP_XBUF15_OFFSET              143
#endif /* _MCASP_CHANNEL_CNT == 16 */


  #define _MCASP_XBUF00_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF0_OFFSET)
  #define _MCASP_XBUF10_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF1_OFFSET)
  #define _MCASP_XBUF20_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF2_OFFSET)
  #define _MCASP_XBUF30_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF3_OFFSET)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_XBUF40_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF4_OFFSET)
  #define _MCASP_XBUF50_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF5_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_XBUF60_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF6_OFFSET)
  #define _MCASP_XBUF70_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF7_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_XBUF80_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF8_OFFSET)
  #define _MCASP_XBUF90_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF9_OFFSET)
  #define _MCASP_XBUF100_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF10_OFFSET)
  #define _MCASP_XBUF110_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF11_OFFSET)
  #define _MCASP_XBUF120_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF12_OFFSET)
  #define _MCASP_XBUF130_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF13_OFFSET)
  #define _MCASP_XBUF140_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF14_OFFSET)
  #define _MCASP_XBUF150_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_XBUF15_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 16 */
 
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_XBUF01_ADDR               (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF0_OFFSET)
  #define _MCASP_XBUF11_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF1_OFFSET)
  #define _MCASP_XBUF21_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF2_OFFSET)
  #define _MCASP_XBUF31_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF3_OFFSET)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

 #if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_XBUF41_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF4_OFFSET)
  #define _MCASP_XBUF51_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF5_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 6 */

 #if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_XBUF61_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF6_OFFSET)
  #define _MCASP_XBUF71_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF7_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 8 */

 #if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_XBUF81_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF8_OFFSET)
  #define _MCASP_XBUF91_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF9_OFFSET)
  #define _MCASP_XBUF101_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF10_OFFSET)
  #define _MCASP_XBUF111_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF11_OFFSET)
  #define _MCASP_XBUF121_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF12_OFFSET)
  #define _MCASP_XBUF131_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF13_OFFSET)
  #define _MCASP_XBUF141_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF14_OFFSET)
  #define _MCASP_XBUF151_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_XBUF15_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 16 */
#endif
  

/******************************************************************************\
*  
* _____________________
* |                   |
* |       RBUF        |
* |_______n: 0-15_____|
*
* RBUF  -  Receive Buffer for Serializers
*
*
\******************************************************************************/

  #define _MCASP_RBUF0_ADDR                 0x3C000000u
#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RBUF1_ADDR                 0x3C100000u
#endif


  #define _MCASP_RBUF0_OFFSET               160
  #define _MCASP_RBUF1_OFFSET               161
  #define _MCASP_RBUF2_OFFSET               162
  #define _MCASP_RBUF3_OFFSET               163
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_RBUF4_OFFSET               164
  #define _MCASP_RBUF5_OFFSET               165
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_RBUF6_OFFSET               166
  #define _MCASP_RBUF7_OFFSET               167
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_RBUF8_OFFSET               168
  #define _MCASP_RBUF9_OFFSET               169
  #define _MCASP_RBUF10_OFFSET               170
  #define _MCASP_RBUF11_OFFSET               171
  #define _MCASP_RBUF12_OFFSET               172
  #define _MCASP_RBUF13_OFFSET               173
  #define _MCASP_RBUF14_OFFSET               174
  #define _MCASP_RBUF15_OFFSET               175
#endif /* _MCASP_CHANNEL_CNT == 16 */

  #define _MCASP_RBUF00_ADDR               (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF0_OFFSET)
  #define _MCASP_RBUF10_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF1_OFFSET)
  #define _MCASP_RBUF20_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF2_OFFSET)
  #define _MCASP_RBUF30_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF3_OFFSET)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

#if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_RBUF40_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF4_OFFSET)
  #define _MCASP_RBUF50_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF5_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 6 */

#if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_RBUF60_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF6_OFFSET)
  #define _MCASP_RBUF70_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF7_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 8 */

#if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_RBUF80_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF8_OFFSET)
  #define _MCASP_RBUF90_ADDR                 (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF9_OFFSET)
  #define _MCASP_RBUF100_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF10_OFFSET)
  #define _MCASP_RBUF110_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF11_OFFSET)
  #define _MCASP_RBUF120_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF12_OFFSET)
  #define _MCASP_RBUF130_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF13_OFFSET)
  #define _MCASP_RBUF140_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF14_OFFSET)
  #define _MCASP_RBUF150_ADDR                (_MCASP_BASE_PORT0 + 4*_MCASP_RBUF15_OFFSET)
#endif /* _MCASP_CHANNEL_CNT == 16 */

#if (_MCASP_PORT_CNT > 1)
  #define _MCASP_RBUF01_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF0_OFFSET)
  #define _MCASP_RBUF11_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF1_OFFSET)
  #define _MCASP_RBUF21_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF2_OFFSET)
  #define _MCASP_RBUF31_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF3_OFFSET)
 /* Fields for _MCASP_CHANNEL_CNT == 4 end here*/

 #if (_MCASP_CHANNEL_CNT > 4)
  #define _MCASP_RBUF41_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF4_OFFSET)
  #define _MCASP_RBUF51_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF5_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 6 */

 #if (_MCASP_CHANNEL_CNT > 6) /* For channel count 8 and 16 */
  #define _MCASP_RBUF61_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF6_OFFSET)
  #define _MCASP_RBUF71_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF7_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 8 */

 #if (_MCASP_CHANNEL_CNT == 16)
  #define _MCASP_RBUF81_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF8_OFFSET)
  #define _MCASP_RBUF91_ADDR                 (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF9_OFFSET)
  #define _MCASP_RBUF101_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF10_OFFSET)
  #define _MCASP_RBUF111_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF11_OFFSET)
  #define _MCASP_RBUF121_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF12_OFFSET)
  #define _MCASP_RBUF131_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF13_OFFSET)
  #define _MCASP_RBUF141_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF14_OFFSET)
  #define _MCASP_RBUF151_ADDR                (_MCASP_BASE_PORT1 + 4*_MCASP_RBUF15_OFFSET)
 #endif /* _MCASP_CHANNEL_CNT == 16 */
#endif


/******************************************************************\
* Step 5. #endif MODULE_SUPPORT and _CSL_MODULELHAL_H_
\******************************************************************/

#endif /* (MODULE_SUPPORT) */
#endif /* _CSL_MCASPHAL_H_ */
/******************************************************************************\
* End of csl_mcasphal.h
\******************************************************************************/

csl_mcbsp.h/    1030611972  0     0     0       16132     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mcbsp.h
* DATE CREATED.. 06/11/1999 
* LAST MODIFIED. 09/24/2001
*                      - MCBSP_read32 / MCBSP_write32
\******************************************************************************/
#ifndef _CSL_MCBSP_H_
#define _CSL_MCBSP_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_mcbsphal.h>


#if (MCBSP_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _MCBSP_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/

/* MCBSP_open() flags */
#define MCBSP_OPEN_RESET     (0x00000001)

/* Renaming MCBSP_read/write  */
#define MCBSP_read32 MCBSP_read 
#define MCBSP_write32 MCBSP_write 


/* pin identifiers used with MCBSP_getPins() and MCBSP_setPins() */
#define MCBSP_PIN_CLKX       _MCBSP_PCR_CLKXP_MASK
#define MCBSP_PIN_FSX        _MCBSP_PCR_FSXP_MASK
#define MCBSP_PIN_DX         _MCBSP_PCR_DXSTAT_MASK
#define MCBSP_PIN_CLKR       _MCBSP_PCR_CLKRP_MASK
#define MCBSP_PIN_FSR        _MCBSP_PCR_FSRP_MASK
#define MCBSP_PIN_DR         _MCBSP_PCR_DRSTAT_MASK
#define MCBSP_PIN_CLKS       _MCBSP_PCR_CLKSSTAT_MASK

/* device identifiers for MCBSP_open() */
#define MCBSP_DEV0    (0)
#define MCBSP_DEV1    (1)
#if (_MCBSP_PORT_CNT == 3)
  #define MCBSP_DEV2  (2)
#endif

/* device identifiers for MCBSP_open() */
#define MCBSP_PORT0    MCBSP_DEV0
#define MCBSP_PORT1    MCBSP_DEV1
#if (_MCBSP_PORT_CNT == 3)
  #define MCBSP_PORT2  MCBSP_DEV2
#endif

/* Constants for MCBSP_start */
#define MCBSP_RCV_START       (1u)
#define MCBSP_XMIT_START      (2u)
#define MCBSP_SRGR_START      (4u)
#define MCBSP_SRGR_FRAMESYNC  (8u)
#define MCBSP_SRGR_DEFAULT_DELAY  (0xFFFFFFFFu)

/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* device handle object */
typedef struct {
  Uint32 allocated;
  Uint32 xmtEventId;
  Uint32 rcvEventId;
  volatile Uint32 *baseAddr;
  Uint32 drrAddr;
  Uint32 dxrAddr;
} MCBSP_Obj, *MCBSP_Handle;

/* device configuration structure */
#if (!C64_SUPPORT)
typedef struct {
  Uint32 spcr;
  Uint32 rcr;
  Uint32 xcr;
  Uint32 srgr;
  Uint32 mcr;
  Uint32 rcer; 
  Uint32 xcer;
  Uint32 pcr;
} MCBSP_Config;
#else
typedef struct {
  Uint32 spcr;
  Uint32 rcr;
  Uint32 xcr;
  Uint32 srgr;
  Uint32 mcr;
  Uint32 rcere0;
  Uint32 rcere1;
  Uint32 rcere2;
  Uint32 rcere3;
  Uint32 xcere0;
  Uint32 xcere1;
  Uint32 xcere2;
  Uint32 xcere3;
  Uint32 pcr;
} MCBSP_Config;
#endif

/******************************************************************************\
* global variable declarations
\******************************************************************************/

/* predefined deviced handles for legacy - should not be used*/
extern far MCBSP_Handle _MCBSP_hDev0;
extern far MCBSP_Handle _MCBSP_hDev1;
#if (_MCBSP_PORT_CNT == 3)
  extern far MCBSP_Handle _MCBSP_hDev2;
#endif



/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void MCBSP_reset(MCBSP_Handle hMcbsp);
CSLAPI void MCBSP_resetAll();
CSLAPI void MCBSP_start(MCBSP_Handle hMcbsp, Uint32 startMask, Uint32 sampleratedelay); 

CSLAPI MCBSP_Handle MCBSP_open(int devNum, Uint32 flags);
CSLAPI void MCBSP_close(MCBSP_Handle hMcbsp);

CSLAPI Uint32 MCBSP_getPins(MCBSP_Handle hMcbsp);
CSLAPI void MCBSP_setPins(MCBSP_Handle hMcbsp, Uint32 pins);


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 MCBSP_getXmtAddr(MCBSP_Handle hMcbsp);
IDECL Uint32 MCBSP_getRcvAddr(MCBSP_Handle hMcbsp);
IDECL Uint32 MCBSP_getXmtEventId(MCBSP_Handle hMcbsp);
IDECL Uint32 MCBSP_getRcvEventId(MCBSP_Handle hMcbsp);

IDECL Uint32 MCBSP_read(MCBSP_Handle hMcbsp);
IDECL void   MCBSP_write(MCBSP_Handle hMcbsp, Uint32 val);

IDECL void   MCBSP_enableXmt(MCBSP_Handle hMcbsp);
IDECL void   MCBSP_enableRcv(MCBSP_Handle hMcbsp);
IDECL void   MCBSP_enableFsync(MCBSP_Handle hMcbsp);
IDECL void   MCBSP_enableSrgr(MCBSP_Handle hMcbsp);

IDECL Uint32 MCBSP_xrdy(MCBSP_Handle hMcbsp);
IDECL Uint32 MCBSP_rrdy(MCBSP_Handle hMcbsp);
IDECL Uint32 MCBSP_xempty(MCBSP_Handle hMcbsp);
IDECL Uint32 MCBSP_rfull(MCBSP_Handle hMcbsp);
IDECL Uint32 MCBSP_xsyncerr(MCBSP_Handle hMcbsp);
IDECL Uint32 MCBSP_rsyncerr(MCBSP_Handle hMcbsp);

IDECL void MCBSP_config(MCBSP_Handle hMcbsp, MCBSP_Config *config);

#if (!C64_SUPPORT) /* ?? added C64_SUPPORT */
IDECL void MCBSP_configArgs(MCBSP_Handle hMcbsp, Uint32 spcr, Uint32 rcr, 
  Uint32 xcr, Uint32 srgr, Uint32 mcr, Uint32 rcer, Uint32 xcer, Uint32 pcr);
#else /* (C64_SUPPORT) */
IDECL void MCBSP_configArgs(MCBSP_Handle hMcbsp, Uint32 spcr, Uint32 rcr, 
  Uint32 xcr, Uint32 srgr, Uint32 mcr, Uint32 rcere0, Uint32 rcere1, 
  Uint32 rcere2, Uint32 rcere3, Uint32 xcere0, Uint32 xcere1, Uint32 xcere2, 
  Uint32 xcere3, Uint32 pcr);
#endif

IDECL void MCBSP_getConfig(MCBSP_Handle hMcbsp, MCBSP_Config *config);


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_getXmtAddr(MCBSP_Handle hMcbsp) {
  return (Uint32)(hMcbsp->dxrAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_getRcvAddr(MCBSP_Handle hMcbsp) {
  return (Uint32)(hMcbsp->drrAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_getXmtEventId(MCBSP_Handle hMcbsp) {
  return (hMcbsp->xmtEventId);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_getRcvEventId(MCBSP_Handle hMcbsp) {
  return (hMcbsp->rcvEventId);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_read(MCBSP_Handle hMcbsp) {
  return (*(volatile Uint32 *)(hMcbsp->drrAddr));
}
/*----------------------------------------------------------------------------*/
IDEF void MCBSP_write(MCBSP_Handle hMcbsp, Uint32 val) {
  (*(volatile Uint32 *)(hMcbsp->dxrAddr)) = val;
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_xrdy(MCBSP_Handle hMcbsp) {
  return MCBSP_FGETH(hMcbsp,SPCR,XRDY);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_rrdy(MCBSP_Handle hMcbsp) {
  return MCBSP_FGETH(hMcbsp,SPCR,RRDY);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_xempty(MCBSP_Handle hMcbsp) {
  return MCBSP_FGETH(hMcbsp,SPCR,XEMPTY);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_rfull(MCBSP_Handle hMcbsp) {
  return MCBSP_FGETH(hMcbsp,SPCR,RFULL);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_xsyncerr(MCBSP_Handle hMcbsp) {
  return MCBSP_FGETH(hMcbsp,SPCR,XSYNCERR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 MCBSP_rsyncerr(MCBSP_Handle hMcbsp) {
  return MCBSP_FGETH(hMcbsp,SPCR,RSYNCERR);
}
/*----------------------------------------------------------------------------*/
IDEF void MCBSP_enableXmt(MCBSP_Handle hMcbsp) {
  MCBSP_FSETSH(hMcbsp,SPCR,XRST,NO);
}
/*----------------------------------------------------------------------------*/
IDEF void MCBSP_enableRcv(MCBSP_Handle hMcbsp) {
  MCBSP_FSETSH(hMcbsp,SPCR,RRST,NO);
}
/*----------------------------------------------------------------------------*/
IDEF void MCBSP_enableFsync(MCBSP_Handle hMcbsp) {
  MCBSP_FSETSH(hMcbsp,SPCR,FRST,NO);
}
/*----------------------------------------------------------------------------*/
IDEF void MCBSP_enableSrgr(MCBSP_Handle hMcbsp) {
  MCBSP_FSETSH(hMcbsp,SPCR,GRST,NO);
}
/*----------------------------------------------------------------------------*/
#if(!C64_SUPPORT) /* ?? added C64_SUPPORT */
IDEF void MCBSP_config(MCBSP_Handle hMcbsp, MCBSP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcbsp->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0 = config->spcr;
  x1 = config->rcr;
  x2 = config->xcr;
  x3 = config->srgr;
  x4 = config->mcr;
  x5 = config->rcer;
  x6 = config->xcer;
  x7 = config->pcr;

  base[_MCBSP_SPCR_OFFSET] = 0x00000000;
  base[_MCBSP_RCR_OFFSET]  = x1;
  base[_MCBSP_XCR_OFFSET]  = x2;
  base[_MCBSP_SRGR_OFFSET] = x3;
  base[_MCBSP_MCR_OFFSET]  = x4;
  base[_MCBSP_RCER_OFFSET] = x5;
  base[_MCBSP_XCER_OFFSET] = x6;
  base[_MCBSP_PCR_OFFSET]  = x7;
  base[_MCBSP_SPCR_OFFSET] = x0;

  IRQ_globalRestore(gie);
}
#else /* (C64_SUPPORT)*/
IDEF void MCBSP_config(MCBSP_Handle hMcbsp, MCBSP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcbsp->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0  = config->spcr;
  x1  = config->rcr;
  x2  = config->xcr;
  x3  = config->srgr;
  x4  = config->mcr;
  x5  = config->rcere0;
  x6  = config->rcere1;
  x7  = config->rcere2;
  x8  = config->rcere3;
  x9  = config->xcere0;
  x10 = config->xcere1;
  x11 = config->xcere2;
  x12 = config->xcere3;
  x13 = config->pcr;

  base[_MCBSP_SPCR_OFFSET]   = 0x00000000;
  base[_MCBSP_RCR_OFFSET]    = x1;
  base[_MCBSP_XCR_OFFSET]    = x2;
  base[_MCBSP_SRGR_OFFSET]   = x3;
  base[_MCBSP_MCR_OFFSET]    = x4;
  base[_MCBSP_RCERE0_OFFSET] = x5;
  base[_MCBSP_RCERE1_OFFSET] = x6;
  base[_MCBSP_RCERE2_OFFSET] = x7;
  base[_MCBSP_RCERE3_OFFSET] = x8;
  base[_MCBSP_XCERE0_OFFSET] = x9;
  base[_MCBSP_XCERE1_OFFSET] = x10;
  base[_MCBSP_XCERE2_OFFSET] = x11;
  base[_MCBSP_XCERE3_OFFSET] = x12;
  base[_MCBSP_PCR_OFFSET]    = x13;
  base[_MCBSP_SPCR_OFFSET]   = x0;

  IRQ_globalRestore(gie);
}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
#if (!C64_SUPPORT) /* ?? added C64_SUPPORT */
IDEF void MCBSP_configArgs(MCBSP_Handle hMcbsp, Uint32 spcr, Uint32 rcr, 
  Uint32 xcr, Uint32 srgr, Uint32 mcr, Uint32 rcer, Uint32 xcer, Uint32 pcr) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcbsp->baseAddr);

  gie = IRQ_globalDisable();

  base[_MCBSP_SPCR_OFFSET] = 0x00000000;
  base[_MCBSP_RCR_OFFSET]  = rcr;
  base[_MCBSP_XCR_OFFSET]  = xcr;
  base[_MCBSP_SRGR_OFFSET] = srgr;
  base[_MCBSP_MCR_OFFSET]  = mcr;
  base[_MCBSP_RCER_OFFSET] = rcer;
  base[_MCBSP_XCER_OFFSET] = xcer;
  base[_MCBSP_PCR_OFFSET]  = pcr;
  base[_MCBSP_SPCR_OFFSET] = spcr;

  IRQ_globalRestore(gie);
}
#else /* (C64_SUPPORT) */
IDEF void MCBSP_configArgs(MCBSP_Handle hMcbsp, Uint32 spcr, Uint32 rcr, 
  Uint32 xcr, Uint32 srgr, Uint32 mcr, Uint32 rcere0, Uint32 rcere1, 
  Uint32 rcere2, Uint32 rcere3, Uint32 xcere0, Uint32 xcere1, Uint32 xcere2, 
  Uint32 xcere3, Uint32 pcr) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcbsp->baseAddr);

  gie = IRQ_globalDisable();

  base[_MCBSP_SPCR_OFFSET]   = 0x00000000;
  base[_MCBSP_RCR_OFFSET]    = rcr;
  base[_MCBSP_XCR_OFFSET]    = xcr;
  base[_MCBSP_SRGR_OFFSET]   = srgr;
  base[_MCBSP_MCR_OFFSET]    = mcr;
  base[_MCBSP_RCERE0_OFFSET] = rcere0;
  base[_MCBSP_RCERE1_OFFSET] = rcere1;
  base[_MCBSP_RCERE2_OFFSET] = rcere2;
  base[_MCBSP_RCERE3_OFFSET] = rcere3;
  base[_MCBSP_XCERE0_OFFSET] = xcere0;
  base[_MCBSP_XCERE1_OFFSET] = xcere1;
  base[_MCBSP_XCERE2_OFFSET] = xcere2;
  base[_MCBSP_XCERE3_OFFSET] = xcere3;
  base[_MCBSP_PCR_OFFSET]    = pcr;
  base[_MCBSP_SPCR_OFFSET]   = spcr;

  IRQ_globalRestore(gie);
}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
#if (!C64_SUPPORT) /* ?? added C64_SUPPORT */
IDEF void MCBSP_getConfig(MCBSP_Handle hMcbsp, MCBSP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcbsp->baseAddr);
  volatile MCBSP_Config* cfg = (volatile MCBSP_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */

  x0 = base[_MCBSP_SPCR_OFFSET];
  x1 = base[_MCBSP_RCR_OFFSET];
  x2 = base[_MCBSP_XCR_OFFSET];
  x3 = base[_MCBSP_SRGR_OFFSET];
  x4 = base[_MCBSP_MCR_OFFSET];
  x5 = base[_MCBSP_RCER_OFFSET];
  x6 = base[_MCBSP_XCER_OFFSET];
  x7 = base[_MCBSP_PCR_OFFSET];

  cfg->spcr = x0;
  cfg->rcr  = x1;
  cfg->xcr  = x2;
  cfg->srgr = x3;
  cfg->mcr  = x4;
  cfg->rcer = x5;
  cfg->xcer = x6;
  cfg->pcr  = x7;

  IRQ_globalRestore(gie);
}
#else /* (C64_SUPPORT) */
IDEF void MCBSP_getConfig(MCBSP_Handle hMcbsp, MCBSP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hMcbsp->baseAddr);
  volatile MCBSP_Config* cfg = (volatile MCBSP_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */

  x0  = base[_MCBSP_SPCR_OFFSET];
  x1  = base[_MCBSP_RCR_OFFSET];
  x2  = base[_MCBSP_XCR_OFFSET];
  x3  = base[_MCBSP_SRGR_OFFSET];
  x4  = base[_MCBSP_MCR_OFFSET];
  x5  = base[_MCBSP_RCERE0_OFFSET];
  x6  = base[_MCBSP_RCERE1_OFFSET];
  x7  = base[_MCBSP_RCERE2_OFFSET];
  x8  = base[_MCBSP_RCERE3_OFFSET];
  x9  = base[_MCBSP_XCERE0_OFFSET];
  x10 = base[_MCBSP_XCERE1_OFFSET];
  x11 = base[_MCBSP_XCERE2_OFFSET];
  x12 = base[_MCBSP_XCERE3_OFFSET];
  x13 = base[_MCBSP_PCR_OFFSET];

  cfg->spcr   = x0;
  cfg->rcr    = x1;
  cfg->xcr    = x2;
  cfg->srgr   = x3;
  cfg->mcr    = x4;
  cfg->rcere0 = x5;
  cfg->rcere1 = x6;
  cfg->rcere2 = x7;
  cfg->rcere3 = x8;
  cfg->xcere0 = x9;
  cfg->xcere1 = x10;
  cfg->xcere2 = x11;
  cfg->xcere3 = x12;
  cfg->pcr    = x13;

  IRQ_globalRestore(gie);
}
#endif /* C64_SUPPORT */
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* MCBSP_SUPPORT */
#endif /* _CSL_MCBSP_H_ */
/******************************************************************************\
* End of csl_mcbsp.h
\******************************************************************************/

csl_mcbsphal.h/ 1092218723  0     0     0       80471     `
/******************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mcbsphal.h
* DATE CREATED.. 06/12/1999
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                10/02/2001
*                          - 6713 device addition
*                04/21/2004 - Fixed XCR0 bad address
*------------------------------------------------------------------------------
* REGISTERS
*
* DRR0  - serial port 0 data receive register
* DRR1  - serial port 1 data receive register
* DRR2  - serial port 2 data receive register (1)
* DXR0  - serial port 0 data transmit register
* DXR1  - serial port 1 data transmit register
* DXR2  - serial port 2 data transmit register (1)
* SPCR0 - serial port 0 control register
* SPCR1 - serial port 1 control register
* SPCR2 - serial port 2 control register (1)
* RCR0  - serial port 0 receive control register
* RCR1  - serial port 1 receive control register
* RCR2  - serial port 2 receive control register (1)
* XCR0  - serial port 0 transmit control register
* XCR1  - serial port 1 transmit control register
* XCR2  - serial port 2 transmit control register (1)
* SRGR0 - serial port 0 sample rate generator register
* SRGR1 - serial port 1 sample rate generator register
* SRGR2 - serial port 2 sample rate generator register (1)
* MCR0  - serial port 0 multichannel control register
* MCR1  - serial port 1 multichannel control register
* MCR2  - serial port 2 multichannel control register (1)
* RCER0 - serial port 0 receive channel enable register
* RCER1 - serial port 1 receive channel enable register
* RCER2 - serial port 2 receive channel enable register (1)
* XCER0 - serial port 0 transmit channel enable register
* XCER1 - serial port 1 transmit channel enable register
* XCER2 - serial port 2 transmit channel enable register (1)
* RCERE00 - serial port 0 Enhanced receive channel enable register 0 (2)
* RCERE01 - serial port 1 Enhanced receive channel enable register 0 (2)
* RCERE02 - serial port 2 Enhanced receive channel enable register 0 (2)
* RCERE10 - serial port 0 Enhanced receive channel enable register 1 (2)
* RCERE11 - serial port 1 Enhanced receive channel enable register 1 (2)
* RCERE12 - serial port 2 Enhanced receive channel enable register 1 (2)
* RCERE20 - serial port 0 Enhanced receive channel enable register 2 (2)
* RCERE21 - serial port 1 Enhanced receive channel enable register 2 (2)
* RCERE22 - serial port 2 Enhanced receive channel enable register 2 (2)
* RCERE30 - serial port 0 Enhanced receive channel enable register 3 (2)
* RCERE31 - serial port 1 Enhanced receive channel enable register 3 (2)
* RCERE32 - serial port 2 Enhanced receive channel enable register 3 (2)
* XCERE00 - serial port 0 Enhanced transmit channel enable register 0 (2)
* XCERE01 - serial port 1 Enhanced transmit channel enable register 0 (2)
* XCERE02 - serial port 2 Enhanced transmit channel enable register 0 (2)
* XCERE10 - serial port 0 Enhanced transmit channel enable register 1 (2)
* XCERE11 - serial port 1 Enhanced transmit channel enable register 1 (2)
* XCERE12 - serial port 2 Enhanced transmit channel enable register 1 (2)
* XCERE20 - serial port 0 Enhanced transmit channel enable register 2 (2)
* XCERE21 - serial port 1 Enhanced transmit channel enable register 2 (2)
* XCERE22 - serial port 2 Enhanced transmit channel enable register 2 (2)
* XCERE30 - serial port 0 Enhanced transmit channel enable register 3 (2)
* XCERE31 - serial port 1 Enhanced transmit channel enable register 3 (2)
* XCERE32 - serial port 2 Enhanced transmit channel enable register 3 (2)
* PCR0  - serial port 0 pin control register
* PCR1  - serial port 1 pin control register
* PCR2  - serial port 2 pin control register (1)
*
* (1) only supported on devices with three serial ports
* (2) supported by C64x devices (RCERx replaced by RCERE0x, XCERx replaced by XCERE0x)
*
\******************************************************************************/
#ifndef _CSL_MCBSPHAL_H_
#define _CSL_MCBSPHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (MCBSP_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/

#if (CHIP_6202|CHIP_6203|CHIP_6414|CHIP_6415|CHIP_6416)
  #define _MCBSP_PORT_CNT        3
  #define _MCBSP_BASE_PORT0      0x018C0000u
  #define _MCBSP_BASE_PORT1      0x01900000u
  #define _MCBSP_BASE_PORT2      0x01A40000u
#else
  #define _MCBSP_PORT_CNT        2
  #define _MCBSP_BASE_PORT0      0x018C0000u
  #define _MCBSP_BASE_PORT1      0x01900000u
#endif


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define MCBSP_FMK(REG,FIELD,x)\
    _PER_FMK(MCBSP,##REG,##FIELD,x)

  #define MCBSP_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(MCBSP,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define MCBSP_ADDR(REG)\
    _MCBSP_##REG##_ADDR

  #define MCBSP_RGET(REG)\
    _PER_RGET(_MCBSP_##REG##_ADDR,MCBSP,##REG)

  #define MCBSP_RSET(REG,x)\
    _PER_RSET(_MCBSP_##REG##_ADDR,MCBSP,##REG,x)

  #define MCBSP_FGET(REG,FIELD)\
    _MCBSP_##REG##_FGET(##FIELD)

  #define MCBSP_FSET(REG,FIELD,x)\
    _MCBSP_##REG##_FSET(##FIELD,##x)

  #define MCBSP_FSETS(REG,FIELD,SYM)\
    _MCBSP_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define MCBSP_RGETA(addr,REG)\
    _PER_RGET(addr,MCBSP,##REG)

  #define MCBSP_RSETA(addr,REG,x)\
    _PER_RSET(addr,MCBSP,##REG,x)

  #define MCBSP_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,MCBSP,##REG,##FIELD)

  #define MCBSP_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,MCBSP,##REG,##FIELD,x)

  #define MCBSP_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,MCBSP,##REG,##FIELD,##SYM)


  /* ----------------------------------------- */
  /* HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define MCBSP_ADDRH(h,REG)\
    (Uint32)(&((h)->baseAddr[_MCBSP_##REG##_OFFSET]))

  #define MCBSP_RGETH(h,REG)\
    MCBSP_RGETA(MCBSP_ADDRH(h,##REG),##REG)


  #define MCBSP_RSETH(h,REG,x)\
    MCBSP_RSETA(MCBSP_ADDRH(h,##REG),##REG,x)


  #define MCBSP_FGETH(h,REG,FIELD)\
    MCBSP_FGETA(MCBSP_ADDRH(h,##REG),##REG,##FIELD)


  #define MCBSP_FSETH(h,REG,FIELD,x)\
    MCBSP_FSETA(MCBSP_ADDRH(h,##REG),##REG,##FIELD,x)


  #define MCBSP_FSETSH(h,REG,FIELD,SYM)\
    MCBSP_FSETSA(MCBSP_ADDRH(h,##REG),##REG,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  D R R            |
* |___________________|
*
* DRR0  - serial port 0 data receive register
* DRR1  - serial port 1 data receive register
* DRR2  - serial port 2 data receive register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (r) DR
*
\******************************************************************************/
  #define _MCBSP_DRR_OFFSET            0

#if (C11_SUPPORT | C64_SUPPORT)
  #define _MCBSP_DRR0_ADDR             0x30000000u
  #define _MCBSP_DRR1_ADDR             0x34000000u
#else
  #define _MCBSP_DRR0_ADDR             0x018C0000u
  #define _MCBSP_DRR1_ADDR             0x01900000u
#endif

#if (_MCBSP_PORT_CNT==3 && (CHIP_6202 | CHIP_6203 ) )
  #define _MCBSP_DRR2_ADDR             0x01A40000u
#endif

#if (_MCBSP_PORT_CNT==3 && (CHIP_6414 | CHIP_6415 | CHIP_6416))
  #define _MCBSP_DRR2_ADDR             0x38000000u
#endif

  #define _MCBSP_DRR_DR_MASK           0xFFFFFFFFu
  #define _MCBSP_DRR_DR_SHIFT          0x00000000u
  #define  MCBSP_DRR_DR_DEFAULT        0x00000000u
  #define  MCBSP_DRR_DR_OF(x)          _VALUEOF(x)

  #define  MCBSP_DRR_OF(x)             _VALUEOF(x)

  #define MCBSP_DRR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(MCBSP,DRR,DR)\
  )

 #if (CHIP_6413 | CHIP_6418 | CHIP_6410)
  #define MCBSP_DRR_RMK(dr) (Uint32)(\
    _PER_FMK(MCBSP,DRR,DR,dr)\
  )
 #endif

  #define _MCBSP_DRR_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_DRR##N##_ADDR,MCBSP,DRR,##FIELD)
  #define _MCBSP_DRR_FSET(N,FIELD,field)\
     _PER_FSET(_MCBSP_DRR##N##_ADDR,MCBSP,DRR,##FIELD,field)	
  #define _MCBSP_DRR_FSETS(N,FIELD,SYM)\
     _PER_FSETS(_MCBSP_DRR##N##_ADDR,MCBSP,DRR,##FIELD,##SYM) 	
  #define _MCBSP_DRR0_FGET(FIELD) _MCBSP_DRR_FGET(0,##FIELD)
  #define _MCBSP_DRR1_FGET(FIELD) _MCBSP_DRR_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_DRR2_FGET(FIELD) _MCBSP_DRR_FGET(2,##FIELD)
#endif
  #define _MCBSP_DRR0_FSET(FIELD,f) _MCBSP_DRR_FSET(0,##FIELD,f)	
  #define _MCBSP_DRR1_FSET(FIELD,f) _MCBSP_DRR_FSET(1,##FIELD,f)	
#if(_MCBSP_PORT_CNT==3)  	
  #define _MCBSP_DRR2_FSET(FIELD,f) _MCBSP_DRR_FSET(2,##FIELD,f)	
#endif	
  #define _MCBSP_DRR0_FSETS(FIELD,SYM) _MCBSP_DRR_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_DRR1_FSETS(FIELD,SYM) _MCBSP_DRR_FSETS(1,##FIELD,##SYM)
#if(_MCBSP_PORT_CNT==3)	
  #define _MCBSP_DRR2_FSETS(FIELD,SYM) _MCBSP_DRR_FSETS(2,##FIELD,##SYM)	
#endif	
/******************************************************************************\
* _____________________
* |                   |
* |  D X R            |
* |___________________|
*
* DXR0  - serial port 0 data transmit register
* DXR1  - serial port 1 data transmit register
* DXR2  - serial port 2 data transmit register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (w) DX
*
\******************************************************************************/
  #define _MCBSP_DXR_OFFSET            1

#if (C11_SUPPORT | C64_SUPPORT)
  #define _MCBSP_DXR0_ADDR             0x30000000u
  #define _MCBSP_DXR1_ADDR             0x34000000u
#else
  #define _MCBSP_DXR0_ADDR             0x018C0004u
  #define _MCBSP_DXR1_ADDR             0x01900004u
#endif

#if (_MCBSP_PORT_CNT==3 && (CHIP_6202 | CHIP_6203) )
  #define _MCBSP_DXR2_ADDR             0x01A40004u
#endif

#if (_MCBSP_PORT_CNT==3 && (CHIP_6414 | CHIP_6415 | CHIP_6416))
  #define _MCBSP_DXR2_ADDR             0x38000000u
#endif

  #define _MCBSP_DXR_DX_MASK           0xFFFFFFFFu
  #define _MCBSP_DXR_DX_SHIFT          0x00000000u
  #define  MCBSP_DXR_DX_DEFAULT        0x00000000u
  #define  MCBSP_DXR_DX_OF(x)          _VALUEOF(x)

  #define  MCBSP_DXR_OF(x)             _VALUEOF(x)

  #define MCBSP_DXR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(MCBSP,DXR,DX)\
  )

  #define MCBSP_DXR_RMK(dr) (Uint32)(\
    _PER_FMK(MCBSP,DXR,DX,dr)\
  )

  #define _MCBSP_DXR_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_DXR##N##_ADDR,MCBSP,DXR,##FIELD)

  #define _MCBSP_DXR_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_DXR##N##_ADDR,MCBSP,DXR,##FIELD,field)

  #define _MCBSP_DXR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_DXR##N##_ADDR,MCBSP,DXR,##FIELD,##SYM)

  #define _MCBSP_DXR0_FGET(FIELD) _MCBSP_DXR_FGET(0,##FIELD)
  #define _MCBSP_DXR1_FGET(FIELD) _MCBSP_DXR_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_DXR2_FGET(FIELD) _MCBSP_DXR_FGET(2,##FIELD)
#endif

  #define _MCBSP_DXR0_FSET(FIELD,f) _MCBSP_DXR_FSET(0,##FIELD,f)
  #define _MCBSP_DXR1_FSET(FIELD,f) _MCBSP_DXR_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_DXR2_FSET(FIELD,f) _MCBSP_DXR_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_DXR0_FSETS(FIELD,SYM) _MCBSP_DXR_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_DXR1_FSETS(FIELD,SYM) _MCBSP_DXR_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_DXR2_FSETS(FIELD,SYM) _MCBSP_DXR_FSETS(2,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  S P C R          |
* |___________________|
*
* SPCR0 - serial port 0 control register
* SPCR1 - serial port 1 control register
* SPCR2 - serial port 2 control register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (rw) FREE (2)
* (rw) SOFT (2)
* (rw) FRST
* (rw) GRST
* (rw) XINTM
* (rw) XSYNCERR
* (r)  XEMPTY
* (r)  XRDY
* (rw) XRST
* (rw) DLB
* (rw) RJUST
* (rw) CLKSTP
* (rw) DXENA (2)
* (rw) RINTM
* (rw) RSYNCERR
* (r)  RFULL
* (r)  RRDY
* (rw) RRST
*
* (2) - C11_SUPPORT/C64_SUPPORT only
*
\******************************************************************************/
  #define _MCBSP_SPCR_OFFSET           2

  #define _MCBSP_SPCR0_ADDR            0x018C0008u
  #define _MCBSP_SPCR1_ADDR            0x01900008u

#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_SPCR2_ADDR            0x01A40008u
#endif

#if (C11_SUPPORT | C64_SUPPORT)
  #define _MCBSP_SPCR_FREE_MASK        0x02000000u
  #define _MCBSP_SPCR_FREE_SHIFT       0x00000019u
  #define  MCBSP_SPCR_FREE_DEFAULT     0x00000000u
  #define  MCBSP_SPCR_FREE_OF(x)       _VALUEOF(x)
  #define  MCBSP_SPCR_FREE_NO          0x00000000u
  #define  MCBSP_SPCR_FREE_YES         0x00000001u

  #define _MCBSP_SPCR_SOFT_MASK        0x01000000u
  #define _MCBSP_SPCR_SOFT_SHIFT       0x00000018u
  #define  MCBSP_SPCR_SOFT_DEFAULT     0x00000000u
  #define  MCBSP_SPCR_SOFT_OF(x)       _VALUEOF(x)
  #define  MCBSP_SPCR_SOFT_NO          0x00000000u
  #define  MCBSP_SPCR_SOFT_YES         0x00000001u

#endif

  #define _MCBSP_SPCR_FRST_MASK        0x00800000u
  #define _MCBSP_SPCR_FRST_SHIFT       0x00000017u
  #define  MCBSP_SPCR_FRST_DEFAULT     0x00000000u
  #define  MCBSP_SPCR_FRST_OF(x)       _VALUEOF(x)
  #define  MCBSP_SPCR_FRST_YES         0x00000000u
  #define  MCBSP_SPCR_FRST_0           0x00000000u
  #define  MCBSP_SPCR_FRST_NO          0x00000001u
  #define  MCBSP_SPCR_FRST_1           0x00000001u

  #define _MCBSP_SPCR_GRST_MASK        0x00400000u
  #define _MCBSP_SPCR_GRST_SHIFT       0x00000016u
  #define  MCBSP_SPCR_GRST_DEFAULT     0x00000000u
  #define  MCBSP_SPCR_GRST_OF(x)       _VALUEOF(x)
  #define  MCBSP_SPCR_GRST_YES         0x00000000u
  #define  MCBSP_SPCR_GRST_0           0x00000000u
  #define  MCBSP_SPCR_GRST_NO          0x00000001u
  #define  MCBSP_SPCR_GRST_1           0x00000001u

  #define _MCBSP_SPCR_XINTM_MASK       0x00300000u
  #define _MCBSP_SPCR_XINTM_SHIFT      0x00000014u
  #define  MCBSP_SPCR_XINTM_DEFAULT    0x00000000u
  #define  MCBSP_SPCR_XINTM_OF(x)      _VALUEOF(x)
  #define  MCBSP_SPCR_XINTM_XRDY       0x00000000u
  #define  MCBSP_SPCR_XINTM_EOS        0x00000001u
  #define  MCBSP_SPCR_XINTM_FRM        0x00000002u
  #define  MCBSP_SPCR_XINTM_XSYNCERR   0x00000003u

  #define _MCBSP_SPCR_XSYNCERR_MASK    0x00080000u
  #define _MCBSP_SPCR_XSYNCERR_SHIFT   0x00000013u
  #define  MCBSP_SPCR_XSYNCERR_DEFAULT 0x00000000u
  #define  MCBSP_SPCR_XSYNCERR_OF(x)   _VALUEOF(x)
  #define  MCBSP_SPCR_XSYNCERR_NO      0x00000000u
  #define  MCBSP_SPCR_XSYNCERR_0       0x00000000u
  #define  MCBSP_SPCR_XSYNCERR_YES     0x00000001u
  #define  MCBSP_SPCR_XSYNCERR_1       0x00000001u

  #define _MCBSP_SPCR_XEMPTY_MASK      0x00040000u
  #define _MCBSP_SPCR_XEMPTY_SHIFT     0x00000012u
  #define  MCBSP_SPCR_XEMPTY_DEFAULT   0x00000000u
  #define  MCBSP_SPCR_XEMPTY_OF(x)     _VALUEOF(x)
  #define  MCBSP_SPCR_XEMPTY_YES       0x00000000u
  #define  MCBSP_SPCR_XEMPTY_0        0x00000000u
  #define  MCBSP_SPCR_XEMPTY_NO        0x00000001u
  #define  MCBSP_SPCR_XEMPTY_1         0x00000001u

  #define _MCBSP_SPCR_XRDY_MASK        0x00020000u
  #define _MCBSP_SPCR_XRDY_SHIFT       0x00000011u
  #define  MCBSP_SPCR_XRDY_DEFAULT     0x00000000u
  #define  MCBSP_SPCR_XRDY_OF(x)       _VALUEOF(x)
  #define  MCBSP_SPCR_XRDY_NO          0x00000000u
  #define  MCBSP_SPCR_XRDY_YES         0x00000001u

  #define _MCBSP_SPCR_XRST_MASK        0x00010000u
  #define _MCBSP_SPCR_XRST_SHIFT       0x00000010u
  #define  MCBSP_SPCR_XRST_DEFAULT     0x00000000u
  #define  MCBSP_SPCR_XRST_OF(x)       _VALUEOF(x)
  #define  MCBSP_SPCR_XRST_YES         0x00000000u
  #define  MCBSP_SPCR_XRST_0           0x00000000u
  #define  MCBSP_SPCR_XRST_NO          0x00000001u
  #define  MCBSP_SPCR_XRST_1           0x00000001u

  #define _MCBSP_SPCR_DLB_MASK         0x00008000u
  #define _MCBSP_SPCR_DLB_SHIFT        0x0000000Fu
  #define  MCBSP_SPCR_DLB_DEFAULT      0x00000000u
  #define  MCBSP_SPCR_DLB_OF(x)        _VALUEOF(x)
  #define  MCBSP_SPCR_DLB_OFF          0x00000000u
  #define  MCBSP_SPCR_DLB_ON           0x00000001u

  #define _MCBSP_SPCR_RJUST_MASK       0x00006000u
  #define _MCBSP_SPCR_RJUST_SHIFT      0x0000000Du
  #define  MCBSP_SPCR_RJUST_DEFAULT    0x00000000u
  #define  MCBSP_SPCR_RJUST_OF(x)      _VALUEOF(x)
  #define  MCBSP_SPCR_RJUST_RZF        0x00000000u
  #define  MCBSP_SPCR_RJUST_RSE        0x00000001u
  #define  MCBSP_SPCR_RJUST_LZF        0x00000002u

  #define _MCBSP_SPCR_CLKSTP_MASK      0x00001800u
  #define _MCBSP_SPCR_CLKSTP_SHIFT     0x0000000Bu
  #define  MCBSP_SPCR_CLKSTP_DEFAULT   0x00000000u
  #define  MCBSP_SPCR_CLKSTP_OF(x)     _VALUEOF(x)
  #define  MCBSP_SPCR_CLKSTP_DISABLE   0x00000000u
  #define  MCBSP_SPCR_CLKSTP_NODELAY   0x00000002u
  #define  MCBSP_SPCR_CLKSTP_DELAY     0x00000003u

#if (C11_SUPPORT | C64_SUPPORT)
  #define _MCBSP_SPCR_DXENA_MASK       0x00000080u
  #define _MCBSP_SPCR_DXENA_SHIFT      0x00000007u
  #define  MCBSP_SPCR_DXENA_DEFAULT    0x00000000u
  #define  MCBSP_SPCR_DXENA_OF(x)      _VALUEOF(x)
  #define  MCBSP_SPCR_DXENA_OFF        0x00000000u
  #define  MCBSP_SPCR_DXENA_ON         0x00000001u
#endif

  #define _MCBSP_SPCR_RINTM_MASK       0x00000030u
  #define _MCBSP_SPCR_RINTM_SHIFT      0x00000004u
  #define  MCBSP_SPCR_RINTM_DEFAULT    0x00000000u
  #define  MCBSP_SPCR_RINTM_OF(x)      _VALUEOF(x)
  #define  MCBSP_SPCR_RINTM_RRDY       0x00000000u
  #define  MCBSP_SPCR_RINTM_EOS        0x00000001u
  #define  MCBSP_SPCR_RINTM_FRM        0x00000002u
  #define  MCBSP_SPCR_RINTM_RSYNCERR   0x00000003u

  #define _MCBSP_SPCR_RSYNCERR_MASK    0x00000008u
  #define _MCBSP_SPCR_RSYNCERR_SHIFT   0x00000003u
  #define  MCBSP_SPCR_RSYNCERR_DEFAULT 0x00000000u
  #define  MCBSP_SPCR_RSYNCERR_OF(x)   _VALUEOF(x)
  #define  MCBSP_SPCR_RSYNCERR_NO      0x00000000u
  #define  MCBSP_SPCR_RSYNCERR_0       0x00000000u
  #define  MCBSP_SPCR_RSYNCERR_YES     0x00000001u
  #define  MCBSP_SPCR_RSYNCERR_1       0x00000001u

  #define _MCBSP_SPCR_RFULL_MASK       0x00000004u
  #define _MCBSP_SPCR_RFULL_SHIFT      0x00000002u
  #define  MCBSP_SPCR_RFULL_DEFAULT    0x00000000u
  #define  MCBSP_SPCR_RFULL_OF(x)      _VALUEOF(x)
  #define  MCBSP_SPCR_RFULL_NO         0x00000000u
  #define  MCBSP_SPCR_RFULL_YES        0x00000001u

  #define _MCBSP_SPCR_RRDY_MASK        0x00000002u
  #define _MCBSP_SPCR_RRDY_SHIFT       0x00000001u
  #define  MCBSP_SPCR_RRDY_DEFAULT     0x00000000u
  #define  MCBSP_SPCR_RRDY_OF(x)       _VALUEOF(x)
  #define  MCBSP_SPCR_RRDY_NO          0x00000000u
  #define  MCBSP_SPCR_RRDY_YES         0x00000001u

  #define _MCBSP_SPCR_RRST_MASK        0x00000001u
  #define _MCBSP_SPCR_RRST_SHIFT       0x00000000u
  #define  MCBSP_SPCR_RRST_DEFAULT     0x00000000u
  #define  MCBSP_SPCR_RRST_OF(x)       _VALUEOF(x)
  #define  MCBSP_SPCR_RRST_YES         0x00000000u
  #define  MCBSP_SPCR_RRST_0           0x00000000u
  #define  MCBSP_SPCR_RRST_NO          0x00000001u
  #define  MCBSP_SPCR_RRST_1           0x00000001u

  #define  MCBSP_SPCR_OF(x)            _VALUEOF(x)

#if (C11_SUPPORT | C64_SUPPORT)
  #define MCBSP_SPCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,SPCR,FREE)\
    |_PER_FDEFAULT(MCBSP,SPCR,SOFT)\
    |_PER_FDEFAULT(MCBSP,SPCR,FRST)\
    |_PER_FDEFAULT(MCBSP,SPCR,GRST)\
    |_PER_FDEFAULT(MCBSP,SPCR,XINTM)\
    |_PER_FDEFAULT(MCBSP,SPCR,XSYNCERR)\
    |_PER_FDEFAULT(MCBSP,SPCR,XEMPTY)\
    |_PER_FDEFAULT(MCBSP,SPCR,XRDY)\
    |_PER_FDEFAULT(MCBSP,SPCR,XRST)\
    |_PER_FDEFAULT(MCBSP,SPCR,DLB)\
    |_PER_FDEFAULT(MCBSP,SPCR,RJUST)\
    |_PER_FDEFAULT(MCBSP,SPCR,CLKSTP)\
    |_PER_FDEFAULT(MCBSP,SPCR,DXENA)\
    |_PER_FDEFAULT(MCBSP,SPCR,RINTM)\
    |_PER_FDEFAULT(MCBSP,SPCR,RSYNCERR)\
    |_PER_FDEFAULT(MCBSP,SPCR,RFULL)\
    |_PER_FDEFAULT(MCBSP,SPCR,RRDY)\
    |_PER_FDEFAULT(MCBSP,SPCR,RRST)\
  )

  #define MCBSP_SPCR_RMK(free,soft,frst,grst,xintm,xsyncerr,xrst,dlb,rjust,\
    clkstp,dxena,rintm,rsyncerr,rrst) (Uint32)(\
     _PER_FMK(MCBSP,SPCR,FREE,free)\
    |_PER_FMK(MCBSP,SPCR,SOFT,soft)\
    |_PER_FMK(MCBSP,SPCR,FRST,frst)\
    |_PER_FMK(MCBSP,SPCR,GRST,grst)\
    |_PER_FMK(MCBSP,SPCR,XINTM,xintm)\
    |_PER_FMK(MCBSP,SPCR,XSYNCERR,xsyncerr)\
    |_PER_FMK(MCBSP,SPCR,XRST,xrst)\
    |_PER_FMK(MCBSP,SPCR,DLB,dlb)\
    |_PER_FMK(MCBSP,SPCR,RJUST,rjust)\
    |_PER_FMK(MCBSP,SPCR,CLKSTP,clkstp)\
    |_PER_FMK(MCBSP,SPCR,DXENA,dxena)\
    |_PER_FMK(MCBSP,SPCR,RINTM,rintm)\
    |_PER_FMK(MCBSP,SPCR,RSYNCERR,rsyncerr)\
    |_PER_FMK(MCBSP,SPCR,RRST,rrst)\
  )
#endif

#if (!C11_SUPPORT && !C64_SUPPORT)
  #define MCBSP_SPCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,SPCR,FRST)\
    |_PER_FDEFAULT(MCBSP,SPCR,GRST)\
    |_PER_FDEFAULT(MCBSP,SPCR,XINTM)\
    |_PER_FDEFAULT(MCBSP,SPCR,XSYNCERR)\
    |_PER_FDEFAULT(MCBSP,SPCR,XEMPTY)\
    |_PER_FDEFAULT(MCBSP,SPCR,XRDY)\
    |_PER_FDEFAULT(MCBSP,SPCR,XRST)\
    |_PER_FDEFAULT(MCBSP,SPCR,DLB)\
    |_PER_FDEFAULT(MCBSP,SPCR,RJUST)\
    |_PER_FDEFAULT(MCBSP,SPCR,CLKSTP)\
    |_PER_FDEFAULT(MCBSP,SPCR,RINTM)\
    |_PER_FDEFAULT(MCBSP,SPCR,RSYNCERR)\
    |_PER_FDEFAULT(MCBSP,SPCR,RFULL)\
    |_PER_FDEFAULT(MCBSP,SPCR,RRDY)\
    |_PER_FDEFAULT(MCBSP,SPCR,RRST)\
  )

  #define MCBSP_SPCR_RMK(frst,grst,xintm,xsyncerr,xrst,dlb,rjust,\
    clkstp,rintm,rsyncerr,rrst) (Uint32)(\
     _PER_FMK(MCBSP,SPCR,FRST,frst)\
    |_PER_FMK(MCBSP,SPCR,GRST,grst)\
    |_PER_FMK(MCBSP,SPCR,XINTM,xintm)\
    |_PER_FMK(MCBSP,SPCR,XSYNCERR,xsyncerr)\
    |_PER_FMK(MCBSP,SPCR,XRST,xrst)\
    |_PER_FMK(MCBSP,SPCR,DLB,dlb)\
    |_PER_FMK(MCBSP,SPCR,RJUST,rjust)\
    |_PER_FMK(MCBSP,SPCR,CLKSTP,clkstp)\
    |_PER_FMK(MCBSP,SPCR,RINTM,rintm)\
    |_PER_FMK(MCBSP,SPCR,RSYNCERR,rsyncerr)\
    |_PER_FMK(MCBSP,SPCR,RRST,rrst)\
  )
#endif

  #define _MCBSP_SPCR_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_SPCR##N##_ADDR,MCBSP,SPCR,##FIELD)

  #define _MCBSP_SPCR_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_SPCR##N##_ADDR,MCBSP,SPCR,##FIELD,field)

  #define _MCBSP_SPCR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_SPCR##N##_ADDR,MCBSP,SPCR,##FIELD,##SYM)

  #define _MCBSP_SPCR0_FGET(FIELD) _MCBSP_SPCR_FGET(0,##FIELD)
  #define _MCBSP_SPCR1_FGET(FIELD) _MCBSP_SPCR_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_SPCR2_FGET(FIELD) _MCBSP_SPCR_FGET(2,##FIELD)
#endif

  #define _MCBSP_SPCR0_FSET(FIELD,f) _MCBSP_SPCR_FSET(0,##FIELD,f)
  #define _MCBSP_SPCR1_FSET(FIELD,f) _MCBSP_SPCR_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_SPCR2_FSET(FIELD,f) _MCBSP_SPCR_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_SPCR0_FSETS(FIELD,SYM) _MCBSP_SPCR_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_SPCR1_FSETS(FIELD,SYM) _MCBSP_SPCR_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_SPCR2_FSETS(FIELD,SYM) _MCBSP_SPCR_FSETS(2,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  R C R            |
* |___________________|
*
* RCR0  - serial port 0 receive control register
* RCR1  - serial port 1 receive control register
* RCR2  - serial port 2 receive control register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (rw) RPHASE
* (rw) RFRLEN2
* (rw) RWDLEN2
* (rw) RCOMPAND
* (rw) RFIG
* (rw) RDATDLY
* (rw) RFRLEN1
* (rw) RWDLEN1
* (rw) RWDREVRS (2)
*
* (2) - C11_SUPPORT / C64_SUPPORT only
*
\******************************************************************************/
  #define _MCBSP_RCR_OFFSET            3

  #define _MCBSP_RCR0_ADDR             0x018C000Cu
  #define _MCBSP_RCR1_ADDR             0x0190000Cu

#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCR2_ADDR             0x01A4000Cu
#endif

  #define _MCBSP_RCR_RPHASE_MASK       0x80000000u
  #define _MCBSP_RCR_RPHASE_SHIFT      0x0000001Fu
  #define  MCBSP_RCR_RPHASE_DEFAULT    0x00000000u
  #define  MCBSP_RCR_RPHASE_OF(x)      _VALUEOF(x)
  #define  MCBSP_RCR_RPHASE_SINGLE     0x00000000u
  #define  MCBSP_RCR_RPHASE_DUAL       0x00000001u

  #define _MCBSP_RCR_RFRLEN2_MASK      0x7F000000u
  #define _MCBSP_RCR_RFRLEN2_SHIFT     0x00000018u
  #define  MCBSP_RCR_RFRLEN2_DEFAULT   0x00000000u
  #define  MCBSP_RCR_RFRLEN2_OF(x)     _VALUEOF(x)

  #define _MCBSP_RCR_RWDLEN2_MASK      0x00E00000u
  #define _MCBSP_RCR_RWDLEN2_SHIFT     0x00000015u
  #define  MCBSP_RCR_RWDLEN2_DEFAULT   0x00000000u
  #define  MCBSP_RCR_RWDLEN2_OF(x)     _VALUEOF(x)
  #define  MCBSP_RCR_RWDLEN2_8BIT      0x00000000u
  #define  MCBSP_RCR_RWDLEN2_12BIT     0x00000001u
  #define  MCBSP_RCR_RWDLEN2_16BIT     0x00000002u
  #define  MCBSP_RCR_RWDLEN2_20BIT     0x00000003u
  #define  MCBSP_RCR_RWDLEN2_24BIT     0x00000004u
  #define  MCBSP_RCR_RWDLEN2_32BIT     0x00000005u

  #define _MCBSP_RCR_RCOMPAND_MASK     0x00180000u
  #define _MCBSP_RCR_RCOMPAND_SHIFT    0x00000013u
  #define  MCBSP_RCR_RCOMPAND_DEFAULT  0x00000000u
  #define  MCBSP_RCR_RCOMPAND_OF(x)    _VALUEOF(x)
  #define  MCBSP_RCR_RCOMPAND_MSB      0x00000000u
  #define  MCBSP_RCR_RCOMPAND_8BITLSB  0x00000001u
  #define  MCBSP_RCR_RCOMPAND_ULAW     0x00000002u
  #define  MCBSP_RCR_RCOMPAND_ALAW     0x00000003u

  #define _MCBSP_RCR_RFIG_MASK         0x00040000u
  #define _MCBSP_RCR_RFIG_SHIFT        0x00000012u
  #define  MCBSP_RCR_RFIG_DEFAULT      0x00000000u
  #define  MCBSP_RCR_RFIG_OF(x)        _VALUEOF(x)
  #define  MCBSP_RCR_RFIG_NO           0x00000000u
  #define  MCBSP_RCR_RFIG_YES          0x00000001u

  #define _MCBSP_RCR_RDATDLY_MASK      0x00030000u
  #define _MCBSP_RCR_RDATDLY_SHIFT     0x00000010u
  #define  MCBSP_RCR_RDATDLY_DEFAULT   0x00000000u
  #define  MCBSP_RCR_RDATDLY_OF(x)     _VALUEOF(x)
  #define  MCBSP_RCR_RDATDLY_0BIT      0x00000000u
  #define  MCBSP_RCR_RDATDLY_1BIT      0x00000001u
  #define  MCBSP_RCR_RDATDLY_2BIT      0x00000002u

  #define _MCBSP_RCR_RFRLEN1_MASK      0x00007F00u
  #define _MCBSP_RCR_RFRLEN1_SHIFT     0x00000008u
  #define  MCBSP_RCR_RFRLEN1_DEFAULT   0x00000000u
  #define  MCBSP_RCR_RFRLEN1_OF(x)     _VALUEOF(x)

  #define _MCBSP_RCR_RWDLEN1_MASK      0x000000E0u
  #define _MCBSP_RCR_RWDLEN1_SHIFT     0x00000005u
  #define  MCBSP_RCR_RWDLEN1_DEFAULT   0x00000000u
  #define  MCBSP_RCR_RWDLEN1_OF(x)     _VALUEOF(x)
  #define  MCBSP_RCR_RWDLEN1_8BIT      0x00000000u
  #define  MCBSP_RCR_RWDLEN1_12BIT     0x00000001u
  #define  MCBSP_RCR_RWDLEN1_16BIT     0x00000002u
  #define  MCBSP_RCR_RWDLEN1_20BIT     0x00000003u
  #define  MCBSP_RCR_RWDLEN1_24BIT     0x00000004u
  #define  MCBSP_RCR_RWDLEN1_32BIT     0x00000005u

#if (C11_SUPPORT | C64_SUPPORT)
  #define _MCBSP_RCR_RWDREVRS_MASK     0x00000010u
  #define _MCBSP_RCR_RWDREVRS_SHIFT    0x00000004u
  #define  MCBSP_RCR_RWDREVRS_DEFAULT  0x00000000u
  #define  MCBSP_RCR_RWDREVRS_OF(x)    _VALUEOF(x)
  #define  MCBSP_RCR_RWDREVRS_DISABLE  0x00000000u
  #define  MCBSP_RCR_RWDREVRS_ENABLE   0x00000001u
#endif

  #define  MCBSP_RCR_OF(x)             _VALUEOF(x)

#if (C11_SUPPORT | C64_SUPPORT)
  #define MCBSP_RCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,RCR,RPHASE)\
    |_PER_FDEFAULT(MCBSP,RCR,RFRLEN2)\
    |_PER_FDEFAULT(MCBSP,RCR,RWDLEN2)\
    |_PER_FDEFAULT(MCBSP,RCR,RCOMPAND)\
    |_PER_FDEFAULT(MCBSP,RCR,RFIG)\
    |_PER_FDEFAULT(MCBSP,RCR,RDATDLY)\
    |_PER_FDEFAULT(MCBSP,RCR,RFRLEN1)\
    |_PER_FDEFAULT(MCBSP,RCR,RWDLEN1)\
    |_PER_FDEFAULT(MCBSP,RCR,RWDREVRS)\
  )

  #define MCBSP_RCR_RMK(rphase,rfrlen2,rwdlen2,rcompand,rfig,\
    rdatdly,rfrlen1,rwdlen1,rwdrevrs) (Uint32)(\
     _PER_FMK(MCBSP,RCR,RPHASE,rphase)\
    |_PER_FMK(MCBSP,RCR,RFRLEN2,rfrlen2)\
    |_PER_FMK(MCBSP,RCR,RWDLEN2,rwdlen2)\
    |_PER_FMK(MCBSP,RCR,RCOMPAND,rcompand)\
    |_PER_FMK(MCBSP,RCR,RFIG,rfig)\
    |_PER_FMK(MCBSP,RCR,RDATDLY,rdatdly)\
    |_PER_FMK(MCBSP,RCR,RFRLEN1,rfrlen1)\
    |_PER_FMK(MCBSP,RCR,RWDLEN1,rwdlen1)\
    |_PER_FMK(MCBSP,RCR,RWDREVRS,rwdrevrs)\
  )
#endif

#if (!C11_SUPPORT && !C64_SUPPORT)
  #define MCBSP_RCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,RCR,RPHASE)\
    |_PER_FDEFAULT(MCBSP,RCR,RFRLEN2)\
    |_PER_FDEFAULT(MCBSP,RCR,RWDLEN2)\
    |_PER_FDEFAULT(MCBSP,RCR,RCOMPAND)\
    |_PER_FDEFAULT(MCBSP,RCR,RFIG)\
    |_PER_FDEFAULT(MCBSP,RCR,RDATDLY)\
    |_PER_FDEFAULT(MCBSP,RCR,RFRLEN1)\
    |_PER_FDEFAULT(MCBSP,RCR,RWDLEN1)\
  )

  #define MCBSP_RCR_RMK(rphase,rfrlen2,rwdlen2,rcompand,rfig,\
    rdatdly,rfrlen1,rwdlen1) (Uint32)(\
     _PER_FMK(MCBSP,RCR,RPHASE,rphase)\
    |_PER_FMK(MCBSP,RCR,RFRLEN2,rfrlen2)\
    |_PER_FMK(MCBSP,RCR,RWDLEN2,rwdlen2)\
    |_PER_FMK(MCBSP,RCR,RCOMPAND,rcompand)\
    |_PER_FMK(MCBSP,RCR,RFIG,rfig)\
    |_PER_FMK(MCBSP,RCR,RDATDLY,rdatdly)\
    |_PER_FMK(MCBSP,RCR,RFRLEN1,rfrlen1)\
    |_PER_FMK(MCBSP,RCR,RWDLEN1,rwdlen1)\
  )
#endif

  #define _MCBSP_RCR_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_RCR##N##_ADDR,MCBSP,RCR,##FIELD)

  #define _MCBSP_RCR_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_RCR##N##_ADDR,MCBSP,RCR,##FIELD,field)

  #define _MCBSP_RCR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_RCR##N##_ADDR,MCBSP,RCR,##FIELD,##SYM)

  #define _MCBSP_RCR0_FGET(FIELD) _MCBSP_RCR_FGET(0,##FIELD)
  #define _MCBSP_RCR1_FGET(FIELD) _MCBSP_RCR_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCR2_FGET(FIELD) _MCBSP_RCR_FGET(2,##FIELD)
#endif

  #define _MCBSP_RCR0_FSET(FIELD,f) _MCBSP_RCR_FSET(0,##FIELD,f)
  #define _MCBSP_RCR1_FSET(FIELD,f) _MCBSP_RCR_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCR2_FSET(FIELD,f) _MCBSP_RCR_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_RCR0_FSETS(FIELD,SYM) _MCBSP_RCR_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_RCR1_FSETS(FIELD,SYM) _MCBSP_RCR_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCR2_FSETS(FIELD,SYM) _MCBSP_RCR_FSETS(2,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  X C R            |
* |___________________|
*
* XCR0  - serial port 0 transmit control register
* XCR1  - serial port 1 transmit control register
* XCR2  - serial port 2 transmit control register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (rw) XPHASE
* (rw) XFRLEN2
* (rw) XWDLEN2
* (rw) XCOMPAND
* (rw) XFIG
* (rw) XDATDLY
* (rw) XFRLEN1
* (rw) XWDLEN1
* (rw) XWDREVRS (2)
*
* (2) - C11_SUPPORT /C64_SUPPORT only
*
\******************************************************************************/
  #define _MCBSP_XCR_OFFSET            4

  #define _MCBSP_XCR0_ADDR             0x018C0010u
  #define _MCBSP_XCR1_ADDR             0x01900010u

#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCR2_ADDR             0x01A40010u
#endif

  #define _MCBSP_XCR_XPHASE_MASK       0x80000000u
  #define _MCBSP_XCR_XPHASE_SHIFT      0x0000001Fu
  #define  MCBSP_XCR_XPHASE_DEFAULT    0x00000000u
  #define  MCBSP_XCR_XPHASE_OF(x)      _VALUEOF(x)
  #define  MCBSP_XCR_XPHASE_SINGLE     0x00000000u
  #define  MCBSP_XCR_XPHASE_DUAL       0x00000001u

  #define _MCBSP_XCR_XFRLEN2_MASK      0x7F000000u
  #define _MCBSP_XCR_XFRLEN2_SHIFT     0x00000018u
  #define  MCBSP_XCR_XFRLEN2_DEFAULT   0x00000000u
  #define  MCBSP_XCR_XFRLEN2_OF(x)     _VALUEOF(x)

  #define _MCBSP_XCR_XWDLEN2_MASK      0x00E00000u
  #define _MCBSP_XCR_XWDLEN2_SHIFT     0x00000015u
  #define  MCBSP_XCR_XWDLEN2_DEFAULT   0x00000000u
  #define  MCBSP_XCR_XWDLEN2_OF(x)     _VALUEOF(x)
  #define  MCBSP_XCR_XWDLEN2_8BIT      0x00000000u
  #define  MCBSP_XCR_XWDLEN2_12BIT     0x00000001u
  #define  MCBSP_XCR_XWDLEN2_16BIT     0x00000002u
  #define  MCBSP_XCR_XWDLEN2_20BIT     0x00000003u
  #define  MCBSP_XCR_XWDLEN2_24BIT     0x00000004u
  #define  MCBSP_XCR_XWDLEN2_32BIT     0x00000005u

  #define _MCBSP_XCR_XCOMPAND_MASK     0x00180000u
  #define _MCBSP_XCR_XCOMPAND_SHIFT    0x00000013u
  #define  MCBSP_XCR_XCOMPAND_DEFAULT  0x00000000u
  #define  MCBSP_XCR_XCOMPAND_OF(x)    _VALUEOF(x)
  #define  MCBSP_XCR_XCOMPAND_MSB      0x00000000u
  #define  MCBSP_XCR_XCOMPAND_8BITLSB  0x00000001u
  #define  MCBSP_XCR_XCOMPAND_ULAW     0x00000002u
  #define  MCBSP_XCR_XCOMPAND_ALAW     0x00000003u

  #define _MCBSP_XCR_XFIG_MASK         0x00040000u
  #define _MCBSP_XCR_XFIG_SHIFT        0x00000012u
  #define  MCBSP_XCR_XFIG_DEFAULT      0x00000000u
  #define  MCBSP_XCR_XFIG_OF(x)        _VALUEOF(x)
  #define  MCBSP_XCR_XFIG_NO           0x00000000u
  #define  MCBSP_XCR_XFIG_YES          0x00000001u

  #define _MCBSP_XCR_XDATDLY_MASK      0x00030000u
  #define _MCBSP_XCR_XDATDLY_SHIFT     0x00000010u
  #define  MCBSP_XCR_XDATDLY_DEFAULT   0x00000000u
  #define  MCBSP_XCR_XDATDLY_OF(x)     _VALUEOF(x)
  #define  MCBSP_XCR_XDATDLY_0BIT      0x00000000u
  #define  MCBSP_XCR_XDATDLY_1BIT      0x00000001u
  #define  MCBSP_XCR_XDATDLY_2BIT      0x00000002u

  #define _MCBSP_XCR_XFRLEN1_MASK      0x00007F00u
  #define _MCBSP_XCR_XFRLEN1_SHIFT     0x00000008u
  #define  MCBSP_XCR_XFRLEN1_DEFAULT   0x00000000u
  #define  MCBSP_XCR_XFRLEN1_OF(x)     _VALUEOF(x)

  #define _MCBSP_XCR_XWDLEN1_MASK      0x000000E0u
  #define _MCBSP_XCR_XWDLEN1_SHIFT     0x00000005u
  #define  MCBSP_XCR_XWDLEN1_DEFAULT   0x00000000u
  #define  MCBSP_XCR_XWDLEN1_OF(x)     _VALUEOF(x)
  #define  MCBSP_XCR_XWDLEN1_8BIT      0x00000000u
  #define  MCBSP_XCR_XWDLEN1_12BIT     0x00000001u
  #define  MCBSP_XCR_XWDLEN1_16BIT     0x00000002u
  #define  MCBSP_XCR_XWDLEN1_20BIT     0x00000003u
  #define  MCBSP_XCR_XWDLEN1_24BIT     0x00000004u
  #define  MCBSP_XCR_XWDLEN1_32BIT     0x00000005u

#if (C11_SUPPORT | C64_SUPPORT)
  #define _MCBSP_XCR_XWDREVRS_MASK     0x00000010u
  #define _MCBSP_XCR_XWDREVRS_SHIFT    0x00000004u
  #define  MCBSP_XCR_XWDREVRS_DEFAULT  0x00000000u
  #define  MCBSP_XCR_XWDREVRS_OF(x)    _VALUEOF(x)
  #define  MCBSP_XCR_XWDREVRS_DISABLE  0x00000000u
  #define  MCBSP_XCR_XWDREVRS_ENABLE   0x00000001u
#endif

  #define  MCBSP_XCR_OF(x)             _VALUEOF(x)

#if (C11_SUPPORT | C64_SUPPORT)
  #define MCBSP_XCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,XCR,XPHASE)\
    |_PER_FDEFAULT(MCBSP,XCR,XFRLEN2)\
    |_PER_FDEFAULT(MCBSP,XCR,XWDLEN2)\
    |_PER_FDEFAULT(MCBSP,XCR,XCOMPAND)\
    |_PER_FDEFAULT(MCBSP,XCR,XFIG)\
    |_PER_FDEFAULT(MCBSP,XCR,XDATDLY)\
    |_PER_FDEFAULT(MCBSP,XCR,XFRLEN1)\
    |_PER_FDEFAULT(MCBSP,XCR,XWDLEN1)\
    |_PER_FDEFAULT(MCBSP,XCR,XWDREVRS)\
  )

  #define MCBSP_XCR_RMK(xphase,xfrlen2,xwdlen2,xcompand,xfig,\
    xdatdly,xfrlen1,xwdlen1,xwdrevrs) (Uint32)(\
     _PER_FMK(MCBSP,XCR,XPHASE,xphase)\
    |_PER_FMK(MCBSP,XCR,XFRLEN2,xfrlen2)\
    |_PER_FMK(MCBSP,XCR,XWDLEN2,xwdlen2)\
    |_PER_FMK(MCBSP,XCR,XCOMPAND,xcompand)\
    |_PER_FMK(MCBSP,XCR,XFIG,xfig)\
    |_PER_FMK(MCBSP,XCR,XDATDLY,xdatdly)\
    |_PER_FMK(MCBSP,XCR,XFRLEN1,xfrlen1)\
    |_PER_FMK(MCBSP,XCR,XWDLEN1,xwdlen1)\
    |_PER_FMK(MCBSP,XCR,XWDREVRS,xwdrevrs)\
  )
#endif

#if (!C11_SUPPORT && !C64_SUPPORT)
  #define MCBSP_XCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,XCR,XPHASE)\
    |_PER_FDEFAULT(MCBSP,XCR,XFRLEN2)\
    |_PER_FDEFAULT(MCBSP,XCR,XWDLEN2)\
    |_PER_FDEFAULT(MCBSP,XCR,XCOMPAND)\
    |_PER_FDEFAULT(MCBSP,XCR,XFIG)\
    |_PER_FDEFAULT(MCBSP,XCR,XDATDLY)\
    |_PER_FDEFAULT(MCBSP,XCR,XFRLEN1)\
    |_PER_FDEFAULT(MCBSP,XCR,XWDLEN1)\
  )

  #define MCBSP_XCR_RMK(xphase,xfrlen2,xwdlen2,xcompand,xfig,\
    xdatdly,xfrlen1,xwdlen1) (Uint32)(\
     _PER_FMK(MCBSP,XCR,XPHASE,xphase)\
    |_PER_FMK(MCBSP,XCR,XFRLEN2,xfrlen2)\
    |_PER_FMK(MCBSP,XCR,XWDLEN2,xwdlen2)\
    |_PER_FMK(MCBSP,XCR,XCOMPAND,xcompand)\
    |_PER_FMK(MCBSP,XCR,XFIG,xfig)\
    |_PER_FMK(MCBSP,XCR,XDATDLY,xdatdly)\
    |_PER_FMK(MCBSP,XCR,XFRLEN1,xfrlen1)\
    |_PER_FMK(MCBSP,XCR,XWDLEN1,xwdlen1)\
  )
#endif

  #define _MCBSP_XCR_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_XCR##N##_ADDR,MCBSP,XCR,##FIELD)

  #define _MCBSP_XCR_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_XCR##N##_ADDR,MCBSP,XCR,##FIELD,field)

  #define _MCBSP_XCR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_XCR##N##_ADDR,MCBSP,XCR,##FIELD,##SYM)

  #define _MCBSP_XCR0_FGET(FIELD) _MCBSP_XCR_FGET(0,##FIELD)
  #define _MCBSP_XCR1_FGET(FIELD) _MCBSP_XCR_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCR2_FGET(FIELD) _MCBSP_XCR_FGET(2,##FIELD)
#endif

  #define _MCBSP_XCR0_FSET(FIELD,f) _MCBSP_XCR_FSET(0,##FIELD,f)
  #define _MCBSP_XCR1_FSET(FIELD,f) _MCBSP_XCR_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCR2_FSET(FIELD,f) _MCBSP_XCR_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_XCR0_FSETS(FIELD,SYM) _MCBSP_XCR_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_XCR1_FSETS(FIELD,SYM) _MCBSP_XCR_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCR2_FSETS(FIELD,SYM) _MCBSP_XCR_FSETS(2,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  S R G R          |
* |___________________|
*
* SRGR0 - serial port 0 sample rate generator register
* SRGR1 - serial port 1 sample rate generator register
* SRGR2 - serial port 2 sample rate generator register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (rw) GSYNC
* (rw) CLKSP
* (rw) CLKSM
* (rw) FSGM
* (rw) FPER
* (rw) FWID
* (rw) CLKGDV
*
\******************************************************************************/
  #define _MCBSP_SRGR_OFFSET           5

  #define _MCBSP_SRGR0_ADDR            0x018C0014u
  #define _MCBSP_SRGR1_ADDR            0x01900014u

#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_SRGR2_ADDR            0x01A40014u
#endif

  #define _MCBSP_SRGR_GSYNC_MASK       0x80000000u
  #define _MCBSP_SRGR_GSYNC_SHIFT      0x0000001Fu
  #define  MCBSP_SRGR_GSYNC_DEFAULT    0x00000000u
  #define  MCBSP_SRGR_GSYNC_OF(x)      _VALUEOF(x)
  #define  MCBSP_SRGR_GSYNC_FREE       0x00000000u
  #define  MCBSP_SRGR_GSYNC_SYNC       0x00000001u

  #define _MCBSP_SRGR_CLKSP_MASK       0x40000000u
  #define _MCBSP_SRGR_CLKSP_SHIFT      0x0000001Eu
  #define  MCBSP_SRGR_CLKSP_DEFAULT    0x00000000u
  #define  MCBSP_SRGR_CLKSP_OF(x)      _VALUEOF(x)
  #define  MCBSP_SRGR_CLKSP_RISING     0x00000000u
  #define  MCBSP_SRGR_CLKSP_FALLING    0x00000001u

  #define _MCBSP_SRGR_CLKSM_MASK       0x20000000u
  #define _MCBSP_SRGR_CLKSM_SHIFT      0x0000001Du
  #define  MCBSP_SRGR_CLKSM_DEFAULT    0x00000001u
  #define  MCBSP_SRGR_CLKSM_OF(x)      _VALUEOF(x)
  #define  MCBSP_SRGR_CLKSM_CLKS       0x00000000u
  #define  MCBSP_SRGR_CLKSM_INTERNAL   0x00000001u

  #define _MCBSP_SRGR_FSGM_MASK        0x10000000u
  #define _MCBSP_SRGR_FSGM_SHIFT       0x0000001Cu
  #define  MCBSP_SRGR_FSGM_DEFAULT     0x00000000u
  #define  MCBSP_SRGR_FSGM_OF(x)       _VALUEOF(x)
  #define  MCBSP_SRGR_FSGM_DXR2XSR     0x00000000u
  #define  MCBSP_SRGR_FSGM_FSG         0x00000001u

  #define _MCBSP_SRGR_FPER_MASK        0x0FFF0000u
  #define _MCBSP_SRGR_FPER_SHIFT       0x00000010u
  #define  MCBSP_SRGR_FPER_DEFAULT     0x00000000u
  #define  MCBSP_SRGR_FPER_OF(x)       _VALUEOF(x)

  #define _MCBSP_SRGR_FWID_MASK        0x0000FF00u
  #define _MCBSP_SRGR_FWID_SHIFT       0x00000008u
  #define  MCBSP_SRGR_FWID_DEFAULT     0x00000000u
  #define  MCBSP_SRGR_FWID_OF(x)       _VALUEOF(x)

  #define _MCBSP_SRGR_CLKGDV_MASK      0x000000FFu
  #define _MCBSP_SRGR_CLKGDV_SHIFT     0x00000000u
  #define  MCBSP_SRGR_CLKGDV_DEFAULT   0x00000001u
  #define  MCBSP_SRGR_CLKGDV_OF(x)     _VALUEOF(x)

  #define  MCBSP_SRGR_OF(x)            _VALUEOF(x)

  #define MCBSP_SRGR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,SRGR,GSYNC)\
    |_PER_FDEFAULT(MCBSP,SRGR,CLKSP)\
    |_PER_FDEFAULT(MCBSP,SRGR,CLKSM)\
    |_PER_FDEFAULT(MCBSP,SRGR,FSGM)\
    |_PER_FDEFAULT(MCBSP,SRGR,FPER)\
    |_PER_FDEFAULT(MCBSP,SRGR,FWID)\
    |_PER_FDEFAULT(MCBSP,SRGR,CLKGDV)\
  )

  #define MCBSP_SRGR_RMK(gsync,clksp,clksm,fsgm,fper,fwid,clkgdv) (Uint32)(\
     _PER_FMK(MCBSP,SRGR,GSYNC,gsync)\
    |_PER_FMK(MCBSP,SRGR,CLKSP,clksp)\
    |_PER_FMK(MCBSP,SRGR,CLKSM,clksm)\
    |_PER_FMK(MCBSP,SRGR,FSGM,fsgm)\
    |_PER_FMK(MCBSP,SRGR,FPER,fper)\
    |_PER_FMK(MCBSP,SRGR,FWID,fwid)\
    |_PER_FMK(MCBSP,SRGR,CLKGDV,clkgdv)\
  )

  #define _MCBSP_SRGR_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_SRGR##N##_ADDR,MCBSP,SRGR,##FIELD)

  #define _MCBSP_SRGR_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_SRGR##N##_ADDR,MCBSP,SRGR,##FIELD,field)

  #define _MCBSP_SRGR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_SRGR##N##_ADDR,MCBSP,SRGR,##FIELD,##SYM)

  #define _MCBSP_SRGR0_FGET(FIELD) _MCBSP_SRGR_FGET(0,##FIELD)
  #define _MCBSP_SRGR1_FGET(FIELD) _MCBSP_SRGR_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_SRGR2_FGET(FIELD) _MCBSP_SRGR_FGET(2,##FIELD)
#endif

  #define _MCBSP_SRGR0_FSET(FIELD,f) _MCBSP_SRGR_FSET(0,##FIELD,f)
  #define _MCBSP_SRGR1_FSET(FIELD,f) _MCBSP_SRGR_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_SRGR2_FSET(FIELD,f) _MCBSP_SRGR_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_SRGR0_FSETS(FIELD,SYM) _MCBSP_SRGR_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_SRGR1_FSETS(FIELD,SYM) _MCBSP_SRGR_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_SRGR2_FSETS(FIELD,SYM) _MCBSP_SRGR_FSETS(2,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  M C R            |
* |___________________|
*
* MCR0  - serial port 0 multichannel control register
* MCR1  - serial port 1 multichannel control register
* MCR2  - serial port 2 multichannel control register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (rw) XMCME (1)
* (rw) XPBBLK
* (rw) XPABLK
* (r)  XCBLK
* (rw) XMCM
* (rw) RMCME (1)
* (rw) RPBBLK
* (rw) RPABLK
* (r)  RCBLK
* (rw) RMCM
*
* (1) C64_SUPPORT only
\******************************************************************************/
  #define _MCBSP_MCR_OFFSET            6

  #define _MCBSP_MCR0_ADDR             0x018C0018u
  #define _MCBSP_MCR1_ADDR             0x01900018u

#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_MCR2_ADDR             0x01A40018u
#endif

#if (C64_SUPPORT)
  #define _MCBSP_MCR_XMCME_MASK       0x02000000u
  #define _MCBSP_MCR_XMCME_SHIFT      0x00000019u
  #define  MCBSP_MCR_XMCME_DEFAULT    0x00000000u
  #define  MCBSP_MCR_XMCME_OF(x)      _VALUEOF(x)
  #define  MCBSP_MCR_XMCME_NORMAL     0x00000000u
  #define  MCBSP_MCR_XMCME_ENHANCED   0x00000001u
#endif

  #define _MCBSP_MCR_XPBBLK_MASK       0x01800000u
  #define _MCBSP_MCR_XPBBLK_SHIFT      0x00000017u
  #define  MCBSP_MCR_XPBBLK_DEFAULT    0x00000000u
  #define  MCBSP_MCR_XPBBLK_OF(x)      _VALUEOF(x)
  #define  MCBSP_MCR_XPBBLK_SF1        0x00000000u
  #define  MCBSP_MCR_XPBBLK_SF3        0x00000001u
  #define  MCBSP_MCR_XPBBLK_SF5        0x00000002u
  #define  MCBSP_MCR_XPBBLK_SF7        0x00000003u

  #define _MCBSP_MCR_XPABLK_MASK       0x00600000u
  #define _MCBSP_MCR_XPABLK_SHIFT      0x00000015u
  #define  MCBSP_MCR_XPABLK_DEFAULT    0x00000000u
  #define  MCBSP_MCR_XPABLK_OF(x)      _VALUEOF(x)
  #define  MCBSP_MCR_XPABLK_SF0        0x00000000u
  #define  MCBSP_MCR_XPABLK_SF2        0x00000001u
  #define  MCBSP_MCR_XPABLK_SF4        0x00000002u
  #define  MCBSP_MCR_XPABLK_SF6        0x00000003u

  #define _MCBSP_MCR_XCBLK_MASK        0x001C0000u
  #define _MCBSP_MCR_XCBLK_SHIFT       0x00000012u
  #define  MCBSP_MCR_XCBLK_DEFAULT     0x00000000u
  #define  MCBSP_MCR_XCBLK_OF(x)       _VALUEOF(x)
  #define  MCBSP_MCR_XCBLK_SF0         0x00000000u
  #define  MCBSP_MCR_XCBLK_SF1         0x00000001u
  #define  MCBSP_MCR_XCBLK_SF2         0x00000002u
  #define  MCBSP_MCR_XCBLK_SF3         0x00000003u
  #define  MCBSP_MCR_XCBLK_SF4         0x00000004u
  #define  MCBSP_MCR_XCBLK_SF5         0x00000005u
  #define  MCBSP_MCR_XCBLK_SF6         0x00000006u
  #define  MCBSP_MCR_XCBLK_SF7         0x00000007u

  #define _MCBSP_MCR_XMCM_MASK         0x00030000u
  #define _MCBSP_MCR_XMCM_SHIFT        0x00000010u
  #define  MCBSP_MCR_XMCM_DEFAULT      0x00000000u
  #define  MCBSP_MCR_XMCM_OF(x)        _VALUEOF(x)
  #define  MCBSP_MCR_XMCM_ENNOMASK     0x00000000u
  #define  MCBSP_MCR_XMCM_DISXP        0x00000001u
  #define  MCBSP_MCR_XMCM_ENMASK       0x00000002u
  #define  MCBSP_MCR_XMCM_DISRP        0x00000003u

#if (C64_SUPPORT)
  #define _MCBSP_MCR_RMCME_MASK       0x00000200u
  #define _MCBSP_MCR_RMCME_SHIFT      0x00000009u
  #define  MCBSP_MCR_RMCME_DEFAULT    0x00000000u
  #define  MCBSP_MCR_RMCME_OF(x)      _VALUEOF(x)
  #define  MCBSP_MCR_RMCME_NORMAL     0x00000000u
  #define  MCBSP_MCR_RMCME_ENHANCED   0x00000001u
#endif

  #define _MCBSP_MCR_RPBBLK_MASK       0x00000180u
  #define _MCBSP_MCR_RPBBLK_SHIFT      0x00000007u
  #define  MCBSP_MCR_RPBBLK_DEFAULT    0x00000000u
  #define  MCBSP_MCR_RPBBLK_OF(x)      _VALUEOF(x)
  #define  MCBSP_MCR_RPBBLK_SF1        0x00000000u
  #define  MCBSP_MCR_RPBBLK_SF3        0x00000001u
  #define  MCBSP_MCR_RPBBLK_SF5        0x00000002u
  #define  MCBSP_MCR_RPBBLK_SF7        0x00000003u

  #define _MCBSP_MCR_RPABLK_MASK       0x00000060u
  #define _MCBSP_MCR_RPABLK_SHIFT      0x00000005u
  #define  MCBSP_MCR_RPABLK_DEFAULT    0x00000000u
  #define  MCBSP_MCR_RPABLK_OF(x)      _VALUEOF(x)
  #define  MCBSP_MCR_RPABLK_SF0        0x00000000u
  #define  MCBSP_MCR_RPABLK_SF2        0x00000001u
  #define  MCBSP_MCR_RPABLK_SF4        0x00000002u
  #define  MCBSP_MCR_RPABLK_SF6        0x00000003u

  #define _MCBSP_MCR_RCBLK_MASK        0x0000001Cu
  #define _MCBSP_MCR_RCBLK_SHIFT       0x00000002u
  #define  MCBSP_MCR_RCBLK_DEFAULT     0x00000000u
  #define  MCBSP_MCR_RCBLK_OF(x)       _VALUEOF(x)
  #define  MCBSP_MCR_RCBLK_SF0         0x00000000u
  #define  MCBSP_MCR_RCBLK_SF1         0x00000001u
  #define  MCBSP_MCR_RCBLK_SF2         0x00000002u
  #define  MCBSP_MCR_RCBLK_SF3         0x00000003u
  #define  MCBSP_MCR_RCBLK_SF4         0x00000004u
  #define  MCBSP_MCR_RCBLK_SF5         0x00000005u
  #define  MCBSP_MCR_RCBLK_SF6         0x00000006u
  #define  MCBSP_MCR_RCBLK_SF7         0x00000007u

  #define _MCBSP_MCR_RMCM_MASK         0x00000001u
  #define _MCBSP_MCR_RMCM_SHIFT        0x00000000u
  #define  MCBSP_MCR_RMCM_DEFAULT      0x00000000u
  #define  MCBSP_MCR_RMCM_OF(x)        _VALUEOF(x)
  #define  MCBSP_MCR_RMCM_CHENABLE     0x00000000u
  #define  MCBSP_MCR_RMCM_ELDISABLE    0x00000001u

  #define  MCBSP_MCR_OF(x)             _VALUEOF(x)


#if (!C64_SUPPORT)
  #define MCBSP_MCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,MCR,XPBBLK)\
    |_PER_FDEFAULT(MCBSP,MCR,XPABLK)\
    |_PER_FDEFAULT(MCBSP,MCR,XCBLK)\
    |_PER_FDEFAULT(MCBSP,MCR,XMCM)\
    |_PER_FDEFAULT(MCBSP,MCR,RPBBLK)\
    |_PER_FDEFAULT(MCBSP,MCR,RPABLK)\
    |_PER_FDEFAULT(MCBSP,MCR,RCBLK)\
    |_PER_FDEFAULT(MCBSP,MCR,RMCM)\
  )

  #define MCBSP_MCR_RMK(xpbblk,xpablk,xmcm,rpbblk,rpablk,rmcm) (Uint32)(\
     _PER_FMK(MCBSP,MCR,XPBBLK,xpbblk)\
    |_PER_FMK(MCBSP,MCR,XPABLK,xpablk)\
    |_PER_FMK(MCBSP,MCR,XMCM,xmcm)\
    |_PER_FMK(MCBSP,MCR,RPBBLK,rpbblk)\
    |_PER_FMK(MCBSP,MCR,RPABLK,rpablk)\
    |_PER_FMK(MCBSP,MCR,RMCM,rmcm)\
  )
#endif

#if (C64_SUPPORT)
  #define MCBSP_MCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,MCR,XMCME)\
    |_PER_FDEFAULT(MCBSP,MCR,XPBBLK)\
    |_PER_FDEFAULT(MCBSP,MCR,XPABLK)\
    |_PER_FDEFAULT(MCBSP,MCR,XCBLK)\
    |_PER_FDEFAULT(MCBSP,MCR,XMCM)\
    |_PER_FDEFAULT(MCBSP,MCR,RMCME)\
    |_PER_FDEFAULT(MCBSP,MCR,RPBBLK)\
    |_PER_FDEFAULT(MCBSP,MCR,RPABLK)\
    |_PER_FDEFAULT(MCBSP,MCR,RCBLK)\
    |_PER_FDEFAULT(MCBSP,MCR,RMCM)\
  )

  #define MCBSP_MCR_RMK(xmcme,xpbblk,xpablk,xmcm,rmcme,rpbblk,rpablk,rmcm) (Uint32)(\
     _PER_FMK(MCBSP,MCR,XMCME,xmcme)\
    |_PER_FMK(MCBSP,MCR,XPBBLK,xpbblk)\
    |_PER_FMK(MCBSP,MCR,XPABLK,xpablk)\
    |_PER_FMK(MCBSP,MCR,XMCM,xmcm)\
    |_PER_FMK(MCBSP,MCR,RMCME,rmcme)\
    |_PER_FMK(MCBSP,MCR,RPBBLK,rpbblk)\
    |_PER_FMK(MCBSP,MCR,RPABLK,rpablk)\
    |_PER_FMK(MCBSP,MCR,RMCM,rmcm)\
  )
#endif

  #define _MCBSP_MCR_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_MCR##N##_ADDR,MCBSP,MCR,##FIELD)

  #define _MCBSP_MCR_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_MCR##N##_ADDR,MCBSP,MCR,##FIELD,field)

  #define _MCBSP_MCR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_MCR##N##_ADDR,MCBSP,MCR,##FIELD,##SYM)

  #define _MCBSP_MCR0_FGET(FIELD) _MCBSP_MCR_FGET(0,##FIELD)
  #define _MCBSP_MCR1_FGET(FIELD) _MCBSP_MCR_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_MCR2_FGET(FIELD) _MCBSP_MCR_FGET(2,##FIELD)
#endif

  #define _MCBSP_MCR0_FSET(FIELD,f) _MCBSP_MCR_FSET(0,##FIELD,f)
  #define _MCBSP_MCR1_FSET(FIELD,f) _MCBSP_MCR_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_MCR2_FSET(FIELD,f) _MCBSP_MCR_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_MCR0_FSETS(FIELD,SYM) _MCBSP_MCR_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_MCR1_FSETS(FIELD,SYM) _MCBSP_MCR_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_MCR2_FSETS(FIELD,SYM) _MCBSP_MCR_FSETS(2,##FIELD,##SYM)
#endif


/******************************************************************************\
* _____________________
* |                   |
* |  R C E R          |
* |___________________|
*
* RCER0 - serial port 0 receive channel enable register
* RCER1 - serial port 1 receive channel enable register
* RCER2 - serial port 2 receive channel enable register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (rw) RCEB
* (rw) RCEA
*
\******************************************************************************/
#if (!C64_SUPPORT)
  #define _MCBSP_RCER_OFFSET           7

  #define _MCBSP_RCER0_ADDR            0x018C001Cu
  #define _MCBSP_RCER1_ADDR            0x0190001Cu

#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCER2_ADDR            0x01A4001Cu
#endif

  #define _MCBSP_RCER_RCEB_MASK        0xFFFF0000u
  #define _MCBSP_RCER_RCEB_SHIFT       0x00000010u
  #define  MCBSP_RCER_RCEB_DEFAULT     0x00000000u
  #define  MCBSP_RCER_RCEB_OF(x)       _VALUEOF(x)

  #define _MCBSP_RCER_RCEA_MASK        0x0000FFFFu
  #define _MCBSP_RCER_RCEA_SHIFT       0x00000000u
  #define  MCBSP_RCER_RCEA_DEFAULT     0x00000000u
  #define  MCBSP_RCER_RCEA_OF(x)       _VALUEOF(x)


  #define  MCBSP_RCER_OF(x)            _VALUEOF(x)


  #define MCBSP_RCER_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,RCER,RCEB)\
    |_PER_FDEFAULT(MCBSP,RCER,RCEA)\
  )

  #define MCBSP_RCER_RMK(rceb,rcea) (Uint32)(\
     _PER_FMK(MCBSP,RCER,RCEB,rceb)\
    |_PER_FMK(MCBSP,RCER,RCEA,rcea)\
  )


  #define _MCBSP_RCER_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_RCER##N##_ADDR,MCBSP,RCER,##FIELD)

  #define _MCBSP_RCER_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_RCER##N##_ADDR,MCBSP,RCER,##FIELD,field)

  #define _MCBSP_RCER_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_RCER##N##_ADDR,MCBSP,RCER,##FIELD,##SYM)

  #define _MCBSP_RCER0_FGET(FIELD) _MCBSP_RCER_FGET(0,##FIELD)
  #define _MCBSP_RCER1_FGET(FIELD) _MCBSP_RCER_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCER2_FGET(FIELD) _MCBSP_RCER_FGET(2,##FIELD)
#endif

  #define _MCBSP_RCER0_FSET(FIELD,f) _MCBSP_RCER_FSET(0,##FIELD,f)
  #define _MCBSP_RCER1_FSET(FIELD,f) _MCBSP_RCER_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCER2_FSET(FIELD,f) _MCBSP_RCER_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_RCER0_FSETS(FIELD,SYM) _MCBSP_RCER_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_RCER1_FSETS(FIELD,SYM) _MCBSP_RCER_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCER2_FSETS(FIELD,SYM) _MCBSP_RCER_FSETS(2,##FIELD,##SYM)
#endif

#endif /* !C64_SUPPORT */

/******************************************************************************\
* _____________________
* |                   |
* |  R C E R E 0      |
* |___________________|
*
* RCERE00 - serial port 0 enhanced receive channel enable register 0
* RCERE01 - serial port 1 enhanced receive channel enable register 0
* RCERE02 - serial port 2 enhanced receive channel enable register 0
*
* FIELDS (msb -> lsb)
* (rw) RCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _MCBSP_RCERE0_OFFSET           7

  #define _MCBSP_RCERE00_ADDR            0x018C001Cu
  #define _MCBSP_RCERE01_ADDR            0x0190001Cu
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE02_ADDR            0x01A4001Cu
#endif
  #define _MCBSP_RCERE0_RCE_MASK        0xFFFFFFFFu
  #define _MCBSP_RCERE0_RCE_SHIFT       0x00000000u
  #define  MCBSP_RCERE0_RCE_DEFAULT     0x00000000u
  #define  MCBSP_RCERE0_RCE_OF(x)       _VALUEOF(x)

  #define  MCBSP_RCERE0_OF(x)            _VALUEOF(x)

  #define MCBSP_RCERE0_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,RCERE0,RCE)\
  )

  #define MCBSP_RCERE0_RMK(rce) (Uint32)(\
     _PER_FMK(MCBSP,RCERE0,RCE,rce) \
  )

  #define _MCBSP_RCERE0_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_RCERE0##N##_ADDR,MCBSP,RCERE0,FIELD)

  #define _MCBSP_RCERE0_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_RCERE0##N##_ADDR,MCBSP,RCERE0,FIELD,field)

  #define _MCBSP_RCERE0_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_RCERE0##N##_ADDR,MCBSP,RCERE0,FIELD,##SYM)

  #define _MCBSP_RCERE00_FGET(FIELD) _MCBSP_RCERE0_FGET(0,##FIELD)
  #define _MCBSP_RCERE01_FGET(FIELD) _MCBSP_RCERE0_FGET(1,##FIELD)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE02_FGET(FIELD) _MCBSP_RCERE0_FGET(2,##FIELD)
 #endif

  #define _MCBSP_RCERE00_FSET(FIELD,f) _MCBSP_RCERE0_FSET(0,##FIELD,f)
  #define _MCBSP_RCERE01_FSET(FIELD,f) _MCBSP_RCERE0_FSET(1,##FIELD,f)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE02_FSET(FIELD,f) _MCBSP_RCERE0_FSET(2,##FIELD,f)
 #endif

  #define _MCBSP_RCERE00_FSETS(FIELD,SYM) _MCBSP_RCERE0_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_RCERE01_FSETS(FIELD,SYM) _MCBSP_RCERE0_FSETS(1,##FIELD,##SYM)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE02_FSETS(FIELD,SYM) _MCBSP_RCERE0_FSETS(2,##FIELD,##SYM)
 #endif
#endif /* C64_SUPPORT */


/******************************************************************************\
* _____________________
* |                   |
* |  R C E R E 1      |
* |___________________|
*
* RCERE10 - serial port 0 enhanced receive channel enable register 1
* RCERE11 - serial port 1 enhanced receive channel enable register 1
* RCERE12 - serial port 2 enhanced receive channel enable register 1
*
* FIELDS (msb -> lsb)
* (rw) RCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _MCBSP_RCERE1_OFFSET           10

  #define _MCBSP_RCERE10_ADDR            0x018C0028u
  #define _MCBSP_RCERE11_ADDR            0x01900028u
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE12_ADDR            0x01A40028u
 #endif

  #define _MCBSP_RCERE1_RCE_MASK        0xFFFFFFFFu
  #define _MCBSP_RCERE1_RCE_SHIFT       0x00000000u
  #define  MCBSP_RCERE1_RCE_DEFAULT     0x00000000u
  #define  MCBSP_RCERE1_RCE_OF(x)       _VALUEOF(x)

  #define  MCBSP_RCERE1_OF(x)            _VALUEOF(x)

  #define MCBSP_RCERE1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,RCERE1,RCE)\
  )

  #define MCBSP_RCERE1_RMK(rce) (Uint32)(\
     _PER_FMK(MCBSP,RCERE1,RCE,rce)\
  )

  #define _MCBSP_RCERE1_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_RCERE1##N##_ADDR,MCBSP,RCERE1,FIELD)

  #define _MCBSP_RCERE1_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_RCERE1##N##_ADDR,MCBSP,RCERE1,FIELD,field)

  #define _MCBSP_RCERE1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_RCERE1##N##_ADDR,MCBSP,RCERE1,FIELD,##SYM)

  #define _MCBSP_RCERE10_FGET(FIELD) _MCBSP_RCERE1_FGET(0,##FIELD)
  #define _MCBSP_RCERE11_FGET(FIELD) _MCBSP_RCERE1_FGET(1,##FIELD)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE12_FGET(FIELD) _MCBSP_RCERE1_FGET(2,##FIELD)
 #endif

  #define _MCBSP_RCERE10_FSET(FIELD,f) _MCBSP_RCERE1_FSET(0,##FIELD,f)
  #define _MCBSP_RCERE11_FSET(FIELD,f) _MCBSP_RCERE1_FSET(1,##FIELD,f)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE12_FSET(FIELD,f) _MCBSP_RCERE1_FSET(2,##FIELD,f)
 #endif

  #define _MCBSP_RCERE10_FSETS(FIELD,SYM) _MCBSP_RCERE1_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_RCERE11_FSETS(FIELD,SYM) _MCBSP_RCERE1_FSETS(1,##FIELD,##SYM)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE12_FSETS(FIELD,SYM) _MCBSP_RCERE1_FSETS(2,##FIELD,##SYM)
 #endif
#endif /* C64_SUPPORT */


/******************************************************************************\
* _____________________
* |                   |
* |  R C E R E 2      |
* |___________________|
*
* RCERE20 - serial port 0 enhanced receive channel enable register 2
* RCERE21 - serial port 1 enhanced receive channel enable register 2
* RCERE22 - serial port 2 enhanced receive channel enable register 2
*
* FIELDS (msb -> lsb)
* (rw) RCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _MCBSP_RCERE2_OFFSET           0xC

  #define _MCBSP_RCERE20_ADDR            0x018C0030u
  #define _MCBSP_RCERE21_ADDR            0x01900030u
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE22_ADDR            0x01A40030u
 #endif

  #define _MCBSP_RCERE2_RCE_MASK        0xFFFFFFFFu
  #define _MCBSP_RCERE2_RCE_SHIFT       0x00000000u
  #define  MCBSP_RCERE2_RCE_DEFAULT     0x00000000u
  #define  MCBSP_RCERE2_RCE_OF(x)       _VALUEOF(x)

  #define  MCBSP_RCERE2_OF(x)            _VALUEOF(x)

  #define MCBSP_RCERE2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,RCERE2,RCE)\
  )

  #define MCBSP_RCERE2_RMK(rce) (Uint32)(\
     _PER_FMK(MCBSP,RCERE2,RCE,rce) \
  )

  #define _MCBSP_RCERE2_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_RCERE2##N##_ADDR,MCBSP,RCERE2,FIELD)

  #define _MCBSP_RCERE2_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_RCERE2##N##_ADDR,MCBSP,RCERE2,FIELD,field)

  #define _MCBSP_RCERE2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_RCERE2##N##_ADDR,MCBSP,RCERE2,FIELD,##SYM)

  #define _MCBSP_RCERE20_FGET(FIELD) _MCBSP_RCERE2_FGET(0,##FIELD)
  #define _MCBSP_RCERE21_FGET(FIELD) _MCBSP_RCERE2_FGET(1,##FIELD)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE22_FGET(FIELD) _MCBSP_RCERE2_FGET(2,##FIELD)
 #endif

  #define _MCBSP_RCERE20_FSET(FIELD,f) _MCBSP_RCERE2_FSET(0,##FIELD,f)
  #define _MCBSP_RCERE21_FSET(FIELD,f) _MCBSP_RCERE2_FSET(1,##FIELD,f)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE22_FSET(FIELD,f) _MCBSP_RCERE2_FSET(2,##FIELD,f)
 #endif

  #define _MCBSP_RCERE20_FSETS(FIELD,SYM) _MCBSP_RCERE2_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_RCERE21_FSETS(FIELD,SYM) _MCBSP_RCERE2_FSETS(1,##FIELD,##SYM)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE22_FSETS(FIELD,SYM) _MCBSP_RCERE2_FSETS(2,##FIELD,##SYM)
 #endif
#endif /* C64_SUPPORT */


/******************************************************************************\
* _____________________
* |                   |
* |  R C E R E 3      |
* |___________________|
*
* RCERE30 - serial port 0 enhanced receive channel enable register 3
* RCERE31 - serial port 1 enhanced receive channel enable register 3
* RCERE32 - serial port 2 enhanced receive channel enable register 3
*
* FIELDS (msb -> lsb)
* (rw) RCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _MCBSP_RCERE3_OFFSET           0xE

  #define _MCBSP_RCERE30_ADDR            0x018C0038u
  #define _MCBSP_RCERE31_ADDR            0x01900038u
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE32_ADDR            0x01A40038u
 #endif

  #define _MCBSP_RCERE3_RCE_MASK        0xFFFFFFFFu
  #define _MCBSP_RCERE3_RCE_SHIFT       0x00000000u
  #define  MCBSP_RCERE3_RCE_DEFAULT     0x00000000u
  #define  MCBSP_RCERE3_RCE_OF(x)       _VALUEOF(x)

  #define  MCBSP_RCERE3_OF(x)            _VALUEOF(x)

  #define MCBSP_RCERE3_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,RCERE3,RCE)\
  )

  #define MCBSP_RCERE3_RMK(rce) (Uint32)(\
     _PER_FMK(MCBSP,RCERE3,RCE,rce)\
  )

  #define _MCBSP_RCERE3_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_RCERE3##N##_ADDR,MCBSP,RCERE3,FIELD)

  #define _MCBSP_RCERE3_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_RCERE3##N##_ADDR,MCBSP,RCERE3,FIELD,field)

  #define _MCBSP_RCERE3_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_RCERE3##N##_ADDR,MCBSP,RCERE3,FIELD,##SYM)

  #define _MCBSP_RCERE30_FGET(FIELD) _MCBSP_RCERE3_FGET(0,##FIELD)
  #define _MCBSP_RCERE31_FGET(FIELD) _MCBSP_RCERE3_FGET(1,##FIELD)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE32_FGET(FIELD) _MCBSP_RCERE3_FGET(2,##FIELD)
 #endif

  #define _MCBSP_RCERE30_FSET(FIELD,f) _MCBSP_RCERE3_FSET(0,##FIELD,f)
  #define _MCBSP_RCERE31_FSET(FIELD,f) _MCBSP_RCERE3_FSET(1,##FIELD,f)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE32_FSET(FIELD,f) _MCBSP_RCERE3_FSET(2,##FIELD,f)
 #endif

  #define _MCBSP_RCERE30_FSETS(FIELD,SYM) _MCBSP_RCERE3_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_RCERE31_FSETS(FIELD,SYM) _MCBSP_RCERE3_FSETS(1,##FIELD,##SYM)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_RCERE32_FSETS(FIELD,SYM) _MCBSP_RCERE3_FSETS(2,##FIELD,##SYM)
 #endif
#endif /* C64_SUPPORT */

/******************************************************************************\
* _____________________
* |                   |
* |  X C E R          |
* |___________________|
*
* XCER0 - serial port 0 transmit channel enable register
* XCER1 - serial port 1 transmit channel enable register
* XCER2 - serial port 2 transmit channel enable register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (rw) XCEB
* (rw) XCEA
*
\******************************************************************************/
 #if (!C64_SUPPORT)
   #define _MCBSP_XCER_OFFSET           8

  #define _MCBSP_XCER0_ADDR            0x018C0020u
  #define _MCBSP_XCER1_ADDR            0x01900020u

#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCER2_ADDR            0x01A40020u
#endif


  #define _MCBSP_XCER_XCEB_MASK        0xFFFF0000u
  #define _MCBSP_XCER_XCEB_SHIFT       0x00000010u
  #define  MCBSP_XCER_XCEB_DEFAULT     0x00000000u
  #define  MCBSP_XCER_XCEB_OF(x)       _VALUEOF(x)

  #define _MCBSP_XCER_XCEA_MASK        0x0000FFFFu
  #define _MCBSP_XCER_XCEA_SHIFT       0x00000000u
  #define  MCBSP_XCER_XCEA_DEFAULT     0x00000000u
  #define  MCBSP_XCER_XCEA_OF(x)       _VALUEOF(x)

  #define  MCBSP_XCER_OF(x)            _VALUEOF(x)


  #define MCBSP_XCER_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,XCER,XCEB)\
    |_PER_FDEFAULT(MCBSP,XCER,XCEA)\
  )

  #define MCBSP_XCER_RMK(xceb,xcea) (Uint32)(\
     _PER_FMK(MCBSP,XCER,XCEB,xceb)\
    |_PER_FMK(MCBSP,XCER,XCEA,xcea)\
  )

  #define _MCBSP_XCER_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_XCER##N##_ADDR,MCBSP,XCER,##FIELD)

  #define _MCBSP_XCER_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_XCER##N##_ADDR,MCBSP,XCER,##FIELD,field)

  #define _MCBSP_XCER_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_XCER##N##_ADDR,MCBSP,XCER,##FIELD,##SYM)

  #define _MCBSP_XCER0_FGET(FIELD) _MCBSP_XCER_FGET(0,##FIELD)
  #define _MCBSP_XCER1_FGET(FIELD) _MCBSP_XCER_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCER2_FGET(FIELD) _MCBSP_XCER_FGET(2,##FIELD)
#endif

  #define _MCBSP_XCER0_FSET(FIELD,f) _MCBSP_XCER_FSET(0,##FIELD,f)
  #define _MCBSP_XCER1_FSET(FIELD,f) _MCBSP_XCER_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCER2_FSET(FIELD,f) _MCBSP_XCER_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_XCER0_FSETS(FIELD,SYM) _MCBSP_XCER_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_XCER1_FSETS(FIELD,SYM) _MCBSP_XCER_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCER2_FSETS(FIELD,SYM) _MCBSP_XCER_FSETS(2,##FIELD,##SYM)
#endif

#endif


/******************************************************************************\
* _____________________
* |                   |
* |  X C E R E 0      |
* |___________________|
*
* XCERE00 - serial port 0 enhanced transmit channel enable register 0
* XCERE01 - serial port 1 enhanced transmit channel enable register 0
* XCERE02 - serial port 2 enhanced transmit channel enable register 0
*
* FIELDS (msb -> lsb)
* (rw) XCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _MCBSP_XCERE0_OFFSET           8

  #define _MCBSP_XCERE00_ADDR            0x018C0020u
  #define _MCBSP_XCERE01_ADDR            0x01900020u
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE02_ADDR            0x01A40020u
 #endif

  #define _MCBSP_XCERE0_XCE_MASK        0xFFFFFFFFu
  #define _MCBSP_XCERE0_XCE_SHIFT       0x00000000u
  #define  MCBSP_XCERE0_XCE_DEFAULT     0x00000000u
  #define  MCBSP_XCERE0_XCE_OF(x)       _VALUEOF(x)

  #define  MCBSP_XCERE0_OF(x)            _VALUEOF(x)

  #define MCBSP_XCERE0_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,XCERE0,XCE)\
  )

  #define MCBSP_XCERE0_RMK(xce) (Uint32)(\
     _PER_FMK(MCBSP,XCERE0,XCE,xce) \
  )

  #define _MCBSP_XCERE0_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_XCERE0##N##_ADDR,MCBSP,XCERE0,FIELD)

  #define _MCBSP_XCERE0_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_XCERE0##N##_ADDR,MCBSP,XCERE0,FIELD,field)

  #define _MCBSP_XCERE0_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_XCERE0##N##_ADDR,MCBSP,XCERE0,FIELD,##SYM)

  #define _MCBSP_XCERE00_FGET(FIELD) _MCBSP_XCERE0_FGET(0,##FIELD)
  #define _MCBSP_XCERE01_FGET(FIELD) _MCBSP_XCERE0_FGET(1,##FIELD)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE02_FGET(FIELD) _MCBSP_XCERE0_FGET(2,##FIELD)
 #endif

  #define _MCBSP_XCERE00_FSET(FIELD,f) _MCBSP_XCERE0_FSET(0,##FIELD,f)
  #define _MCBSP_XCERE01_FSET(FIELD,f) _MCBSP_XCERE0_FSET(1,##FIELD,f)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE02_FSET(FIELD,f) _MCBSP_XCERE0_FSET(2,##FIELD,f)
 #endif

  #define _MCBSP_XCERE00_FSETS(FIELD,SYM) _MCBSP_XCERE0_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_XCERE01_FSETS(FIELD,SYM) _MCBSP_XCERE0_FSETS(1,##FIELD,##SYM)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE02_FSETS(FIELD,SYM) _MCBSP_XCERE0_FSETS(2,##FIELD,##SYM)
 #endif
#endif /* C64_SUPPORT */


/******************************************************************************\
* _____________________
* |                   |
* |  X C E R E 1      |
* |___________________|
*
* XCERE10 - serial port 0 enhanced transmit channel enable register 1
* XCERE11 - serial port 1 enhanced transmit channel enable register 1
* XCERE12 - serial port 2 enhanced transmit channel enable register 1
*
* FIELDS (msb -> lsb)
* (rw) XCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _MCBSP_XCERE1_OFFSET           0xB

  #define _MCBSP_XCERE10_ADDR            0x018C002Cu
  #define _MCBSP_XCERE11_ADDR            0x0190002Cu
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE12_ADDR            0x01A4002Cu
 #endif

  #define _MCBSP_XCERE1_XCE_MASK        0xFFFFFFFFu
  #define _MCBSP_XCERE1_XCE_SHIFT       0x00000000u
  #define  MCBSP_XCERE1_XCE_DEFAULT     0x00000000u
  #define  MCBSP_XCERE1_XCE_OF(x)       _VALUEOF(x)

  #define  MCBSP_XCERE1_OF(x)            _VALUEOF(x)

  #define MCBSP_XCERE1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,XCERE1,XCE)\
  )

  #define MCBSP_XCERE1_RMK(xce) (Uint32)(\
     _PER_FMK(MCBSP,XCERE1,XCE,xce)\
  )

  #define _MCBSP_XCERE1_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_XCERE1##N##_ADDR,MCBSP,XCERE1,FIELD)

  #define _MCBSP_XCERE1_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_XCERE1##N##_ADDR,MCBSP,XCERE1,FIELD,field)

  #define _MCBSP_XCERE1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_XCERE1##N##_ADDR,MCBSP,XCERE1,FIELD,##SYM)

  #define _MCBSP_XCERE10_FGET(FIELD) _MCBSP_XCERE1_FGET(0,##FIELD)
  #define _MCBSP_XCERE11_FGET(FIELD) _MCBSP_XCERE1_FGET(1,##FIELD)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE12_FGET(FIELD) _MCBSP_XCERE1_FGET(2,##FIELD)
 #endif

  #define _MCBSP_XCERE10_FSET(FIELD,f) _MCBSP_XCERE1_FSET(0,##FIELD,f)
  #define _MCBSP_XCERE11_FSET(FIELD,f) _MCBSP_XCERE1_FSET(1,##FIELD,f)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE12_FSET(FIELD,f) _MCBSP_XCERE1_FSET(2,##FIELD,f)
 #endif

  #define _MCBSP_XCERE10_FSETS(FIELD,SYM) _MCBSP_XCERE1_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_XCERE11_FSETS(FIELD,SYM) _MCBSP_XCERE1_FSETS(1,##FIELD,##SYM)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE12_FSETS(FIELD,SYM) _MCBSP_XCERE1_FSETS(2,##FIELD,##SYM)
 #endif
#endif /* C64_SUPPORT */


/******************************************************************************\
* _____________________
* |                   |
* |  X C E R E 2      |
* |___________________|
*
* XCERE20 - serial port 0 enhanced transmit channel enable register 2
* XCERE21 - serial port 1 enhanced transmit channel enable register 2
* XCERE22 - serial port 2 enhanced transmit channel enable register 2
*
* FIELDS (msb -> lsb)
* (rw) XCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _MCBSP_XCERE2_OFFSET           0xD

  #define _MCBSP_XCERE20_ADDR            0x018C0034u
  #define _MCBSP_XCERE21_ADDR            0x01900034u
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE22_ADDR            0x01A40034u
 #endif

  #define _MCBSP_XCERE2_XCE_MASK        0xFFFFFFFFu
  #define _MCBSP_XCERE2_XCE_SHIFT       0x00000000u
  #define  MCBSP_XCERE2_XCE_DEFAULT     0x00000000u
  #define  MCBSP_XCERE2_XCE_OF(x)       _VALUEOF(x)

  #define  MCBSP_XCERE2_OF(x)            _VALUEOF(x)

  #define MCBSP_XCERE2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,XCERE2,XCE)\
  )

  #define MCBSP_XCERE2_RMK(xce) (Uint32)(\
     _PER_FMK(MCBSP,XCERE2,XCE,xce)\
  )

  #define _MCBSP_XCERE2_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_XCERE2##N##_ADDR,MCBSP,XCERE2,FIELD)

  #define _MCBSP_XCERE2_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_XCERE2##N##_ADDR,MCBSP,XCERE2,FIELD,field)

  #define _MCBSP_XCERE2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_XCERE2##N##_ADDR,MCBSP,XCERE2,FIELD,##SYM)

  #define _MCBSP_XCERE20_FGET(FIELD) _MCBSP_XCERE2_FGET(0,##FIELD)
  #define _MCBSP_XCERE21_FGET(FIELD) _MCBSP_XCERE2_FGET(1,##FIELD)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE22_FGET(FIELD) _MCBSP_XCERE2_FGET(2,##FIELD)
 #endif

  #define _MCBSP_XCERE20_FSET(FIELD,f) _MCBSP_XCERE2_FSET(0,##FIELD,f)
  #define _MCBSP_XCERE21_FSET(FIELD,f) _MCBSP_XCERE2_FSET(1,##FIELD,f)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE22_FSET(FIELD,f) _MCBSP_XCERE2_FSET(2,##FIELD,f)
 #endif

  #define _MCBSP_XCERE20_FSETS(FIELD,SYM) _MCBSP_XCERE2_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_XCERE21_FSETS(FIELD,SYM) _MCBSP_XCERE2_FSETS(1,##FIELD,##SYM)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE22_FSETS(FIELD,SYM) _MCBSP_XCERE2_FSETS(2,##FIELD,##SYM)
 #endif
#endif /* C64_SUPPORT */


/******************************************************************************\
* _____________________
* |                   |
* |  X C E R E 3      |
* |___________________|
*
* XCERE30 - serial port 0 enhanced transmit channel enable register 3
* XCERE31 - serial port 1 enhanced transmit channel enable register 3
* XCERE32 - serial port 2 enhanced transmit channel enable register 3
*
* FIELDS (msb -> lsb)
* (rw) XCE
*
\******************************************************************************/
#if (C64_SUPPORT)
  #define _MCBSP_XCERE3_OFFSET           0xF

  #define _MCBSP_XCERE30_ADDR            0x018C003Cu
  #define _MCBSP_XCERE31_ADDR            0x0190003Cu
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE32_ADDR            0x01A4003Cu
 #endif

  #define _MCBSP_XCERE3_XCE_MASK        0xFFFFFFFFu
  #define _MCBSP_XCERE3_XCE_SHIFT       0x00000000u
  #define  MCBSP_XCERE3_XCE_DEFAULT     0x00000000u
  #define  MCBSP_XCERE3_XCE_OF(x)       _VALUEOF(x)

  #define  MCBSP_XCERE3_OF(x)            _VALUEOF(x)

  #define MCBSP_XCERE3_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,XCERE3,XCE)\
  )

  #define MCBSP_XCERE3_RMK(xce) (Uint32)(\
     _PER_FMK(MCBSP,XCERE3,XCE,xce)\
  )

  #define _MCBSP_XCERE3_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_XCERE3##N##_ADDR,MCBSP,XCERE3,FIELD)

  #define _MCBSP_XCERE3_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_XCERE3##N##_ADDR,MCBSP,XCERE3,FIELD,field)

  #define _MCBSP_XCERE3_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_XCERE3##N##_ADDR,MCBSP,XCERE3,FIELD,##SYM)

  #define _MCBSP_XCERE30_FGET(FIELD) _MCBSP_XCERE3_FGET(0,##FIELD)
  #define _MCBSP_XCERE31_FGET(FIELD) _MCBSP_XCERE3_FGET(1,##FIELD)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE32_FGET(FIELD) _MCBSP_XCERE3_FGET(2,##FIELD)
 #endif

  #define _MCBSP_XCERE30_FSET(FIELD,f) _MCBSP_XCERE3_FSET(0,##FIELD,f)
  #define _MCBSP_XCERE31_FSET(FIELD,f) _MCBSP_XCERE3_FSET(1,##FIELD,f)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE32_FSET(FIELD,f) _MCBSP_XCERE3_FSET(2,##FIELD,f)
 #endif

  #define _MCBSP_XCERE30_FSETS(FIELD,SYM) _MCBSP_XCERE3_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_XCERE31_FSETS(FIELD,SYM) _MCBSP_XCERE3_FSETS(1,##FIELD,##SYM)
 #if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_XCERE32_FSETS(FIELD,SYM) _MCBSP_XCERE3_FSETS(2,##FIELD,##SYM)
 #endif
#endif /* C64_SUPPORT */

/******************************************************************************\
* _____________________
* |                   |
* |  P C R            |
* |___________________|
*
* PCR0  - serial port 0 pin control register
* PCR1  - serial port 1 pin control register
* PCR2  - serial port 2 pin control register (1)
*
* (1) only supported on devices with three serial ports
*
* FIELDS (msb -> lsb)
* (rw) XIOEN
* (rw) RIOEN
* (rw) FSXM
* (rw) FSRM
* (rw) CLKXM
* (rw) CLKRM
* (r) CLKSSTAT
* (rw) DXSTAT
* (r)  DRSTAT
* (rw) FSXP
* (rw) FSRP
* (rw) CLKXP
* (rw) CLKRP
*
\******************************************************************************/
  #define _MCBSP_PCR_OFFSET            9

  #define _MCBSP_PCR0_ADDR             0x018C0024u
  #define _MCBSP_PCR1_ADDR             0x01900024u

#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_PCR2_ADDR             0x01A40024u
#endif

  #define _MCBSP_PCR_XIOEN_MASK        0x00002000u
  #define _MCBSP_PCR_XIOEN_SHIFT       0x0000000Du
  #define  MCBSP_PCR_XIOEN_DEFAULT     0x00000000u
  #define  MCBSP_PCR_XIOEN_OF(x)       _VALUEOF(x)
  #define  MCBSP_PCR_XIOEN_SP          0x00000000u
  #define  MCBSP_PCR_XIOEN_GPIO        0x00000001u

  #define _MCBSP_PCR_RIOEN_MASK        0x00001000u
  #define _MCBSP_PCR_RIOEN_SHIFT       0x0000000Cu
  #define  MCBSP_PCR_RIOEN_DEFAULT     0x00000000u
  #define  MCBSP_PCR_RIOEN_OF(x)       _VALUEOF(x)
  #define  MCBSP_PCR_RIOEN_SP          0x00000000u
  #define  MCBSP_PCR_RIOEN_GPIO        0x00000001u

  #define _MCBSP_PCR_FSXM_MASK         0x00000800u
  #define _MCBSP_PCR_FSXM_SHIFT        0x0000000Bu
  #define  MCBSP_PCR_FSXM_DEFAULT      0x00000000u
  #define  MCBSP_PCR_FSXM_OF(x)        _VALUEOF(x)
  #define  MCBSP_PCR_FSXM_EXTERNAL     0x00000000u
  #define  MCBSP_PCR_FSXM_INTERNAL     0x00000001u

  #define _MCBSP_PCR_FSRM_MASK         0x00000400u
  #define _MCBSP_PCR_FSRM_SHIFT        0x0000000Au
  #define  MCBSP_PCR_FSRM_DEFAULT      0x00000000u
  #define  MCBSP_PCR_FSRM_OF(x)        _VALUEOF(x)
  #define  MCBSP_PCR_FSRM_EXTERNAL     0x00000000u
  #define  MCBSP_PCR_FSRM_INTERNAL     0x00000001u

  #define _MCBSP_PCR_CLKXM_MASK        0x00000200u
  #define _MCBSP_PCR_CLKXM_SHIFT       0x00000009u
  #define  MCBSP_PCR_CLKXM_DEFAULT     0x00000000u
  #define  MCBSP_PCR_CLKXM_OF(x)       _VALUEOF(x)
  #define  MCBSP_PCR_CLKXM_INPUT       0x00000000u
  #define  MCBSP_PCR_CLKXM_OUTPUT      0x00000001u

  #define _MCBSP_PCR_CLKRM_MASK        0x00000100u
  #define _MCBSP_PCR_CLKRM_SHIFT       0x00000008u
  #define  MCBSP_PCR_CLKRM_DEFAULT     0x00000000u
  #define  MCBSP_PCR_CLKRM_OF(x)       _VALUEOF(x)
  #define  MCBSP_PCR_CLKRM_INPUT       0x00000000u
  #define  MCBSP_PCR_CLKRM_OUTPUT      0x00000001u

  #define _MCBSP_PCR_CLKSSTAT_MASK     0x00000040u
  #define _MCBSP_PCR_CLKSSTAT_SHIFT    0x00000006u
  #define  MCBSP_PCR_CLKSSTAT_DEFAULT  0x00000000u
  #define  MCBSP_PCR_CLKSSTAT_OF(x)    _VALUEOF(x)
  #define  MCBSP_PCR_CLKSSTAT_0        0x00000000u
  #define  MCBSP_PCR_CLKSSTAT_1        0x00000001u

  #define _MCBSP_PCR_DXSTAT_MASK       0x00000020u
  #define _MCBSP_PCR_DXSTAT_SHIFT      0x00000005u
  #define  MCBSP_PCR_DXSTAT_DEFAULT    0x00000000u
  #define  MCBSP_PCR_DXSTAT_OF(x)      _VALUEOF(x)
  #define  MCBSP_PCR_DXSTAT_0          0x00000000u
  #define  MCBSP_PCR_DXSTAT_1          0x00000001u

  #define _MCBSP_PCR_DRSTAT_MASK       0x00000010u
  #define _MCBSP_PCR_DRSTAT_SHIFT      0x00000004u
  #define  MCBSP_PCR_DRSTAT_DEFAULT    0x00000000u
  #define  MCBSP_PCR_DRSTAT_OF(x)      _VALUEOF(x)
  #define  MCBSP_PCR_DRSTAT_0          0x00000000u
  #define  MCBSP_PCR_DRSTAT_1          0x00000001u

  #define _MCBSP_PCR_FSXP_MASK         0x00000008u
  #define _MCBSP_PCR_FSXP_SHIFT        0x00000003u
  #define  MCBSP_PCR_FSXP_DEFAULT      0x00000000u
  #define  MCBSP_PCR_FSXP_OF(x)        _VALUEOF(x)
  #define  MCBSP_PCR_FSXP_ACTIVEHIGH   0x00000000u
  #define  MCBSP_PCR_FSXP_ACTIVELOW    0x00000001u

  #define _MCBSP_PCR_FSRP_MASK         0x00000004u
  #define _MCBSP_PCR_FSRP_SHIFT        0x00000002u
  #define  MCBSP_PCR_FSRP_DEFAULT      0x00000000u
  #define  MCBSP_PCR_FSRP_OF(x)        _VALUEOF(x)
  #define  MCBSP_PCR_FSRP_ACTIVEHIGH   0x00000000u
  #define  MCBSP_PCR_FSRP_ACTIVELOW    0x00000001u

  #define _MCBSP_PCR_CLKXP_MASK        0x00000002u
  #define _MCBSP_PCR_CLKXP_SHIFT       0x00000001u
  #define  MCBSP_PCR_CLKXP_DEFAULT     0x00000000u
  #define  MCBSP_PCR_CLKXP_OF(x)       _VALUEOF(x)
  #define  MCBSP_PCR_CLKXP_RISING      0x00000000u
  #define  MCBSP_PCR_CLKXP_FALLING     0x00000001u

  #define _MCBSP_PCR_CLKRP_MASK        0x00000001u
  #define _MCBSP_PCR_CLKRP_SHIFT       0x00000000u
  #define  MCBSP_PCR_CLKRP_DEFAULT     0x00000000u
  #define  MCBSP_PCR_CLKRP_OF(x)       _VALUEOF(x)
  #define  MCBSP_PCR_CLKRP_FALLING     0x00000000u
  #define  MCBSP_PCR_CLKRP_RISING      0x00000001u

  #define  MCBSP_PCR_OF(x)             _VALUEOF(x)

  #define MCBSP_PCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(MCBSP,PCR,XIOEN)\
    |_PER_FDEFAULT(MCBSP,PCR,RIOEN)\
    |_PER_FDEFAULT(MCBSP,PCR,FSXM)\
    |_PER_FDEFAULT(MCBSP,PCR,FSRM)\
    |_PER_FDEFAULT(MCBSP,PCR,CLKXM)\
    |_PER_FDEFAULT(MCBSP,PCR,CLKRM)\
    |_PER_FDEFAULT(MCBSP,PCR,CLKSSTAT)\
    |_PER_FDEFAULT(MCBSP,PCR,DXSTAT)\
    |_PER_FDEFAULT(MCBSP,PCR,DRSTAT)\
    |_PER_FDEFAULT(MCBSP,PCR,FSXP)\
    |_PER_FDEFAULT(MCBSP,PCR,FSRP)\
    |_PER_FDEFAULT(MCBSP,PCR,CLKXP)\
    |_PER_FDEFAULT(MCBSP,PCR,CLKRP)\
  )

 #if (CHIP_6410 | CHIP_6413 | CHIP_6418)
  #define MCBSP_PCR_RMK(xioen,rioen,fsxm,fsrm,clkxm,clkrm,\
                        dxstat,fsxp,fsrp,clkxp,clkrp) (Uint32)(\
     _PER_FMK(MCBSP,PCR,XIOEN,xioen)\
    |_PER_FMK(MCBSP,PCR,RIOEN,rioen)\
    |_PER_FMK(MCBSP,PCR,FSXM,fsxm)\
    |_PER_FMK(MCBSP,PCR,FSRM,fsrm)\
    |_PER_FMK(MCBSP,PCR,CLKXM,clkxm)\
    |_PER_FMK(MCBSP,PCR,CLKRM,clkrm)\
    |_PER_FMK(MCBSP,PCR,DXSTAT,dxstat)\
    |_PER_FMK(MCBSP,PCR,FSXP,fsxp)\
    |_PER_FMK(MCBSP,PCR,FSRP,fsrp)\
    |_PER_FMK(MCBSP,PCR,CLKXP,clkxp)\
    |_PER_FMK(MCBSP,PCR,CLKRP,clkrp)\
  )
 #else
  #define MCBSP_PCR_RMK(xioen,rioen,fsxm,fsrm,clkxm,clkrm,clksstat,\
    dxstat,fsxp,fsrp,clkxp,clkrp) (Uint32)(\
     _PER_FMK(MCBSP,PCR,XIOEN,xioen)\
    |_PER_FMK(MCBSP,PCR,RIOEN,rioen)\
    |_PER_FMK(MCBSP,PCR,FSXM,fsxm)\
    |_PER_FMK(MCBSP,PCR,FSRM,fsrm)\
    |_PER_FMK(MCBSP,PCR,CLKXM,clkxm)\
    |_PER_FMK(MCBSP,PCR,CLKRM,clkrm)\
    |_PER_FMK(MCBSP,PCR,CLKSSTAT,clksstat)\
    |_PER_FMK(MCBSP,PCR,DXSTAT,dxstat)\
    |_PER_FMK(MCBSP,PCR,FSXP,fsxp)\
    |_PER_FMK(MCBSP,PCR,FSRP,fsrp)\
    |_PER_FMK(MCBSP,PCR,CLKXP,clkxp)\
    |_PER_FMK(MCBSP,PCR,CLKRP,clkrp)\
  )
 #endif
  #define _MCBSP_PCR_FGET(N,FIELD)\
    _PER_FGET(_MCBSP_PCR##N##_ADDR,MCBSP,PCR,##FIELD)

  #define _MCBSP_PCR_FSET(N,FIELD,field)\
    _PER_FSET(_MCBSP_PCR##N##_ADDR,MCBSP,PCR,##FIELD,field)

  #define _MCBSP_PCR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_MCBSP_PCR##N##_ADDR,MCBSP,PCR,##FIELD,##SYM)

  #define _MCBSP_PCR0_FGET(FIELD) _MCBSP_PCR_FGET(0,##FIELD)
  #define _MCBSP_PCR1_FGET(FIELD) _MCBSP_PCR_FGET(1,##FIELD)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_PCR2_FGET(FIELD) _MCBSP_PCR_FGET(2,##FIELD)
#endif

  #define _MCBSP_PCR0_FSET(FIELD,f) _MCBSP_PCR_FSET(0,##FIELD,f)
  #define _MCBSP_PCR1_FSET(FIELD,f) _MCBSP_PCR_FSET(1,##FIELD,f)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_PCR2_FSET(FIELD,f) _MCBSP_PCR_FSET(2,##FIELD,f)
#endif

  #define _MCBSP_PCR0_FSETS(FIELD,SYM) _MCBSP_PCR_FSETS(0,##FIELD,##SYM)
  #define _MCBSP_PCR1_FSETS(FIELD,SYM) _MCBSP_PCR_FSETS(1,##FIELD,##SYM)
#if (_MCBSP_PORT_CNT==3)
  #define _MCBSP_PCR2_FSETS(FIELD,SYM) _MCBSP_PCR_FSETS(2,##FIELD,##SYM)
#endif


/*----------------------------------------------------------------------------*/

#endif /* MCBSP_SUPPORT */
#endif /* _CSL_MCBSPHAL_H_ */
/******************************************************************************\
* End of csl_mcbsphal.h
\******************************************************************************/


csl_mdio.h/     1057236663  0     0     0       5863      `
/*****************************************************************************\
*           Copyright (C) 1999-2003 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mdio.h
* DATE CREATED.. 02/08/2002
* LAST MODIFIED. 05/09/2003
*------------------------------------------------------------------------------
* NOTE:
*   When used in an multitasking environment, no MDIO function may be
*   called while another MDIO function is operating on the same device
*   handle in another thread. It is the responsibility of the application
*   to assure adherence to this restriction.
*
* ALSO NOTE:
*   When using the CSL EMAC module, the EMAC module will make use of this
*   MDIO module. It is not necessary for the application to call any MDIO
*   functions directly when the CSL EMAC module is in use.
*
\******************************************************************************/
#ifndef _CSL_MDIO_H
#define _CSL_MDIO_H_

#include <csl.h>
#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_mdiohal.h>


#if (MDIO_SUPPORT)
/*-----------------------------------------------------------------------*\
* NEW TYPES
\*-----------------------------------------------------------------------*/
#ifndef _CSL_EMAC_TYPES
#define _CSL_EMAC_TYPES
typedef unsigned int uint;
typedef void * Handle;
#endif

/*-----------------------------------------------------------------------*\
* MDIO Configuration Mode Flags
*
* These flags determine how the MDIO module behaves
\*-----------------------------------------------------------------------*/
#define MDIO_MODEFLG_AUTONEG     0x0001 /* Use Autonegotiate         */
/* The following bits are used for manual and fallback configuration */
#define MDIO_MODEFLG_HD10        0x0002 /* Use 10Mb/s Half Duplex    */
#define MDIO_MODEFLG_FD10        0x0004 /* Use 10Mb/s Full Duplex    */
#define MDIO_MODEFLG_HD100       0x0008 /* Use 100Mb/s Half Duplex   */
#define MDIO_MODEFLG_FD100       0x0010 /* Use 100Mb/s Full Duplex   */
#define MDIO_MODEFLG_LOOPBACK    0x0020 /* Use PHY Loopback          */
/* The following bits are reserved for use by the MDIO module */
#define MDIO_MODEFLG_NWAYACTIVE  0x0040 /* NWAY is currently active  */

/*-----------------------------------------------------------------------*\
* MDIO Link Status Values
*
* These values indicate current PHY link status
\*-----------------------------------------------------------------------*/
#define MDIO_LINKSTATUS_NOLINK   0
#define MDIO_LINKSTATUS_HD10     1
#define MDIO_LINKSTATUS_FD10     2
#define MDIO_LINKSTATUS_HD100    3
#define MDIO_LINKSTATUS_FD100    4

/*-----------------------------------------------------------------------*\
* MDIO Events
*
* These events are returned by MDIO_timerTick() to allow the application
* (or EMAC) to track MDIO status.
\*-----------------------------------------------------------------------*/
#define MDIO_EVENT_NOCHANGE      0   /* No change from previous status */
#define MDIO_EVENT_LINKDOWN      1   /* Link down event                */
#define MDIO_EVENT_LINKUP        2   /* Link (or re-link) event        */
#define MDIO_EVENT_PHYERROR      3   /* No PHY connected               */


/*-----------------------------------------------------------------------*\
* MDIO_open()
*
* Opens the MDIO peripheral and start searching for a PHY device.
*
* It is assumed that the MDIO module is reset prior to calling this
* function.
\*-----------------------------------------------------------------------*/
CSLAPI Handle MDIO_open( uint mdioModeFlags );

/*-----------------------------------------------------------------------*\
* MDIO_close()
*
* Close the MDIO peripheral and disable further operation.
\*-----------------------------------------------------------------------*/
CSLAPI void MDIO_close( Handle hMDIO );

/*-----------------------------------------------------------------------*\
* MDIO_getStatus()
*
* Called to get the status of the MDIO/PHY
\*-----------------------------------------------------------------------*/
CSLAPI void MDIO_getStatus( Handle hMDIO, uint *pPhy, uint *pLinkStatus );

/*-----------------------------------------------------------------------*\
* MDIO_timerTick()
*
* Called to signify that approx 100mS have elapsed
*
* Returns an MDIO event code (see MDIO Events in CSL_MDIO.H).
\*-----------------------------------------------------------------------*/
CSLAPI uint MDIO_timerTick( Handle hMDIO );

/*-----------------------------------------------------------------------*\
* MDIO_initPHY()
*
* Force a switch to the specified PHY, and start negotiation.
*
* This call is only used to override the normal PHY detection process.
*
* Returns 1 if the PHY selection completed OK, else 0
\*-----------------------------------------------------------------------*/
CSLAPI uint MDIO_initPHY( Handle hMDIO, uint phyAddr );

/*-----------------------------------------------------------------------*\
* MDIO_phyRegRead()
*
* Raw data read of a PHY register.
*
* Returns 1 if the PHY ACK'd the read, else 0
\*-----------------------------------------------------------------------*/
CSLAPI uint MDIO_phyRegRead( uint phyIdx, uint phyReg, Uint16 *pData );

/*-----------------------------------------------------------------------*\
* MDIO_phyRegWrite()
*
* Raw data write  of a PHY register.
*
* Returns 1 if the PHY ACK'd the write, else 0
\*-----------------------------------------------------------------------*/
CSLAPI uint MDIO_phyRegWrite( uint phyIdx, uint phyReg, Uint16 data );

#endif /* MDIO_SUPPORT */
#endif /* _CSL_MDIO_H_ */
/******************************************************************************\
* End of mdio.h
\******************************************************************************/

csl_mdiohal.h/  1080217111  0     0     0       18962     `
/*****************************************************************************\
*           Copyright (C) 1999-2003 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_mdiohal.h
* DATE CREATED.. 02/08/2002
* LAST MODIFIED. 03/05/2003
*------------------------------------------------------------------------------
* REGISTERS/PARAMETERS
*
* VERSION           - Module Version Register
* CONTROL           - Module Control Register
* ALIVE             - PHY "Alive" Indication Register
* LINK              - PHY Link Status Register
* LINKINTRAW        - Link Status Change Interrupt Register
* LINKINTMASKED     - Link Status Change Interrupt Register (Masked)
* USERINTRAW        - User Command Complete Interrupt
* USERINTMASKED     - User Command Complete Interrupt (Masked)
* USERINTMASKSET    - Enable User Command Complete Interrupt Mask
* USERINTMASKCLEAR  - Disable User Command Complete Interrupt Mask
* USERACCESS0       - User Access Register 0
* USERPHYSEL0       - User PHY Select Register 0
* USERACCESS1       - User Access Register 1
* USERPHYSEL1       - User PHY Select Register 1
*
*\******************************************************************************/
#ifndef _CSL_MDIOHAL_H
#define _CSL_MDIOHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (MDIO_SUPPORT)

/******************************************************************************\
* MDIO Register section
\******************************************************************************/

#define _MDIO_BASE_ADDR   0x01c83800u


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

/* ----------------- */
/* FIELD MAKE MACROS */
/* ----------------- */

// User Supplied Value
#define MDIO_FMK(REG,FIELD,x)\
  ((x<<_MDIO_##REG##_##FIELD##_SHIFT)&_MDIO_##REG##_##FIELD##_MASK)

// Symbolic Value Name
#define MDIO_FMKS(REG,FIELD,SYM)\
  ((MDIO_##REG##_##FIELD##_##SYM<<_MDIO_##REG##_##FIELD##_SHIFT)\
  &_MDIO_##REG##_##FIELD##_MASK)

// MAC Index Flag Flag
#define MDIO_FMKMIF(MACINDEX)    (1u<<(MACINDEX))


/* -------------------------------- */
/* RAW REGISTER/FIELD ACCESS MACROS */
/* -------------------------------- */

#define MDIO_ADDR(REG)\
    _MDIO_##REG##_ADDR

#define MDIO_REG(REG)\
    *(volatile Uint32*)(_MDIO_##REG##_ADDR)

// Standard Registers
#define MDIO_RGET(REG)\
    (*(volatile Uint32*)(_MDIO_##REG##_ADDR))

#define MDIO_RSET(REG,x)\
    (*(volatile Uint32*)(_MDIO_##REG##_ADDR)=(x))

#define MDIO_FGET(REG,FIELD)\
    ((MDIO_RGET(REG)&_MDIO_##REG##_##FIELD##_MASK)\
    >>_MDIO_##REG##_##FIELD##_SHIFT)

#define MDIO_FSET(REG,FIELD,x)\
    MDIO_RSET(REG,(MDIO_RGET(REG)&~_MDIO_##REG##_##FIELD##_MASK)|\
    MDIO_FMK(REG,FIELD,x))

#define MDIO_FSETS(REG,FIELD,SYM)\
    MDIO_RSET(REG,(MDIO_RGET(REG)&~_MDIO_##REG##_##FIELD##_MASK)|\
    MDIO_FMKS(REG,FIELD,SYM))



/******************************************************************************\
* _____________________
* |                   |
* |  VERSION          |
* |___________________|
*
* TXIDVER           - TX Identification and Version Register
*
* FIELDS (msb -> lsb)
* (r)   MODID       - Module Id
* (r)   REVMAJ      - Major Revision
* (r)   REVMIN      - Minor Revision
*
* MACROS SUPPORTED
*  MDIO_FMK     y
*  MDIO_FMKS    .
*  MDIO_FMKMIF  .
*  MDIO_ADDR    y
*  MDIO_REG     y
*  MDIO_RGET    y
*  MDIO_RSET    y
*  MDIO_FGET    y
*  MDIO_FSET    y
*  MDIO_FSETS   .
*
\******************************************************************************/
#define _MDIO_VERSION_ADDR                      (_MDIO_BASE_ADDR+0x0000u)

#define MDIO_VERSION                            MDIO_REG(VERSION)

#define _MDIO_VERSION_MODID_MASK                0xFFFF0000u
#define _MDIO_VERSION_MODID_SHIFT               16u
#define  MDIO_VERSION_MODID_DEFAULT		0x00000007u	

#define _MDIO_VERSION_REVMAJ_MASK               0x0000FF00u
#define _MDIO_VERSION_REVMAJ_SHIFT              8u
#define  MDIO_VERSION_REVMAJ_DEFAULT		0x00000000u	

#define _MDIO_VERSION_REVMIN_MASK               0x000000FFu
#define _MDIO_VERSION_REVMIN_SHIFT              0u
#define	 MDIO_VERSION_REVMIN_DEFAULT		0x00000000u	



/******************************************************************************\
* _____________________
* |                   |
* |    CONTROL        |
* |___________________|
*
* CONTROL           - MDIO Control Register
*
* FIELDS (msb -> lsb)
* (r)   IDLE        - MDIO State Machine Idle
* (rw)  ENABLE      - Enable Control
* (rw)  PREAMBLE    - Preamble Disable
* (rwc) FAULT       - Fault Indicator
* (rw)  FAULTENB    - Fault Detect Enable
* (rw)  INTTESTENB  - Link Test Enable
* (rw)  CLKDIV      - Clock Divider
*
*
* MACROS SUPPORTED
*  MDIO_FMK     y
*  MDIO_FMKS    y
*  MDIO_FMKMIF  .
*  MDIO_ADDR    y
*  MDIO_REG     y
*  MDIO_RGET    y
*  MDIO_RSET    y
*  MDIO_FGET    y
*  MDIO_FSET    y
*  MDIO_FSETS   y
*
\******************************************************************************/
#define _MDIO_CONTROL_ADDR                      (_MDIO_BASE_ADDR+0x0004u)

#define MDIO_CONTROL                            MDIO_REG(TXCONTROL)

#define _MDIO_CONTROL_IDLE_MASK                 0x80000000u
#define _MDIO_CONTROL_IDLE_SHIFT                31u
#define  MDIO_CONTROL_IDLE_DEFAULT		0x00000001u	
#define MDIO_CONTROL_IDLE_YES                   1u
#define MDIO_CONTROL_IDLE_NO                    0u

#define _MDIO_CONTROL_ENABLE_MASK               0x40000000u
#define _MDIO_CONTROL_ENABLE_SHIFT              30u
#define  MDIO_CONTROL_ENABLE_DEFAULT		0x00000000u	
#define MDIO_CONTROL_ENABLE_YES                 1u
#define MDIO_CONTROL_ENABLE_NO                  0u

#define _MDIO_CONTROL_PREAMBLE_MASK             0x00100000u
#define _MDIO_CONTROL_PREAMBLE_SHIFT            20u
#define  MDIO_CONTROL_PREAMBLE_DEFAULT		0x00000000u	
#define MDIO_CONTROL_PREAMBLE_DISABLED          1u
#define MDIO_CONTROL_PREAMBLE_ENABLED           0u

#define _MDIO_CONTROL_FAULT_MASK                0x00080000u
#define _MDIO_CONTROL_FAULT_SHIFT               19u
#define  MDIO_CONTROL_FAULT_DEFAULT		0x00000000u	
#define MDIO_CONTROL_FAULT_YES                  1u
#define MDIO_CONTROL_FAULT_NO                   0u

#define _MDIO_CONTROL_FAULTENB_MASK             0x00040000u
#define _MDIO_CONTROL_FAULTENB_SHIFT            18u
#define  MDIO_CONTROL_FAULTENB_DEFAULT		0x00000000u	
#define MDIO_CONTROL_FAULTENB_YES               1u
#define MDIO_CONTROL_FAULTENB_NO                0u

#define _MDIO_CONTROL_INTTESTENB_MASK           0x00020000u
#define _MDIO_CONTROL_INTTESTENB_SHIFT          17u
#define  MDIO_CONTROL_INTTESTENB_DEFAULT	0x00000000u	
#define MDIO_CONTROL_INTTESTENB_YES             1u
#define MDIO_CONTROL_INTTESTENB_NO              0u

#define _MDIO_CONTROL_CLKDIV_MASK               0x000000FFu
#define _MDIO_CONTROL_CLKDIV_SHIFT              0u
#define  MDIO_CONTROL_CLKDIV_DEFAULT		0x000000FFu	



/******************************************************************************\
* _____________________
* |                   |
* |   ALIVE           |
* |   LINK            |
* |___________________|
*
* ALIVE             - PHY "Alive" Indication Register
* LINK              - PHY Link Status Register
*
* FIELDS (msb -> lsb)
*  PHY Index Flags (0-31) (use MDIO_FMKMIF)
*
* MACROS SUPPORTED
*  MDIO_FMK     .
*  MDIO_FMKS    .
*  MDIO_FMKMIF  y
*  MDIO_ADDR    y
*  MDIO_REG     y
*  MDIO_RGET    y
*  MDIO_RSET    y
*  MDIO_FGET    .
*  MDIO_FSET    .
*  MDIO_FSETS   .
*
\******************************************************************************/
#define _MDIO_ALIVE_ADDR                        (_MDIO_BASE_ADDR+0x0008u)
#define _MDIO_LINK_ADDR                         (_MDIO_BASE_ADDR+0x000Cu)

#define MDIO_ALIVE                              MDIO_REG(ALIVE)
#define MDIO_LINK                               MDIO_REG(LINK)



/******************************************************************************\
* _____________________
* |                   |
* | LINKINTRAW        |
* | LINKINTMASKED     |
* | USERINTRAW        |
* | USERINTMASKED     |
* | USERINTMASKSET    |
* | USERINTMASKCLEAR  |
* |___________________|
*
* LINKINTRAW        - Link Status Change Interrupt Register
* LINKINTMASKED     - Link Status Change Interrupt Register (Masked)
* USERINTRAW        - User Command Complete Interrupt
* USERINTMASKED     - User Command Complete Interrupt (Masked)
* USERINTMASKSET    - Enable User Command Complete Interrupt Mask
* USERINTMASKCLEAR  - Disable User Command Complete Interrupt Mask
*
* FIELDS (msb -> lsb)
*       MAC0        - Mac 0 Flag (yes/no)
*       MAC1        - Mac 1 Flag (yes/no)
*
* MACROS SUPPORTED
*  MDIO_FMK     y
*  MDIO_FMKS    y
*  MDIO_FMKMIF  .
*  MDIO_ADDR    y
*  MDIO_REG     y
*  MDIO_RGET    y
*  MDIO_RSET    y
*  MDIO_FGET    y
*  MDIO_FSET    y
*  MDIO_FSETS   .
*
\******************************************************************************/
#define _MDIO_LINKINTRAW_ADDR                   (_MDIO_BASE_ADDR+0x0010u)
#define _MDIO_LINKINTMASKED_ADDR                (_MDIO_BASE_ADDR+0x0014u)
#define _MDIO_USERINTRAW_ADDR                   (_MDIO_BASE_ADDR+0x0020u)
#define _MDIO_USERINTMASKED_ADDR                (_MDIO_BASE_ADDR+0x0024u)
#define _MDIO_USERINTMASKSET_ADDR               (_MDIO_BASE_ADDR+0x0028u)
#define _MDIO_USERINTMASKCLEAR_ADDR             (_MDIO_BASE_ADDR+0x002Cu)

#define MDIO_LINKINTRAW                         MDIO_REG(LINKINT)
#define MDIO_LINKINTMASKED                      MDIO_REG(LINKINTMASKED)
#define MDIO_USERINTRAW                         MDIO_REG(USERINTRAW)
#define MDIO_USERINTMASKED                      MDIO_REG(USERINTMASKED)
#define MDIO_USERINTMASKSET                     MDIO_REG(USERINTMASKSET)
#define MDIO_USERINTMASKCLEAR                   MDIO_REG(USERINTMASKCLEAR)

#define _MDIO_LINKINTRAW_MAC0_MASK              0x00000001u
#define _MDIO_LINKINTRAW_MAC0_SHIFT             0u
#define  MDIO_LINKINTRAW_MAC0_DEFAULT		0x00000000u	
#define _MDIO_LINKINTRAW_MAC1_MASK              0x00000002u
#define _MDIO_LINKINTRAW_MAC1_SHIFT             1u
#define  MDIO_LINKINTRAW_MAC1_DEFAULT		0x00000000u	

#define MDIO_LINKINTRAW_MAC0_YES                1u
#define MDIO_LINKINTRAW_MAC0_NO                 0u
#define MDIO_LINKINTRAW_MAC1_YES                1u
#define MDIO_LINKINTRAW_MAC1_NO                 0u

#define _MDIO_LINKINTMASKED_MAC0_MASK           0x00000001u
#define _MDIO_LINKINTMASKED_MAC0_SHIFT          0u
#define  MDIO_LINKINTMASKED_MAC0_DEFAULT	0x00000000u	
#define _MDIO_LINKINTMASKED_MAC1_MASK           0x00000002u
#define _MDIO_LINKINTMASKED_MAC1_SHIFT          1u
#define  MDIO_LINKINTMASKED_MAC1_DEFAULT	0x00000000u	

#define MDIO_LINKINTMASKED_MAC0_YES             1u
#define MDIO_LINKINTMASKED_MAC0_NO              0u
#define MDIO_LINKINTMASKED_MAC1_YES             1u
#define MDIO_LINKINTMASKED_MAC1_NO              0u

#define _MDIO_USERINTRAW_MAC0_MASK              0x00000001u
#define _MDIO_USERINTRAW_MAC0_SHIFT             0u
#define  MDIO_USERINTRAW_MAC0_DEFAULT		0x00000000u	
#define _MDIO_USERINTRAW_MAC1_MASK              0x00000002u
#define _MDIO_USERINTRAW_MAC1_SHIFT             1u
#define	 MDIO_USERINTRAW_MAC1_DEFAULT		0x00000000u	

#define MDIO_USERINTRAW_MAC0_YES                1u
#define MDIO_USERINTRAW_MAC0_NO                 0u
#define MDIO_USERINTRAW_MAC1_YES                1u
#define MDIO_USERINTRAW_MAC1_NO                 0u

#define _MDIO_USERINTMASKED_MAC0_MASK           0x00000001u
#define _MDIO_USERINTMASKED_MAC0_SHIFT          0u
#define  MDIO_USERINTMASKED_MAC0_DEFAULT	0x00000000u
#define _MDIO_USERINTMASKED_MAC1_MASK           0x00000002u
#define _MDIO_USERINTMASKED_MAC1_SHIFT          1u
#define  MDIO_USERINTMASKED_MAC1_DEFAULT	0x00000000u	

#define MDIO_USERINTMASKED_MAC0_YES             1u
#define MDIO_USERINTMASKED_MAC0_NO              0u
#define MDIO_USERINTMASKED_MAC1_YES             1u
#define MDIO_USERINTMASKED_MAC1_NO              0u

#define _MDIO_USERINTMASKSET_MAC0_MASK          0x00000001u
#define _MDIO_USERINTMASKSET_MAC0_SHIFT         0u
#define  MDIO_USERINTMASKSET_MAC0_DEFAULT	0x00000000u
#define _MDIO_USERINTMASKSET_MAC1_MASK          0x00000002u
#define _MDIO_USERINTMASKSET_MAC1_SHIFT         1u
#define  MDIO_USERINTMASKSET_MAC1_DEFAULT	0x00000000u	

#define MDIO_USERINTMASKSET_MAC0_YES            1u
#define MDIO_USERINTMASKSET_MAC0_NO             0u
#define MDIO_USERINTMASKSET_MAC1_YES            1u
#define MDIO_USERINTMASKSET_MAC1_NO             0u

#define _MDIO_USERINTMASKCLEAR_MAC0_MASK        0x00000001u
#define _MDIO_USERINTMASKCLEAR_MAC0_SHIFT       0u
#define  MDIO_USERINTMASKCLEAR_MAC0_DEFAULT	0x00000000u	
#define _MDIO_USERINTMASKCLEAR_MAC1_MASK        0x00000002u
#define _MDIO_USERINTMASKCLEAR_MAC1_SHIFT       1u
#define  MDIO_USERINTMASKCLEAR_MAC1_DEFAULT	0x00000000u	

#define MDIO_USERINTMASKCLEAR_MAC0_YES          1u
#define MDIO_USERINTMASKCLEAR_MAC0_NO           0u
#define MDIO_USERINTMASKCLEAR_MAC1_YES          1u
#define MDIO_USERINTMASKCLEAR_MAC1_NO           0u



/******************************************************************************\
* _____________________
* |                   |
* |   USERACCESS0     |
* |   USERACCESS1     |
* |___________________|
*
* USERACCESS0       - User Access Register 0
* USERACCESS1       - User Access Register 1
*
* FIELDS (msb -> lsb)
* (rws) GO          - Go Bit
* (rw)  WRITE       - Write Enable
* (r)   ACK         - Acknowledge
* (rw)  REGADR      - PHY Register Address
* (rw)  PHYADR      - PHY Device Address
* (rw)  DATA        - User Data to Read/Write
*
* MACROS SUPPORTED
*  MDIO_FMK     y
*  MDIO_FMKS    .
*  MDIO_FMKMIF  .
*  MDIO_ADDR    y
*  MDIO_REG     y
*  MDIO_RGET    y
*  MDIO_RSET    y
*  MDIO_FGET    y
*  MDIO_FSET    y
*  MDIO_FSETS   .
*
\******************************************************************************/
#define _MDIO_USERACCESS0_ADDR                  (_MDIO_BASE_ADDR+0x0080u)
#define _MDIO_USERACCESS1_ADDR                  (_MDIO_BASE_ADDR+0x0088u)

#define  MDIO_USERACCESS0                       MDIO_REG(USERACCESS0)
#define  MDIO_USERACCESS1                       MDIO_REG(USERACCESS1)

#define _MDIO_USERACCESS0_GO_MASK               0x80000000u
#define _MDIO_USERACCESS0_GO_SHIFT              31u
#define  MDIO_USERACCESS0_GO_DEFAULT		0x00000000u
#define _MDIO_USERACCESS0_WRITE_MASK            0x40000000u
#define _MDIO_USERACCESS0_WRITE_SHIFT           30u
#define  MDIO_USERACCESS0_WRITE_DEFAULT		0x00000000u
#define _MDIO_USERACCESS0_ACK_MASK              0x20000000u
#define _MDIO_USERACCESS0_ACK_SHIFT             29u
#define  MDIO_USERACCESS0_ACK_DEFAULT		0x00000000u
#define _MDIO_USERACCESS0_REGADR_MASK           0x03E00000u
#define _MDIO_USERACCESS0_REGADR_SHIFT          21u
#define  MDIO_USERACCESS0_REGADR_DEFAULT	0x00000000u
#define _MDIO_USERACCESS0_PHYADR_MASK           0x001F0000u
#define _MDIO_USERACCESS0_PHYADR_SHIFT          16u
#define  MDIO_USERACCESS0_PHYADR_DEFAULT	0x00000000u
#define _MDIO_USERACCESS0_DATA_MASK             0x0000FFFFu
#define _MDIO_USERACCESS0_DATA_SHIFT            0u
#define  MDIO_USERACCESS0_DATA_DEFAULT		0x00000000u

#define _MDIO_USERACCESS1_GO_MASK               0x80000000u
#define _MDIO_USERACCESS1_GO_SHIFT              31u
#define  MDIO_USERACCESS1_GO_DEFAULT		0x00000000u
#define _MDIO_USERACCESS1_WRITE_MASK            0x40000000u
#define _MDIO_USERACCESS1_WRITE_SHIFT           30u
#define  MDIO_USERACCESS1_WRITE_DEFAULT		0x00000000u
#define _MDIO_USERACCESS1_ACK_MASK              0x20000000u
#define _MDIO_USERACCESS1_ACK_SHIFT             29u
#define  MDIO_USERACCESS1_ACK_DEFAULT		0x00000000u
#define _MDIO_USERACCESS1_REGADR_MASK           0x03E00000u
#define _MDIO_USERACCESS1_REGADR_SHIFT          21u
#define  MDIO_USERACCESS1_REGADR_DEFAULT	0x00000000u
#define _MDIO_USERACCESS1_PHYADR_MASK           0x001F0000u
#define _MDIO_USERACCESS1_PHYADR_SHIFT          16u
#define  MDIO_USERACCESS1_PHYADR_DEFAULT	0x00000000u
#define _MDIO_USERACCESS1_DATA_MASK             0x0000FFFFu
#define _MDIO_USERACCESS1_DATA_SHIFT            0u
#define  MDIO_USERACCESS1_DATA_DEFAULT		0x00000000u


/******************************************************************************\
* _____________________
* |                   |
* |   USERPHYSEL0     |
* |   USERPHYSEL1     |
* |___________________|
*
* USERPHYSEL0       - User PHY Select Register 0
* USERPHYSEL1       - User PHY Select Register 1
*
* FIELDS (msb -> lsb)
* (rw)  LINKSEL     - Link Detect Type Selection
* (rw)  LINKINTENB  - Link Interrupt Enable
* (rw)  PHYADDR     - Address (0-31) of Phy to Use
*
* MACROS SUPPORTED
*  MDIO_FMK     y
*  MDIO_FMKS    y
*  MDIO_FMKMIF  .
*  MDIO_ADDR    y
*  MDIO_REG     y
*  MDIO_RGET    y
*  MDIO_RSET    y
*  MDIO_FGET    y
*  MDIO_FSET    y
*  MDIO_FSETS   y
*
\******************************************************************************/
#define _MDIO_USERPHYSEL0_ADDR                  (_MDIO_BASE_ADDR+0x0084u)
#define _MDIO_USERPHYSEL1_ADDR                  (_MDIO_BASE_ADDR+0x008Cu)

#define  MDIO_USERPHYSEL0                       MDIO_REG(USERPHYSEL0)
#define  MDIO_USERPHYSEL1                       MDIO_REG(USERPHYSEL1)

#define _MDIO_USERPHYSEL0_LINKSEL_MASK          0x00000080u
#define _MDIO_USERPHYSEL0_LINKSEL_SHIFT         7u
#define  MDIO_USERPHYSEL0_LINKSEL_DEFAULT	0x00000000u
#define MDIO_USERPHYSEL0_LINKSEL_MLINK          1u
#define MDIO_USERPHYSEL0_LINKSEL_MDIO           0u

#define _MDIO_USERPHYSEL0_LINKINTENB_MASK       0x00000040u
#define _MDIO_USERPHYSEL0_LINKINTENB_SHIFT      6u
#define  MDIO_USERPHYSEL0_LINKINTENB_DEFAULT	0x00000000u
#define MDIO_USERPHYSEL0_LINKINTENB_ENABLE      1u
#define MDIO_USERPHYSEL0_LINKINTENB_DISABLE     0u

#define _MDIO_USERPHYSEL0_PHYADDR_MASK          0x0000001Fu
#define _MDIO_USERPHYSEL0_PHYADDR_SHIFT         0u
#define  MDIO_USERPHYSEL0_PHYADDR_DEFAULT	0x00000000u

#define _MDIO_USERPHYSEL1_LINKSEL_MASK          0x00000080u
#define _MDIO_USERPHYSEL1_LINKSEL_SHIFT         7u
#define  MDIO_USERPHYSEL1_LINKSEL_DEFAULT	0x00000000u
#define MDIO_USERPHYSEL1_LINKSEL_MLINK          1u
#define MDIO_USERPHYSEL1_LINKSEL_MDIO           0u

#define _MDIO_USERPHYSEL1_LINKINTENB_MASK       0x00000040u
#define _MDIO_USERPHYSEL1_LINKINTENB_SHIFT      6u
#define  MDIO_USERPHYSEL1_LINKINTENB_DEFAULT	0x00000000u
#define MDIO_USERPHYSEL1_LINKINTENB_ENABLE      1u
#define MDIO_USERPHYSEL1_LINKINTENB_DISABLE     0u

#define _MDIO_USERPHYSEL1_PHYADDR_MASK          0x0000001Fu
#define _MDIO_USERPHYSEL1_PHYADDR_SHIFT         0u
#define  MDIO_USERPHYSEL1_PHYADDR_DEFAULT	0x00000000u


#endif /* MDIO_SUPPORT */

#endif /* _CSL_MDIOHAL_H_ */
/******************************************************************************\
* End of csl_mdiohal.h
\******************************************************************************/




csl_pci.h/      1055323622  0     0     0       13300     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_pci.h
* DATE CREATED.. Mon 06/12/2000
* LAST MODIFIED. 02/12/2002  PCI_intClear()
*                04/20/2001  (C64x compatibility)
*				 06/20/2003  TRCTL enhancement
*
\******************************************************************************/
#ifndef _CSL_PCI_H_
#define _CSL_PCI_H_

#include <csl_chip.h>
#include <csl_stdinc.h>
#include <csl_irq.h>
#include <csl_pcihal.h>

#if (PCI_SUPPORT)
/****************************************\
* PCI scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _PCI_MOD_
  #define IDECL extern far
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL extern far
  #endif
#endif

/****************************************\
* PCI global macro declarations
\****************************************/
#define PCI_EVENT_CNT   11

/* eventPci  definitions */
#define PCI_EVT_DMAHALTED    12
#define PCI_EVT_PRST         11
#define PCI_EVT_EERDY	      9
#define PCI_EVT_CFGERR	      8
#define PCI_EVT_CFGDONE	      7
#define PCI_EVT_MASTEROK      6
#define PCI_EVT_PWRHL         5
#define PCI_EVT_PWRLH         4
#define PCI_EVT_HOSTSW	      3
#define PCI_EVT_PCIMASTER     2
#define PCI_EVT_PCITARGET     1
#define PCI_EVT_PWRMGMT	      0


/* mode StarttXfr definitions */
#define	PCI_WRITE	 0x1u
#define PCI_READ_PREF    0x2u
#define	PCI_READ_NOPREF  0x3u

/* EEPROM sizes */
 #define PCI_EEPROM_NONE     0x00000000u
 #define PCI_EEPROM_4K       0x00000011u
#if (!C64_SUPPORT)
 #define PCI_EEPROM_1K       0x00000001u
 #define PCI_EEPROM_2K       0x00000010u
 #define PCI_EEPROM_16K      0x00000100u
#endif

/****************************************\
* PCI global typedef declarations
\****************************************/
#if(!C64_SUPPORT)
typedef struct {
   Uint32 dspma;
   Uint32 pcima;
   Uint32 pcimc;
} PCI_ConfigXfr;
#else
typedef struct {
   Uint32 dspma;
   Uint32 pcima;
   Uint32 pcimc;
   Uint32 trctl;
} PCI_ConfigXfr;
#endif

/****************************************\
* PCI global variable declarations
\****************************************/
extern far Uint32 _PCI_maskTable[13];



/*_PCI_maskTable[PCI_EVT_PWRMGMT]= _PCI_PCIIEN_PWRMGMT_MASK;
_PCI_maskTable[PCI_EVT_PCITARGET]= _PCI_PCIIEN_PCITARGET_MASK;
_PCI_maskTable[PCI_EVT_PCIMASTER]= _PCI_PCIIEN_PCIMASTER_MASK;
_PCI_maskTable[PCI_EVT_HOSTSW]= _PCI_PCIIEN_PWRLH_MASK;
_PCI_maskTable[PCI_EVT_PWRLH]= _PCI_PCIIEN_PWRLH_MASK;
_PCI_maskTable[PCI_EVT_PWRHL]= _PCI_PCIIEN_PWRHL_MASK;
_PCI_maskTable[PCI_EVT_MASTEROK]= _PCI_PCIIEN_MASTEROK_MASK;
_PCI_maskTable[PCI_EVT_CFGDONE]= _PCI_PCIIEN_CFGDONE_MASK;
_PCI_maskTable[PCI_EVT_CFGERR]= _PCI_PCIIEN_CFGERR_MASK;
_PCI_maskTable[PCI_EVT_EERDY]=  _PCI_PCIIEN_EERDY_MASK;
_PCI_maskTable[PCI_EVT_PRST]= _PCI_PCIIEN_PRST_MASK;
_PCI_maskTable[PCI_EVT_DMAHALTED]= _PCI_PCIIS_DMAHALTED_MASK;
 */

/****************************************\
* PCI global function declarations
\****************************************/
extern far Uint32 _PCI_eepromEnableWrite();
extern far Uint32 PCI_eepromWrite(Uint32 eeaddr,Uint16 eedata);
extern far Uint32 PCI_eepromWriteAll(Uint16 eedata);
extern far Uint16 PCI_eepromRead(Uint32 eeaddr);
extern far Uint32 PCI_eepromErase(Uint32 eeaddr);
extern far Uint32 PCI_eepromEraseAll();
/****************************************\
* PCI inline function declarations
\****************************************/

/* Master transfer functions */
IDECL void   PCI_xfrStart(Uint32 modeXfr);
IDECL void   PCI_xfrFlush();      // Field START=00  - flush current Transaction
IDECL int    PCI_xfrTest();   // test if the transfer is done - wait the Start field back to 00 */
IDECL void   PCI_xfrByteCntSet(Uint16 nbbyte); // set field CNT - # of bytes to be transfered

/* Halt function (HALT register ) */
#if (!C64_SUPPORT)
IDECL void   PCI_xfrHalt();
IDECL void   PCI_xfrEnable();
#endif


IDECL Uint32 PCI_curDspAddrGet();
IDECL Uint32 PCI_curPciAddrGet();
IDECL Uint32 PCI_curByteCntGet();
#if(!C64_SUPPORT)
IDECL void PCI_xfrConfig(PCI_ConfigXfr *config);
IDECL void PCI_xfrConfigArgs(Uint32 dspma, Uint32 pcima, Uint32 pcimc);
IDECL void PCI_xfrGetConfig(PCI_ConfigXfr *config);
#else
IDECL void PCI_xfrConfig(PCI_ConfigXfr *config);
IDECL void PCI_xfrConfigArgs(Uint32 dspma, Uint32 pcima, Uint32 pcimc , Uint32 trctl);
IDECL void PCI_xfrGetConfig(PCI_ConfigXfr *config);
#endif
/* PCI Interrupt Enable/Reporting functions */
IDECL void   PCI_intEnable(Uint32 eventPci);
IDECL void   PCI_intDisable(Uint32 eventPci);
IDECL Uint32 PCI_intTest(Uint32 eventPci);
IDECL void   PCI_intClear(Uint32 eventPci);

IDECL void PCI_dspIntReqSet();
IDECL void PCI_dspIntReqClear();

/* DSP EEPROM interface functions */
IDECL Uint32 PCI_eepromSize();      /*  reads fieds EESZ of EECTL reg   */
IDECL Uint32 PCI_eepromTest();    /* returns success if EESZ != 0 - EEPROM present */
IDECL Uint32 PCI_eepromIsAutoCfg();  /* reads the EEAI bit status of EECTL- AutoCfgEnable  */

/* Power Management functions */
#if (!C64_SUPPORT)
IDECL void PCI_pwrStatUpdate();
IDECL Uint32 PCI_pwrStatTest();
#endif


/****************************************\
* PCI inline function definitions
\****************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void PCI_xfrStart(Uint32 modeXfr) {
   PCI_FSET(PCIMC,START,modeXfr) ;
}
/*----------------------------------------------------------------------------*/
#if (!C64_SUPPORT)
IDEF void PCI_xfrHalt(){
  PCI_FSET(HALT,HALT,1);
}
/*----------------------------------------------------------------------------*/
IDEF void PCI_xfrEnable(){
  PCI_FSET(HALT,HALT,0);
}
#endif /* !C64_SUPPORT */
/*----------------------------------------------------------------------------*/
IDEF void PCI_xfrFlush(){
  PCI_FSET(PCIMC,START,0);
}
/*----------------------------------------------------------------------------*/
IDEF int PCI_xfrTest(){
  return PCI_FGET(PCIMC,START);
}
/*----------------------------------------------------------------------------*/
IDEF void PCI_xfrByteCntSet(Uint16 nbbyte){
  PCI_FSET(PCIMC,CNT,nbbyte);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PCI_curDspAddrGet() {
  return PCI_FGET(CDSPA,CDSPA);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PCI_curPciAddrGet() {
  return PCI_FGET(CPCIA,CPCIA);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PCI_curByteCntGet() {
  return PCI_FGET(CCNT,CCNT);
}
/*----------------------------------------------------------------------------*/
#if(!C64_SUPPORT)
IDEF void PCI_xfrConfig(PCI_ConfigXfr *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _PCI_BASE1_GLOBAL;
  register int x0,x1,x2;

  gie = IRQ_globalDisable();

  x0 = config->dspma;
  x1 = config->pcima;
  x2 = config->pcimc;

  base[_PCI_PCIMC_OFFSET] = 0x00000000;
  base[_PCI_DSPMA_OFFSET] = x0;
  base[_PCI_PCIMA_OFFSET] = x1;
  base[_PCI_PCIMC_OFFSET] = x2;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void PCI_xfrConfigArgs(Uint32 dspma,Uint32 pcima,Uint32 pcimc) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _PCI_BASE1_GLOBAL;

  gie = IRQ_globalDisable();

  base[_PCI_PCIMC_OFFSET] = 0x00000000u;
  base[_PCI_DSPMA_OFFSET] = dspma;
  base[_PCI_PCIMA_OFFSET] = pcima;
  base[_PCI_PCIMC_OFFSET] = pcimc;

 IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
IDEF void PCI_xfrGetConfig(PCI_ConfigXfr *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _PCI_BASE1_GLOBAL;
  volatile PCI_ConfigXfr *cfg = (volatile PCI_ConfigXfr*)config;
  register int x0,x1,x2;

  gie = IRQ_globalDisable();

  x0 = base[_PCI_DSPMA_OFFSET];
  x1 = base[_PCI_PCIMA_OFFSET];
  x2 = base[_PCI_PCIMC_OFFSET];

  cfg->dspma = x0;
  cfg->pcima = x1;
  cfg->pcimc = x2;

  IRQ_globalRestore(gie);
}
#else
IDEF void PCI_xfrConfig(PCI_ConfigXfr *config) {

  Uint32 gie;
  volatile Uint32 *base1 = (volatile Uint32 *) _PCI_BASE1_GLOBAL;
  volatile Uint32 *base2 = (volatile Uint32 *) _PCI_BASE3_GLOBAL;

  register int x0,x1,x2,x3;

  gie = IRQ_globalDisable();

  x0 = config->dspma;
  x1 = config->pcima;
  x2 = config->pcimc;
  x3 = config->trctl;

  base1[_PCI_PCIMC_OFFSET] = 0x00000000;
  base1[_PCI_DSPMA_OFFSET] = x0;
  base1[_PCI_PCIMA_OFFSET] = x1;
  base1[_PCI_PCIMC_OFFSET] = x2;
  base2[_PCI_TRCTL_OFFSET] = x3;


  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void PCI_xfrConfigArgs(Uint32 dspma,Uint32 pcima,Uint32 pcimc,Uint32 trctl) {

  Uint32 gie;
  volatile Uint32 *base1 = (volatile Uint32 *) _PCI_BASE1_GLOBAL;
  volatile Uint32 *base2 = (volatile Uint32 *) _PCI_BASE3_GLOBAL;

  gie = IRQ_globalDisable();

  base1[_PCI_PCIMC_OFFSET] = 0x00000000u;
  base1[_PCI_DSPMA_OFFSET] = dspma;
  base1[_PCI_PCIMA_OFFSET] = pcima;
  base1[_PCI_PCIMC_OFFSET] = pcimc;
  base2[_PCI_TRCTL_OFFSET] = trctl;

 IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
IDEF void PCI_xfrGetConfig(PCI_ConfigXfr *config) {

  Uint32 gie;
  volatile Uint32 *base1 = (volatile Uint32 *) _PCI_BASE1_GLOBAL;
  volatile Uint32 *base2 = (volatile Uint32 *) _PCI_BASE3_GLOBAL;
  volatile PCI_ConfigXfr *cfg = (volatile PCI_ConfigXfr*)config;
  register int x0,x1,x2,x3;

  gie = IRQ_globalDisable();

  x0 = base1[_PCI_DSPMA_OFFSET];
  x1 = base1[_PCI_PCIMA_OFFSET];
  x2 = base1[_PCI_PCIMC_OFFSET];
  x3 = base2[_PCI_TRCTL_OFFSET];

  cfg->dspma = x0;
  cfg->pcima = x1;
  cfg->pcimc = x2;
  cfg->trctl = x3;

  IRQ_globalRestore(gie);
}
#endif
/*----------------------------------------------------------------------------*/
IDEF void PCI_intEnable(Uint32 eventPci) {
  volatile Uint32 value ;
  value=  PCI_RGET(PCIIEN);
  /* Set bit of eventPCi */
  PCI_RSET(PCIIEN,(value | _PCI_maskTable[eventPci]));
}
/*----------------------------------------------------------------------------*/
IDEF void PCI_intDisable(Uint32 eventPci) {
   volatile Uint32 value;
   value =( PCI_RGET(PCIIEN) &= ~_PCI_maskTable[eventPci]);            /* Set the opposite mask of eventPci    */
  PCI_RSET(PCIIEN,value);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PCI_intTest(Uint32 eventPci) {
    return ( ( PCI_RGET(PCIIS) & _PCI_maskTable[eventPci]) >> eventPci );
}
/*----------------------------------------------------------------------------*/
IDEF void  PCI_intClear(Uint32 eventPci) {
    PCI_RSET(PCIIS, PCI_RGET(PCIIS) & _PCI_maskTable[eventPci]) ;
}
/*----------------------------------------------------------------------------*/
IDEF void PCI_dspIntReqSet(){
 PCI_FSET(RSTSRC,INTREQ,1);
}
/*----------------------------------------------------------------------------*/
IDEF void PCI_dspIntReqClear(){
 PCI_FSET(RSTSRC,INTRST,1);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PCI_eepromSize(){
  return (PCI_FGET(EECTL,EESZ));
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PCI_eepromTest(){
  volatile Uint32 test = 0;
   if ( (PCI_FGET(EECTL,EESZ) != 0))
    {
     test = 1;
    }
   return test;
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PCI_eepromIsAutoCfg() {
  return((Uint32) PCI_FGET(EECTL,EEAI));
}
/*----------------------------------------------------------------------------*/
#if (!C64_SUPPORT)
IDEF void PCI_pwrStatUpdate() {
    PCI_FSET(PMDCSR,CURSTATE,PCI_FGET(PMDCSR,REQSTATE));   /* update value  */
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PCI_pwrStatTest() {
    volatile Uint32 status;
      status= PCI_FGET(PCIIS,PWRMGMT) | (PCI_FGET(PMDCSR,D2WARMONWKP)<<1) \
              | ((PCI_FGET(PMDCSR,D3WARMONWKP)<<1) + 1);
     return( status );
}
#endif /* !C64_SUPPORT */

/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */

#endif /* PCI_SUPPORT */
#endif /* _PCI_H_ */
/******************************************************************************\
* End of csl_pci.h
\******************************************************************************/

csl_pcihal.h/   1092218724  0     0     0       40134     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_pcihal.h
* DATE CREATED.. 10/02/2000
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                06/09/2003
*------------------------------------------------------------------------------
* REGISTERS
*
*   RSTSRC   - Reset Source/Status register
*   PMDCSR   - Power Management DSP Control/Status register
*   PCIIS    - PCI Interrupt Source register
*   PCIIEN   - PCI Interrupt Enable register
*   DSPMA    - DSP Master Address register
*   PCIMA    - PCI Master Address register
*   PCIMC    - PCI Master Control register
*   CDSPA    - Current DSP Address register
*   CPCIA    - Current PCI Address regsiter
*   CCNT     - Current Byte Count register
*   HALT     - PCI Transfer Halt register (1)
*   EEADD    - EEPROM Address register
*   EEDAT    - EEPROM Date register
*   EECTL    - EEPROM Control register
*   TRCTL    - Transfer request control register(C64x Only)
*
*   (1) not supported by C64x devices
\******************************************************************************/
#ifndef _CSL_PCIHAL_H_
#define _CSL_PCIHAL_H_

#include <csl_stdinc.h>


#if (PCI_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#if (C64_SUPPORT)
  #define _PCI_BASE1_GLOBAL             0x01C00000u
  #define _PCI_BASE2_GLOBAL             0x01C20000u
  #define _PCI_BASE3_GLOBAL             0x01C30000u
#else
  #define _PCI_BASE1_GLOBAL             0x01A40000u
  #define _PCI_BASE2_GLOBAL             0x01A80000u
#endif

/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define PCI_FMK(REG,FIELD,x)\
    _PER_FMK(DMA,##REG,##FIELD,x)

  #define PCI_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(DMA,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define PCI_ADDR(REG)\
    _PCI_##REG##_ADDR

  #define PCI_RGET(REG)\
    _PER_RGET(_PCI_##REG##_ADDR,PCI,##REG)

  #define PCI_RSET(REG,x)\
    _PER_RSET(_PCI_##REG##_ADDR,PCI,##REG,x)

  #define PCI_FGET(REG,FIELD)\
    _PCI_##REG##_FGET(##FIELD)

  #define PCI_FSET(REG,FIELD,x)\
    _PCI_##REG##_FSET(##FIELD,##x)

  #define PCI_FSETS(REG,FIELD,SYM)\
    _PCI_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define PCI_RGETA(addr,REG)\
    _PER_RGET(addr,PCI,##REG)

  #define PCI_RSETA(addr,REG,x)\
    _PER_RSET(addr,PCI,##REG,x)

  #define PCI_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,PCI,##REG,##FIELD)

  #define PCI_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,PCI,##REG,##FIELD,x)

  #define PCI_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,PCI,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  R S T S R C      |
* |___________________|
*
* RSTSRC - DSP Reset Source-Status Regsiter
*
* FIELDS (msb -> lsb)
* (r)  CFGERR
* (r)  CFGDONE
* (w)  INTRST
* (w)  INTREQ
* (r)  WARMRST
* (r)  PRST
* (r)  RST
*
\******************************************************************************/
  #define _PCI_RSTSRC_OFFSET      0

  #if (C64_SUPPORT)
  #define _PCI_RSTSRC_ADDR        0x01C00000u
  #else
  #define _PCI_RSTSRC_ADDR        0x01A40000u
  #endif

  #define _PCI_RSTSRC_CFGERR_MASK         0x00000040u
  #define _PCI_RSTSRC_CFGERR_SHIFT        0x00000006u
  #define  PCI_RSTSRC_CFGERR_DEFAULT      0x00000000u
  #define  PCI_RSTSRC_CFGERR_OF(x)        _VALUEOF(x)


  #define _PCI_RSTSRC_CFGDONE_MASK        0x00000020u
  #define _PCI_RSTSRC_CFGDONE_SHIFT       0x00000005u
  #define  PCI_RSTSRC_CFGDONE_DEFAULT     0x00000000u
  #define  PCI_RSTSRC_CFGDONE_OF(x)       _VALUEOF(x)

  #define _PCI_RSTSRC_INTRST_MASK         0x00000010u
  #define _PCI_RSTSRC_INTRST_SHIFT        0x00000004u
  #define  PCI_RSTSRC_INTRST_DEFAULT      0x00000000u
  #define  PCI_RSTSRC_INTRST_OF(x)        _VALUEOF(x)
  #define  PCI_RSTSRC_INTRST_YES          0x00000001u
  #define  PCI_RSTSRC_INTRST_NO           0x00000000u

  #define _PCI_RSTSRC_INTREQ_MASK         0x00000008u
  #define _PCI_RSTSRC_INTREQ_SHIFT        0x00000003u
  #define  PCI_RSTSRC_INTREQ_DEFAULT      0x00000000u
  #define  PCI_RSTSRC_INTREQ_OF(x)        _VALUEOF(x)
  #define  PCI_RSTSRC_INTREQ_YES          0x00000001u
  #define  PCI_RSTSRC_INTREQ_NO           0x00000000u

  #define _PCI_RSTSRC_WARMRST_MASK        0x00000004u
  #define _PCI_RSTSRC_WARMRST_SHIFT       0x00000002u
  #define  PCI_RSTSRC_WARMRST_DEFAULT     0x00000000u
  #define  PCI_RSTSRC_WARMRST_OF(x)        _VALUEOF(x)


  #define _PCI_RSTSRC_PRST_MASK           0x00000002u
  #define _PCI_RSTSRC_PRST_SHIFT          0x00000001u
  #define  PCI_RSTSRC_PRST_DEFAULT        0x00000000u
  #define  PCI_RSTSRC_PRST_OF(x)		_VALUEOF(x)

  #define _PCI_RSTSRC_RST_MASK            0x00000001u
  #define _PCI_RSTSRC_RST_SHIFT        	0x00000000u
  #define  PCI_RSTSRC_RST_DEFAULT       	0x00000001u
  #define  PCI_RSTSRC_RST_OF(x)           _VALUEOF(x)

  #define  PCI_RSTSRC_OF(x)              _VALUEOF(x)


  #define PCI_RSTRC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,RSTSRC,CFGERR) \
    |_PER_FDEFAULT(PCI,RSTSRC,CFGDONE) \
    |_PER_FDEFAULT(PCI,RSTSRC,INTRST) \
    |_PER_FDEFAULT(PCI,RSTSRC,INTREQ) \
    |_PER_FDEFAULT(PCI,RSTSRC,WARMRST) \
    |_PER_FDEFAULT(PCI,RSTSRC,PRST) \
    |_PER_FDEFAULT(PCI,RSTSRC,RST) \
   )

  #define PCI_RSTSRC_RMK(intrst,intreq) \
    (Uint32)( \
     _PER_FMK(PCI,RSTSRC,INTRST,intrst) \
    |_PER_FMK(PCI,RSTSRC,INTREQ,intreq) \
   )

 #define _PCI_RSTSRC_FGET(FIELD)\
    _PER_FGET(_PCI_RSTSRC_ADDR,PCI,RSTSRC,##FIELD)

 #define _PCI_RSTSRC_FSET(FIELD,field)\
    _PER_FSET(_PCI_RSTSRC_ADDR,PCI,RSTSRC,##FIELD,field)

 #define _PCI_RSTSRC_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_RSTSRC_ADDR,PCI,RSTSRC,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  P M D C S R      |
* |___________________|
*
* PMDCSR - Power Management DSP Control-Status Register
*
* FIELDS (msb -> lsb)
* (rw) HWPMECTL
* (r)  D3WARMONWKP
* (r)  D2WARMONWKP
* (rw) PMEEN
* (r)  PWRWKP
* (rw) PMESTAT
* (r)  PMEDRVN
* (r)  AUXDETECT
* (rw) CURSTATE
* (r)  REQSTATE
*
\******************************************************************************/
  #define _PCI_PMDCSR_OFFSET      1

 #if (C64_SUPPORT)
  #define _PCI_PMDCSR_ADDR                0x01C00004u
 #else
  #define _PCI_PMDCSR_ADDR                0x01A40004u
 #endif


  #define _PCI_PMDCSR_HWPMECTL_MASK          0x0007F800u
  #define _PCI_PMDCSR_HWPMECTL_SHIFT         0x0000000Bu
  #define  PCI_PMDCSR_HWPMECTL_DEFAULT       0x00000088u
  #define  PCI_PMDCSR_HWPMECTL_OF(x)         _VALUEOF(x)
  #define  PCI_PMDCSR_HWPMECTL_REQD0         0x00000001u
  #define  PCI_PMDCSR_HWPMECTL_REQD1         0x00000002u
  #define  PCI_PMDCSR_HWPMECTL_REQD2         0x00000003u
  #define  PCI_PMDCSR_HWPMECTL_REQD3         0x00000004u

  #define _PCI_PMDCSR_D3WARMONWKP_MASK       0x00000400u
  #define _PCI_PMDCSR_D3WARMONWKP_SHIFT      0x0000000Au
  #define  PCI_PMDCSR_D3WARMONWKP_DEFAULT    0x00000000u
  #define  PCI_PMDCSR_D3WARMONWKP_OF(x)      _VALUEOF(x)

  #define _PCI_PMDCSR_D2WARMONWKP_MASK       0x00000200u
  #define _PCI_PMDCSR_D2WARMONWKP_SHIFT      0x00000009u
  #define  PCI_PMDCSR_D2WARMONWKP_DEFAULT    0x00000000u
  #define  PCI_PMDCSR_D2WARMONWKP_OF(x)     _VALUEOF(x)

  #define _PCI_PMDCSR_PMEEN_MASK            0x00000100u
  #define _PCI_PMDCSR_PMEEN_SHIFT           0x00000008u
  #define  PCI_PMDCSR_PMEEN_DEFAULT         0x00000000u
  #define  PCI_PMDCSR_PMEEN_OF(x)           _VALUEOF(x)
  #define  PCI_PMDCSR_PMEEN_CLR             0x00000001u

  #define _PCI_PMDCSR_PMEWKP_MASK            0x00000080u
  #define _PCI_PMDCSR_PMEWKP_SHIFT           0x00000007u
  #define  PCI_PMDCSR_PMEWKP_DEFAULT         0x00000000u
  #define  PCI_PMDCSR_PMEWKP_OF(x)           _VALUEOF(x)

  #define _PCI_PMDCSR_PMESTAT_MASK           0x00000040u
  #define _PCI_PMDCSR_PMESTAT_SHIFT          0x00000006u
  #define  PCI_PMDCSR_PMESTAT_DEFAULT        0x00000000u
  #define  PCI_PMDCSR_PMESTAT_OF(x)          _VALUEOF(x)
  #define  PCI_PMDCSR_PMESTAT_SET            0x00000001u

  #define _PCI_PMDCSR_PMEDRVN_MASK           0x00000020u
  #define _PCI_PMDCSR_PMEDRVN_SHIFT          0x00000005u
  #define  PCI_PMDCSR_PMEDRVN_DEFAULT        0x00000000u
  #define  PCI_PMDCSR_PMEDRVN_OF(x)          _VALUEOF(x)

  #define _PCI_PMDCSR_AUXDETECT_MASK         0x00000010u
  #define _PCI_PMDCSR_AUXDETECT_SHIFT        0x00000004u
  #define  PCI_PMDCSR_AUXDETECT_DEFAULT      0x00000000u
  #define  PCI_PMDCSR_AUXDETECT_OF(x)          _VALUEOF(x)

  #define _PCI_PMDCSR_CURSTATE_MASK          0x0000000Cu
  #define _PCI_PMDCSR_CURSTATE_SHIFT         0x00000002u
  #define  PCI_PMDCSR_CURSTATE_DEFAULT       0x00000000u
  #define  PCI_PMDCSR_CURSTATE_OF(x)         _VALUEOF(x)
  #define  PCI_PMDCSR_CURSTATE_D0            0x00000000u
  #define  PCI_PMDCSR_CURSTATE_D1	    	   0x00000001u
  #define  PCI_PMDCSR_CURSTATE_D2            0x00000002u
  #define  PCI_PMDCSR_CURSTATE_D3            0x00000003u

  #define _PCI_PMDCSR_REQSTATE_MASK          0x00000003u
  #define _PCI_PMDCSR_REQSTATE_SHIFT         0x00000000u
  #define  PCI_PMDCSR_REQSTATE_DEFAULT       0x00000000u
  #define  PCI_PMDCSR_REQSTATE_OF(x)         _VALUEOF(x)

  #define  PCI_PMDCSR_OF(x)                  _VALUEOF(x)

 #define PCI_PMDCSR_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,PMDCSR,HWPMECTL) \
    |_PER_FMK(PCI,PMDCSR,D3WARMONWKP) \
    |_PER_FMK(PCI,PMDCSR,D2WARMONWKP) \
    |_PER_FDEFAULT(PCI,PMDCSR,PMEEN) \
    |_PER_FDEFAULT(PCI,PMDCSR,PMEWKP) \
    |_PER_FDEFAULT(PCI,PMDCSR,PMESTAT) \
    |_PER_FDEFAULT(PCI,PMDCSR,PMEDRVN) \
    |_PER_FDEFAULT(PCI,PMDCSR,AUXDETECT) \
    |_PER_FDEFAULT(PCI,PMDCSR,CURSTATE) \
    |_PER_FDEFAULT(PCI,PMDCSR,REQSTATE) \
   )

  #define PCI_PMDCSR_RMK(hwpmectl,pmeen,pmestat,curstate) \
    (Uint32)( \
     _PER_FMK(PCI,PMDCSR,HWPMECTL,hwpmectl) \
    |_PER_FMK(PCI,PMDCSR,PMEEN,pmeena) \
    |_PER_FMK(PCI,PMDCSR,PMESTAT,pmestat) \
    |_PER_FMK(PCI,PMDCSR,CURSTATE,curstate) \
   )

 #define _PCI_PMDCSR_FGET(FIELD)\
    _PER_FGET(_PCI_PMDCSR_ADDR,PCI,PMDCSR,##FIELD)

 #define _PCI_PMDCSR_FSET(FIELD,field)\
    _PER_FSET(_PCI_PMDCSR_ADDR,PCI,PMDCSR,##FIELD,field)

 #define _PCI_PMDCSR_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_PMDCSR_ADDR,PCI,PMDCSR,##FIELD,##SYM)




/******************************************************************************\
* _____________________
* |                   |
* |  P C I I S        |
* |___________________|
*
* PCIIS - PCI Interrupt Source Register
*
* FIELDS (msb -> lsb)
* (rw) DMAHALTED
* (rw) PRST
* (rw) EERDY
* (rw) CFGERR
* (rw) CFGDONE
* (rw) MASTEROK
* (rw) PWRHL
* (rw) PWRLH
* (rw) HOSTSW
* (rw) PCIMASTER
* (rw) PCITARGET
* (rw) PWRMGMT
*
\******************************************************************************/
  #define _PCI_PCIIS_OFFSET     2

 #if (C64_SUPPORT)
   #define _PCI_PCIIS_ADDR                0x01C00008u
 #else
   #define _PCI_PCIIS_ADDR                0x01A40008u
 #endif


  #define _PCI_PCIIS_DMAHALTED_MASK         0x00001000u
  #define _PCI_PCIIS_DMAHALTED_SHIFT        0x0000000Cu
  #define  PCI_PCIIS_DMAHALTED_DEFAULT      0x00000000u
  #define  PCI_PCIIS_DMAHALTED_OF(x)        _VALUEOF(x)
  #define  PCI_PCIIS_DMAHALTED_CLR          0x00000001u

  #define _PCI_PCIIS_PRST_MASK              0x00000800u
  #define _PCI_PCIIS_PRST_SHIFT             0x0000000Bu
  #define  PCI_PCIIS_PRST_DEFAULT           0x00000000u
  #define  PCI_PCIIS_PRST_OF(x)             _VALUEOF(x)
  #define  PCI_PCIIS_PRST_CHGSTATE          0x00000001u
  #define  PCI_PCIIS_PRST_NOCHG             0x00000000u

  #define _PCI_PCIIS_EERDY_MASK             0x00000200u
  #define _PCI_PCIIS_EERDY_SHIFT            0x00000009u
  #define  PCI_PCIIS_EERDY_DEFAULT          0x00000000u
  #define  PCI_PCIIS_EERDY_OF(x)            _VALUEOF(x)
  #define  PCI_PCIIS_EERDY_CLR              0x00000001u


  #define _PCI_PCIIS_CFGERR_MASK            0x00000100u
  #define _PCI_PCIIS_CFGERR_SHIFT          0x00000008u
  #define  PCI_PCIIS_CFGERR_DEFAULT         0x00000000u
  #define  PCI_PCIIS_CFGERR_OF(x)           _VALUEOF(x)
  #define  PCI_PCIIS_CFGERR_CLR             0x00000001u

  #define _PCI_PCIIS_CFGDONE_MASK           0x00000080u
  #define _PCI_PCIIS_CFGDONE_SHIFT          0x00000007u
  #define  PCI_PCIIS_CFGDONE_DEFAULT        0x00000000u
  #define  PCI_PCIIS_CFGDONE_OF(x)          _VALUEOF(x)
  #define  PCI_PCIIS_CFGDONE_CLR            0x00000001u

  #define _PCI_PCIIS_MASTEROK_MASK          0x00000040u
  #define _PCI_PCIIS_MASTEROK_SHIFT         0x00000006u
  #define  PCI_PCIIS_MASTEROK_DEFAULT       0x00000000u
  #define  PCI_PCIIS_MASTEROK_OF(x)         _VALUEOF(x)
  #define  PCI_PCIIS_MASTEROK_CLR           0x00000001u

  #define _PCI_PCIIS_PWRHL_MASK             0x00000020u
  #define _PCI_PCIIS_PWRHL_SHIFT            0x00000005u
  #define  PCI_PCIIS_PWRHL_DEFAULT          0x00000000u
  #define  PCI_PCIIS_PWRHL_OF(x)            _VALUEOF(x)
  #define  PCI_PCIIS_PWRHL_CLR              0x00000001u

  #define _PCI_PCIIS_PWRLH_MASK             0x00000010u
  #define _PCI_PCIIS_PWRLH_SHIFT            0x00000004u
  #define  PCI_PCIIS_PWRLH_DEFAULT          0x00000000u
  #define  PCI_PCIIS_PWRLH_OF(x)            _VALUEOF(x)
  #define  PCI_PCIIS_PWRLH_CLR              0x00000001u

  #define _PCI_PCIIS_HOSTSW_MASK            0x00000008u
  #define _PCI_PCIIS_HOSTSW_SHIFT           0x00000003u
  #define  PCI_PCIIS_HOSTSW_DEFAULT         0x00000000u
  #define  PCI_PCIIS_HOSTSW_OF(x)           _VALUEOF(x)
  #define  PCI_PCIIS_HOSTSW_CLR             0x00000001u

  #define _PCI_PCIIS_PCIMASTER_MASK         0x00000004u
  #define _PCI_PCIIS_PCIMASTER_SHIFT        0x00000002u
  #define  PCI_PCIIS_PCIMASTER_DEFAULT      0x00000000u
  #define  PCI_PCIIS_PCIMASTER_OF(x)        _VALUEOF(x)
  #define  PCI_PCIIS_PCIMASTER_CLR          0x00000001u

  #define _PCI_PCIIS_PCITARGET_MASK         0x00000002u
  #define _PCI_PCIIS_PCITARGET_SHIFT        0x00000001u
  #define  PCI_PCIIS_PCITARGET_DEFAULT      0x00000000u
  #define  PCI_PCIIS_PCITARGET_OF(x)        _VALUEOF(x)
  #define  PCI_PCIIS_PCITARGET_CLR          0x00000001u

  #define _PCI_PCIIS_PWRMGMT_MASK           0x00000001u
  #define _PCI_PCIIS_PWRMGMT_SHIFT          0x00000000u
  #define  PCI_PCIIS_PWRMGMT_DEFAULT        0x00000000u
  #define  PCI_PCIIS_PWRMGMT_OF(x)          _VALUEOF(x)
  #define  PCI_PCIIS_PWRMGMT_CLR            0x00000001u

  #define  PCI_PCIIS_OF(x)                 _VALUEOF(x)

  #define PCI_PCIIS_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,PCIIS,DMAHALTED) \
    |_PER_FDEFAULT(PCI,PCIIS,PRST) \
    |_PER_FDEFAULT(PCI,PCIIS,EERDY) \
    |_PER_FDEFAULT(PCI,PCIIS,CFGERR) \
    |_PER_FDEFAULT(PCI,PCIIS,CFGDONE) \
    |_PER_FDEFAULT(PCI,PCIIS,MASTEROK) \
    |_PER_FDEFAULT(PCI,PCIIS,PWRHL) \
    |_PER_FDEFAULT(PCI,PCIIS,PWRLH) \
    |_PER_FDEFAULT(PCI,PCIIS,HOSTSW) \
    |_PER_FDEFAULT(PCI,PCIIS,PCIMASTER) \
    |_PER_FDEFAULT(PCI,PCIIS,PCITARGET) \
    |_PER_FDEFAULT(PCI,PCIIS,PWRMGMT) \
   )

 #define PCI_PCIIS_RMK(dmahalted,prst,eerdy,cfgerr,cfgdone,masterok, \
                      pwrhl,pwrlh,hostsw,pcimaster,pcitarget,pwrmgmt)\
   (Uint32)( \
     _PER_FMK(PCI,PCIIS,DMAHALTED,dmahalted) \
    |_PER_FMK(PCI,PCIIS,PRST,prst) \
    |_PER_FMK(PCI,PCIIS,EERDY,eerdy) \
    |_PER_FMK(PCI,PCIIS,CFGERR,cfgerr) \
    |_PER_FMK(PCI,PCIIS,CFGDONE,cfgdone) \
    |_PER_FMK(PCI,PCIIS,MASTEROK,masterok) \
    |_PER_FMK(PCI,PCIIS,PWRHL,pwrhl) \
    |_PER_FMK(PCI,PCIIS,PWRLH,pwrlh) \
    |_PER_FMK(PCI,PCIIS,HOSTSW,hostsw) \
    |_PER_FMK(PCI,PCIIS,PCIMASTER,pcimaster) \
    |_PER_FMK(PCI,PCIIS,PCITARGET,pcitarget) \
    |_PER_FMK(PCI,PCIIS,PWRMGMT,pwrmgmt) \
   )

  #define _PCI_PCIIS_FGET(FIELD)\
    _PER_FGET(_PCI_PCIIS_ADDR,PCI,PCIIS,##FIELD)

 #define _PCI_PCIIS_FSET(FIELD,field)\
    _PER_FSET(_PCI_PCIIS_ADDR,PCI,PCIIS,##FIELD,field)

 #define _PCI_PCIIS_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_PCIIS_ADDR,PCI,PCIIS,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  P C I I E N      |
* |___________________|
*
* PCIIEN - PCI Interrupt Enable Register
*
* FIELDS (msb -> lsb)
* (rw) PRST
* (rw) EERDY
* (rw) CFGERR
* (rw) CFGDONE
* (rw) MASTEROK
* (rw) PWRHL
* (rw) PWRLH
* (rw) HOSTSW
* (rw) PCIMASTER
* (rw) PCITARGET
* (rw) PWRMGMT
*
\******************************************************************************/
  #define _PCI_PCIIEN_OFFSET     3

  #if (C64_SUPPORT)
   #define _PCI_PCIIEN_ADDR               0x01C0000Cu
 #else
   #define _PCI_PCIIEN_ADDR               0x01A4000Cu
 #endif



  #define _PCI_PCIIEN_PRST_MASK              0x00000800u
  #define _PCI_PCIIEN_PRST_SHIFT             0x0000000Bu
  #define  PCI_PCIIEN_PRST_DEFAULT           0x00000000u
  #define  PCI_PCIIEN_PRST_OF(x)             _VALUEOF(x)
  #define  PCI_PCIIEN_PRST_DISABLE           0x00000000u
  #define  PCI_PCIIEN_PRST_ENABLE            0x00000001u

  #define _PCI_PCIIEN_EERDY_MASK             0x00000200u
  #define _PCI_PCIIEN_EERDY_SHIFT            0x00000009u
  #define  PCI_PCIIEN_EERDY_DEFAULT          0x00000000u
  #define  PCI_PCIIEN_EERDY_OF(x)            _VALUEOF(x)
  #define  PCI_PCIIEN_EERDY_DISABLE          0x00000000u
  #define  PCI_PCIIEN_EERDY_ENABLE           0x00000001u


  #define _PCI_PCIIEN_CFGERR_MASK            0x00000100u
  #define _PCI_PCIIEN_CFGERR_SHIFT           0x00000008u
  #define  PCI_PCIIEN_CFGERR_DEFAULT         0x00000000u
  #define  PCI_PCIIEN_CFGERR_OF(x)           _VALUEOF(x)
  #define  PCI_PCIIEN_CFGERR_DISABLE         0x00000000u
  #define  PCI_PCIIEN_CFGERR_ENABLE          0x00000001u

  #define _PCI_PCIIEN_CFGDONE_MASK           0x00000080u
  #define _PCI_PCIIEN_CFGDONE_SHIFT          0x00000007u
  #define  PCI_PCIIEN_CFGDONE_DEFAULT        0x00000000u
  #define  PCI_PCIIEN_CFGDONE_OF(x)          _VALUEOF(x)
  #define  PCI_PCIIEN_CFGDONE_DISABLE        0x00000000u
  #define  PCI_PCIIEN_CFGDONE_ENABLE         0x00000001u

  #define _PCI_PCIIEN_MASTEROK_MASK          0x00000040u
  #define _PCI_PCIIEN_MASTEROK_SHIFT         0x00000006u
  #define  PCI_PCIIEN_MASTEROK_DEFAULT       0x00000000u
  #define  PCI_PCIIEN_MASTEROK_OF(x)         _VALUEOF(x)
  #define  PCI_PCIIEN_MASTEROK_DISABLE       0x00000000u
  #define  PCI_PCIIEN_MASTEROK_ENABLE        0x00000001u

  #define _PCI_PCIIEN_PWRHL_MASK             0x00000020u
  #define _PCI_PCIIEN_PWRHL_SHIFT            0x00000005u
  #define  PCI_PCIIEN_PWRHL_DEFAULT          0x00000000u
  #define  PCI_PCIIEN_PWRHL_OF(x)            _VALUEOF(x)
  #define  PCI_PCIIEN_PWRHL_DISABLE          0x00000000u
  #define  PCI_PCIIEN_PWRHL_ENABLE           0x00000001u

  #define _PCI_PCIIEN_PWRLH_MASK             0x00000010u
  #define _PCI_PCIIEN_PWRLH_SHIFT            0x00000004u
  #define  PCI_PCIIEN_PWRLH_DEFAULT          0x00000000u
  #define  PCI_PCIIEN_PWRLH_OF(x)            _VALUEOF(x)
  #define  PCI_PCIIEN_PWRLH_DISABLE          0x00000000u
  #define  PCI_PCIIEN_PWRLH_ENABLE           0x00000001u

  #define _PCI_PCIIEN_HOSTSW_MASK            0x00000008u
  #define _PCI_PCIIEN_HOSTSW_SHIFT           0x00000003u
  #define  PCI_PCIIEN_HOSTSW_DEFAULT         0x00000008u
  #define  PCI_PCIIEN_HOSTSW_OF(x)           _VALUEOF(x)
  #define  PCI_PCIIEN_HOSTSW_DISABLE         0x00000000u
  #define  PCI_PCIIEN_HOSTSW_ENABLE          0x00000001u

  #define _PCI_PCIIEN_PCIMASTER_MASK         0x00000004u
  #define _PCI_PCIIEN_PCIMASTER_SHIFT        0x00000002u
  #define  PCI_PCIIEN_PCIMASTER_DEFAULT      0x00000000u
  #define  PCI_PCIIEN_PCIMASTER_OF(x)        _VALUEOF(x)
  #define  PCI_PCIIEN_PCIMASTER_DISABLE      0x00000000u
  #define  PCI_PCIIEN_PCIMASTER_ENABLE       0x00000001u

  #define _PCI_PCIIEN_PCITARGET_MASK         0x00000002u
  #define _PCI_PCIIEN_PCITARGET_SHIFT        0x00000001u
  #define  PCI_PCIIEN_PCITARGET_DEFAULT      0x00000000u
  #define  PCI_PCIIEN_PCITARGET_OF(x)        _VALUEOF(x)
  #define  PCI_PCIIEN_PCITARGET_DISABLE      0x00000000u
  #define  PCI_PCIIEN_PCITARGET_ENABLE       0x00000001u

  #define _PCI_PCIIEN_PWRMGMT_MASK           0x00000001u
  #define _PCI_PCIIEN_PWRMGMT_SHIFT          0x00000000u
  #define  PCI_PCIIEN_PWRMGMT_DEFAULT        0x00000000u
  #define  PCI_PCIIEN_PWRMGMT_OF(x)          _VALUEOF(x)
  #define  PCI_PCIIEN_PWRMGMT_DISABLE        0x00000000u
  #define  PCI_PCIIEN_PWRMGMT_ENABLE         0x00000001u

  #define  PCI_PCIIEN_OF(x)                   _VALUEOF(x)

  #define PCI_PCIIEN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,PCIIEN,PRST) \
    |_PER_FDEFAULT(PCI,PCIIEN,EERDY) \
    |_PER_FDEFAULT(PCI,PCIIEN,CFGERR) \
    |_PER_FDEFAULT(PCI,PCIIEN,CFGDONE) \
    |_PER_FDEFAULT(PCI,PCIIEN,MASTEROK) \
    |_PER_FDEFAULT(PCI,PCIIEN,PWRHL) \
    |_PER_FDEFAULT(PCI,PCIIEN,PWRLH) \
    |_PER_FDEFAULT(PCI,PCIIEN,HOSTSW) \
    |_PER_FDEFAULT(PCI,PCIIEN,PCIMASTER) \
    |_PER_FDEFAULT(PCI,PCIIEN,PCITARGET) \
    |_PER_FDEFAULT(PCI,PCIIEN,PWRMGMT) \
   )

 #define PCI_PCIIEN_RMK(prst,eerdy,cfgerr,cfgdone,masterok, \
                      pwrhl,pwrlh,hostsw,pcimaster,pcitarget,pwrmgmt)\
   (Uint32)( \
     _PER_FMK(PCI,PCIIEN,PRST,prst) \
    |_PER_FMK(PCI,PCIIEN,EERDY,eerdy) \
    |_PER_FMK(PCI,PCIIEN,CFGERR,cfgerr) \
    |_PER_FMK(PCI,PCIIEN,CFGDONE,cfgdone) \
    |_PER_FMK(PCI,PCIIEN,MASTEROK,masterok) \
    |_PER_FMK(PCI,PCIIEN,PWRHL,pwrhl) \
    |_PER_FMK(PCI,PCIIEN,PWRLH,pwrlh) \
    |_PER_FMK(PCI,PCIIEN,HOSTSW,hostsw) \
    |_PER_FMK(PCI,PCIIEN,PCIMASTER,pcimaster) \
    |_PER_FMK(PCI,PCIIEN,PCITARGET,pcitarget) \
    |_PER_FMK(PCI,PCIIEN,PWRMGMT,pwrmgmt) \
   )

  #define _PCI_PCIIEN_FGET(FIELD)\
    _PER_FGET(_PCI_PCIIEN_ADDR,PCI,PCIIEN,##FIELD)

 #define _PCI_PCIIEN_FSET(FIELD,field)\
    _PER_FSET(_PCI_PCIIEN_ADDR,PCI,PCIIEN,##FIELD,field)

 #define _PCI_PCIIEN_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_PCIIEN_ADDR,PCI,PCIIEN,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  D S P M A        |
* |___________________|
*
* DSPMA - DSP Master Address Register
*
* FIELDS (msb -> lsb)
* (rw) ADDRMA
* (rw) AINC
*
\******************************************************************************/
  #define _PCI_DSPMA_OFFSET          4


 #if (C64_SUPPORT)
   #define _PCI_DSPMA_ADDR                 0x01C00010u
 #else
   #define _PCI_DSPMA_ADDR                 0x01A40010u
 #endif

  #define _PCI_DSPMA_ADDRMA_MASK           0xFFFFFFFCu
  #define _PCI_DSPMA_ADDRMA_SHIFT          0x00000002u
  #define  PCI_DSPMA_ADDRMA_DEFAULT        0x00000000u
  #define  PCI_DSPMA_ADDRMA_OF(x)          _VALUEOF(x)

  #define _PCI_DSPMA_AINC_MASK              0x00000002u
  #define _PCI_DSPMA_AINC_SHIFT             0x00000001u
  #define  PCI_DSPMA_AINC_DEFAULT           0x00000000u
  #define  PCI_DSPMA_AINC_OF(x)             _VALUEOF(x)
  #define  PCI_DSPMA_AINC_ENABLE            0x00000000u
  #define  PCI_DSPMA_AINC_DISABLE           0x00000001u

  #define  PCI_DSPMA_OF(x)                  _VALUEOF(x)

  #define PCI_DSPMA_DEFAULT  (Uint32)( \
     _PER_FDEFAULT(PCI,DSPMA,ADDRMA) \
    |_PER_FDEFAULT(PCI,DSPMA,AINC) \
   )

 #define PCI_DSPMA_RMK(addrma,ainc)\
 (Uint32)( \
     _PER_FMK(PCI,DSPMA,ADDRMA,addrma) \
    |_PER_FMK(PCI,DSPMA,AINC,ainc) \
   )

 #define _PCI_DSPMA_FGET(FIELD)\
    _PER_FGET(_PCI_DSPMA_ADDR,PCI,DSPMA,##FIELD)

 #define _PCI_DSPMA_FSET(FIELD,field)\
    _PER_FSET(_PCI_DSPMA_ADDR,PCI,DSPMA,##FIELD,field)

 #define _PCI_DSPMA_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_DSPMA_ADDR,PCI,DSPMA,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  P C I M A        |
* |___________________|
*
* PCIMA - PCI Master Address Register
*
* FIELDS (msb -> lsb)
* (rw) ADDRMA
*
\******************************************************************************/
  #define _PCI_PCIMA_OFFSET          5

 #if (C64_SUPPORT)
   #define _PCI_PCIMA_ADDR                0x01C00014u
 #else
   #define _PCI_PCIMA_ADDR                0x01A40014u
 #endif

  #define _PCI_PCIMA_ADDRMA_MASK          0xFFFFFFFCu
  #define _PCI_PCIMA_ADDRMA_SHIFT         0x00000002u
  #define  PCI_PCIMA_ADDRMA_DEFAULT       0x00000000u
  #define  PCI_PCIMA_ADDRMA_OF(x)         _VALUEOF(x)

  #define  PCI_PCIMA_OF(x)                _VALUEOF(x)

  #define PCI_PCIMA_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,PCIMA,ADDRMA) \
   )

  #define PCI_PCIMA_RMK(addrma)\
 (Uint32)( \
     _PER_FMK(PCI,PCIMA,ADDRMA,addrma) \
   )

 #define _PCI_PCIMA_FGET(FIELD)\
    _PER_FGET(_PCI_PCIMA_ADDR,PCI,PCIMA,##FIELD)

 #define _PCI_PCIMA_FSET(FIELD,field)\
    _PER_FSET(_PCI_PCIMA_ADDR,PCI,PCIMA,##FIELD,field)

 #define _PCI_PCIMA_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_PCIMA_ADDR,PCI,PCIMA,##FIELD,##SYM)




/******************************************************************************\
* _____________________
* |                   |
* |  P C I M C        |
* |___________________|
*
* PCIMC - PCI Master Control Register
*
* FIELDS (msb -> lsb)
* (rw)  CNT
* (rw)  START
*
\******************************************************************************/
  #define _PCI_PCIMC_OFFSET     6

 #if (C64_SUPPORT)
   #define _PCI_PCIMC_ADDR                0x01C00018u
 #else
   #define _PCI_PCIMC_ADDR                0x01A40018u
 #endif

  #define _PCI_PCIMC_CNT_MASK              0xFFFF0000u
  #define _PCI_PCIMC_CNT_SHIFT             0x00000010u
  #define  PCI_PCIMC_CNT_DEFAULT           0x00000000u
  #define  PCI_PCIMC_CNT_OF(x)             _VALUEOF(x)


  #define _PCI_PCIMC_START_MASK             0x00000007u
  #define _PCI_PCIMC_START_SHIFT            0x00000000u
  #define  PCI_PCIMC_START_DEFAULT          0x00000000u
  #define  PCI_PCIMC_START_OF(x)            _VALUEOF(x)
  #define  PCI_PCIMC_START_FLUSH            0x00000000u
  #define  PCI_PCIMC_START_WRITE            0x00000001u
  #define  PCI_PCIMC_START_READPREF         0x00000002u
  #define  PCI_PCIMC_START_READNOPREF       0x00000003u
  #define  PCI_PCIMC_START_CONFIGWRITE      0x00000004u
  #define  PCI_PCIMC_START_CONFIGREAD       0x00000005u
  #define  PCI_PCIMC_START_IOWRITE          0x00000006u
  #define  PCI_PCIMC_START_IOREAD           0x00000007u


  #define  PCI_PCIMC_OF(x)                  _VALUEOF(x)

 #define PCI_PCIMC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,PCIMC,CNT) \
    |_PER_FDEFAULT(PCI,PCIMC,START) \
   )

 #define PCI_PCIMC_RMK(cnt,start)\
 (Uint32)( \
     _PER_FMK(PCI,PCIMC,CNT,cnt) \
    |_PER_FMK(PCI,PCIMC,START,start) \
   )
 #define _PCI_PCIMC_FGET(FIELD)\
    _PER_FGET(_PCI_PCIMC_ADDR,PCI,PCIMC,##FIELD)

 #define _PCI_PCIMC_FSET(FIELD,field)\
    _PER_FSET(_PCI_PCIMC_ADDR,PCI,PCIMC,##FIELD,field)

 #define _PCI_PCIMC_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_PCIMC_ADDR,PCI,PCIMC,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C D S P A        |
* |___________________|
*
* CDSPA - Current DSP Address Register
*
* FIELDS (msb -> lsb)
* (r) CDSPA
*
\******************************************************************************/
  #define _PCI_CDSPA_OFFSET      7

 #if (C64_SUPPORT)
   #define _PCI_CDSPA_ADDR                 0x01C0001Cu
 #else
   #define _PCI_CDSPA_ADDR                 0x01A4001Cu
 #endif

  #define _PCI_CDSPA_CDSPA_MASK            0xFFFFFFFFu
  #define _PCI_CDSPA_CDSPA_SHIFT           0x00000000u
  #define  PCI_CDSPA_CDSPA_DEFAULT         0x00000000u
  #define  PCI_CDSPA_CDSPA_OF(x)           _VALUEOF(x)

  #define  PCI_CDSPA_OF(x)                 _VALUEOF(x)

  #define PCI_CDSPA_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,CDSPA,CDSPA) \
   )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define PCI_CDSPA_RMK(cdspa)\
  (Uint32)(\
      _PER_FMK(PCI,CDSPA,CDSPA,cdspa)\
  )      
#endif   
 #define _PCI_CDSPA_FGET(FIELD)\
    _PER_FGET(_PCI_CDSPA_ADDR,PCI,CDSPA,##FIELD)

/******************************************************************************\
* _____________________
* |                   |
* |  C P C I A        |
* |___________________|
*
* CPCIA - Current PCI Address Register
*
* FIELDS (msb -> lsb)
* (r) CPCIA
*
\******************************************************************************/
  #define _PCI_CPCIA_OFFSET      8

 #if (C64_SUPPORT)
   #define _PCI_CPCIA_ADDR                0x01C00020u
 #else
   #define _PCI_CPCIA_ADDR                0x01A40020u
 #endif

  #define _PCI_CPCIA_CPCIA_MASK           0xFFFFFFFFu
  #define _PCI_CPCIA_CPCIA_SHIFT          0x00000000u
  #define  PCI_CPCIA_CPCIA_DEFAULT        0x00000000u
  #define  PCI_CPCIA_CPCIA_OF(x)          _VALUEOF(x)

  #define  PCI_CPCIA_OF(x)                _VALUEOF(x)

  #define PCI_CPCIA_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,CPCIA,CPCIA) \
   )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define PCI_CPCIA_RMK(cpcia)\
  (Uint32)(\
     _PER_FMK(PCI,CPCIA,CPCIA,cpcia)\
  )     
#endif  
  #define _PCI_CPCIA_FGET(FIELD)\
    _PER_FGET(_PCI_CPCIA_ADDR,PCI,CPCIA,##FIELD)

/******************************************************************************\
* _____________________
* |                   |
* |  C C N T          |
* |___________________|
*
* CCNT - Current Byte Counter Register
*
* FIELDS (msb -> lsb)
* (r)  CCNT
*
\******************************************************************************/
  #define _PCI_CCNT_OFFSET      9

 #if (C64_SUPPORT)
   #define _PCI_CCNT_ADDR                 0x01C00024u
 #else
   #define _PCI_CCNT_ADDR                 0x01A40024u
 #endif

  #define _PCI_CCNT_CCNT_MASK             0x0000FFFFu
  #define _PCI_CCNT_CCNT_SHIFT            0x00000000u
  #define  PCI_CCNT_CCNT_DEFAULT          0x00000000u
  #define  PCI_CCNT_CCNT_OF(x)            _VALUEOF(x)

  #define  PCI_CCNT_OF(x)                 _VALUEOF(x)

  #define PCI_CCNT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,CCNT,CCNT) \
   )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define PCI_CCNT_RMK(ccnt) (Uint32)(\
     _PER_FMK(PCI,CCNT,CCNT,ccnt)\
  )     
#endif  
  #define _PCI_CCNT_FGET(FIELD)\
    _PER_FGET(_PCI_CCNT_ADDR,PCI,CCNT,##FIELD)


/****************************************************************************\
* _____________________
* |                   |
* |  H A L T          |
* |___________________|
*
* HALT - PCI Transfer Halt Register
*
* FIELDS (msb -> lsb)
* (rw)  HALT
*
\******************************************************************************/
#define _PCI_HALT_OFFSET     10

 #if (C64_SUPPORT)
  #define _PCI_HALT_ADDR                   0x01C00028u
 #else
  #define _PCI_HALT_ADDR                   0x01A40028u
 #endif

 #if (C64_SUPPORT)
  #define _PCI_HALT_HALT_MASK              0x00000000u
  #define _PCI_HALT_HALT_SHIFT             0x00000000u
  #define  PCI_HALT_HALT_DEFAULT           0x00000000u
  #define  PCI_HALT_HALT_OF(x)             _VALUEOF(x)
#else
  #define _PCI_HALT_HALT_MASK              0x00000001u
  #define _PCI_HALT_HALT_SHIFT             0x00000000u
  #define  PCI_HALT_HALT_DEFAULT           0x00000000u
  #define  PCI_HALT_HALT_DEFAULT           0x00000000u
  #define  PCI_HALT_HALT_OF(x)             _VALUEOF(x)
   #define  PCI_HALT_HALT_SET              0x00000001u
 #endif

  #define  PCI_HALT_OF(x)                  _VALUEOF(x)

  #define PCI_HALT_RMK(halt)\
  (Uint32)( \
     _PER_FMK(PCI,HALT,HALT,halt) \
   )

  #define PCI_HALT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,HALT,HALT) \
   )

 #define _PCI_HALT_FGET(FIELD)\
    _PER_FGET(_PCI_HALT_ADDR,PCI,HALT,##FIELD)

 #define _PCI_HALT_FSET(FIELD,field)\
    _PER_FSET(_PCI_HALT_ADDR,PCI,HALT,##FIELD,field)

 #define _PCI_HALT_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_HALT_ADDR,PCI,HALT,##FIELD,##SYM)

/****************************************************************************\
* _____________________
* |                   |
* |  E E A D D        |
* |___________________|
*
* EEADD - EEPROM Address Register
*
* FIELDS (msb -> lsb)
* (rw) EEADD
*
\******************************************************************************/

  #define _PCI_EEADD_OFFSET          0


 #if (C64_SUPPORT)
  #define _PCI_EEADD_ADDR	  		   0x01C20000u
 #else
   #define _PCI_EEADD_ADDR	  		   0x01A80000u
 #endif

  #define _PCI_EEADD_EEADD_MASK              0x000003FFu
  #define _PCI_EEADD_EEADD_SHIFT             0x00000000u
  #define  PCI_EEADD_EEADD_DEFAULT           0x00000000u
  #define  PCI_EEADD_EEADD_OF(x)             _VALUEOF(x)

  #define  PCI_EEADD_OF(x)                   _VALUEOF(x)

  #define PCI_EEADD_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,EEADD,EEADD) \
   )

  #define PCI_EEADD_RMK(eeadd)  \
  (Uint32)( \
     _PER_FMK(PCI,EEADD,EEADD,eeadd) \
   )

  #define _PCI_EEADD_FGET(FIELD)\
    _PER_FGET(_PCI_EEADD_ADDR,PCI,EEADD,##FIELD)

  #define _PCI_EEADD_FSET(FIELD,field)\
    _PER_FSET(_PCI_EEADD_ADDR,PCI,EEADD,##FIELD,field)

  #define _PCI_EEADD_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_EEADD_ADDR,PCI,EEADD,##FIELD,##SYM)

/****************************************************************************\
* _____________________
* |                   |
* |  E E D A T        |
* |___________________|
*
* EEDAT - EEPROM Data Register
*
* FIELDS (msb -> lsb)
* (rw) EEDAT
*
\*****************************************************************************/

  #define _PCI_EEDAT_OFFSET          1


 #if (C64_SUPPORT)
   #define _PCI_EEDAT_ADDR                   0x01C20004u
 #else
   #define _PCI_EEDAT_ADDR                  0x01A80004u
 #endif

  #define _PCI_EEDAT_EEDAT_MASK              0x0000FFFFu
  #define _PCI_EEDAT_EEDAT_SHIFT             0x00000000u
  #define  PCI_EEDAT_EEDAT_DEFAULT           0x00000000u
  #define  PCI_EEDAT_EEDAT_OF(x)             _VALUEOF(x)

  #define  PCI_EEDAT_OF(x)                   _VALUEOF(x)

  #define PCI_EEDAT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,EEDAT,EEDAT) \
   )

  #define PCI_EEDAT_RMK(eedat) \
  (Uint32)( \
     _PER_FMK(PCI,EEDAT,EEDAT,eedat) \
   )

  #define _PCI_EEDAT_FGET(FIELD)\
    _PER_FGET(_PCI_EEDAT_ADDR,PCI,EEDAT,##FIELD)

  #define _PCI_EEDAT_FSET(FIELD,field)\
    _PER_FSET(_PCI_EEDAT_ADDR,PCI,EEDAT,##FIELD,field)

  #define _PCI_EEDAT_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_EEDAT_ADDR,PCI,EEDAT,##FIELD,##SYM)



/****************************************************************************\
* _____________________
* |                   |
* |  E E C T L        |
* |___________________|
*
* EECTL - EEPROM Control Register
*
* FIELDS (msb -> lsb)
* (r)  CFGDONE
* (r)  CFGERR
* (r)  EEAI
* (r)  EESZ
* (r)  READY
* (rw) EECNT
*
\******************************************************************************/
  #define _PCI_EECTL_OFFSET         2


 #if (C64_SUPPORT)
   #define _PCI_EECTL_ADDR                0x01C20008u
 #else
   #define _PCI_EECTL_ADDR                0x01A80008u
 #endif

  #define _PCI_EECTL_CFGDONE_MASK            0x00000100u
  #define _PCI_EECTL_CFGDONE_SHIFT           0x00000008u
  #define  PCI_EECTL_CFGDONE_DEFAULT         0x00000000u
  #define  PCI_EECTL_CFGDONE_OF(x)           _VALUEOF(x)


  #define _PCI_EECTL_CFGERR_MASK             0x00000080u
  #define _PCI_EECTL_CFGERR_SHIFT            0x00000007u
  #define  PCI_EECTL_CFGERR_DEFAULT          0x00000000u
  #define  PCI_EECTL_CFGERR_OF(x)             _VALUEOF(x)


  #define _PCI_EECTL_EEAI_MASK               0x00000040u
  #define _PCI_EECTL_EEAI_SHIFT              0x00000006u
  #define  PCI_EECTL_EEAI_DEFAULT            0x00000000u
  #define  PCI_EECTL_EEAI_OF(x)              _VALUEOF(x)


  #define _PCI_EECTL_EESZ_MASK               0x00000038u
  #define _PCI_EECTL_EESZ_SHIFT              0x00000003u
  #define  PCI_EECTL_EESZ_DEFAULT            0x00000000u
  #define  PCI_EECTL_EESZ_OF(x)              _VALUEOF(x)


  #define _PCI_EECTL_READY_MASK              0x00000004u
  #define _PCI_EECTL_READY_SHIFT             0x00000002u
  #define  PCI_EECTL_READY_DEFAULT           0x00000000u
  #define  PCI_EECTL_READY_OF(x)             _VALUEOF(x)


  #define _PCI_EECTL_EECNT_MASK              0x00000003u
  #define _PCI_EECTL_EECNT_SHIFT             0x00000000u
  #define  PCI_EECTL_EECNT_DEFAULT           0x00000000u
  #define  PCI_EECTL_EECNT_OF(x)             _VALUEOF(x)
  #define  PCI_EECTL_EECNT_EWEN              0x00000000u
  #define  PCI_EECTL_EECNT_ERAL              0x00000000u
  #define  PCI_EECTL_EECNT_WRAL              0x00000000u
  #define  PCI_EECTL_EECNT_EWDS              0x00000000u
  #define  PCI_EECTL_EECNT_WRITE             0x00000001u
  #define  PCI_EECTL_EECNT_READ              0x00000002u
  #define  PCI_EECTL_EECNT_ERASE             0x00000003u

  #define  PCI_EECTL_OF(x)                   _VALUEOF(x)

  #define PCI_EECTL_DEFAULT (Uint32)( \
    _PER_FDEFAULT(PCI,EECTL,CFGDONE) \
   |_PER_FDEFAULT(PCI,EECTL,CFGERR) \
   |_PER_FDEFAULT(PCI,EECTL,EEAI) \
   |_PER_FDEFAULT(PCI,EECTL,EESZ) \
   |_PER_FDEFAULT(PCI,EECTL,READY) \
   |_PER_FDEFAULT(PCI,EECTL,EECNT) \
   )

  #define PCI_EECTL_RMK(eecnt) \
  (Uint32)( \
      _PER_FMK(PCI,EECTL,EECNT,eecnt) \
   )

  #define _PCI_EECTL_FGET(FIELD)\
    _PER_FGET(_PCI_EECTL_ADDR,PCI,EECTL,##FIELD)

  #define _PCI_EECTL_FSET(FIELD,field)\
    _PER_FSET(_PCI_EECTL_ADDR,PCI,EECTL,##FIELD,field)

  #define _PCI_EECTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_EECTL_ADDR,PCI,EECTL,##FIELD,##SYM)



/****************************************************************************\
* _____________________
* |                   |
* |  T R C T L        |
* |___________________|
*
* TRCTL - TR Control Register
*
* FIELDS (msb -> lsb)
* (rw) TRSTALL
* (rw) PRI
* (rw) PALLOC
*
\*****************************************************************************/
#if (C64_SUPPORT)
  #define _PCI_TRCTL_OFFSET          0



   #define _PCI_TRCTL_ADDR                   0x01C30000u


  #define _PCI_TRCTL_TRSTALL_MASK              0x00000100u
  #define _PCI_TRCTL_TRSTALL_SHIFT             0x00000008u
  #define  PCI_TRCTL_TRSTALL_DEFAULT           0x00000000u
  #define  PCI_TRCTL_TRSTALL_OF(x)             _VALUEOF(x)

  #define _PCI_TRCTL_PRI_MASK    	           0x00000030u
  #define _PCI_TRCTL_PRI_SHIFT   	           0x00000004u
  #define  PCI_TRCTL_PRI_DEFAULT 	           0x00000002u
  #define  PCI_TRCTL_PRI_OF(x)   	           _VALUEOF(x)

  #define _PCI_TRCTL_PALLOC_MASK               0x0000000Fu
  #define _PCI_TRCTL_PALLOC_SHIFT              0x00000000u
  #define  PCI_TRCTL_PALLOC_DEFAULT            0x00000004u
  #define  PCI_TRCTL_PALLOC_OF(x)              _VALUEOF(x)

  #define  PCI_TRCTL_OF(x)                   _VALUEOF(x)

  #define PCI_TRCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PCI,TRCTL,TRSTALL) \
    |_PER_FDEFAULT(PCI,TRCTL,PRI) \
    |_PER_FDEFAULT(PCI,TRCTL,PALLOC) \
   )

  #define PCI_TRCTL_RMK(trstall,pri,palloc) \
  (Uint32)( \
     _PER_FMK(PCI,TRCTL,TRSTALL,trctl) \
    |_PER_FMK(PCI,TRCTL,PRI,pri) \
    |_PER_FMK(PCI,TRCTL,PALLOC,palloc) \
   )

  #define _PCI_TRCTL_FGET(FIELD)\
    _PER_FGET(_PCI_TRCTL_ADDR,PCI,TRCTL,##FIELD)

  #define _PCI_TRCTL_FSET(FIELD,field)\
    _PER_FSET(_PCI_TRCTL_ADDR,PCI,TRCTL,##FIELD,field)

  #define _PCI_TRCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_PCI_TRCTL_ADDR,PCI,TRCTL,##FIELD,##SYM)

 #endif
/******************************************************************************/

#endif /* PCI_SUPPORT */
#endif /* _CSL_PCIHAL_H_ */
/******************************************************************************\
* End of pcihal.h
\******************************************************************************/

csl_pll.h/      1076583464  0     0     0       11437     `
/******************************************************************************\
*  Step 1.      Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_pll.h
* DATE CREATED.. 10/29/2001 
* LAST MODIFIED. 11/30/2001
*                11/30/2003 Modified PLL_init() sequence to fix the PLL 
*                           initialization problem
\******************************************************************************/

/******************************************************************************\
* Step 2. Private Macros - Include files - PLL_SUPPORT
\******************************************************************************/
#ifndef _CSL_PLL_H_
#define _CSL_PLL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>
#include <csl_pllhal.h>

#if (PLL_SUPPORT)
/******************************************************************************\
* Step 3. scope and inline control macros  
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far 
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _PLL_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/******************************************************************************\
* Step 4. global macro declarations
\******************************************************************************/
#define PLL_DIV0  0
#define PLL_DIV1  1
#define PLL_DIV2  2
#define PLL_DIV3  3


/*****************************************************************************\
* Step 5. global typedef declarations
* Example : Config structure 
* typedef struct {
*   Uint32 rg1;
*   Uint32 rg2;
*  } PLL_Config;
\******************************************************************************/
typedef struct{
    Uint32 pllcsr;
    Uint32 pllm;
    Uint32 plldiv0;
    Uint32 plldiv1;
    Uint32 plldiv2;
    Uint32 plldiv3;
    Uint32 oscdiv1;
}PLL_Config;
    
  
typedef struct {
   Uint32  mdiv;
   Uint32  d0ratio;
   Uint32  d1ratio;
   Uint32  d2ratio;
   Uint32  d3ratio;
   Uint32  od1ratio;
 }PLL_Init;	 

/******************************************************************************\
* Step 6. global variable declarations
\******************************************************************************/
/* private vars */
extern far Uint32 _PLL_divAddr[4];


/******************************************************************************\
* Step 7. global function declarations
\******************************************************************************/

/* Private functions (If applicable)*/

static void plldelay(Uint32 count);

/* API functions (Non-Inline function : Source file) */
CSLAPI void PLL_wait100();
CSLAPI Uint32 PLL_wait1();

/******************************************************************************\
* Step 8. inline function declarations ( IDECL keyword)
\******************************************************************************/
IDECL void PLL_config(PLL_Config *config);
IDECL void PLL_configArgs(Uint32 pllcsr, Uint32 pllm, Uint32 plldiv0, Uint32 plldiv1, Uint32 plldiv2, Uint32 plldiv3,Uint32 oscdiv1);
IDECL void PLL_getConfig(PLL_Config *config);

IDECL void PLL_init(PLL_Init *init);

IDECL void PLL_pwrdwn();
IDECL void PLL_operational();
IDECL void PLL_enable();
IDECL void PLL_bypass();
IDECL void PLL_reset();
IDECL void PLL_deassert();


IDECL Uint32 PLL_clkTest();

IDECL void PLL_enablePllDiv(Uint32 divId);
IDECL void PLL_disablePllDiv(Uint32 divId);

IDECL void PLL_enableOscDiv();
IDECL void PLL_disableOscDiv();

IDECL void PLL_setMultiplier(Uint32 val);
IDECL void PLL_setPllRatio(Uint32 divId,Uint32 val);
IDECL void PLL_setOscRatio(Uint32 val);

IDECL Uint32 PLL_getMultiplier();
IDECL Uint32 PLL_getPllRatio(Uint32 divnum);
IDECL Uint32 PLL_getOscRatio();

/******************************************************************************\
* Step 9. inline function definitions  ( #if USEDEF - IDEF keywords)
\******************************************************************************/

#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void PLL_pwrdwn(){       
      PLL_FSETS(PLLCSR,PLLEN,BYPASS); /* Bypass mode PLLEN = 0 */ 
      PLL_FSETS(PLLCSR,PLLPWRDN,YES); /* PwrDwn mode */

}
/*----------------------------------------------------------------------------*/
IDEF void PLL_operational(){       
      PLL_FSETS(PLLCSR,PLLPWRDN,NO);     /* Operational mode */
      PLL_FSETS(PLLDIV0,D0EN,ENABLE);    /* Enable D0 path   */
      PLL_FSETS(PLLCSR,PLLEN,ENABLE);    /* Enable PLLEN = 1 */ 
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_enable(){
      PLL_FSETS(PLLCSR,PLLEN,ENABLE); /* Bypass mode PLLEN = 1 */ 
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_bypass(){
     PLL_FSETS(PLLCSR,PLLEN,BYPASS); /* Bypass mode PLLEN = 0 */ 
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PLL_clkTest(){   
     return(PLL_FGET(PLLCSR,STABLE));  
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_reset(){   
     PLL_FSETS(PLLCSR,PLLRST,1);     /* reset mode */
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_deassert(){   
     PLL_FSETS(PLLCSR,PLLRST,0);    /* deassert PLL */ 
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_enablePllDiv(Uint32 divId){
   (*(volatile Uint32*) _PLL_divAddr[divId]) |=(0x00008000u);
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_disablePllDiv(Uint32 divId){
   (*(volatile Uint32*)  _PLL_divAddr[divId]) &=~(0x00008000u);
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_enableOscDiv(){
    PLL_FSET(OSCDIV1,OD1EN,1);
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_disableOscDiv(){
    PLL_FSET(OSCDIV1,OD1EN,0);
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_setPllRatio(Uint32 divId, Uint32 val){
  Uint32  tmp= ((*(volatile Uint32*) _PLL_divAddr[divId])  & 0xFFFFFFE0u);
     (*(volatile Uint32*) _PLL_divAddr[divId]) =(val | tmp );
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_setOscRatio(Uint32 val){
    PLL_FSET(OSCDIV1,RATIO,val);
}
/*----------------------------------------------------------------------------*/
IDEF void PLL_setMultiplier(Uint32 val){
    PLL_FSET(PLLM,PLLM,val);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PLL_getPllRatio(Uint32 divId){
    return (Uint32)((*(volatile Uint32*) _PLL_divAddr[divId]) & 0x0000001Fu);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PLL_getOscRatio(){
    return(PLL_FGET(OSCDIV1,RATIO));
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 PLL_getMultiplier(){
    return(PLL_FGET(PLLM,PLLM));
}

/*----------------------------------------------------------------------------*/
IDEF void PLL_init(PLL_Init *init) {

  Uint32 gie ;
  gie = IRQ_globalDisable();

  PLL_FSETS(PLLCSR,PLLEN,BYPASS); /* Bypass mode PLLEN = 0 */ 

  plldelay(20);

  PLL_FSETS(PLLCSR,PLLRST,1);     /* reset mode */
  
  plldelay(20);

  // Set main multiplier/divisor 
  PLL_RSET(PLLM,init->mdiv);
  PLL_RSET(PLLDIV0, PLL_PLLDIV0_RMK(0,init->d0ratio));
  PLL_RSET(OSCDIV1,PLL_OSCDIV1_RMK(0,init->od1ratio));		  
  
  // Set DSP clock 
  PLL_RSET(PLLDIV1,PLL_PLLDIV1_RMK(0,init->d1ratio));
  
  // Set EMIF clock 
  PLL_RSET(PLLDIV3,PLL_PLLDIV3_RMK(0,init->d3ratio));

  plldelay(20);

  //   Take PLL out of reset
  PLL_FSETS(PLLCSR,PLLRST,0);
  plldelay(1500);

  // Enable PLL
  PLL_FSETS(PLLCSR,PLLEN,ENABLE);
  plldelay(20);
 
  IRQ_globalRestore(gie);
}
  

/*----------------------------------------------------------------------------*/
IDEF void PLL_config(PLL_Config *config) {
  Uint32 gie;
  volatile Uint32 *base;
  register Uint32 x0,x1,x2,x3,x4,x5,x6;
 
  gie = IRQ_globalDisable();

  x0 = config->pllcsr;
  x1 = config->pllm;
  x2 = config->plldiv0;
  x3 = config->plldiv1;
  x4 = config->plldiv2;
  x5 = config->plldiv3;
  x6 = config->oscdiv1;


  base = (volatile Uint32 *)(_PLL_BASE_ADDR);

  base[_PLL_PLLM_OFFSET] = x1;
  base[_PLL_PLLDIV0_OFFSET] = x2;
  base[_PLL_PLLDIV1_OFFSET] = x3;
  base[_PLL_PLLDIV2_OFFSET] = x4;
  base[_PLL_PLLDIV3_OFFSET] = x5;
  base[_PLL_OSCDIV1_OFFSET] = x6;
  base[_PLL_PLLCSR_OFFSET] = x0;

  IRQ_globalRestore(gie);
  
}

/*----------------------------------------------------------------------------*/
IDEF void PLL_configArgs(Uint32 pllcsr, Uint32 pllm, Uint32 plldiv0, Uint32 plldiv1, Uint32 plldiv2, Uint32 plldiv3,Uint32 oscdiv1){

  Uint32 gie;
  volatile Uint32 *base;
  gie = IRQ_globalDisable();

  base = (volatile Uint32 *)(_PLL_BASE_ADDR);

  base[_PLL_PLLM_OFFSET] = pllm;
  base[_PLL_PLLDIV0_OFFSET] = plldiv0;
  base[_PLL_PLLDIV1_OFFSET] = plldiv1;
  base[_PLL_PLLDIV2_OFFSET] = plldiv2;
  base[_PLL_PLLDIV3_OFFSET] = plldiv3;
  base[_PLL_OSCDIV1_OFFSET] = oscdiv1;
  base[_PLL_PLLCSR_OFFSET] = pllcsr;

  IRQ_globalRestore(gie);
}


/*----------------------------------------------------------------------------*/
IDEF void PLL_getConfig(PLL_Config *config) {
  Uint32 gie;
  volatile Uint32 *base;
  register Uint32 x0,x1,x2,x3,x4,x5,x6;
 
  gie = IRQ_globalDisable();

  base = (volatile Uint32 *)(_PLL_BASE_ADDR);
 
 x0 = base[_PLL_PLLCSR_OFFSET];
 x1 = base[_PLL_PLLM_OFFSET];
 x2 = base[_PLL_PLLDIV0_OFFSET];
 x3 = base[_PLL_PLLDIV1_OFFSET];
 x4 = base[_PLL_PLLDIV2_OFFSET];
 x5 = base[_PLL_PLLDIV3_OFFSET];
 x6 = base[_PLL_OSCDIV1_OFFSET];

  config->pllcsr = x0;
  config->pllm = x1;
  config->plldiv0 = x2;
  config->plldiv1 = x3;
  config->plldiv2 = x4;
  config->plldiv3 = x5;
  config->oscdiv1 = x6;

  IRQ_globalRestore(gie);
  
}



/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */

/* Local software delay function */

static void plldelay(Uint32 count){
   Uint32 i = count;
   while(i--){
     asm(" NOP 1");
   }
}

/******************************************************************************\
* Step 10. #endif for PLL_SUPPORT and CSL_PLL_H Macro + Footer
\******************************************************************************/
#endif /* PLL_SUPPORT */
#endif /* _CSL_PLL_H_ */
/******************************************************************************\
* End of csl_module.h
\******************************************************************************/

csl_pllhal.h/   1082727955  0     0     0       22080     `
/****************************************************************************\
*           Copyright (C) 2001 Texas Instruments Incorporated.
*                           All Rights Reserved 
*------------------------------------------------------------------------------
* MODULE NAME... PLL
* FILENAME...... csl_pllhal.h 
* DATE CREATED.. Tue 10-30-2001 at 9:08:46a
* DATE MODIFIED. Fri 04-16-2004 Modified PID field default values(CLASS,TYPE).
*------------------------------------------------------------------------------
* HISTORY:
*------------------------------------------------------------------------------
* DESCRIPTION: (HAL interface file for the PLL module) 
*
* REGISTERS  
*   
*   PID        -   "PLL Controller Peripheral Identification Register"
*   PLLCSR     -   "Control Status register"                                       
*   PLLM       -   "Multiplier Control register"   (PLLM)
*   PLLDIV0    -   "PLL Divider 0 register"  
*   PLLDIV1    -   "PLL Divider 1 register"  
*   PLLDIV2    -   "PLL Divider 2 register"  
*   PLLDIV3    -   "PLL Divider 3 register"  
*   OSCDIV1    -   "Oscillator Divider 1 register"  
*
\***************************************************************************/

#ifndef  _CSL_PLLHAL_H_  
#define  _CSL_PLLHAL_H_  

/*****************************\
*   Include files        
\*****************************/
#include <csl_stdinc.h> 
#include <csl_chip.h> 

#if (PLL_SUPPORT) 
/************************************************************\
*    Misc. Declarations          
\************************************************************/

 #define   _PLL_BASE_ADDR  0x01B7C000u

/************************************************************\
*    Module level register/field access macros          
\************************************************************/

  /* ------------------- */
  /* FIELD MAKE MACROS   */
  /* ------------------- */

  #define PLL_FMK(REG,FIELD,x)\
   _PER_FMK(PLL,##REG,##FIELD,x)

  #define PLL_FMKS(REG,FIELD,SYM)\
   _PER_FMKS(PLL,##REG,##FIELD,##SYM)

  /* ---------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS   */
  /* ---------------------------------- */

  #define PLL_REG(REG)  (*(volatile Uint32*) (_PLL_##REG##_ADDR)) 

  #define PLL_ADDR(REG)\
   _PLL_##REG##_ADDR 

  #define PLL_RGET(REG)\
   _PER_RGET(_PLL_##REG##_ADDR,PLL,##REG)

  #define PLL_RSET(REG,x)\
   _PER_RSET(_PLL_##REG##_ADDR,PLL,##REG,x)

  #define PLL_FGET(REG,FIELD)\
   _PLL_##REG##_FGET(##FIELD) 

  #define PLL_FSET(REG,FIELD,x)\
   _PLL_##REG##_FSET(##FIELD,x) 

  #define PLL_FSETS(REG,FIELD,SYM)\
   _PLL_##REG##_FSETS(##FIELD,##SYM)

  /* -------------------------------------------- */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS   */
  /* -------------------------------------------- */

  #define PLL_RGETA(addr,REG)\
   _PER_RGET(addr,PLL,##REG) 

  #define PLL_RSETA(addr,REG,x)\
   _PER_RSET(addr,PLL,##REG,x)

  #define PLL_FGETA(addr,REG,FIELD)\
   _PER_FGET(addr,PLL,##REG,##FIELD)

  #define PLL_FSETA(addr,REG,FIELD,x)\
   _PER_FSET(addr,PLL,##REG,##FIELD,x)

  #define PLL_FSETSA(addr,REG,FIELD,SYM)\
   _PER_FSETS(addr,PLL,##REG,##FIELD,##SYM) 



/*******************************************************************\
*        
*  ________________  
* |                |  
* |  PID           |
* |________________| 
*
*       PID   -    "Peripheral Identification register"  
*
* FIELDS (msb -> lsb)
*   (r) TYPE
*   (r) CLASS
*   (r) REV
*
\*******************************************************************/

   #define _PLL_PID_OFFSET       0
   #define _PLL_PID_ADDR         0x01B7C000u
   #define  PLL_PID              PLL_REG(PID)      


   #define _PLL_PID_TYPE_MASK             0x00FF0000u
   #define _PLL_PID_TYPE_SHIFT            0x00000010u
   #define  PLL_PID_TYPE_DEFAULT          0x00000001u
   #define  PLL_PID_TYPE_OF(x)            _VALUEOF(x)

   #define _PLL_PID_CLASS_MASK             0x0000FF00u
   #define _PLL_PID_CLASS_SHIFT            0x00000008u
   #define  PLL_PID_CLASS_DEFAULT          0x00000008u
   #define  PLL_PID_CLASS_OF(x)            _VALUEOF(x)

   #define _PLL_PID_REV_MASK             0x000000FFu
   #define _PLL_PID_REV_SHIFT            0x00000000u
   #define  PLL_PID_REV_DEFAULT          0x00000001u
   #define  PLL_PID_REV_OF(x)            _VALUEOF(x)

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_PID_DEFAULT  (Uint32) (\
      _PER_FDEFAULT(PLL,PID,TYPE) \
     |_PER_FDEFAULT(PLL,PID,CLASS) \
     |_PER_FDEFAULT(PLL,PID,REV) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 

   /*=============   Register Access macros ==============*/ 
   #define _PLL_PID_FGET(FIELD)\
     _PER_FGET(_PLL_PID_ADDR,PLL,PID,##FIELD)

   #define _PLL_PID_FSET(FIELD,field)\
     _PER_FSET(_PLL_PID_ADDR,PLL,PID,##FIELD,field)

   #define _PLL_PID_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_PID_ADDR,PLL,PID,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
* |  PLLCSR        |
* |________________| 
*
*       PLLCSR   -    "Control Status register"  
*
* FIELDS (msb -> lsb)
*   (r)  STABLE
*   (rw) PLLRST
*   (rw) PLLPWRDN
*   (rw) PLLEN
*
\*******************************************************************/

   #define _PLL_PLLCSR_OFFSET       64
   #define _PLL_PLLCSR_ADDR         (_PLL_BASE_ADDR + 0x100u)
   #define  PLL_PLLCSR              PLL_REG(PLLCSR)      


   #define _PLL_PLLCSR_STABLE_MASK             0x00000040u
   #define _PLL_PLLCSR_STABLE_SHIFT            0x00000006u
   #define  PLL_PLLCSR_STABLE_DEFAULT          0x00000001u
   #define  PLL_PLLCSR_STABLE_OF(x)            _VALUEOF(x)

   #define _PLL_PLLCSR_PLLRST_MASK             0x00000008u
   #define _PLL_PLLCSR_PLLRST_SHIFT            0x00000003u
   #define  PLL_PLLCSR_PLLRST_DEFAULT          0x00000001u
   #define  PLL_PLLCSR_PLLRST_OF(x)            _VALUEOF(x)
   #define  PLL_PLLCSR_PLLRST_1                0x00000001u
   #define  PLL_PLLCSR_PLLRST_0                0x00000000u

   #define _PLL_PLLCSR_PLLPWRDN_MASK             0x00000002u
   #define _PLL_PLLCSR_PLLPWRDN_SHIFT            0x00000001u
   #define  PLL_PLLCSR_PLLPWRDN_DEFAULT          0x00000000u
   #define  PLL_PLLCSR_PLLPWRDN_OF(x)            _VALUEOF(x)
   #define  PLL_PLLCSR_PLLPWRDN_YES             0x00000001u
   #define  PLL_PLLCSR_PLLPWRDN_NO             0x00000000u

   #define _PLL_PLLCSR_PLLEN_MASK             0x00000001u
   #define _PLL_PLLCSR_PLLEN_SHIFT            0x00000000u
   #define  PLL_PLLCSR_PLLEN_DEFAULT          0x00000000u
   #define  PLL_PLLCSR_PLLEN_OF(x)            _VALUEOF(x)
   #define  PLL_PLLCSR_PLLEN_ENABLE             0x00000001u
   #define  PLL_PLLCSR_PLLEN_BYPASS             0x00000000u

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_PLLCSR_DEFAULT  (Uint32) (\
      _PER_FDEFAULT(PLL,PLLCSR,STABLE) \
     |_PER_FDEFAULT(PLL,PLLCSR,PLLRST) \
     |_PER_FDEFAULT(PLL,PLLCSR,PLLPWRDN) \
     |_PER_FDEFAULT(PLL,PLLCSR,PLLEN) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_PLLCSR_RMK(pllrst,pllpwrdn,pllen) \
 (Uint32) (\
      _PER_FMK(PLL,PLLCSR,PLLRST,pllrst) \
     |_PER_FMK(PLL,PLLCSR,PLLPWRDN,pllpwrdn) \
     |_PER_FMK(PLL,PLLCSR,PLLEN,pllen) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_PLLCSR_FGET(FIELD)\
     _PER_FGET(_PLL_PLLCSR_ADDR,PLL,PLLCSR,##FIELD)

   #define _PLL_PLLCSR_FSET(FIELD,field)\
     _PER_FSET(_PLL_PLLCSR_ADDR,PLL,PLLCSR,##FIELD,field)

   #define _PLL_PLLCSR_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_PLLCSR_ADDR,PLL,PLLCSR,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
*   PLLM   
* |________________| 
*
*       PLLM   -    "Multiplier Control register"  
*
* FIELDS (msb -> lsb)
*   (rw) PLLM
*
\*******************************************************************/

   #define _PLL_PLLM_OFFSET       68
   #define _PLL_PLLM_ADDR         (_PLL_BASE_ADDR + 0x110u) 
   #define  PLL_PLLM              PLL_REG(PLLM)      


   #define _PLL_PLLM_PLLM_MASK             0x0000001Fu
   #define _PLL_PLLM_PLLM_SHIFT            0x00000000u
   #define  PLL_PLLM_PLLM_DEFAULT          0x00000007u
   #define  PLL_PLLM_PLLM_OF(x)            _VALUEOF(x)

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_PLLM_DEFAULT  (Uint32) (\
     _PER_FDEFAULT(PLL,PLLM,PLLM) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_PLLM_RMK(pllm) \
 (Uint32) (\
      _PER_FMK(PLL,PLLM,PLLM,pllm) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_PLLM_FGET(FIELD)\
     _PER_FGET(_PLL_PLLM_ADDR,PLL,PLLM,##FIELD)

   #define _PLL_PLLM_FSET(FIELD,field)\
     _PER_FSET(_PLL_PLLM_ADDR,PLL,PLLM,##FIELD,field)

   #define _PLL_PLLM_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_PLLM_ADDR,PLL,PLLM,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
* | PLLDIV0        |
* |________________| 
*
*       PLLDIV0   -    "PLL Divider 0 register"  
*
* FIELDS (msb -> lsb)
*   (rw) D0EN
*   (rw) RATIO
*
\*******************************************************************/

   #define _PLL_PLLDIV0_OFFSET       69
   #define _PLL_PLLDIV0_ADDR         (_PLL_BASE_ADDR + 0x114u) 
   #define  PLL_PLLDIV0              PLL_REG(PLLDIV0)      


   #define _PLL_PLLDIV0_D0EN_MASK             0x00008000u
   #define _PLL_PLLDIV0_D0EN_SHIFT            0x0000000Fu
   #define  PLL_PLLDIV0_D0EN_DEFAULT          0x00000001u
   #define  PLL_PLLDIV0_D0EN_OF(x)            _VALUEOF(x)
   #define  PLL_PLLDIV0_D0EN_ENABLE             0x00000001u
   #define  PLL_PLLDIV0_D0EN_DISABLE             0x00000000u

   #define _PLL_PLLDIV0_RATIO_MASK             0x0000001Fu
   #define _PLL_PLLDIV0_RATIO_SHIFT            0x00000000u
   #define  PLL_PLLDIV0_RATIO_DEFAULT          0x00000000u
   #define  PLL_PLLDIV0_RATIO_OF(x)            _VALUEOF(x)

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_PLLDIV0_DEFAULT  (Uint32) (\
      _PER_FDEFAULT(PLL,PLLDIV0,D0EN) \
     |_PER_FDEFAULT(PLL,PLLDIV0,RATIO) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_PLLDIV0_RMK(d0en,ratio) \
 (Uint32) (\
      _PER_FMK(PLL,PLLDIV0,D0EN,d0en) \
     |_PER_FMK(PLL,PLLDIV0,RATIO,ratio) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_PLLDIV0_FGET(FIELD)\
     _PER_FGET(_PLL_PLLDIV0_ADDR,PLL,PLLDIV0,##FIELD)

   #define _PLL_PLLDIV0_FSET(FIELD,field)\
     _PER_FSET(_PLL_PLLDIV0_ADDR,PLL,PLLDIV0,##FIELD,field)

   #define _PLL_PLLDIV0_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_PLLDIV0_ADDR,PLL,PLLDIV0,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
* |  PLLDIV1       |
* |________________| 
*
*       PLLDIV1   -    "PLL Divider 1 register"  
*
* FIELDS (msb -> lsb)
*   (rw) D1EN
*   (rw) RATIO
*
\*******************************************************************/

   #define _PLL_PLLDIV1_OFFSET       70
   #define _PLL_PLLDIV1_ADDR         (_PLL_BASE_ADDR + 0x118u) 
   #define  PLL_PLLDIV1              PLL_REG(PLLDIV1)      


   #define _PLL_PLLDIV1_D1EN_MASK             0x00008000u
   #define _PLL_PLLDIV1_D1EN_SHIFT            0x0000000Fu
   #define  PLL_PLLDIV1_D1EN_DEFAULT          0x00000001u
   #define  PLL_PLLDIV1_D1EN_OF(x)            _VALUEOF(x)
   #define  PLL_PLLDIV1_D1EN_ENABLE             0x00000001u
   #define  PLL_PLLDIV1_D1EN_DISABLE             0x00000000u

   #define _PLL_PLLDIV1_RATIO_MASK             0x0000001Fu
   #define _PLL_PLLDIV1_RATIO_SHIFT            0x00000000u
   #define  PLL_PLLDIV1_RATIO_DEFAULT          0x00000000u
   #define  PLL_PLLDIV1_RATIO_OF(x)            _VALUEOF(x)

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_PLLDIV1_DEFAULT  (Uint32) (\
      _PER_FDEFAULT(PLL,PLLDIV1,D1EN) \
     |_PER_FDEFAULT(PLL,PLLDIV1,RATIO) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_PLLDIV1_RMK(d1en,ratio) \
 (Uint32) (\
      _PER_FMK(PLL,PLLDIV1,D1EN,d1en) \
     |_PER_FMK(PLL,PLLDIV1,RATIO,ratio) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_PLLDIV1_FGET(FIELD)\
     _PER_FGET(_PLL_PLLDIV1_ADDR,PLL,PLLDIV1,##FIELD)

   #define _PLL_PLLDIV1_FSET(FIELD,field)\
     _PER_FSET(_PLL_PLLDIV1_ADDR,PLL,PLLDIV1,##FIELD,field)

   #define _PLL_PLLDIV1_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_PLLDIV1_ADDR,PLL,PLLDIV1,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
* |  PLLDIV2       |
* |________________| 
*
*       PLLDIV2   -    "PLL Divider 2 register"  
*
* FIELDS (msb -> lsb)
*   (rw) D2EN
*   (rw) RATIO
*
\*******************************************************************/

   #define _PLL_PLLDIV2_OFFSET       71
   #define _PLL_PLLDIV2_ADDR        (_PLL_BASE_ADDR + 0x11Cu) 
   #define  PLL_PLLDIV2              PLL_REG(PLLDIV2)      


   #define _PLL_PLLDIV2_D2EN_MASK             0x00008000u
   #define _PLL_PLLDIV2_D2EN_SHIFT            0x0000000Fu
   #define  PLL_PLLDIV2_D2EN_DEFAULT          0x00000001u
   #define  PLL_PLLDIV2_D2EN_OF(x)            _VALUEOF(x)
   #define  PLL_PLLDIV2_D2EN_ENABLE             0x00000001u
   #define  PLL_PLLDIV2_D2EN_DISABLE             0x00000000u

   #define _PLL_PLLDIV2_RATIO_MASK             0x0000001Fu
   #define _PLL_PLLDIV2_RATIO_SHIFT            0x00000000u
   #define  PLL_PLLDIV2_RATIO_DEFAULT          0x00000001u
   #define  PLL_PLLDIV2_RATIO_OF(x)            _VALUEOF(x)

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_PLLDIV2_DEFAULT  (Uint32) (\
      _PER_FDEFAULT(PLL,PLLDIV2,D2EN) \
     |_PER_FDEFAULT(PLL,PLLDIV2,RATIO) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_PLLDIV2_RMK(d2en,ratio) \
 (Uint32) (\
      _PER_FMK(PLL,PLLDIV2,D2EN,d2en) \
     |_PER_FMK(PLL,PLLDIV2,RATIO,ratio) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_PLLDIV2_FGET(FIELD)\
     _PER_FGET(_PLL_PLLDIV2_ADDR,PLL,PLLDIV2,##FIELD)

   #define _PLL_PLLDIV2_FSET(FIELD,field)\
     _PER_FSET(_PLL_PLLDIV2_ADDR,PLL,PLLDIV2,##FIELD,field)

   #define _PLL_PLLDIV2_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_PLLDIV2_ADDR,PLL,PLLDIV2,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
* |  PLLDIV3       |
* |________________| 
*
*       PLLDIV3   -    "PLL Divider 3 register"  
*
* FIELDS (msb -> lsb)
*   (rw) D3EN
*   (rw) RATIO
*
\*******************************************************************/

   #define _PLL_PLLDIV3_OFFSET       72
   #define _PLL_PLLDIV3_ADDR         (_PLL_BASE_ADDR + 0x120u) 
   #define  PLL_PLLDIV3              PLL_REG(PLLDIV3)      


   #define _PLL_PLLDIV3_D3EN_MASK             0x00008000u
   #define _PLL_PLLDIV3_D3EN_SHIFT            0x0000000Fu
   #define  PLL_PLLDIV3_D3EN_DEFAULT          0x00000001u
   #define  PLL_PLLDIV3_D3EN_OF(x)            _VALUEOF(x)
   #define  PLL_PLLDIV3_D3EN_ENABLE             0x00000001u
   #define  PLL_PLLDIV3_D3EN_DISABLE             0x00000000u

   #define _PLL_PLLDIV3_RATIO_MASK             0x0000001Fu
   #define _PLL_PLLDIV3_RATIO_SHIFT            0x00000000u
   #define  PLL_PLLDIV3_RATIO_DEFAULT          0x00000001u
   #define  PLL_PLLDIV3_RATIO_OF(x)            _VALUEOF(x)

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_PLLDIV3_DEFAULT  (Uint32) (\
      _PER_FDEFAULT(PLL,PLLDIV3,D3EN) \
     |_PER_FDEFAULT(PLL,PLLDIV3,RATIO) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_PLLDIV3_RMK(d3en,ratio) \
 (Uint32) (\
      _PER_FMK(PLL,PLLDIV3,D3EN,d3en) \
     |_PER_FMK(PLL,PLLDIV3,RATIO,ratio) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_PLLDIV3_FGET(FIELD)\
     _PER_FGET(_PLL_PLLDIV3_ADDR,PLL,PLLDIV3,##FIELD)

   #define _PLL_PLLDIV3_FSET(FIELD,field)\
     _PER_FSET(_PLL_PLLDIV3_ADDR,PLL,PLLDIV3,##FIELD,field)

   #define _PLL_PLLDIV3_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_PLLDIV3_ADDR,PLL,PLLDIV3,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
* |  OSCDIV1       |
* |________________| 
*
*       OSCDIV1   -    "Oscillator Divider 1 register"  
*
* FIELDS (msb -> lsb)
*   (rw) OD1EN
*   (rw) RATIO
*
\*******************************************************************/

   #define _PLL_OSCDIV1_OFFSET       73
   #define _PLL_OSCDIV1_ADDR         (_PLL_BASE_ADDR + 0x124u) 

   #define  PLL_OSCDIV1              PLL_REG(OSCDIV1)      


   #define _PLL_OSCDIV1_OD1EN_MASK             0x00008000u
   #define _PLL_OSCDIV1_OD1EN_SHIFT            0x0000000Fu
   #define  PLL_OSCDIV1_OD1EN_DEFAULT          0x00000001u
   #define  PLL_OSCDIV1_OD1EN_OF(x)            _VALUEOF(x)
   #define  PLL_OSCDIV1_OD1EN_ENABLE             0x00000001u
   #define  PLL_OSCDIV1_OD1EN_DISABLE             0x00000000u

   #define _PLL_OSCDIV1_RATIO_MASK             0x0000001Fu
   #define _PLL_OSCDIV1_RATIO_SHIFT            0x00000000u
   #define  PLL_OSCDIV1_RATIO_DEFAULT          0x00000007u
   #define  PLL_OSCDIV1_RATIO_OF(x)            _VALUEOF(x)

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_OSCDIV1_DEFAULT  (Uint32) (\
      _PER_FDEFAULT(PLL,OSCDIV1,OD1EN) \
     |_PER_FDEFAULT(PLL,OSCDIV1,RATIO) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_OSCDIV1_RMK(od1en,ratio) \
 (Uint32) (\
      _PER_FMK(PLL,OSCDIV1,OD1EN,od1en) \
     |_PER_FMK(PLL,OSCDIV1,RATIO,ratio) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_OSCDIV1_FGET(FIELD)\
     _PER_FGET(_PLL_OSCDIV1_ADDR,PLL,OSCDIV1,##FIELD)

   #define _PLL_OSCDIV1_FSET(FIELD,field)\
     _PER_FSET(_PLL_OSCDIV1_ADDR,PLL,OSCDIV1,##FIELD,field)

   #define _PLL_OSCDIV1_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_OSCDIV1_ADDR,PLL,OSCDIV1,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
*   WAKEUP   
* |________________| 
*
*       WAKEUP   -    "Wakeup register"   Not Documented
*
* FIELDS (msb -> lsb)
*   (rw) WKEN
*
\*******************************************************************/

   #define _PLL_WAKEUP_OFFSET       76
   #define _PLL_WAKEUP_ADDR         (_PLL_BASE_ADDR + 0x130u) 
   #define  PLL_WAKEUP              PLL_REG(WAKEUP)      


   #define _PLL_WAKEUP_WKEN_MASK             0xFFFFFFFFu
   #define _PLL_WAKEUP_WKEN_SHIFT            0x00000000u
   #define  PLL_WAKEUP_WKEN_DEFAULT          0x00000000u
   #define  PLL_WAKEUP_WKEN_OF(x)            _VALUEOF(x)
   #define  PLL_WAKEUP_WKEN_ENABLE           0x00000001u
   #define  PLL_WAKEUP_WKEN_DISABLE          0x00000000u

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_WAKEUP_DEFAULT  (Uint32) (\
     _PER_FDEFAULT(PLL,WAKEUP,WKEN) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_WAKEUP_RMK(wken) \
 (Uint32) (\
      _PER_FMK(PLL,WAKEUP,WKEN,wken) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_WAKEUP_FGET(FIELD)\
     _PER_FGET(_PLL_WAKEUP_ADDR,PLL,WAKEUP,##FIELD)

   #define _PLL_WAKEUP_FSET(FIELD,field)\
     _PER_FSET(_PLL_WAKEUP_ADDR,PLL,WAKEUP,##FIELD,field)

   #define _PLL_WAKEUP_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_WAKEUP_ADDR,PLL,WAKEUP,##FIELD,##SYM)



/*******************************************************************\
*        
*  ________________  
* |                |  
*   CLK3SEL   
* |________________| 
*
*       CLK3SEL   -    "Clkout3 Select register"   Not Documented
*
* FIELDS (msb -> lsb)
*   (rw) CK3SEL
*
\*******************************************************************/

   #define _PLL_CLK3SEL_OFFSET       65
   #define _PLL_CLK3SEL_ADDR        (_PLL_BASE_ADDR + 0x104u) 
   #define  PLL_CLK3SEL              PLL_REG(CLK3SEL)      


   #define _PLL_CLK3SEL_CK3SEL_MASK             0x0000000Fu
   #define _PLL_CLK3SEL_CK3SEL_SHIFT            0x00000000u
   #define  PLL_CLK3SEL_CK3SEL_DEFAULT          0x00000000u
   #define  PLL_CLK3SEL_CK3SEL_OF(x)            _VALUEOF(x)
   #define  PLL_CLK3SEL_CK3SEL_DISABLED             0x00000008u
   #define  PLL_CLK3SEL_CK3SEL_PTA             0x00000009u
   #define  PLL_CLK3SEL_CK3SEL_PTB             0x0000000Au
   #define  PLL_CLK3SEL_CK3SEL_PTC             0x0000000Bu
   #define  PLL_CLK3SEL_CK3SEL_PTD             0x0000000Cu
   #define  PLL_CLK3SEL_CK3SEL_PTE             0x0000000Du
   #define  PLL_CLK3SEL_CK3SEL_PTF             0x0000000Eu
   #define  PLL_CLK3SEL_CK3SEL_PTG             0x0000000Fu

   /*=============   Register DEFAULT macro ==============*/ 
   #define  PLL_CLK3SEL_DEFAULT  (Uint32) (\
     _PER_FDEFAULT(PLL,CLK3SEL,CK3SEL) \
   )


   /*=============   Register MAKE _RMK macro ==============*/ 
   #define  PLL_CLK3SEL_RMK(ck3sel) \
 (Uint32) (\
      _PER_FMK(PLL,CLK3SEL,CK3SEL,ck3sel) \
   )

   /*=============   Register Access macros ==============*/ 
   #define _PLL_CLK3SEL_FGET(FIELD)\
     _PER_FGET(_PLL_CLK3SEL_ADDR,PLL,CLK3SEL,##FIELD)

   #define _PLL_CLK3SEL_FSET(FIELD,field)\
     _PER_FSET(_PLL_CLK3SEL_ADDR,PLL,CLK3SEL,##FIELD,field)

   #define _PLL_CLK3SEL_FSETS(FIELD,SYM)\
     _PER_FSETS(_PLL_CLK3SEL_ADDR,PLL,CLK3SEL,##FIELD,##SYM)


/*----------------------------------------------------------------------*/
#endif /* PLL_SUPPORT */
#endif /* _PLLHAL_H */ 
/*******************************************************************\
*      End of file            
\*******************************************************************/
csl_pwr.h/      1030611976  0     0     0       4039      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_pwr.h
* DATE CREATED.. 11/11/1999 
* LAST MODIFIED. 10/03/2000
\******************************************************************************/
#ifndef _CSL_PWR_H_
#define _CSL_PWR_H_

#include <csl_stdinc.h>
#include <csl_chip.h>
#include <csl_pwrhal.h>


#if (PWR_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _PWR_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/******************************************************************************\
* global macro declarations
\******************************************************************************/


/******************************************************************************\
* global typedef declarations
\******************************************************************************/
typedef enum {
  PWR_NONE = 0x00,
  PWR_PD1A = 0x09,
  PWR_PD1B = 0x11, 
  PWR_PD2  = 0x1A,
  PWR_PD3  = 0x1C,
  PWR_IDLE = 0xFF
} PWR_Mode;

#if (_PWR_COND1)
  typedef struct {
    Uint32 pdctl;
  } PWR_Config;
#endif


/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL void PWR_powerDown(PWR_Mode mode);
#if (_PWR_COND1)
  IDECL void PWR_config(PWR_Config *config);
  IDECL void PWR_configArgs(Uint32 pdctl);
  IDECL void PWR_getConfig(PWR_Config *config);
#endif


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void PWR_powerDown(PWR_Mode mode) {
  if (mode == PWR_IDLE) {
    asm(" IDLE");
  } else {
    CHIP_FSET(CSR,PWRD,(Uint32)mode);
  }
}
/*----------------------------------------------------------------------------*/
#if (_PWR_COND1)
  IDEF void PWR_config(PWR_Config *config) {
    PWR_RSET(PDCTL,config->pdctl);
  }
#endif
/*----------------------------------------------------------------------------*/
#if (_PWR_COND1)
  IDEF void PWR_configArgs(Uint32 pdctl) {
    PWR_RSET(PDCTL,pdctl);
  }
#endif
/*----------------------------------------------------------------------------*/
#if (_PWR_COND1)
  IDEF void PWR_getConfig(PWR_Config *config) {
    volatile PWR_Config* cfg = (volatile PWR_Config*)config;
    cfg->pdctl = PWR_RGET(PDCTL);
  }
#endif
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* PWR_SUPPORT */
#endif /* _CSL_PWR_H_ */
/******************************************************************************\
* End of csl_pwr.h
\******************************************************************************/


csl_pwrhal.h/   1057134894  0     0     0       5722      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_pwrhal.h
* DATE CREATED.. 11/11/1999
* LAST MODIFIED. 11/06/2000
*------------------------------------------------------------------------------
* REGISTERS
*
* PDCTL - power down control register
*
\******************************************************************************/
#ifndef _CSL_PWRHAL_H_
#define _CSL_PWRHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (PWR_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#define _PWR_COND1 (CHIP_6202|CHIP_6203|CHIP_6411)

/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define PWR_FMK(REG,FIELD,x)\
    _PER_FMK(PWR,##REG,##FIELD,x)

  #define PWR_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(PWR,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define PWR_ADDR(REG)\
    _PWR_##REG##_ADDR

  #define PWR_RGET(REG)\
    _PER_RGET(_PWR_##REG##_ADDR,PWR,##REG)

  #define PWR_RSET(REG,x)\
    _PER_RSET(_PWR_##REG##_ADDR,PWR,##REG,x)

  #define PWR_FGET(REG,FIELD)\
    _PWR_##REG##_FGET(##FIELD)

  #define PWR_FSET(REG,FIELD,x)\
    _PWR_##REG##_FSET(##FIELD,##x)

  #define PWR_FSETS(REG,FIELD,SYM)\
    _PWR_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define PWR_RGETA(addr,REG)\
    _PER_RGET(addr,PWR,##REG)

  #define PWR_RSETA(addr,REG,x)\
    _PER_RSET(addr,PWR,##REG,x)

  #define PWR_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,PWR,##REG,##FIELD)

  #define PWR_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,PWR,##REG,##FIELD,x)

  #define PWR_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,PWR,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  P D C T L        |
* |___________________|
*
* PDCTL - powerdown control register
*
* FIELDS (msb -> lsb)
* (rw) MCBSP2
* (rw) MCBSP1
* (rw) MCBSP0
* (rw) EMIF
* (rw) DMA
*
\******************************************************************************/
#if (_PWR_COND1)
  #define _PWR_PDCTL_ADDR              0x019C0200u

  #define _PWR_PDCTL_MCBSP2_MASK       0x00000010u
  #define _PWR_PDCTL_MCBSP2_SHIFT      0x00000004u
  #define  PWR_PDCTL_MCBSP2_DEFAULT    0x00000000u
  #define  PWR_PDCTL_MCBSP2_OF(x)      _VALUEOF(x)
  #define  PWR_PDCTL_MCBSP2_CLKON      0x00000000u
  #define  PWR_PDCTL_MCBSP2_CLKOFF     0x00000001u

  #define _PWR_PDCTL_MCBSP1_MASK       0x00000008u
  #define _PWR_PDCTL_MCBSP1_SHIFT      0x00000003u
  #define  PWR_PDCTL_MCBSP1_DEFAULT    0x00000000u
  #define  PWR_PDCTL_MCBSP1_OF(x)      _VALUEOF(x)
  #define  PWR_PDCTL_MCBSP1_CLKON      0x00000000u
  #define  PWR_PDCTL_MCBSP1_CLKOFF     0x00000001u

  #define _PWR_PDCTL_MCBSP0_MASK       0x00000004u
  #define _PWR_PDCTL_MCBSP0_SHIFT      0x00000002u
  #define  PWR_PDCTL_MCBSP0_DEFAULT    0x00000000u
  #define  PWR_PDCTL_MCBSP0_OF(x)      _VALUEOF(x)
  #define  PWR_PDCTL_MCBSP0_CLKON      0x00000000u
  #define  PWR_PDCTL_MCBSP0_CLKOFF     0x00000001u

  #define _PWR_PDCTL_EMIF_MASK         0x00000002u
  #define _PWR_PDCTL_EMIF_SHIFT        0x00000001u
  #define  PWR_PDCTL_EMIF_DEFAULT      0x00000000u
  #define  PWR_PDCTL_EMIF_OF(x)        _VALUEOF(x)
  #define  PWR_PDCTL_EMIF_CLKON        0x00000000u
  #define  PWR_PDCTL_EMIF_CLKOFF       0x00000001u

  #define _PWR_PDCTL_DMA_MASK          0x00000001u
  #define _PWR_PDCTL_DMA_SHIFT         0x00000000u
  #define  PWR_PDCTL_DMA_DEFAULT       0x00000000u
  #define  PWR_PDCTL_DMA_OF(x)         _VALUEOF(x)
  #define  PWR_PDCTL_DMA_CLKON         0x00000000u
  #define  PWR_PDCTL_DMA_CLKOFF        0x00000001u

  #define  PWR_PDCTL_OF(x)             _VALUEOF(x)

  #define PWR_PDCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(PWR,PDCTL,MCBSP2) \
    |_PER_FDEFAULT(PWR,PDCTL,MCBSP1) \
    |_PER_FDEFAULT(PWR,PDCTL,MCBSP0) \
    |_PER_FDEFAULT(PWR,PDCTL,EMIF) \
    |_PER_FDEFAULT(PWR,PDCTL,DMA) \
  )

  #define PWR_PDCTL_RMK(mcbsp2,mcbsp1,mcbsp0,emif,dma) (Uint32)( \
     _PER_FMK(PWR,PDCTL,MCBSP2,mcbsp2) \
    |_PER_FMK(PWR,PDCTL,MCBSP1,mcbsp1) \
    |_PER_FMK(PWR,PDCTL,MCBSP0,mcbsp0) \
    |_PER_FMK(PWR,PDCTL,EMIF,emif) \
    |_PER_FMK(PWR,PDCTL,DMA,dma) \
   )

  #define _PWR_PDCTL_FGET(FIELD)\
    _PER_FGET(_PWR_PDCTL_ADDR,PWR,PDCTL,##FIELD)

  #define _PWR_PDCTL_FSET(FIELD,field)\
    _PER_FSET(_PWR_PDCTL_ADDR,PWR,PDCTL,##FIELD,field)

  #define _PWR_PDCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_PWR_PDCTL_ADDR,PWR,PDCTL,##FIELD,##SYM)
#endif


/*----------------------------------------------------------------------------*/

#endif /* PWR_SUPPORT */
#endif /* _CSL_PWRHAL_H_ */
/******************************************************************************\
* End of csl_pwrhal.h
\******************************************************************************/

csl_stdinc.h/   1030611976  0     0     0       2455      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_stdinc.h
* DATE CREATED.. 03/11/1999 
* LAST MODIFIED. 10/03/2000
\******************************************************************************/
#ifndef _CSL_STDINC_H_
#define _CSL_STDINC_H_

#include <csl_stdinchal.h>


/******************************************************************************\
* macro declarations
\******************************************************************************/

/* a few standard constants */
#ifndef TRUE
  #define TRUE   1
#endif
#ifndef FALSE
  #define FALSE  0
#endif

/* Invalid Pointer                                               */
/* In many instances, it is better to use INV as opposed to NULL */
/* because 0 may actually be a valid pointer                     */
#ifndef INV
  #define INV    ((void*)(-1))
#endif

#ifndef UNREFERENCED_PARAMETER
  #define UNREFERENCED_PARAMETER(P)    ((P)=(P))
#endif

#ifndef REG32
  #define REG32(addr) (*(volatile unsigned int*)(addr))
  #define REG16(addr) (*(volatile unsigned short*)(addr))
  #define REG8(addr)  (*(volatile unsigned char*)(addr))
#endif

/******************************************************************************\
* typedef declarations
\******************************************************************************/
typedef unsigned char    Uint8;
typedef unsigned short   Uint16;
typedef unsigned int     Uint32;
typedef unsigned long    Uint40;
typedef char             Int8;
typedef short            Int16;
typedef int              Int32;
typedef long             Int40;

/******************************************************************************\
* variable declarations
\******************************************************************************/


/******************************************************************************\
* function declarations
\******************************************************************************/


#endif /* _CSL_STDINC_H_ */
/******************************************************************************\
* End of csl_stdinc.h
\******************************************************************************/


csl_stdinchal.h/1030611977  0     0     0       4067      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_stdinchal.h
* DATE CREATED.. 03/11/1999 
* LAST MODIFIED. 03/23/2001
\******************************************************************************/
#ifndef _CSL_STDINCHAL_H_
#define _CSL_STDINCHAL_H_


/******************************************************************************\
* HAL macro definitions
\******************************************************************************/

  #define _VALUEOF(x) ((Uint32)(x))

  /*******************************************************/
  /* generic macros for field manipulation               */
  /*******************************************************/

  #define _PER_FSHIFT(PER,REG,FIELD) \
    _##PER##_##REG##_##FIELD##_SHIFT

  #define _PER_FMASK(PER,REG,FIELD) \
    _##PER##_##REG##_##FIELD##_MASK

  #define _PER_FSYM(PER,REG,FIELD,SYM)\
    PER##_##REG##_##FIELD##_##SYM

  #define _PER_FDEFAULT(PER,REG,FIELD) \
    ((##PER##_##REG##_##FIELD##_DEFAULT << _##PER##_##REG##_##FIELD##_SHIFT) \
    & _##PER##_##REG##_##FIELD##_MASK)

  #define _PER_FMK(PER,REG,FIELD,x) (\
    (((Uint32)(x))<<_PER_FSHIFT(##PER,##REG,##FIELD))\
    &_PER_FMASK(##PER,##REG,##FIELD)\
  )

  #define _PER_FMKS(PER,REG,FIELD,SYM) (\
    (_PER_FSYM(##PER,##REG,##FIELD,##SYM)<<_PER_FSHIFT(##PER,##REG,##FIELD))\
    &_PER_FMASK(##PER,##REG,##FIELD)\
  )

  #define _PER_FEXTRACT(PER,REG,FIELD,reg) (Uint32)(\
    (((Uint32)(reg)&_PER_FMASK(##PER,##REG,##FIELD))\
    >>_PER_FSHIFT(##PER,##REG,##FIELD))\
  )

  #define _PER_FINSERT(PER,REG,FIELD,reg,field) (Uint32)(\
    (((Uint32)(reg)&~_PER_FMASK(##PER,##REG,##FIELD))|\
    (((Uint32)(field)<<_PER_FSHIFT(##PER,##REG,##FIELD))\
    &_PER_FMASK(##PER,##REG,##FIELD)))\
  )

  /*******************************************************/
  /* macros for memmory mapped registers                 */
  /*******************************************************/

  #define _PER_RAOI(addr,PER,REG,and,or,inv)\
    (*(volatile Uint32*)(addr))=(\
      ((((*(volatile Uint32*)(addr))\
      &((Uint32)(and)))\
      |((Uint32)(or)))\
      ^((Uint32)(inv)))\
    )

  #define _PER_RGET(addr,PER,REG) \
    (*(volatile Uint32*)(addr))

  #define _PER_RSET(addr,PER,REG,x) \
    (*(volatile Uint32*)(addr))=((Uint32)(x))

  #define _PER_FGET(addr,PER,REG,FIELD) \
    _PER_FEXTRACT(##PER,##REG,##FIELD,_PER_RGET(addr,##PER,##REG))

  #define _PER_FSET(addr,PER,REG,FIELD,field)\
    _PER_RSET(addr,##PER,##REG,\
    _PER_FINSERT(##PER,##REG,##FIELD,_PER_RGET(addr,##PER,##REG),field))

  #define _PER_FSETS(addr,PER,REG,FIELD,SYM)\
    _PER_RSET(addr,##PER,##REG,_PER_FINSERT(##PER,##REG,##FIELD,_PER_RGET(addr,##PER,##REG),\
    _PER_FSYM(##PER,##REG,##FIELD,##SYM)))

  /*******************************************************/
  /* macros for CPU control registers                    */
  /*******************************************************/

  #define _PER_CRGET(PER,REG) \
    REG

  #define _PER_CRSET(PER,REG,reg) \
    REG=((Uint32)(reg))

  #define _PER_CFGET(PER,REG,FIELD) \
    _PER_FEXTRACT(##PER,##REG,##FIELD,_PER_CRGET(##PER,##REG))

  #define _PER_CFSET(PER,REG,FIELD,field)\
    _PER_CRSET(##PER,##REG,\
    _PER_FINSERT(##PER,##REG,##FIELD,_PER_CRGET(##PER,##REG),field))

  #define _PER_CFSETS(PER,REG,FIELD,SYM)\
    _PER_CRSET(##PER,##REG,\
    _PER_FINSERT(##PER,##REG,FIELD,_PER_CRGET(##PER,##REG),\
    _PER_FSYM(##PER,##REG,##FIELD,##SYM)))

/*----------------------------------------------------------------------------*/

#endif /* _CSL_STDINCHAL_H_ */
/******************************************************************************\
* End of csl_stdinchal.h
\******************************************************************************/


csl_tcp.h/      1034315833  0     0     0       21855     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_tcp.h
* DATE CREATED.. 02/22/2001 
* LAST MODIFIED. 09/17/2001 
*
\******************************************************************************/
#ifndef _CSL_TCP_H_
#define _CSL_TCP_H_

#include <csl_chip.h>   
#include <csl_stdinc.h>
#include <csl_irq.h>
#include "csl_tcphal.h"

#if (TCP_SUPPORT)
/****************************************\
* TCP scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _TCP_MOD_
  #define IDECL extern far
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL extern far
  #endif
#endif

/****************************************\
* TCP global macro declarations
\****************************************/

/****************************************\
* TCP global typedef declarations
\****************************************/
typedef Uint8  TCP_Standard;
typedef Uint8  TCP_Mode;
typedef Uint8  TCP_Map;
typedef Uint8  TCP_Rate;
typedef Uint8  TCP_UserData;
typedef Uint8  TCP_ExtrinsicData;

typedef struct {
   Uint32 ic0;
   Uint32 ic1;
   Uint32 ic2;
   Uint32 ic3;
   Uint32 ic4;
   Uint32 ic5;
   Uint32 ic6;
   Uint32 ic7;
   Uint32 ic8;
   Uint32 ic9;
   Uint32 ic10;
   Uint32 ic11;
} TCP_ConfigIc;

typedef struct {
   TCP_Standard standard;
   TCP_Mode     mode;
   TCP_Map      map;
   TCP_Rate     rate;
   Uint32       intFlag;
   Uint32       outParmFlag;
   Uint32       frameLen;
   Uint32       subFrameLen;
   Uint32       relLen;
   Uint32       relLenLast;
   Uint32       prologSize;
   Uint32       numSubBlock;
   Uint32       numSubBlockLast;
   Uint32       maxIter;
   Uint32       snr;
   Uint32       numInter;
   Uint32       numSysPar;
   Uint32       numApriori;
   Uint32       numExt;
   Uint32       numHd;
} TCP_Params;

typedef struct {
   TCP_Standard standard;
   TCP_Rate     rate;
   Uint16       frameLen;
   Uint8        prologSize;
   Uint8        maxIter;
   Uint8        snr;
   Uint8        intFlag;
   Uint8        outParmFlag;
} TCP_BaseParams;

/************ New structure for Init ***************/
typedef struct {
   TCP_UserData *restrict xabData;
   TCP_Standard standard;
   TCP_Rate     rate;
   Uint16       frameLen;
   Uint8        prologSize;
   Uint8        maxIter;
   Uint8        snr;
   Uint8        intFlag;
   Uint8        outParmFlag;
} TCP_Init;

/****************************************\
* TCP global ants declarations
\****************************************/
#define TCP_RATE_1_2           2
#define TCP_RATE_1_3           3
#define TCP_RATE_1_4           4
#define TCP_MODE_SA            0
#define TCP_MODE_SP            1
#define TCP_MAP_MAP1A          0
#define TCP_MAP_MAP1B          1
#define TCP_MAP_MAP2           3 
#define TCP_STANDARD_3GPP      0
#define TCP_STANDARD_IS2000    1
#define TCP_RLEN_MAX         128
#define TCP_FLEN_MAX        5114
#define TCP_NUM_IC            12
#define TCP_NUM_OP             2

/****************************************\
* TCP global function declarations
\****************************************/

/* Set the ic6-ic9 registers (tails) based on the user data          */
/* TCP_tailConfig calls TCP_tailConfig3GPP() or TCP_tailConfigIs2000 */
/* based on the "standard" parameter value                           */
CSLAPI void TCP_tailConfig(TCP_Standard standard,
                          TCP_Mode mode,
                          TCP_Map map,
                          TCP_Rate rate,
                          TCP_UserData *restrict xabData,
                          TCP_ConfigIc *restrict configIc);
CSLAPI void TCP_tailConfig3GPP(TCP_Mode mode,
                          TCP_Map map,
                          TCP_UserData *restrict xabData,
                          TCP_ConfigIc *restrict configIc);
CSLAPI void TCP_tailConfigIs2000(TCP_Mode mode,
                          TCP_Map map,
                          TCP_Rate rate,
                          TCP_UserData *restrict xabData,
                          TCP_ConfigIc *restrict configIc);

/* Set the Parameters passed via Param structure to ic0-ic5 registers */
/* configIc is the returned config structure of the icx registers */
CSLAPI void TCP_setParams(TCP_Params *restrict configParms,
                          TCP_ConfigIc *restrict configIc);

/* Set all icx registers :                                     */ 
/* configPrams input parameters dedicated to ic0-ic5 registers */
/* xabData input parameters dedicated to set ic6-ic11 registers (tails */
/* configIc is the returned config structure of the icx registers */
CSLAPI void TCP_genIc(TCP_Params *restrict configParms,
                          TCP_UserData *restrict xabData,
                          TCP_ConfigIc *restrict configIc);

/* Divide the data frames into subframes and subblocks.                     */
/* The values calculated in these routines are entered into the configParms */
/* struct and are used in programming the TCP IC values and the EDMA        */
/* parameters. Either TCP_calcSubBlocks3GPP or TCP_calcSubBlocksIs2000 is   */
/* used depending on the standard.                                          */
CSLAPI void TCP_calcSubBlocksSA(TCP_Params *configParms);

CSLAPI Uint32 TCP_calcSubBlocksSP(TCP_Params *configParms);

/* Fill out the necessary TCP parameters.                                   */
CSLAPI Uint32 TCP_genParams(TCP_BaseParams *configBase,
                          TCP_Params *configParms);


/*** Init parameters and set registers **********/
void TCP_init(TCP_Init *Init);
void TCP_tailInit3GPP(TCP_Mode mode, TCP_Map map,TCP_UserData *restrict xabData);
void TCP_tailInitIs2000(TCP_Mode mode,TCP_Map map,TCP_Rate rate,TCP_UserData *restrict xabData);

/* Calculate the count values (number of 32-bit words) required for the     */
/* programming of the EDMA for all data buffers. The counts calculated      */
/* using either TCP_calcCounts3GPP or TCP_calcCountsIs2000 depending on the */
/* standard.                                                                */
CSLAPI void TCP_calcCountsSA(TCP_Params *configParms);

CSLAPI void TCP_calcCountsSP(TCP_Params *configParms);

/* Interleave the extrinsics data to give the apriori data required for the */
/* subsequent MAP decoding. TCP_interleaveExt is performed by the CPU       */
/* following a MAP1 decoding by the TCP. This function is used in shared    */
/* processing mode only.                                                    */
CSLAPI void TCP_interleaveExt(TCP_ExtrinsicData *restrict aprioriMap2, 
                          const TCP_ExtrinsicData *restrict extrinsicsMap1, 
                          const Uint16 *restrict interleaverTable, 
                          Uint32  numExt);

/* De-interleave the extrinsics data to give the apriori data required for  */
/* the subsequent MAP decoding. TCP_deinterleaveExt is performed by the CPU */
/* following a MAP2 decoding by the TCP. This function is used in shared    */
/* processing mode only.                                                    */
CSLAPI void TCP_deinterleaveExt(TCP_ExtrinsicData *restrict aprioriMap1, 
                          const TCP_ExtrinsicData *restrict extrinsicsMap2, 
                          const Uint16 *restrict interleaverTable, 
                          Uint32  numExt);

/* Calculate hard decisions following all MAP decodings in shared processing*/
/* mode.                                                                    */
CSLAPI void TCP_calculateHd(const TCP_ExtrinsicData *restrict extrinsicsMap1, 
                          const TCP_ExtrinsicData *restrict apriori, 
                          const TCP_UserData *restrict channel_data, 
                          Uint32 *restrict hardDecisions,
                          Uint16 numExt,
                          Uint8  rate);

/* Demultiplex the input data into two "working data" buffers. The two new  */
/* data buffers are used separately for MAP 1 and MAP 2 decodings in shared */
/* processing mode.                                                         */
CSLAPI void TCP_demuxInput(Uint32 rate,
                          Uint32 frameLen,
                          const TCP_UserData *restrict input,
                          const Uint16 *restrict interleaver,
                          TCP_ExtrinsicData *restrict nonInterleaved,
                          TCP_ExtrinsicData *restrict interleaved);
                          
/****************************************\
* TCP inline function declarations
\****************************************/

/* Master transfer functions */
IDECL void   TCP_start();
IDECL void   TCP_pause();
IDECL void   TCP_unpause();

IDECL Uint32 TCP_getNumIt();
IDECL Uint32 TCP_getSysParEndian();
IDECL Uint32 TCP_getIinterEndian();
IDECL Uint32 TCP_getAaprioriEndian();
IDECL Uint32 TCP_getExtEndian();

IDECL void   TCP_setNativeEndian();
IDECL void   TCP_setPacked32Endian();
IDECL void   TCP_setSysParEndian(Uint32 sysParEnd);
IDECL void   TCP_setInterEndian(Uint32 interEnd);
IDECL void   TCP_setAprioriEndian(Uint32 aprioriEnd);
IDECL void   TCP_setExtEndian(Uint32 extEnd);

IDECL Uint32 TCP_statPause();
IDECL Uint32 TCP_statRun();
IDECL Uint32 TCP_statError();
IDECL Uint32 TCP_statWaitIC();
IDECL Uint32 TCP_statWaitInter();
IDECL Uint32 TCP_statWaitSysPar();
IDECL Uint32 TCP_statWaitApriori();
IDECL Uint32 TCP_statWaitExt();
IDECL Uint32 TCP_statWaitHardDec();
IDECL Uint32 TCP_statWaitOutParm();

IDECL Uint32 TCP_errTest();
IDECL Uint32 TCP_getFrameLenErr();
IDECL Uint32 TCP_getProlLenErr();
IDECL Uint32 TCP_getRateErr();
IDECL Uint32 TCP_getSubFrameErr();
IDECL Uint32 TCP_getModeErr();
IDECL Uint32 TCP_getRelLenErr();
IDECL Uint32 TCP_getLastRelLenErr();
IDECL Uint32 TCP_getInterleaveErr();
IDECL Uint32 TCP_getOutParmErr();
IDECL Uint32 TCP_getAccessErr();


/* Set all the TCP registers : ic0-ic11 using a configuration structure  */
IDECL void TCP_icConfig(TCP_ConfigIc *config);

/* Set all the TCP registers : ic0-ic11 with register values   */
IDECL void TCP_icConfigArgs(Uint32 ic0, Uint32 ic1, Uint32 ic2,  Uint32 ic3,
                            Uint32 ic4, Uint32 ic5, Uint32 ic6,  Uint32 ic7,
                            Uint32 ic8, Uint32 ic9, Uint32 ic10, Uint32 ic11);
/* Get TCP registers : ic0-ic11 returned into a configuration structure  */
IDECL void TCP_getIcConfig(TCP_ConfigIc *config);

/* Build the tail value */
IDECL Uint32 TCP_makeTailArgs(Uint8 byte31_24, Uint8 byte23_16,
                              Uint8 byte15_8,  Uint8 byte7_0);

/* Ceiling functions */
IDECL Uint32 TCP_ceil(Uint32 a, Uint32 b);

IDECL Uint32 TCP_normalCeil(Uint32 a, Uint32 b);

/****************************************\
* TCP inline function definitions
\****************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void TCP_start(){
   TCP_FSET(EXE,START,1);  
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_pause(){
  TCP_FSET(EXE,PAUSE,1);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_unpause(){
  TCP_FSET(EXE,UNPAUSE,1);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_reset(){
  TCP_RSET(IC0,TCP_IC0_DEFAULT);
  TCP_RSET(IC1,TCP_IC1_DEFAULT);
  TCP_RSET(IC2,TCP_IC2_DEFAULT);
  TCP_RSET(IC3,TCP_IC3_DEFAULT);
  TCP_RSET(IC4,TCP_IC4_DEFAULT);
  TCP_RSET(IC5,TCP_IC5_DEFAULT);
  TCP_RSET(IC6,TCP_IC6_DEFAULT);
  TCP_RSET(IC7,TCP_IC7_DEFAULT);
  TCP_RSET(IC8,TCP_IC8_DEFAULT);
  TCP_RSET(IC9,TCP_IC9_DEFAULT);
  TCP_RSET(IC10,TCP_IC10_DEFAULT);
  TCP_RSET(IC11,TCP_IC11_DEFAULT);
  TCP_RSET(OUT,TCP_OUT_DEFAULT);
  TCP_RSET(EXE,TCP_EXE_DEFAULT);
  TCP_RSET(END,TCP_END_DEFAULT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getNumIt(){
  return TCP_FGET(OUT,NIT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getSysParEndian(){
  return TCP_FGET(END,SYSPAR);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_setSysParEndian(Uint32 sysParEnd){
 TCP_FSET(END,SYSPAR,sysParEnd);
}

/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getInterEndian(){
  return TCP_FGET(END,INTER);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_setInterEndian(Uint32 interEnd){
  TCP_FSET(END,INTER,interEnd);
}

/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getAprioriEndian(){
  return TCP_FGET(END,AP);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_setAprioriEndian(Uint32 aprioriEnd ){
   TCP_FSET(END,AP,aprioriEnd);
}

/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getExtEndian(){
  return TCP_FGET(END,EXT);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_setExtEndian(Uint32 extEnd){
  TCP_FSET(END,EXT,extEnd);
}
/*----------------------------------------------------------------------------*/
IDEF void   TCP_setNativeEndian(){
    TCP_RSET(END,0xF);
}
/*----------------------------------------------------------------------------*/
IDEF void   TCP_setPacked32Endian(){
    TCP_RSET(END,0x0);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statPause(){
  return TCP_FGET(STAT,PAUS);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statRun(){
  return TCP_FGET(STAT,RUN);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statError(){
  return TCP_FGET(STAT,ERR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statWaitIc(){
  return TCP_FGET(STAT,WIC);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statWaitInter(){
  return TCP_FGET(STAT,WINT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statWaitSysPar(){
  return TCP_FGET(STAT,WSP);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statWaitApriori(){
  return TCP_FGET(STAT,WAP);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statWaitExt(){
  return TCP_FGET(STAT,REXT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statWaitHardDec(){
  return TCP_FGET(STAT,RHD);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_statWaitOutParm(){
  return TCP_FGET(STAT,ROP);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_errTest(){
  return TCP_FGET(ERR,ERR);
}

/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getFrameLenErr(){
  return TCP_FGET(ERR,F);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getProlLenErr(){
  return TCP_FGET(ERR,P);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getRateErr(){
  return TCP_FGET(ERR,RATE);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getSubFrameErr(){
  return TCP_FGET(ERR,SF);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getModeErr(){
  return TCP_FGET(ERR,MODE);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getRelLenErr(){
  return TCP_FGET(ERR,R);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getLastRelLenErr(){
  return TCP_FGET(ERR,LR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getInterleaveErr(){
  return TCP_FGET(ERR,INT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getOutParmErr(){
  return TCP_FGET(ERR,OP);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_getAccessErr(){
  return TCP_FGET(ERR,ACC);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_icConfig(TCP_ConfigIc *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _TCP_BASE_IC;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11;

  gie = IRQ_globalDisable();

   x0 = config->ic0;
   x1 = config->ic1;
   x2 = config->ic2;
   x3 = config->ic3;
   x4 = config->ic4;
   x5 = config->ic5;
   x6 = config->ic6;
   x7 = config->ic7;
   x8 = config->ic8;
   x9 = config->ic9;
  x10 = config->ic10;
  x11 = config->ic11;
  
  base[_TCP_IC0_OFFSET]  = x0;
  base[_TCP_IC1_OFFSET]  = x1;
  base[_TCP_IC2_OFFSET]  = x2;
  base[_TCP_IC3_OFFSET]  = x3;
  base[_TCP_IC4_OFFSET]  = x4;
  base[_TCP_IC5_OFFSET]  = x5;
  base[_TCP_IC6_OFFSET]  = x6;
  base[_TCP_IC7_OFFSET]  = x7;
  base[_TCP_IC8_OFFSET]  = x8;
  base[_TCP_IC9_OFFSET]  = x9;
  base[_TCP_IC10_OFFSET] = x10;
  base[_TCP_IC11_OFFSET] = x11;
  
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_icConfigArgs(Uint32 ic0, Uint32 ic1, Uint32 ic2, Uint32 ic3, Uint32 ic4,
                           Uint32 ic5, Uint32 ic6, Uint32 ic7, Uint32 ic8, Uint32 ic9,
                           Uint32 ic10, Uint32 ic11) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _TCP_BASE_IC;

  gie = IRQ_globalDisable();
  
  base[_TCP_IC0_OFFSET]  = ic0;
  base[_TCP_IC1_OFFSET]  = ic1;
  base[_TCP_IC2_OFFSET]  = ic2;
  base[_TCP_IC3_OFFSET]  = ic3;
  base[_TCP_IC4_OFFSET]  = ic4;
  base[_TCP_IC5_OFFSET]  = ic5;
  base[_TCP_IC6_OFFSET]  = ic6;
  base[_TCP_IC7_OFFSET]  = ic7;
  base[_TCP_IC8_OFFSET]  = ic8;
  base[_TCP_IC9_OFFSET]  = ic9;
  base[_TCP_IC10_OFFSET] = ic10;
  base[_TCP_IC11_OFFSET] = ic11;
  
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void TCP_getIcConfig(TCP_ConfigIc *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _TCP_BASE_IC;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11;

  gie = IRQ_globalDisable();

   x0 = base[_TCP_IC0_OFFSET];
   x1 = base[_TCP_IC1_OFFSET];
   x2 = base[_TCP_IC2_OFFSET];
   x3 = base[_TCP_IC3_OFFSET];
   x4 = base[_TCP_IC4_OFFSET];
   x5 = base[_TCP_IC5_OFFSET];
   x6 = base[_TCP_IC6_OFFSET];
   x7 = base[_TCP_IC7_OFFSET];
   x8 = base[_TCP_IC8_OFFSET];
   x9 = base[_TCP_IC9_OFFSET];
  x10 = base[_TCP_IC10_OFFSET];
  x11 = base[_TCP_IC11_OFFSET];
  
  config->ic0  =  x0;
  config->ic1  =  x1;
  config->ic2  =  x2;
  config->ic3  =  x3;
  config->ic4  =  x4;
  config->ic5  =  x5;
  config->ic6  =  x6;
  config->ic7  =  x7;
  config->ic8  =  x8;
  config->ic9  =  x9;
  config->ic10 = x10;
  config->ic11 = x11;
  
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TCP_makeTailArgs(Uint8 byte31_24, Uint8 byte23_16,
                             Uint8 byte15_8,  Uint8 byte7_0) {

  Uint32 gie;
  Uint32 x;

  gie = IRQ_globalDisable();

  x = (byte31_24 << 24) | (byte23_16 << 16) | (byte15_8 << 8) | byte7_0;
  
  IRQ_globalRestore(gie);

  return(x);
}

/*----------------------------------------------------------------------------*/

IDEF Uint32 TCP_ceil(Uint32 val, Uint32 pwr2) {
  Uint32 gie;
  Uint32 x;
  
  gie = IRQ_globalDisable();

  /* x^pwr2 = ceil(val, 2^pwr2) */
  /* val is increased (if necessary) to be a multiple of 2^pwr2 */
  x = (((val) - (((val)>>(pwr2)) << (pwr2))) == 0) ?                           \
      ((val)>>(pwr2)):(((val)>>(pwr2))+1);
  
  IRQ_globalRestore(gie);

  return(x);
}

/*----------------------------------------------------------------------------*/

IDEF Uint32 TCP_normalCeil(Uint32 val1, Uint32 val2) {
  Uint32 gie;
  Uint32 x;
  
  gie = IRQ_globalDisable();

  /* x = ceil(val1, val2) */
  /* val is increased (if necessary) to be a multiple of val2 */
  x = ( ((val1)%(val2))!=0  )?( ((val1)/(val2)) + 1 ):((val1)/(val2));
  
  IRQ_globalRestore(gie);

  return(x);
}

/*----------------------------------------------------------------------------*/

#endif /* USEDEFS */

#endif /* (TCP_SUPPORT) */
#endif /* _CSL_TCP_H_ */
/******************************************************************************\
* End of csl_tcp.h
\******************************************************************************/


csl_tcphal.h/   1092218724  0     0     0       35974     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_tcphal.h
* DATE CREATED.. 02/21/2001 
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                04/20/2001
*------------------------------------------------------------------------------
* REGISTERS
*
* IC0   - TCP input configuration register  0
* IC1   - TCP input configuration register  1
* IC2   - TCP input configuration register  2
* IC3   - TCP input configuration register  3
* IC4   - TCP input configuration register  4
* IC5   - TCP input configuration register  5
* IC6   - TCP input configuration register  6
* IC7   - TCP input configuration register  7
* IC8   - TCP input configuration register  8
* IC9   - TCP input configuration register  9
* IC10  - TCP input configuration register 10
* IC11  - TCP input configuration register 11
* OUT   - TCP output parameters register
* EXE   - TCP execution register 
* END   - TCP endian mode register
* ERR   - TCP error register
* STAT  - TCP status register
*
*------------------------------------------------------------------------------
* MEMORY REGIONS
*
* ICMEM - TCP interrupt configuration register space
* OPMEM - TCP output parameter register space
* SPMEM - TCP systematics and parities memory
* EXMEM - TCP extrinsics memory
* APMEM - TCP apriori memory
* ILMEM - TCP interleaver memory
* HDMEM - TCP hard decisions memory
*
\******************************************************************************/
#ifndef _CSL_TCPHAL_H_
#define _CSL_TCPHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (TCP_SUPPORT)

/******************************************************************************\
* Memory section
\******************************************************************************/

  #define _TCP_BASE_IC               0x01BA0000u
  #define  TCP_ICMEM_ADDR            0x58000000u
  #define  TCP_OPMEM_ADDR            0x58000030u
  #define  TCP_SPMEM_ADDR            0x58020000u
  #define  TCP_EXMEM_ADDR            0x58040000u
  #define  TCP_APMEM_ADDR            0x58060000u
  #define  TCP_ILMEM_ADDR            0x58080000u
  #define  TCP_HDMEM_ADDR            0x580A0000u


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define TCP_FMK(REG,FIELD,x)\
    _PER_FMK(TCP,##REG,##FIELD,x)

  #define TCP_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(TCP,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define TCP_ADDR(REG)\
    _TCP_##REG##_ADDR

  #define TCP_RGET(REG)\
    _PER_RGET(_TCP_##REG##_ADDR,TCP,##REG)

  #define TCP_RSET(REG,x)\
    _PER_RSET(_TCP_##REG##_ADDR,TCP,##REG,x)

  #define TCP_FGET(REG,FIELD)\
    _TCP_##REG##_FGET(##FIELD)

  #define TCP_FSET(REG,FIELD,x)\
    _TCP_##REG##_FSET(##FIELD,##x)

  #define TCP_FSETS(REG,FIELD,SYM)\
    _TCP_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define TCP_RGETA(addr,REG)\
    _PER_RGET(addr,TCP,##REG)

  #define TCP_RSETA(addr,REG,x)\
    _PER_RSET(addr,TCP,##REG,x)

  #define TCP_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,TCP,##REG,##FIELD)

  #define TCP_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,TCP,##REG,##FIELD,x)

  #define TCP_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,TCP,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  I C 0            |
* |___________________|
*
* TCP input configuration register  0
*
* FIELDS (msb -> lsb)
* (rw) FL
* (rw) OUTF
* (rw) INTER
* (rw) RATE
* (rw) OPMOD
* 
*
\******************************************************************************/
  #define _TCP_IC0_OFFSET            0

    #define _TCP_IC0_ADDR              0x01BA0000u
 // #define _TCP_IC0_ADDR              0x58000000u

  #define _TCP_IC0_FL_MASK           0xFFFF0000u
  #define _TCP_IC0_FL_SHIFT          0x00000010u
  #define  TCP_IC0_FL_DEFAULT        0x00000000u
  #define  TCP_IC0_FL_OF(x)          _VALUEOF(x)

  #define _TCP_IC0_OUTF_MASK         0x00002000u // error doc
  #define _TCP_IC0_OUTF_SHIFT        0x0000000Du
  #define  TCP_IC0_OUTF_DEFAULT      0x00000000u
  #define  TCP_IC0_OUTF_OF(x)        _VALUEOF(x)
  #define  TCP_IC0_OUTF_NO           0x00000000u
  #define  TCP_IC0_OUTF_YES          0x00000001u

  #define _TCP_IC0_INTER_MASK          0x00001000u
  #define _TCP_IC0_INTER_SHIFT         0x0000000Cu
  #define  TCP_IC0_INTER_DEFAULT       0x00000000u
  #define  TCP_IC0_INTER_OF(x)         _VALUEOF(x)
  #define  TCP_IC0_INTER_NO            0x00000000u
  #define  TCP_IC0_INTER_YES           0x00000001u

  #define _TCP_IC0_RATE_MASK         0x00000300u
  #define _TCP_IC0_RATE_SHIFT        0x00000008u
  #define  TCP_IC0_RATE_DEFAULT      0x00000000u
  #define  TCP_IC0_RATE_OF(x)        _VALUEOF(x)
  #define  TCP_IC0_RATE_1_2          0x00000001u
  #define  TCP_IC0_RATE_1_3          0x00000002u
  #define  TCP_IC0_RATE_1_4          0x00000003u

  #define _TCP_IC0_OPMOD_MASK        0x0000000Eu
  #define _TCP_IC0_OPMOD_SHIFT       0x00000001u
  #define  TCP_IC0_OPMOD_DEFAULT     0x00000000u
  #define  TCP_IC0_OPMOD_OF(x)       _VALUEOF(x)
  #define  TCP_IC0_OPMOD_SA          0x00000000u
  #define  TCP_IC0_OPMOD_MAP1A       0x00000004u
  #define  TCP_IC0_OPMOD_MAP1B       0x00000005u
  #define  TCP_IC0_OPMOD_MAP2        0x00000007u

 
  #define  TCP_IC0_OF(x)             _VALUEOF(x)

  #define TCP_IC0_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,IC0,FL)\
   |_PER_FDEFAULT(TCP,IC0,OUTF)\
   |_PER_FDEFAULT(TCP,IC0,INTER)\
   |_PER_FDEFAULT(TCP,IC0,RATE)\
   |_PER_FDEFAULT(TCP,IC0,OPMOD)\
  )

  #define TCP_IC0_RMK(fl,outf,inter,rate,opmod) (Uint32)(\
     _PER_FMK(TCP,IC0,FL,fl)\
    |_PER_FMK(TCP,IC0,OUTF,outf)\
    |_PER_FMK(TCP,IC0,INTER,inter)\
    |_PER_FMK(TCP,IC0,RATE,rate)\
    |_PER_FMK(TCP,IC0,OPMOD,opmod)\
  )

  #define _TCP_IC0_FGET(FIELD)\
    _PER_FGET(_TCP_IC0_ADDR,TCP,IC0,##FIELD)

  #define _TCP_IC0_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC0_ADDR,TCP,IC0,##FIELD,field)

  #define _TCP_IC0_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC0_ADDR,TCP,IC0,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 1            |
* |___________________|
*
* TCP input configuration register  1
*
* FIELDS (msb -> lsb)
* (rw) LASTR
* (rw) R
* (rw) SFL
*
\******************************************************************************/
  #define _TCP_IC1_OFFSET            1

    #define _TCP_IC1_ADDR              0x01BA0004u   
//  #define _TCP_IC1_ADDR              0x580000004u
 
 #define _TCP_IC1_LASTR_MASK        0x7F000000u
  #define _TCP_IC1_LASTR_SHIFT       0x00000018u
  #define  TCP_IC1_LASTR_DEFAULT     0x00000000u
  #define  TCP_IC1_LASTR_OF(x)       _VALUEOF(x)

  #define _TCP_IC1_R_MASK           0x007F0000u
  #define _TCP_IC1_R_SHIFT          0x00000010u
  #define  TCP_IC1_R_DEFAULT        0x00000000u
  #define  TCP_IC1_R_OF(x)          _VALUEOF(x)

  #define _TCP_IC1_SFL_MASK          0x0000FFFFu
  #define _TCP_IC1_SFL_SHIFT         0x00000000u
  #define  TCP_IC1_SFL_DEFAULT       0x00000000u
  #define  TCP_IC1_SFL_OF(x)         _VALUEOF(x)

  #define  TCP_IC1_OF(x)             _VALUEOF(x)

  #define TCP_IC1_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,IC1,LASTR)\
   |_PER_FDEFAULT(TCP,IC1,R)\
   |_PER_FDEFAULT(TCP,IC1,SFL)\
  )

  #define TCP_IC1_RMK(lastr,r,sfl) (Uint32)(\
     _PER_FMK(TCP,IC1,LASTR,lastr)\
    |_PER_FMK(TCP,IC1,R,r)\
    |_PER_FMK(TCP,IC1,SFL,sfl)\
  )

  #define _TCP_IC1_FGET(FIELD)\
    _PER_FGET(_TCP_IC1_ADDR,TCP,IC1,##FIELD)

  #define _TCP_IC1_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC1_ADDR,TCP,IC1,##FIELD,field)

  #define _TCP_IC1_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC1_ADDR,TCP,IC1,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 2            |
* |___________________|
*
* TCP input configuration register  2
*
* FIELDS (msb -> lsb)
* (rw) SNR
* (rw) MAXIT
* (rw) LASTNSB
* (rw) NSB
* (rw) PS
*
\******************************************************************************/
  #define _TCP_IC2_OFFSET            2

  #define _TCP_IC2_ADDR              0x01BA0008u
  // #define _TCP_IC2_ADDR              0x58000008u

  #define _TCP_IC2_SNR_MASK          0xFF000000u
  #define _TCP_IC2_SNR_SHIFT         0x00000018u
  #define  TCP_IC2_SNR_DEFAULT       0x00000000u
  #define  TCP_IC2_SNR_OF(x)         _VALUEOF(x)
  #define  TCP_IC2_SNR_NONE          0x00000000u

  #define _TCP_IC2_MAXIT_MASK        0x001F0000u
  #define _TCP_IC2_MAXIT_SHIFT       0x00000010u
  #define  TCP_IC2_MAXIT_DEFAULT     0x00000000u
  #define  TCP_IC2_MAXIT_OF(x)       _VALUEOF(x)

  #define _TCP_IC2_LASTNSB_MASK      0x0000F000u
  #define _TCP_IC2_LASTNSB_SHIFT     0x0000000Cu
  #define  TCP_IC2_LASTNSB_DEFAULT   0x00000000u
  #define  TCP_IC2_LASTNSB_OF(x)     _VALUEOF(x)

  #define _TCP_IC2_NSB_MASK          0x00000F00u
  #define _TCP_IC2_NSB_SHIFT         0x00000008u
  #define  TCP_IC2_NSB_DEFAULT       0x00000000u
  #define  TCP_IC2_NSB_OF(x)         _VALUEOF(x)

  #define _TCP_IC2_P_MASK           0x0000003Fu
  #define _TCP_IC2_P_SHIFT          0x00000000u
  #define  TCP_IC2_P_DEFAULT        0x00000000u
  #define  TCP_IC2_P_OF(x)          _VALUEOF(x)

  #define  TCP_IC2_OF(x)             _VALUEOF(x)

  #define TCP_IC2_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,IC2,SNR)\
   |_PER_FDEFAULT(TCP,IC2,MAXIT)\
   |_PER_FDEFAULT(TCP,IC2,LASTNSB)\
   |_PER_FDEFAULT(TCP,IC2,NSB)\
   |_PER_FDEFAULT(TCP,IC2,P)\
  )

  #define TCP_IC2_RMK(snr,maxit,lastnsb,nsb,p) (Uint32)(\
     _PER_FMK(TCP,IC2,SNR,snr)\
    |_PER_FMK(TCP,IC2,MAXIT,maxit)\
    |_PER_FMK(TCP,IC2,LASTNSB,lastnsb)\
    |_PER_FMK(TCP,IC2,NSB,nsb)\
    |_PER_FMK(TCP,IC2,P,p)\
  )

  #define _TCP_IC2_FGET(FIELD)\
    _PER_FGET(_TCP_IC2_ADDR,TCP,IC2,##FIELD)

  #define _TCP_IC2_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC2_ADDR,TCP,IC2,##FIELD,field)

  #define _TCP_IC2_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC2_ADDR,TCP,IC2,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 3            |
* |___________________|
*
* TCP input configuration register  3
*
* FIELDS (msb -> lsb)
* (rw) NWDSYPAR
* (rw) NWDINTER
*
\******************************************************************************/
  #define _TCP_IC3_OFFSET            3

  #define _TCP_IC3_ADDR              0x01BA000Cu
 
 // #define _TCP_IC3_ADDR                0x5800000Cu

  #define _TCP_IC3_NWDSYPAR_MASK      0xFFFF0000u
  #define _TCP_IC3_NWDSYPAR_SHIFT     0x00000010u
  #define  TCP_IC3_NWDSYPAR_DEFAULT   0x00000000u
  #define  TCP_IC3_NWDSYPAR_OF(x)     _VALUEOF(x)

  #define _TCP_IC3_NWDINTER_MASK       0x0000FFFFu
  #define _TCP_IC3_NWDINTER_SHIFT      0x00000000u
  #define  TCP_IC3_NWDINTER_DEFAULT    0x00000000u
  #define  TCP_IC3_NWDINTER_OF(x)      _VALUEOF(x)

  #define  TCP_IC3_OF(x)             _VALUEOF(x)

  #define TCP_IC3_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,IC3,NWDSYPAR)\
   |_PER_FDEFAULT(TCP,IC3,NWDINTER)\
  )

  #define TCP_IC3_RMK(nwdsypar,nwdinter) (Uint32)(\
     _PER_FMK(TCP,IC3,NWDSYPAR,nwdsypar)\
    |_PER_FMK(TCP,IC3,NWDINTER,nwdinter)\
  )

  #define _TCP_IC3_FGET(FIELD)\
    _PER_FGET(_TCP_IC3_ADDR,TCP,IC3,##FIELD)

  #define _TCP_IC3_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC3_ADDR,TCP,IC3,##FIELD,field)

  #define _TCP_IC3_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC3_ADDR,TCP,IC3,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 4            |
* |___________________|
*
* TCP input configuration register  4
*
* FIELDS (msb -> lsb)
* (rw) NWDEXT
* (rw) NWDAP
*
\******************************************************************************/
  #define _TCP_IC4_OFFSET            4

  #define _TCP_IC4_ADDR              0x01BA0010u
 //#define _TCP_IC4_ADDR              0x58000010u

  #define _TCP_IC4_NWDEXT_MASK         0xFFFF0000u
  #define _TCP_IC4_NWDEXT_SHIFT        0x00000010u
  #define  TCP_IC4_NWDEXT_DEFAULT      0x00000000u
  #define  TCP_IC4_NWDEXT_OF(x)        _VALUEOF(x)

  #define _TCP_IC4_NWDAP_MASK          0x0000FFFFu
  #define _TCP_IC4_NWDAP_SHIFT         0x00000000u
  #define  TCP_IC4_NWDAP_DEFAULT       0x00000000u
  #define  TCP_IC4_NWDAP_OF(x)         _VALUEOF(x)

  #define  TCP_IC4_OF(x)             _VALUEOF(x)

  #define TCP_IC4_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,IC4,NWDEXT)\
   |_PER_FDEFAULT(TCP,IC4,NWDAP)\
  )

  #define TCP_IC4_RMK(nwdext,nwdap) (Uint32)(\
     _PER_FMK(TCP,IC4,NWDEXT,nwdext)\
    |_PER_FMK(TCP,IC4,NWDAP,nwdap)\
  )

  #define _TCP_IC4_FGET(FIELD)\
    _PER_FGET(_TCP_IC4_ADDR,TCP,IC4,##FIELD)

  #define _TCP_IC4_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC4_ADDR,TCP,IC4,##FIELD,field)

  #define _TCP_IC4_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC4_ADDR,TCP,IC4,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 5            |
* |___________________|
*
* TCP input configuration register  5
*
* FIELDS (msb -> lsb)
* (rw) NWDHD
*
\******************************************************************************/
  #define _TCP_IC5_OFFSET            5

  #define _TCP_IC5_ADDR              0x01BA0014u
  //#define _TCP_IC5_ADDR              0x58000014u

  #define _TCP_IC5_NWDHD_MASK          0x0000FFFFu
  #define _TCP_IC5_NWDHD_SHIFT         0x00000000u
  #define  TCP_IC5_NWDHD_DEFAULT       0x00000000u
  #define  TCP_IC5_NWDHD_OF(x)         _VALUEOF(x)

  #define  TCP_IC5_OF(x)             _VALUEOF(x)

  #define TCP_IC5_DEFAULT (Uint32)(\
     _PER_FDEFAULT(TCP,IC5,NWDHD)\
  )

  #define TCP_IC5_RMK(nwdhd) (Uint32)(\
     _PER_FMK(TCP,IC5,NWDHD,nwdhd)\
  )

  #define _TCP_IC5_FGET(FIELD)\
    _PER_FGET(_TCP_IC5_ADDR,TCP,IC5,##FIELD)

  #define _TCP_IC5_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC5_ADDR,TCP,IC5,##FIELD,field)

  #define _TCP_IC5_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC5_ADDR,TCP,IC5,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 6            |
* |___________________|
*
* TCP input configuration register  6
*
* FIELDS (msb -> lsb)
* (rw) TAIL1
*
\******************************************************************************/
  #define _TCP_IC6_OFFSET            6

    #define _TCP_IC6_ADDR              0x01BA0018u
 // #define _TCP_IC6_ADDR              0x58000018u
  
  #define _TCP_IC6_TAIL1_MASK        0xFFFFFFFFu
  #define _TCP_IC6_TAIL1_SHIFT       0x00000000u
  #define  TCP_IC6_TAIL1_DEFAULT     0x00000000u
  #define  TCP_IC6_TAIL1_OF(x)       _VALUEOF(x)

  #define  TCP_IC6_OF(x)             _VALUEOF(x)

  #define TCP_IC6_DEFAULT (Uint32)(\
     _PER_FDEFAULT(TCP,IC6,TAIL1)\
  )

  #define TCP_IC6_RMK(tail1) (Uint32)(\
     _PER_FMK(TCP,IC6,TAIL1,tail1)\
  )

  #define _TCP_IC6_FGET(FIELD)\
    _PER_FGET(_TCP_IC6_ADDR,TCP,IC6,##FIELD)

  #define _TCP_IC6_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC6_ADDR,TCP,IC6,##FIELD,field)

  #define _TCP_IC6_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC6_ADDR,TCP,IC6,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 7            |
* |___________________|
*
* TCP input configuration register  7
*
* FIELDS (msb -> lsb)
* (rw) TAIL2
*
\******************************************************************************/
  #define _TCP_IC7_OFFSET            7

   #define _TCP_IC7_ADDR              0x01BA001Cu
  // #define _TCP_IC7_ADDR              0x5800001Cu

  #define _TCP_IC7_TAIL2_MASK        0xFFFFFFFFu
  #define _TCP_IC7_TAIL2_SHIFT       0x00000000u
  #define  TCP_IC7_TAIL2_DEFAULT     0x00000000u
  #define  TCP_IC7_TAIL2_OF(x)       _VALUEOF(x)

  #define  TCP_IC7_OF(x)             _VALUEOF(x)

  #define TCP_IC7_DEFAULT (Uint32)(\
     _PER_FDEFAULT(TCP,IC7,TAIL2)\
  )

  #define TCP_IC7_RMK(tail2) (Uint32)(\
     _PER_FMK(TCP,IC7,TAIL2,tail2)\
  )

  #define _TCP_IC7_FGET(FIELD)\
    _PER_FGET(_TCP_IC7_ADDR,TCP,IC7,##FIELD)

  #define _TCP_IC7_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC7_ADDR,TCP,IC7,##FIELD,field)

  #define _TCP_IC7_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC7_ADDR,TCP,IC7,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 8            |
* |___________________|
*
* TCP input configuration register  8
*
* FIELDS (msb -> lsb)
* (rw) TAIL3
*
\******************************************************************************/
  #define _TCP_IC8_OFFSET            8

     #define _TCP_IC8_ADDR              0x01BA0020u
  // #define _TCP_IC8_ADDR              0x58000020u

  #define _TCP_IC8_TAIL3_MASK        0xFFFFFFFFu
  #define _TCP_IC8_TAIL3_SHIFT       0x00000000u
  #define  TCP_IC8_TAIL3_DEFAULT     0x00000000u
  #define  TCP_IC8_TAIL3_OF(x)       _VALUEOF(x)

  #define  TCP_IC8_OF(x)             _VALUEOF(x)

  #define TCP_IC8_DEFAULT (Uint32)(\
     _PER_FDEFAULT(TCP,IC8,TAIL3)\
  )

  #define TCP_IC8_RMK(tail3) (Uint32)(\
     _PER_FMK(TCP,IC8,TAIL3,tail3)\
  )

  #define _TCP_IC8_FGET(FIELD)\
    _PER_FGET(_TCP_IC8_ADDR,TCP,IC8,##FIELD)

  #define _TCP_IC8_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC8_ADDR,TCP,IC8,##FIELD,field)

  #define _TCP_IC8_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC8_ADDR,TCP,IC8,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 9            |
* |___________________|
*
* TCP input configuration register  9
*
* FIELDS (msb -> lsb)
* (rw) TAIL4
*
\******************************************************************************/
  #define _TCP_IC9_OFFSET            9

    #define _TCP_IC9_ADDR              0x01BA0024u
  //#define _TCP_IC9_ADDR              0x58000024u

  #define _TCP_IC9_TAIL4_MASK        0xFFFFFFFFu
  #define _TCP_IC9_TAIL4_SHIFT       0x00000000u
  #define  TCP_IC9_TAIL4_DEFAULT     0x00000000u
  #define  TCP_IC9_TAIL4_OF(x)       _VALUEOF(x)

  #define  TCP_IC9_OF(x)             _VALUEOF(x)

  #define TCP_IC9_DEFAULT (Uint32)(\
     _PER_FDEFAULT(TCP,IC9,TAIL4)\
  )

  #define TCP_IC9_RMK(tail4) (Uint32)(\
     _PER_FMK(TCP,IC9,TAIL4,tail4)\
  )

  #define _TCP_IC9_FGET(FIELD)\
    _PER_FGET(_TCP_IC9_ADDR,TCP,IC9,##FIELD)

  #define _TCP_IC9_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC9_ADDR,TCP,IC9,##FIELD,field)

  #define _TCP_IC9_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC9_ADDR,TCP,IC9,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 1 0          |
* |___________________|
*
* TCP input configuration register 10
*
* FIELDS (msb -> lsb)
* (rw) TAIL5
*
\******************************************************************************/
  #define _TCP_IC10_OFFSET           10

  #define _TCP_IC10_ADDR             0x01BA0028u
 // #define _TCP_IC10_ADDR              0x58000028u

  #define _TCP_IC10_TAIL5_MASK       0xFFFFFFFFu
  #define _TCP_IC10_TAIL5_SHIFT      0x00000000u
  #define  TCP_IC10_TAIL5_DEFAULT    0x00000000u
  #define  TCP_IC10_TAIL5_OF(x)      _VALUEOF(x)

  #define  TCP_IC10_OF(x)            _VALUEOF(x)

  #define TCP_IC10_DEFAULT (Uint32)(\
     _PER_FDEFAULT(TCP,IC10,TAIL5)\
  )

  #define TCP_IC10_RMK(tail5) (Uint32)(\
     _PER_FMK(TCP,IC10,TAIL5,tail5)\
  )

  #define _TCP_IC10_FGET(FIELD)\
    _PER_FGET(_TCP_IC10_ADDR,TCP,IC10,##FIELD)

  #define _TCP_IC10_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC10_ADDR,TCP,IC10,##FIELD,field)

  #define _TCP_IC10_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC10_ADDR,TCP,IC10,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 1 1          |
* |___________________|
*
* TCP input configuration register 11
*
* FIELDS (msb -> lsb)
* (rw) TAIL6
*
\******************************************************************************/
  #define _TCP_IC11_OFFSET           11

  #define _TCP_IC11_ADDR             0x01BA002Cu
 // #define _TCP_IC11_ADDR              0x5800002Cu

  #define _TCP_IC11_TAIL6_MASK       0xFFFFFFFFu
  #define _TCP_IC11_TAIL6_SHIFT      0x00000000u
  #define  TCP_IC11_TAIL6_DEFAULT    0x00000000u
  #define  TCP_IC11_TAIL6_OF(x)      _VALUEOF(x)

  #define  TCP_IC11_OF(x)            _VALUEOF(x)

  #define TCP_IC11_DEFAULT (Uint32)(\
     _PER_FDEFAULT(TCP,IC11,TAIL6)\
  )

  #define TCP_IC11_RMK(tail6) (Uint32)(\
     _PER_FMK(TCP,IC11,TAIL6,tail6)\
  )

  #define _TCP_IC11_FGET(FIELD)\
    _PER_FGET(_TCP_IC11_ADDR,TCP,IC11,##FIELD)

  #define _TCP_IC11_FSET(FIELD,field)\
    _PER_FSET(_TCP_IC11_ADDR,TCP,IC11,##FIELD,field)

  #define _TCP_IC11_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_IC11_ADDR,TCP,IC11,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  O U T            |
* |___________________|
*
* TCP output parameters register
*
* FIELDS (msb -> lsb)
* (rw) NIT
*
\******************************************************************************/
  #define _TCP_OUT_OFFSET            12

  #define _TCP_OUT_ADDR              0x01BA0030u

  #define _TCP_OUT_NIT_MASK          0xFFFF0000u
  #define _TCP_OUT_NIT_SHIFT         0x00000010u
  #define  TCP_OUT_NIT_DEFAULT       0x00000000u
  #define  TCP_OUT_NIT_OF(x)         _VALUEOF(x)

  #define  TCP_OUT_OF(x)             _VALUEOF(x)

  #define TCP_OUT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(TCP,OUT,NIT)\
  )

  #define TCP_OUT_RMK(nit) (Uint32)(\
     _PER_FMK(TCP,OUT,NIT,nit)\
  )

  #define _TCP_OUT_FGET(FIELD)\
    _PER_FGET(_TCP_OUT_ADDR,TCP,OUT,##FIELD)

  #define _TCP_OUT_FSET(FIELD,field)\
    _PER_FSET(_TCP_OUT_ADDR,TCP,OUT,##FIELD,field)

  #define _TCP_OUT_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_OUT_ADDR,TCP,OUT,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  E X E            |
* |___________________|
*
* TCP execution register
*
* FIELDS (msb -> lsb)
* (rw) UNPAUSE
* (rw) PAUSE
* (rw) START
*
\******************************************************************************/
  #define _TCP_EXE_OFFSET            14

  #define _TCP_EXE_ADDR              0x01BA0038u

  #define _TCP_EXE_UNPAUSE_MASK      0x00000004u //0x7F000000u
  #define _TCP_EXE_UNPAUSE_SHIFT     0x00000002u //0x00000018u
  #define  TCP_EXE_UNPAUSE_DEFAULT   0x00000000u
  #define  TCP_EXE_UNPAUSE_OF(x)     _VALUEOF(x)
  #define  TCP_EXE_UNPAUSE_UNPAUSE   0x00000001u

  #define _TCP_EXE_PAUSE_MASK        0x00000002u //0x007F0000u
  #define _TCP_EXE_PAUSE_SHIFT       0x00000001u
  #define  TCP_EXE_PAUSE_DEFAULT     0x00000000u
  #define  TCP_EXE_PAUSE_OF(x)       _VALUEOF(x)
  #define  TCP_EXE_PAUSE_PAUSE       0x00000001u

  #define _TCP_EXE_START_MASK        0x00000001u //0x0000FFFFu
  #define _TCP_EXE_START_SHIFT       0x00000000u
  #define  TCP_EXE_START_DEFAULT     0x00000000u
  #define  TCP_EXE_START_OF(x)       _VALUEOF(x)
  #define  TCP_EXE_START_START       0x00000001u

  #define  TCP_EXE_OF(x)             _VALUEOF(x)

  #define TCP_EXE_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,EXE,UNPAUSE)\
   |_PER_FDEFAULT(TCP,EXE,PAUSE)\
   |_PER_FDEFAULT(TCP,EXE,START)\
  )

  #define TCP_EXE_RMK(unpause,pause,start) (Uint32)(\
     _PER_FMK(TCP,EXE,UNPAUSE,unpause)\
    |_PER_FMK(TCP,EXE,PAUSE,pause)\
    |_PER_FMK(TCP,EXE,START,start)\
  )

  #define _TCP_EXE_FGET(FIELD)\
    _PER_FGET(_TCP_EXE_ADDR,TCP,EXE,##FIELD)

  #define _TCP_EXE_FSET(FIELD,field)\
    _PER_FSET(_TCP_EXE_ADDR,TCP,EXE,##FIELD,field)

  #define _TCP_EXE_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_EXE_ADDR,TCP,EXE,##FIELD,##SYM)

    
/******************************************************************************\
* _____________________
* |                   |
* |  E N D            |
* |___________________|
*
* TCP endian mode register
*
* FIELDS (msb -> lsb)
* (rw) EXF
* (rw) AP
* (rw) INTER
* (rw) SYSPAR
*
\******************************************************************************/
  #define _TCP_END_OFFSET            16

  #define _TCP_END_ADDR              0x01BA0040u

  #define _TCP_END_EXT_MASK          0x00000008u
  #define _TCP_END_EXT_SHIFT         0x00000003u
  #define  TCP_END_EXT_DEFAULT       0x00000000u
  #define  TCP_END_EXT_OF(x)         _VALUEOF(x)
  #define  TCP_END_EXT_32BIT         0x00000000u
  #define  TCP_END_EXT_NATIVE        0x00000001u

  #define _TCP_END_AP_MASK          0x00000004u
  #define _TCP_END_AP_SHIFT         0x00000002u
  #define  TCP_END_AP_DEFAULT       0x00000000u
  #define  TCP_END_AP_OF(x)         _VALUEOF(x)
  #define  TCP_END_AP_32BIT         0x00000000u
  #define  TCP_END_AP_NATIVE        0x00000001u

  #define _TCP_END_INTER_MASK         0x00000002u
  #define _TCP_END_INTER_SHIFT        0x00000001u
  #define  TCP_END_INTER_DEFAULT      0x00000000u
  #define  TCP_END_INTER_OF(x)        _VALUEOF(x)
  #define  TCP_END_INTER_32BIT        0x00000000u
  #define  TCP_END_INTER_NATIVE       0x00000001u

  #define _TCP_END_SYSPAR_MASK        0x00000001u
  #define _TCP_END_SYSPAR_SHIFT       0x00000000u
  #define  TCP_END_SYSPAR_DEFAULT     0x00000000u
  #define  TCP_END_SYSPAR_OF(x)       _VALUEOF(x)
  #define  TCP_END_SYSPAR_32BIT       0x00000000u
  #define  TCP_END_SYSPAR_NATIVE      0x00000001u

  #define  TCP_END_OF(x)             _VALUEOF(x)

  #define TCP_END_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,END,EXT)\
   |_PER_FDEFAULT(TCP,END,AP)\
   |_PER_FDEFAULT(TCP,END,INTER)\
   |_PER_FDEFAULT(TCP,END,SYSPAR)\
  )

  #define TCP_END_RMK(ext,ap,inter,syspar) (Uint32)(\
     _PER_FMK(TCP,END,EXT,ext)\
    |_PER_FMK(TCP,END,AP,ap)\
    |_PER_FMK(TCP,END,INTER,inter)\
    |_PER_FMK(TCP,END,SYSPAR,syspar)\
  )

  #define _TCP_END_FGET(FIELD)\
    _PER_FGET(_TCP_END_ADDR,TCP,END,##FIELD)

  #define _TCP_END_FSET(FIELD,field)\
    _PER_FSET(_TCP_END_ADDR,TCP,END,##FIELD,field)

  #define _TCP_END_FSETS(FIELD,SYM)\
    _PER_FSETS(_TCP_END_ADDR,TCP,END,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  E R R            |
* |___________________|
*
* TCP error register
*
* FIELDS (msb -> lsb)
* (r) ACC
* (r) OP
* (r) INT
* (r) LR
* (r) R
* (r) MODE
* (r) SF
* (r) RATE
* (r) P
* (r) F
* (r) ERR
*
\******************************************************************************/
  #define _TCP_ERR_OFFSET          20

  #define _TCP_ERR_ADDR            0x01BA0050u

  #define _TCP_ERR_ACC_MASK      0x00000800u
  #define _TCP_ERR_ACC_SHIFT     0x0000000Bu
  #define  TCP_ERR_ACC_DEFAULT   0x00000000u
  #define  TCP_ERR_ACC_OF(x)     _VALUEOF(x)
  #define  TCP_ERR_ACC_NO        0x00000000u
  #define  TCP_ERR_ACC_YES       0x00000001u

  #define _TCP_ERR_OP_MASK      0x00000400u
  #define _TCP_ERR_OP_SHIFT     0x0000000Au
  #define  TCP_ERR_OP_DEFAULT   0x00000000u
  #define  TCP_ERR_OP_OF(x)     _VALUEOF(x)
  #define  TCP_ERR_OP_NO        0x00000000u
  #define  TCP_ERR_OP_YES       0x00000001u

  #define _TCP_ERR_INT_MASK      0x00000200u
  #define _TCP_ERR_INT_SHIFT     0x00000009u
  #define  TCP_ERR_INT_DEFAULT   0x00000000u
  #define  TCP_ERR_INT_OF(x)     _VALUEOF(x)
  #define  TCP_ERR_INT_NO        0x00000000u
  #define  TCP_ERR_INT_YES       0x00000001u

  #define _TCP_ERR_LR_MASK     0x00000100u
  #define _TCP_ERR_LR_SHIFT    0x00000008u
  #define  TCP_ERR_LR_DEFAULT  0x00000000u
  #define  TCP_ERR_LR_OF(x)    _VALUEOF(x)
  #define  TCP_ERR_LR_NO       0x00000000u
  #define  TCP_ERR_LR_YES      0x00000001u

  #define _TCP_ERR_R_MASK      0x00000080u
  #define _TCP_ERR_R_SHIFT     0x00000007u
  #define  TCP_ERR_R_DEFAULT   0x00000000u
  #define  TCP_ERR_R_OF(x)     _VALUEOF(x)
  #define  TCP_ERR_R_NO        0x00000000u
  #define  TCP_ERR_R_YES       0x00000001u

  #define _TCP_ERR_MODE_MASK      0x00000040u
  #define _TCP_ERR_MODE_SHIFT     0x00000006u
  #define  TCP_ERR_MODE_DEFAULT   0x00000000u
  #define  TCP_ERR_MODE_OF(x)     _VALUEOF(x)
  #define  TCP_ERR_MODE_NO        0x00000000u
  #define  TCP_ERR_MODE_YES       0x00000001u

  #define _TCP_ERR_SF_MASK     0x00000010u
  #define _TCP_ERR_SF_SHIFT    0x00000004u
  #define  TCP_ERR_SF_DEFAULT  0x00000000u
  #define  TCP_ERR_SF_OF(x)    _VALUEOF(x)
  #define  TCP_ERR_SF_NO       0x00000000u
  #define  TCP_ERR_SF_YES      0x00000001u

  #define _TCP_ERR_RATE_MASK       0x00000008u
  #define _TCP_ERR_RATE_SHIFT      0x00000003u
  #define  TCP_ERR_RATE_DEFAULT    0x00000000u
  #define  TCP_ERR_RATE_OF(x)      _VALUEOF(x)
  #define  TCP_ERR_RATE_NO         0x00000000u
  #define  TCP_ERR_RATE_YES        0x00000001u

  #define _TCP_ERR_P_MASK          0x00000004u
  #define _TCP_ERR_P_SHIFT         0x00000002u
  #define  TCP_ERR_P_DEFAULT       0x00000000u
  #define  TCP_ERR_P_OF(x)         _VALUEOF(x)
  #define  TCP_ERR_P_NO            0x00000000u
  #define  TCP_ERR_P_YES           0x00000001u

  #define _TCP_ERR_F_MASK          0x00000002u
  #define _TCP_ERR_F_SHIFT         0x00000001u
  #define  TCP_ERR_F_DEFAULT       0x00000000u
  #define  TCP_ERR_F_OF(x)         _VALUEOF(x)
  #define  TCP_ERR_F_NO            0x00000000u
  #define  TCP_ERR_F_YES           0x00000001u

  #define _TCP_ERR_ERR_MASK        0x00000001u
  #define _TCP_ERR_ERR_SHIFT       0x00000000u
  #define  TCP_ERR_ERR_DEFAULT     0x00000000u
  #define  TCP_ERR_ERR_OF(x)       _VALUEOF(x)
  #define  TCP_ERR_ERR_NO          0x00000000u
  #define  TCP_ERR_ERR_YES         0x00000001u

  #define  TCP_ERR_OF(x)           _VALUEOF(x)

  #define TCP_ERR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,ERR,ACC)\
   |_PER_FDEFAULT(TCP,ERR,OP)\
   |_PER_FDEFAULT(TCP,ERR,INT)\
   |_PER_FDEFAULT(TCP,ERR,LR)\
   |_PER_FDEFAULT(TCP,ERR,R)\
   |_PER_FDEFAULT(TCP,ERR,MODE)\
   |_PER_FDEFAULT(TCP,ERR,SF)\
   |_PER_FDEFAULT(TCP,ERR,RATE)\
   |_PER_FDEFAULT(TCP,ERR,P)\
   |_PER_FDEFAULT(TCP,ERR,F)\
   |_PER_FDEFAULT(TCP,ERR,ERR)\
  )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define TCP_ERR_RMK(acc,op,inter,lr,r,mode, \
		      sf,rate,p,f,err) (Uint32)(\
       _PER_FMK(TCP,ERR,ACC,acc)\
      |_PER_FMK(TCP,ERR,OP,op)\
      |_PER_FMK(TCP,ERR,INT,inter)\
      |_PER_FMK(TCP,ERR,LR,lr)\
      |_PER_FMK(TCP,ERR,R,r)\
      |_PER_FMK(TCP,ERR,MODE,mode)\
      |_PER_FMK(TCP,ERR,SF,sf)\
      |_PER_FMK(TCP,ERR,RATE,rate)\
      |_PER_FMK(TCP,ERR,P,p)\
      |_PER_FMK(TCP,ERR,F,f)\
      |_PER_FMK(TCP,ERR,ERR,err)\
  )      
#endif			
  #define _TCP_ERR_FGET(FIELD)\
    _PER_FGET(_TCP_ERR_ADDR,TCP,ERR,##FIELD)

/******************************************************************************\
* _____________________
* |                   |
* |  S T A T          |
* |___________________|
*
* TCP status register
*
* FIELDS (msb -> lsb)
* (r) ROP
* (r) RHD
* (r) REXT
* (r) WAP
* (r) WSP
* (r) WINT
* (r) WIC
* (r) ERR
* (r) RUN
* (r) PAUS
*
\******************************************************************************/
  #define _TCP_STAT_OFFSET         22

  #define _TCP_STAT_ADDR           0x01BA0058u

  #define _TCP_STAT_ROP_MASK       0x00000200u
  #define _TCP_STAT_ROP_SHIFT      0x00000009u
  #define  TCP_STAT_ROP_DEFAULT    0x00000000u
  #define  TCP_STAT_ROP_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_ROP_NREADY     0x00000000u
  #define  TCP_STAT_ROP_READY      0x00000001u

  #define _TCP_STAT_RHD_MASK       0x00000100u
  #define _TCP_STAT_RHD_SHIFT      0x00000008u
  #define  TCP_STAT_RHD_DEFAULT    0x00000000u
  #define  TCP_STAT_RHD_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_RHD_NREADY     0x00000000u
  #define  TCP_STAT_RHD_READY      0x00000001u

  #define _TCP_STAT_REXT_MASK       0x00000080u
  #define _TCP_STAT_REXT_SHIFT      0x00000007u
  #define  TCP_STAT_REXT_DEFAULT    0x00000000u
  #define  TCP_STAT_REXT_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_REXT_NREADY     0x00000000u
  #define  TCP_STAT_REXT_READY      0x00000001u

  #define _TCP_STAT_WAP_MASK       0x00000040u
  #define _TCP_STAT_WAP_SHIFT      0x00000006u
  #define  TCP_STAT_WAP_DEFAULT    0x00000000u
  #define  TCP_STAT_WAP_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_WAP_NREADY     0x00000000u
  #define  TCP_STAT_WAP_READY      0x00000001u

  #define _TCP_STAT_WSP_MASK       0x00000020u
  #define _TCP_STAT_WSP_SHIFT      0x00000005u
  #define  TCP_STAT_WSP_DEFAULT    0x00000000u
  #define  TCP_STAT_WSP_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_WSP_NREADY     0x00000000u
  #define  TCP_STAT_WSP_READY      0x00000001u

  #define _TCP_STAT_WINT_MASK       0x00000010u
  #define _TCP_STAT_WINT_SHIFT      0x00000004u
  #define  TCP_STAT_WINT_DEFAULT    0x00000000u
  #define  TCP_STAT_WINT_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_WINT_NREADY     0x00000000u
  #define  TCP_STAT_WINT_READY      0x00000001u

  #define _TCP_STAT_WIC_MASK       0x00000008u
  #define _TCP_STAT_WIC_SHIFT      0x00000003u
  #define  TCP_STAT_WIC_DEFAULT    0x00000000u
  #define  TCP_STAT_WIC_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_WIC_NREADY     0x00000000u
  #define  TCP_STAT_WIC_READY      0x00000001u

  #define _TCP_STAT_ERR_MASK       0x00000004u
  #define _TCP_STAT_ERR_SHIFT      0x00000002u
  #define  TCP_STAT_ERR_DEFAULT    0x00000000u
  #define  TCP_STAT_ERR_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_ERR_NO         0x00000000u
  #define  TCP_STAT_ERR_YES        0x00000001u

  #define _TCP_STAT_RUN_MASK       0x00000002u
  #define _TCP_STAT_RUN_SHIFT      0x00000001u
  #define  TCP_STAT_RUN_DEFAULT    0x00000000u
  #define  TCP_STAT_RUN_OF(x)      _VALUEOF(x)
  #define  TCP_STAT_RUN_NO         0x00000000u
  #define  TCP_STAT_RUN_YES        0x00000001u

  #define _TCP_STAT_PAUS_MASK     0x00000001u
  #define _TCP_STAT_PAUS_SHIFT    0x00000000u
  #define  TCP_STAT_PAUS_DEFAULT  0x00000000u
  #define  TCP_STAT_PAUS_OF(x)    _VALUEOF(x)
  #define  TCP_STAT_PAUS_NO       0x00000000u
  #define  TCP_STAT_PAUS_YES      0x00000001u

  #define  TCP_STAT_OF(x)          _VALUEOF(x)

  #define TCP_STAT_DEFAULT (Uint32)(\
    _PER_FDEFAULT(TCP,STAT,ROP)\
   |_PER_FDEFAULT(TCP,STAT,RHD)\
   |_PER_FDEFAULT(TCP,STAT,REX)\
   |_PER_FDEFAULT(TCP,STAT,WAP)\
   |_PER_FDEFAULT(TCP,STAT,WSP)\
   |_PER_FDEFAULT(TCP,STAT,WINT)\
   |_PER_FDEFAULT(TCP,STAT,WIC)\
   |_PER_FDEFAULT(TCP,STAT,ERR)\
   |_PER_FDEFAULT(TCP,STAT,RUN)\
   |_PER_FDEFAULT(TCP,STAT,PAUS)\
  )
  #define TCP_STAT_RMK(rop,rhd,rex,wap,wsp,wint,wic,err,run,paus) (Uint32)(\
       _PER_FMK(TCP,STAT,ROP,rop)\
      |_PER_FMK(TCP,STAT,RHD,rhd)\
      |_PER_FMK(TCP,STAT,REX,rex)\
      |_PER_FMK(TCP,STAT,WAP,wap)\
      |_PER_FMK(TCP,STAT,WSP,wsp)\
      |_PER_FMK(TCP,STAT,WINT,wint)\
      |_PER_FMK(TCP,STAT,WIC,wic)\
      |_PER_FMK(TCP,STAT,ERR,err)\
      |_PER_FMK(TCP,STAT,RUN,run)\
      |_PER_FMK(TCP,STAT,PAUS,paus)\
   )      
  #define _TCP_STAT_FGET(FIELD)\
    _PER_FGET(_TCP_STAT_ADDR,TCP,STAT,##FIELD)



/*----------------------------------------------------------------------------*/

#endif /* TCP_SUPPORT */
#endif /* _CSL_TCPHAL_H_ */
/******************************************************************************\
* End of csl_tcphal.h
\******************************************************************************/

csl_timer.h/    1090821499  0     0     0       8146      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_timer.h
* DATE CREATED.. 06/20/1999 
* LAST MODIFIED. 07/24/2004   Re-introduced BIOS dependency due to compatibilty issues
*                02/09/2004   Removed bios related items 
*                10/03/2000
\******************************************************************************/
#ifndef _CSL_TIMER_H_
#define _CSL_TIMER_H_

#include <csl_chip.h> 
#include <csl_irq.h>
#include <csl_timerhal.h>


#if (TIMER_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far 
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _TIMER_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/

/* TIMER_open() flags */
#define TIMER_OPEN_RESET     (0x00000001)

/* device identifiers for TIMER_open() */
#define TIMER_DEVANY  (-1)
#define TIMER_DEV0    (0)
#define TIMER_DEV1    (1)
#if (TIMER_DEVICE_CNT > 2)
  #define TIMER_DEV2    (2)
#endif


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* handle structure */
typedef struct {
  Uint32 allocated;
  Uint32 eventId;
  volatile Uint32 *baseAddr;
} TIMER_Obj, *TIMER_Handle;

/* device configuration structure */
typedef struct {
  Uint32 ctl;
  Uint32 prd;
  Uint32 cnt;
} TIMER_Config;


/******************************************************************************\
* global variable declarations
\******************************************************************************/

/* predefined deviced handles for legacy - should not be used */
extern far TIMER_Handle _TIMER_hDev0;
extern far TIMER_Handle _TIMER_hDev1;
extern far TIMER_Handle _TIMER_hBios;


/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI TIMER_Handle TIMER_getBiosHandle(); 

CSLAPI void TIMER_reset(TIMER_Handle hTimer);
CSLAPI void TIMER_resetAll();

CSLAPI TIMER_Handle TIMER_open(int devNum, Uint32 flags);
CSLAPI void TIMER_close(TIMER_Handle hTimer);


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 TIMER_getEventId(TIMER_Handle hTimer);

IDECL void TIMER_start(TIMER_Handle hTimer);
IDECL void TIMER_pause(TIMER_Handle hTimer);
IDECL void TIMER_resume(TIMER_Handle hTimer);

IDECL Uint32 TIMER_getPeriod(TIMER_Handle hTimer);
IDECL void   TIMER_setPeriod(TIMER_Handle hTimer, Uint32 period);
IDECL Uint32 TIMER_getCount(TIMER_Handle hTimer);
IDECL void   TIMER_setCount(TIMER_Handle hTimer, Uint32 count);

IDECL int  TIMER_getDatIn(TIMER_Handle hTimer);
IDECL void TIMER_setDatOut(TIMER_Handle hTimer, int Val);
IDECL int  TIMER_getTstat(TIMER_Handle hTimer);

IDECL void TIMER_config(TIMER_Handle hTimer, TIMER_Config *config);
IDECL void TIMER_configArgs(TIMER_Handle hTimer, Uint32 ctl, Uint32 prd, 
  Uint32 cnt);
IDECL void TIMER_getConfig(TIMER_Handle hTimer, TIMER_Config *config);


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 TIMER_getEventId(TIMER_Handle hTimer) {
  return hTimer->eventId;
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_start(TIMER_Handle hTimer) {
  TIMER_FSETH(hTimer,CTL,HLD,1);
  TIMER_FSETH(hTimer,CTL,GO,1);
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_pause(TIMER_Handle hTimer) {
  TIMER_FSETH(hTimer,CTL,HLD,0);
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_resume(TIMER_Handle hTimer) {
  TIMER_FSETH(hTimer,CTL,HLD,1);
}
/*----------------------------------------------------------------------------*/
IDEF int  TIMER_getDatIn(TIMER_Handle hTimer) {
  return TIMER_FGETH(hTimer,CTL,DATIN);
}  
/*----------------------------------------------------------------------------*/
IDEF void TIMER_setDatOut(TIMER_Handle hTimer, int val) {
  TIMER_FSETH(hTimer,CTL,DATOUT,val);
}
/*----------------------------------------------------------------------------*/
IDEF int  TIMER_getTstat(TIMER_Handle hTimer) {
  return TIMER_FGETH(hTimer,CTL,TSTAT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TIMER_getPeriod(TIMER_Handle hTimer) {
  return TIMER_RGETH(hTimer,PRD);
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_setPeriod(TIMER_Handle hTimer, Uint32 period) {
  TIMER_RSETH(hTimer,PRD,period);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 TIMER_getCount(TIMER_Handle hTimer) {
  return TIMER_RGETH(hTimer,CNT);
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_setCount(TIMER_Handle hTimer, Uint32 count) {
  TIMER_RSETH(hTimer,CNT,count);
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_config(TIMER_Handle hTimer, TIMER_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hTimer->baseAddr);
  register int x0,x1,x2;

  gie = IRQ_globalDisable();

  x0 = config->ctl;
  x1 = config->prd;
  x2 = config->cnt;

  base[_TIMER_CTL_OFFSET] = 0x00000000;
  base[_TIMER_PRD_OFFSET] = x1;
  base[_TIMER_CNT_OFFSET] = x2;
  base[_TIMER_CTL_OFFSET] = x0;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_configArgs(TIMER_Handle hTimer, Uint32 ctl, Uint32 prd,
  Uint32 cnt){

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hTimer->baseAddr);

  gie = IRQ_globalDisable();

  base[_TIMER_CTL_OFFSET] = 0x00000000;
  base[_TIMER_PRD_OFFSET] = prd;
  base[_TIMER_CNT_OFFSET] = cnt;
  base[_TIMER_CTL_OFFSET] = ctl;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void TIMER_getConfig(TIMER_Handle hTimer, TIMER_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hTimer->baseAddr);
  volatile TIMER_Config* cfg = (volatile TIMER_Config*)config;
  register int x0,x1,x2;

  gie = IRQ_globalDisable();

  x0 = base[_TIMER_CTL_OFFSET];
  x1 = base[_TIMER_PRD_OFFSET];
  x2 = base[_TIMER_CNT_OFFSET];

  cfg->ctl = x0;
  cfg->prd = x1;
  cfg->cnt = x2;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* TIMER_SUPPORT */
#endif /* _CSL_TIMER_H_ */
/******************************************************************************\
* End of csl_timer.h
\******************************************************************************/

csl_timerhal.h/ 1092218725  0     0     0       16072     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_timerhal.h
* DATE CREATED.. 08/14/2000
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                09/30/2003  Added SPND field description macros for CTL reg.
*                10/03/2000
*------------------------------------------------------------------------------
* REGISTERS
*
* CTL0  - timer control register 0
* CTL1  - timer control register 1
* CTL2  - timer control register 2 (1)
* PRD0  - timer period register 0
* PRD1  - timer period register 1
* PRD2  - timer period register 2 (1)
* CNT0  - timer count register 0
* CNT1  - timer count register 1
* CNT2  - timer count register 2 (1)
*
* (1) - only supported on C64x devices
*
\******************************************************************************/
#ifndef _CSL_TIMERHAL_H_
#define _CSL_TIMERHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (TIMER_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/

#if (CHIP_6414 | CHIP_6415 | CHIP_6416 | CHIP_DM642 | CHIP_DM641 | CHIP_DM640 | CHIP_6412 | CHIP_6411 | CHIP_6410 | CHIP_6413 | CHIP_6418)
  #define TIMER_DEVICE_CNT  3
  #define _TIMER_BASE_DEV0  0x01940000u
  #define _TIMER_BASE_DEV1  0x01980000u
  #define _TIMER_BASE_DEV2  0x01AC0000u
#else
  #define TIMER_DEVICE_CNT  2
  #define _TIMER_BASE_DEV0  0x01940000u
  #define _TIMER_BASE_DEV1  0x01980000u
#endif


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define TIMER_FMK(REG,FIELD,x)\
    _PER_FMK(TIMER,##REG,##FIELD,x)

  #define TIMER_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(TIMER,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define TIMER_ADDR(REG)\
    _TIMER_##REG##_ADDR

  #define TIMER_RGET(REG)\
    _PER_RGET(_TIMER_##REG##_ADDR,TIMER,##REG)

  #define TIMER_RSET(REG,x)\
    _PER_RSET(_TIMER_##REG##_ADDR,TIMER,##REG,x)

  #define TIMER_FGET(REG,FIELD)\
    _TIMER_##REG##_FGET(##FIELD)

  #define TIMER_FSET(REG,FIELD,x)\
    _TIMER_##REG##_FSET(##FIELD,##x)

  #define TIMER_FSETS(REG,FIELD,SYM)\
    _TIMER_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define TIMER_RGETA(addr,REG)\
    _PER_RGET(addr,TIMER,##REG)

  #define TIMER_RSETA(addr,REG,x)\
    _PER_RSET(addr,TIMER,##REG,x)

  #define TIMER_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,TIMER,##REG,##FIELD)

  #define TIMER_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,TIMER,##REG,##FIELD,x)

  #define TIMER_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,TIMER,##REG,##FIELD,##SYM)


  /* ----------------------------------------- */
  /* HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define TIMER_ADDRH(h,REG)\
    (Uint32)(&((h)->baseAddr[_TIMER_##REG##_OFFSET]))

  #define TIMER_RGETH(h,REG)\
    TIMER_RGETA(TIMER_ADDRH(h,##REG),##REG)


  #define TIMER_RSETH(h,REG,x)\
    TIMER_RSETA(TIMER_ADDRH(h,##REG),##REG,x)


  #define TIMER_FGETH(h,REG,FIELD)\
    TIMER_FGETA(TIMER_ADDRH(h,##REG),##REG,##FIELD)


  #define TIMER_FSETH(h,REG,FIELD,x)\
    TIMER_FSETA(TIMER_ADDRH(h,##REG),##REG,##FIELD,x)


  #define TIMER_FSETSH(h,REG,FIELD,SYM)\
    TIMER_FSETSA(TIMER_ADDRH(h,##REG),##REG,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  C T L            |
* |___________________|
*
* CTL0  - timer control register 0
* CTL1  - timer control register 1
* CTL2  - timer control register 2 (1)
*
* FIELDS (msb -> lsb)
* (rw) SPND   (1)
* (r)  TSTAT
* (rw) INVINP
* (rw) CLKSRC
* (rw) CP
* (rw) HLD
* (rw) GO
* (rw) PWID
* (r)  DATIN
* (rw) DATOUT
* (rw) INVOUT
* (rw) FUNC
*
* (1) - only supported on C64x devices
\******************************************************************************/
  #define _TIMER_CTL_OFFSET            0

  #define _TIMER_CTL0_ADDR             0x01940000u
  #define _TIMER_CTL1_ADDR             0x01980000u
  #if (TIMER_DEVICE_CNT == 3)
    #define _TIMER_CTL2_ADDR           0x01AC0000u
  #endif

  #if (C64_SUPPORT)	
	#define _TIMER_CTL_SPND_MASK         0x00008000u
	#define _TIMER_CTL_SPND_SHIFT        0x0000000Fu
	#define TIMER_CTL_SPND_DEFAULT       0x00000000u
	#define TIMER_CTL_SPND_OF(x)         _VALUEOF(x)
	#define TIMER_CTL_SPND_EMUSTOP       0x00000001u
	#define TIMER_CTL_SPND_EMURUN        0x00000000u	
  #endif
	
  #define _TIMER_CTL_TSTAT_MASK        0x00000800u
  #define _TIMER_CTL_TSTAT_SHIFT       0x0000000Bu
  #define  TIMER_CTL_TSTAT_DEFAULT     0x00000000u
  #define  TIMER_CTL_TSTAT_OF(x)       _VALUEOF(x)
  #define  TIMER_CTL_TSTAT_0           0x00000000u
  #define  TIMER_CTL_TSTAT_1           0x00000001u

  #define _TIMER_CTL_INVINP_MASK       0x00000400u
  #define _TIMER_CTL_INVINP_SHIFT      0x0000000Au
  #define  TIMER_CTL_INVINP_DEFAULT    0x00000000u
  #define  TIMER_CTL_INVINP_OF(x)      _VALUEOF(x)
  #define  TIMER_CTL_INVINP_NO         0x00000000u
  #define  TIMER_CTL_INVINP_YES        0x00000001u

  #define _TIMER_CTL_CLKSRC_MASK       0x00000200u
  #define _TIMER_CTL_CLKSRC_SHIFT      0x00000009u
  #define  TIMER_CTL_CLKSRC_DEFAULT    0x00000000u
  #define  TIMER_CTL_CLKSRC_OF(x)      _VALUEOF(x)
  #define  TIMER_CTL_CLKSRC_EXTERNAL   0x00000000u
  #if (C64_SUPPORT)
    #define  TIMER_CTL_CLKSRC_CPUOVR8    0x00000001u
  #else
    #define  TIMER_CTL_CLKSRC_CPUOVR4    0x00000001u
  #endif

  #define _TIMER_CTL_CP_MASK           0x00000100u
  #define _TIMER_CTL_CP_SHIFT          0x00000008u
  #define  TIMER_CTL_CP_DEFAULT        0x00000000u
  #define  TIMER_CTL_CP_OF(x)          _VALUEOF(x)
  #define  TIMER_CTL_CP_PULSE          0x00000000u
  #define  TIMER_CTL_CP_CLOCK          0x00000001u

  #define _TIMER_CTL_HLD_MASK          0x00000080u
  #define _TIMER_CTL_HLD_SHIFT         0x00000007u
  #define  TIMER_CTL_HLD_DEFAULT       0x00000000u
  #define  TIMER_CTL_HLD_OF(x)         _VALUEOF(x)
  #define  TIMER_CTL_HLD_YES           0x00000000u
  #define  TIMER_CTL_HLD_NO            0x00000001u

  #define _TIMER_CTL_GO_MASK           0x00000040u
  #define _TIMER_CTL_GO_SHIFT          0x00000006u
  #define  TIMER_CTL_GO_DEFAULT        0x00000000u
  #define  TIMER_CTL_GO_OF(x)          _VALUEOF(x)
  #define  TIMER_CTL_GO_NO             0x00000000u
  #define  TIMER_CTL_GO_YES            0x00000001u

  #define _TIMER_CTL_PWID_MASK         0x00000010u
  #define _TIMER_CTL_PWID_SHIFT        0x00000004u
  #define  TIMER_CTL_PWID_DEFAULT      0x00000000u
  #define  TIMER_CTL_PWID_OF(x)        _VALUEOF(x)
  #define  TIMER_CTL_PWID_ONE          0x00000000u
  #define  TIMER_CTL_PWID_TWO          0x00000001u

  #define _TIMER_CTL_DATIN_MASK        0x00000008u
  #define _TIMER_CTL_DATIN_SHIFT       0x00000003u
  #define  TIMER_CTL_DATIN_DEFAULT     0x00000000u
  #define  TIMER_CTL_DATIN_OF(x)       _VALUEOF(x)
  #define  TIMER_CTL_DATIN_0           0x00000000u
  #define  TIMER_CTL_DATIN_1           0x00000001u

  #define _TIMER_CTL_DATOUT_MASK       0x00000004u
  #define _TIMER_CTL_DATOUT_SHIFT      0x00000002u
  #define  TIMER_CTL_DATOUT_DEFAULT    0x00000000u
  #define  TIMER_CTL_DATOUT_OF(x)      _VALUEOF(x)
  #define  TIMER_CTL_DATOUT_0          0x00000000u
  #define  TIMER_CTL_DATOUT_1          0x00000001u

  #define _TIMER_CTL_INVOUT_MASK       0x00000002u
  #define _TIMER_CTL_INVOUT_SHIFT      0x00000001u
  #define  TIMER_CTL_INVOUT_DEFAULT    0x00000000u
  #define  TIMER_CTL_INVOUT_OF(x)      _VALUEOF(x)
  #define  TIMER_CTL_INVOUT_NO         0x00000000u
  #define  TIMER_CTL_INVOUT_YES        0x00000001u

  #define _TIMER_CTL_FUNC_MASK         0x00000001u
  #define _TIMER_CTL_FUNC_SHIFT        0x00000000u
  #define  TIMER_CTL_FUNC_DEFAULT      0x00000000u
  #define  TIMER_CTL_FUNC_OF(x)        _VALUEOF(x)
  #define  TIMER_CTL_FUNC_GPIO         0x00000000u
  #define  TIMER_CTL_FUNC_TOUT         0x00000001u

  #define  TIMER_CTL_OF(x)             _VALUEOF(x)

  #if (C64_SUPPORT)
	#define TIMER_CTL_DEFAULT (Uint32)( \
		_PER_FDEFAULT(TIMER,CTL,SPND) \
		|_PER_FDEFAULT(TIMER,CTL,TSTAT) \
		|_PER_FDEFAULT(TIMER,CTL,INVINP) \
		|_PER_FDEFAULT(TIMER,CTL,CLKSRC) \
		|_PER_FDEFAULT(TIMER,CTL,CP) \
		|_PER_FDEFAULT(TIMER,CTL,HLD) \
		|_PER_FDEFAULT(TIMER,CTL,GO) \
		|_PER_FDEFAULT(TIMER,CTL,PWID) \
		|_PER_FDEFAULT(TIMER,CTL,DATIN) \
		|_PER_FDEFAULT(TIMER,CTL,DATOUT) \
		|_PER_FDEFAULT(TIMER,CTL,INVOUT) \
		|_PER_FDEFAULT(TIMER,CTL,FUNC) \
	)
  #else
	#define TIMER_CTL_DEFAULT (Uint32)( \
		_PER_FDEFAULT(TIMER,CTL,TSTAT) \
		|_PER_FDEFAULT(TIMER,CTL,INVINP) \
		|_PER_FDEFAULT(TIMER,CTL,CLKSRC) \
		|_PER_FDEFAULT(TIMER,CTL,CP) \
		|_PER_FDEFAULT(TIMER,CTL,HLD) \
		|_PER_FDEFAULT(TIMER,CTL,GO) \
		|_PER_FDEFAULT(TIMER,CTL,PWID) \
		|_PER_FDEFAULT(TIMER,CTL,DATIN) \
		|_PER_FDEFAULT(TIMER,CTL,DATOUT) \
		|_PER_FDEFAULT(TIMER,CTL,INVOUT) \
		|_PER_FDEFAULT(TIMER,CTL,FUNC) \
	)
  #endif
  
  #if (C64_SUPPORT)
	#define TIMER_CTL_RMK(spnd,invinp,clksrc,cp,hld,go,pwid,datout,invout,func) \
		(Uint32)( \
		_PER_FMK(TIMER,CTL,SPND,spnd) \
		|_PER_FMK(TIMER,CTL,INVINP,invinp) \
		|_PER_FMK(TIMER,CTL,CLKSRC,clksrc) \
		|_PER_FMK(TIMER,CTL,CP,cp) \
		|_PER_FMK(TIMER,CTL,HLD,hld) \
		|_PER_FMK(TIMER,CTL,GO,go) \
		|_PER_FMK(TIMER,CTL,PWID,pwid) \
		|_PER_FMK(TIMER,CTL,DATOUT,datout) \
		|_PER_FMK(TIMER,CTL,INVOUT,invout) \
		|_PER_FMK(TIMER,CTL,FUNC,func) \
	)
  #else
	#define TIMER_CTL_RMK(invinp,clksrc,cp,hld,go,pwid,datout,invout,func) \
		(Uint32)( \
		_PER_FMK(TIMER,CTL,INVINP,invinp) \
		|_PER_FMK(TIMER,CTL,CLKSRC,clksrc) \
		|_PER_FMK(TIMER,CTL,CP,cp) \
		|_PER_FMK(TIMER,CTL,HLD,hld) \
		|_PER_FMK(TIMER,CTL,GO,go) \
		|_PER_FMK(TIMER,CTL,PWID,pwid) \
		|_PER_FMK(TIMER,CTL,DATOUT,datout) \
		|_PER_FMK(TIMER,CTL,INVOUT,invout) \
		|_PER_FMK(TIMER,CTL,FUNC,func) \
	)
  #endif
		
		
  #define _TIMER_CTL_FGET(N,FIELD)\
    _PER_FGET(_TIMER_CTL##N##_ADDR,TIMER,CTL,##FIELD)

  #define _TIMER_CTL_FSET(N,FIELD,f)\
    _PER_FSET(_TIMER_CTL##N##_ADDR,TIMER,CTL,##FIELD,f)

  #define _TIMER_CTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_TIMER_CTL##N##_ADDR,TIMER,CTL,##FIELD,##SYM)

  #define _TIMER_CTL0_FGET(FIELD) _TIMER_CTL_FGET(0,##FIELD)
  #define _TIMER_CTL1_FGET(FIELD) _TIMER_CTL_FGET(1,##FIELD)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_CTL2_FGET(FIELD) _TIMER_CTL_FGET(2,##FIELD)
  #endif

  #define _TIMER_CTL0_FSET(FIELD,f) _TIMER_CTL_FSET(0,##FIELD,f)
  #define _TIMER_CTL1_FSET(FIELD,f) _TIMER_CTL_FSET(1,##FIELD,f)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_CTL2_FSET(FIELD,f) _TIMER_CTL_FSET(2,##FIELD,f)
  #endif

  #define _TIMER_CTL0_FSETS(FIELD,SYM) _TIMER_CTL_FSETS(0,##FIELD,##SYM)
  #define _TIMER_CTL1_FSETS(FIELD,SYM) _TIMER_CTL_FSETS(1,##FIELD,##SYM)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_CTL2_FSETS(FIELD,SYM) _TIMER_CTL_FSETS(2,##FIELD,##SYM)
  #endif


/******************************************************************************\
* _____________________
* |                   |
* |  P R D            |
* |___________________|
*
* PRD0  - timer period register 0
* PRD1  - timer period register 1
* PRD2  - timer period register 2 (1)
*
* (1) - only supported on C64x devices
*
* FIELDS (msb -> lsb)
* (rw) PRD
*
\******************************************************************************/
  #define _TIMER_PRD_OFFSET            1

  #define _TIMER_PRD0_ADDR             0x01940004u
  #define _TIMER_PRD1_ADDR             0x01980004u
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_PRD2_ADDR           0x01AC0004u
  #endif

  #define _TIMER_PRD_PRD_MASK          0xFFFFFFFFu
  #define _TIMER_PRD_PRD_SHIFT         0x00000000u
  #define  TIMER_PRD_PRD_DEFAULT       0x00000000u
  #define  TIMER_PRD_PRD_OF(x)         _VALUEOF(x)

  #define  TIMER_PRD_OF(x)             _VALUEOF(x)

  #define TIMER_PRD_DEFAULT (Uint32)( \
     _PER_FDEFAULT(TIMER,PRD,PRD) \
  )

  #define TIMER_PRD_RMK(prd) (Uint32)( \
     _PER_FMK(TIMER,PRD,PRD,prd) \
  )

  #define _TIMER_PRD_FGET(N,FIELD)\
    _PER_FGET(_TIMER_PRD##N##_ADDR,TIMER,PRD,##FIELD)

  #define _TIMER_PRD_FSET(N,FIELD,f)\
    _PER_FSET(_TIMER_PRD##N##_ADDR,TIMER,PRD,##FIELD,f)

  #define _TIMER_PRD_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_TIMER_PRD##N##_ADDR,TIMER,PRD,##FIELD,##SYM)

  #define _TIMER_PRD0_FGET(FIELD) _TIMER_PRD_FGET(0,##FIELD)
  #define _TIMER_PRD1_FGET(FIELD) _TIMER_PRD_FGET(1,##FIELD)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_PRD2_FGET(FIELD) _TIMER_PRD_FGET(2,##FIELD)
  #endif

  #define _TIMER_PRD0_FSET(FIELD,f) _TIMER_PRD_FSET(0,##FIELD,f)
  #define _TIMER_PRD1_FSET(FIELD,f) _TIMER_PRD_FSET(1,##FIELD,f)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_PRD2_FSET(FIELD,f) _TIMER_PRD_FSET(2,##FIELD,f)
  #endif

  #define _TIMER_PRD0_FSETS(FIELD,SYM) _TIMER_PRD_FSETS(0,##FIELD,##SYM)
  #define _TIMER_PRD1_FSETS(FIELD,SYM) _TIMER_PRD_FSETS(1,##FIELD,##SYM)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_PRD2_FSETS(FIELD,SYM) _TIMER_PRD_FSETS(2,##FIELD,##SYM)
  #endif


/******************************************************************************\
* _____________________
* |                   |
* |  C N T            |
* |___________________|
*
* CNT0  - timer count register 0
* CNT1  - timer count register 1
* CNT2  - timer count register 2 (1)
*
* (1) - only supported on C64x devices
*
* FIELDS (msb -> lsb)
* (rw) CNT
*
\******************************************************************************/
  #define _TIMER_CNT_OFFSET            2

  #define _TIMER_CNT0_ADDR             0x01940008u
  #define _TIMER_CNT1_ADDR             0x01980008u
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_CNT2_ADDR           0x01AC0008u
  #endif

  #define _TIMER_CNT_CNT_MASK          0xFFFFFFFFu
  #define _TIMER_CNT_CNT_MASK          0xFFFFFFFFu
  #define _TIMER_CNT_CNT_SHIFT         0x00000000u
  #define  TIMER_CNT_CNT_DEFAULT       0x00000000u
  #define  TIMER_CNT_CNT_OF(x)         _VALUEOF(x)

  #define  TIMER_CNT_OF(x)             _VALUEOF(x)

  #define TIMER_CNT_DEFAULT (Uint32)( \
     _PER_FDEFAULT(TIMER,CNT,CNT) \
  )

  #define TIMER_CNT_RMK(cnt) (Uint32)( \
     _PER_FMK(TIMER,CNT,CNT,cnt) \
  )

  #define _TIMER_CNT_FGET(N,FIELD)\
    _PER_FGET(_TIMER_CNT##N##_ADDR,TIMER,CNT,##FIELD)

  #define _TIMER_CNT_FSET(N,FIELD,f)\
    _PER_FSET(_TIMER_CNT##N##_ADDR,TIMER,CNT,##FIELD,f)

  #define _TIMER_CNT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_TIMER_CNT##N##_ADDR,TIMER,CNT,##FIELD,##SYM)

  #define _TIMER_CNT0_FGET(FIELD) _TIMER_CNT_FGET(0,##FIELD)
  #define _TIMER_CNT1_FGET(FIELD) _TIMER_CNT_FGET(1,##FIELD)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_CNT2_FGET(FIELD) _TIMER_CNT_FGET(2,##FIELD)
  #endif

  #define _TIMER_CNT0_FSET(FIELD,f) _TIMER_CNT_FSET(0,##FIELD,f)
  #define _TIMER_CNT1_FSET(FIELD,f) _TIMER_CNT_FSET(1,##FIELD,f)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_CNT2_FSET(FIELD,f) _TIMER_CNT_FSET(2,##FIELD,f)
  #endif

  #define _TIMER_CNT0_FSETS(FIELD,SYM) _TIMER_CNT_FSETS(0,##FIELD,##SYM)
  #define _TIMER_CNT1_FSETS(FIELD,SYM) _TIMER_CNT_FSETS(1,##FIELD,##SYM)
  #if  TIMER_DEVICE_CNT == 3
    #define _TIMER_CNT2_FSETS(FIELD,SYM) _TIMER_CNT_FSETS(2,##FIELD,##SYM)
  #endif


/*----------------------------------------------------------------------------*/

#endif /* (TIMER_SUPPORT) */
#endif /* _CSL_TIMERHAL_H_ */
/******************************************************************************\
* End of csl_timerhal.h
\******************************************************************************/

csl_utop.h/     1030611981  0     0     0       8572      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_utop.h
* DATE CREATED.. 07/19/2000 
* LAST MODIFIED. 12/22/2000 
\******************************************************************************/
#ifndef _CSL_UTOP_H_
#define _CSL_UTOP_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_utophal.h>

#if (UTOP_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far 
#else
#define CSLAPI extern far 
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _UTOP_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/******************************************************************************\
* global macro declarations
\******************************************************************************/

/* utopia interrupt numbers */
#define UTOP_INT_XQ     0
#define UTOP_INT_RQ     16

/* utopia error interrupt numbers */
#define UTOP_ERR_RQS    0
#define UTOP_ERR_RCF    1
#define UTOP_ERR_RCP    2
#define UTOP_ERR_XQS    16
#define UTOP_ERR_XCF    17
#define UTOP_ERR_XCP    18

#define UTOP_RCVQ_ADDR  _UTOP_BASE_RQUEUE 
#define UTOP_XMTQ_ADDR  _UTOP_BASE_XQUEUE 


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* device configuration structure */
typedef struct {
  Uint32 ucr;
  Uint32 cdr;
} UTOP_Config;

/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void UTOP_reset();

/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 UTOP_getXmtAddr();
IDECL Uint32 UTOP_getRcvAddr();
IDECL Uint32 UTOP_getEventId();

/* UTOP_read/write is for CPU servicing Utopia */
IDECL Uint32 UTOP_read();
IDECL void   UTOP_write(Uint32 val);

IDECL void UTOP_enableXmt();
IDECL void UTOP_enableRcv();

IDECL void   UTOP_intDisable(Uint32 intNum);
IDECL void   UTOP_intEnable(Uint32 intNum);
IDECL void   UTOP_intClear(Uint32 intNum);
IDECL Uint32 UTOP_intTest(Uint32 intNum);
IDECL void   UTOP_intReset(Uint32 intNum);

IDECL void   UTOP_errDisable(Uint32 errNum);
IDECL void   UTOP_errEnable(Uint32 errNum);
IDECL void   UTOP_errClear(Uint32 errNum);
IDECL Uint32 UTOP_errTest(Uint32 errNum);
IDECL void   UTOP_errReset(Uint32 errNum);

IDECL void UTOP_config(UTOP_Config *config);
IDECL void UTOP_configArgs(Uint32 ucr, Uint32 cdr);
IDECL void UTOP_getConfig(UTOP_Config *config);


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 UTOP_getXmtAddr() {
  return (Uint32)(_UTOP_BASE_XQUEUE);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 UTOP_getRcvAddr() {
  return (Uint32)(_UTOP_BASE_RQUEUE);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 UTOP_getEventId() {
  return (IRQ_EVT_UINT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 UTOP_read() {
  return (*(volatile Uint32*)(_UTOP_BASE_RQUEUE));
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_write(Uint32 val) {
  (*(volatile Uint32*)(_UTOP_BASE_XQUEUE)) = val;
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_enableXmt() {
  UTOP_FSETS(UCR,UXEN,ENABLE);
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_enableRcv() {
  UTOP_FSETS(UCR,UREN,ENABLE);
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_intDisable(Uint32 intNum){
  UTOP_RSET(UIER,UTOP_RGET(UIER)&~(1<<intNum));
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_intEnable(Uint32 intNum){
  UTOP_RSET(UIER,UTOP_RGET(UIER)|(1<<intNum));
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_intClear(Uint32 intNum){
  UTOP_RSET(UIPR,1<<intNum);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 UTOP_intTest(Uint32 intNum){
  return ((UTOP_RGET(UIPR) & (1<<intNum)) ? 1 : 0);
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_intReset(Uint32 intNum){
  UTOP_intDisable(intNum);
  UTOP_intClear(intNum);
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_errDisable(Uint32 errNum){
  UTOP_RSET(EIER,UTOP_RGET(EIER)&~(1<<errNum));
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_errEnable(Uint32 errNum){
  UTOP_RSET(EIER,UTOP_RGET(EIER)|(1<<errNum));
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_errClear(Uint32 errNum){
  UTOP_RSET(EIPR,1<<errNum);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 UTOP_errTest(Uint32 errNum){
  return ((UTOP_RGET(EIPR) & (1<<errNum)) ? 1 : 0);
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_errReset(Uint32 errNum){
  UTOP_errDisable(errNum);
  UTOP_errClear(errNum);
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_config(UTOP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_UTOP_UCR_ADDR;
  register int x0,x1;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0 = config->ucr;
  x1 = config->cdr;

  base[_UTOP_UCR_OFFSET]    = 0x00000000u;
  base[_UTOP_CDR_OFFSET]    = x1;
  base[_UTOP_UCR_OFFSET]    = x0; /* Enable interface after everything is set up */

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_configArgs(Uint32 ucr, Uint32 cdr) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_UTOP_UCR_ADDR;

  gie = IRQ_globalDisable();

  base[_UTOP_UCR_OFFSET]    = 0x00000000u;
  base[_UTOP_CDR_OFFSET]    = cdr;
  base[_UTOP_UCR_OFFSET]    = ucr; /* Enable interface after everything is set up */

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void UTOP_getConfig(UTOP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_UTOP_UCR_ADDR;
  register int x0,x1;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */

  x0 = base[_UTOP_UCR_OFFSET];
  x1 = base[_UTOP_CDR_OFFSET];
  
  config->ucr    = x0;
  config->cdr    = x1;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* UTOP_SUPPORT */
#endif /* _CSL_UTOP_H_ */
/******************************************************************************\
* End of csl_utop.h
\******************************************************************************/

csl_utophal.h/  1030611981  0     0     0       17023     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_utophal.h
* DATE CREATED.. 07/19/2000 
* LAST MODIFIED. 09/21/2001 
*------------------------------------------------------------------------------
* REGISTERS
*
* UCR   - Utopia Control Register
* UIER  - Utopia Interrupt Enable Register
* UIPR  - Utopia Interrupt Pending Register
* CDR   - Clock Detect Register
* EIER  - Error Interrupt Enable Register
* EIPR  - Error Interrupt Pending Register
*
\******************************************************************************/
#ifndef _CSL_UTOPHAL_H_
#define _CSL_UTOPHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (UTOP_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
  #define _UTOP_BASE_GLOBAL      0x01B40000u
  #define _UTOP_BASE_RQUEUE      0x3C000000u
  #define _UTOP_BASE_XQUEUE      0x3D000000u

/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define UTOP_FMK(REG,FIELD,x)\
    _PER_FMK(UTOP,##REG,##FIELD,x)

  #define UTOP_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(UTOP,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define UTOP_ADDR(REG)\
    _UTOP_##REG##_ADDR

  #define UTOP_RGET(REG)\
    _PER_RGET(_UTOP_##REG##_ADDR,UTOP,##REG)

  #define UTOP_RSET(REG,x)\
    _PER_RSET(_UTOP_##REG##_ADDR,UTOP,##REG,x)

  #define UTOP_FGET(REG,FIELD)\
    _UTOP_##REG##_FGET(##FIELD)

  #define UTOP_FSET(REG,FIELD,x)\
    _UTOP_##REG##_FSET(##FIELD,##x)

  #define UTOP_FSETS(REG,FIELD,SYM)\
    _UTOP_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define UTOP_RGETA(addr,REG)\
    _PER_RGET(addr,UTOP,##REG)

  #define UTOP_RSETA(addr,REG,x)\
    _PER_RSET(addr,UTOP,##REG,x)

  #define UTOP_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,UTOP,##REG,##FIELD)

  #define UTOP_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,UTOP,##REG,##FIELD,x)

  #define UTOP_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,UTOP,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  U C R            |
* |___________________|
*
* UCR   - Utopia Control Register
*
* Fields (msb --> lsb):
* (rw) BEND
* (rw) SLIDSLEND
* (rw) XUDC
* (rw) UXEN
* (rw) MPHY
* (rw) RUDC
* (rw) UREN

\******************************************************************************/
  #define _UTOP_UCR_OFFSET            0

  #define _UTOP_UCR_ADDR              0x01B40000u

  #define _UTOP_UCR_BEND_MASK         0x80000000u
  #define _UTOP_UCR_BEND_SHIFT        0x0000001Fu
  #define  UTOP_UCR_BEND_DEFAULT      0x00000000u
  #define  UTOP_UCR_BEND_OF(x)        _VALUEOF(x)
  #define  UTOP_UCR_BEND_LITTLE       0x00000000u
  #define  UTOP_UCR_BEND_BIG          0x00000001u

  #define _UTOP_UCR_SLID_MASK    0x1F000000u
  #define _UTOP_UCR_SLID_SHIFT   0x00000018u
  #define  UTOP_UCR_SLID_DEFAULT 0x00000000u
  #define  UTOP_UCR_SLID_OF(x)   _VALUEOF(x)
  #define  UTOP_UCR_SLID_NULL    0x0000001Fu

  #define _UTOP_UCR_XUDC_MASK         0x003C0000u
  #define _UTOP_UCR_XUDC_SHIFT        0x00000012u
  #define  UTOP_UCR_XUDC_DEFAULT      0x00000000u
  #define  UTOP_UCR_XUDC_OF(x)        _VALUEOF(x)

  #define _UTOP_UCR_UXEN_MASK         0x00010000u
  #define _UTOP_UCR_UXEN_SHIFT        0x00000010u
  #define  UTOP_UCR_UXEN_DEFAULT      0x00000000u
  #define  UTOP_UCR_UXEN_OF(x)        _VALUEOF(x)
  #define  UTOP_UCR_UXEN_DISABLE      0x00000000u
  #define  UTOP_UCR_UXEN_ENABLE       0x00000001u

  #define _UTOP_UCR_MPHY_MASK         0x00004000u
  #define _UTOP_UCR_MPHY_SHIFT        0x0000000Eu
  #define  UTOP_UCR_MPHY_DEFAULT      0x00000000u
  #define  UTOP_UCR_MPHY_OF(x)        _VALUEOF(x)
  #define  UTOP_UCR_MPHY_SINGLE       0x00000000u
  #define  UTOP_UCR_MPHY_MULTI        0x00000001u
 
  #define _UTOP_UCR_RUDC_MASK         0x0000003Cu
  #define _UTOP_UCR_RUDC_SHIFT        0x00000002u
  #define  UTOP_UCR_RUDC_DEFAULT      0x00000000u
  #define  UTOP_UCR_RUDC_OF(x)        _VALUEOF(x)

  #define _UTOP_UCR_UREN_MASK         0x00000001u
  #define _UTOP_UCR_UREN_SHIFT        0x00000000u
  #define  UTOP_UCR_UREN_DEFAULT      0x00000000u
  #define  UTOP_UCR_UREN_OF(x)        _VALUEOF(x)
  #define  UTOP_UCR_UREN_ENABLE       0x00000001u
  #define  UTOP_UCR_UREN_DISABLE      0x00000000u

  #define  UTOP_UCR_OF(x)             _VALUEOF(x)

  #define UTOP_UCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(UTOP,UCR,BEND)\
    |_PER_FDEFAULT(UTOP,UCR,SLID)\
    |_PER_FDEFAULT(UTOP,UCR,XUDC)\
    |_PER_FDEFAULT(UTOP,UCR,UXEN)\
    |_PER_FDEFAULT(UTOP,UCR,MPHY)\
    |_PER_FDEFAULT(UTOP,UCR,RUDC)\
    |_PER_FDEFAULT(UTOP,UCR,UREN)\
  )

  #define UTOP_UCR_RMK(bend,slid,xudc,uxen,\
    mphy,rudc,uren) (Uint32)(\
     _PER_FMK(UTOP,UCR,BEND,bend)\
    |_PER_FMK(UTOP,UCR,SLID,slid)\
    |_PER_FMK(UTOP,UCR,XUDC,xudc)\
    |_PER_FMK(UTOP,UCR,UXEN,uxen)\
    |_PER_FMK(UTOP,UCR,MPHY,mphy)\
    |_PER_FMK(UTOP,UCR,RUDC,rudc)\
    |_PER_FMK(UTOP,UCR,UREN,uren)\
  )

  #define _UTOP_UCR_FGET(FIELD)\
    _PER_FGET(_UTOP_UCR_ADDR,UTOP,UCR,##FIELD)

  #define _UTOP_UCR_FSET(FIELD,field)\
    _PER_FSET(_UTOP_UCR_ADDR,UTOP,UCR,##FIELD,field)

  #define _UTOP_UCR_FSETS(FIELD,SYM)\
    _PER_FSETS(_UTOP_UCR_ADDR,UTOP,UCR,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  U I E R          |
* |___________________|
*
* UIER  - Utopia Interrupt Enable Register
*
* Fields (msb --> lsb):
* (rw) RQIE
* (rw) XQIE
*
\******************************************************************************/
  #define _UTOP_UIER_OFFSET           3

  #define _UTOP_UIER_ADDR             0x01B4000Cu
  
  #define _UTOP_UIER_RQIE_MASK        0x00010000u
  #define _UTOP_UIER_RQIE_SHIFT       0x00000010u
  #define  UTOP_UIER_RQIE_DEFAULT     0x00000000u
  #define  UTOP_UIER_RQIE_OF(x)       _VALUEOF(x)

  #define _UTOP_UIER_XQIE_MASK        0x00000001u
  #define _UTOP_UIER_XQIE_SHIFT       0x00000000u
  #define  UTOP_UIER_XQIE_DEFAULT     0x00000000u
  #define  UTOP_UIER_XQIE_OF(x)       _VALUEOF(x)

  #define  UTOP_UIER_OF(x)            _VALUEOF(x)

  #define UTOP_UIER_DEFAULT (Uint32)(\
     _PER_FDEFAULT(UTOP,UIER,RQIE)\
    |_PER_FDEFAULT(UTOP,UIER,XQIE)\
  )

  #define UTOP_UIER_RMK(rqie,xqie) (Uint32)(\
     _PER_FMK(UTOP,UIER,RQIE,rqie)\
    |_PER_FMK(UTOP,UIER,XQIE,xqie)\
  )

  #define _UTOP_UIER_FGET(FIELD)\
    _PER_FGET(_UTOP_UIER_ADDR,UTOP,UIER,##FIELD)

  #define _UTOP_UIER_FSET(FIELD,field)\
    _PER_FSET(_UTOP_UIER_ADDR,UTOP,UIER,##FIELD,field)

  #define _UTOP_UIER_FSETS(FIELD,SYM)\
    _PER_FSETS(_UTOP_UIER_ADDR,UTOP,UIER,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  U I P R          |
* |___________________|
*
* UIPR  - Utopia Interrupt Pending Register
*
* Fields (msb --> lsb):
* (rw) RQIP
* (rw) XQIP
*
\******************************************************************************/
  #define _UTOP_UIPR_OFFSET           4

  #define _UTOP_UIPR_ADDR             0x01B40010u

  #define _UTOP_UIPR_RQIP_MASK        0x00010000u
  #define _UTOP_UIPR_RQIP_SHIFT       0x00000010u
  #define  UTOP_UIPR_RQIP_DEFAULT     0x00000000u
  #define  UTOP_UIPR_RQIP_OF(x)       _VALUEOF(x)
  #define  UTOP_UIPR_RQIP_CLEAR       0x00000001u
 
  #define _UTOP_UIPR_XQIP_MASK        0x00000001u
  #define _UTOP_UIPR_XQIP_SHIFT       0x00000000u
  #define  UTOP_UIPR_XQIP_DEFAULT     0x00000000u
  #define  UTOP_UIPR_XQIP_OF(x)       _VALUEOF(x)
  #define  UTOP_UIPR_XQIP_CLEAR       0x00000001u

  #define  UTOP_UIPR_OF(x)            _VALUEOF(x)

  #define UTOP_UIPR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(UTOP,UIPR,RQIP)\
    |_PER_FDEFAULT(UTOP,UIPR,XQIP)\
  )

  #define UTOP_UIPR_RMK(rqip,xqip) (Uint32)(\
     _PER_FMK(UTOP,UIPR,RQIP,rqip)\
    |_PER_FMK(UTOP,UIPR,XQIP,xqip)\
  )

  #define _UTOP_UIPR_FGET(FIELD)\
    _PER_FGET(_UTOP_UIPR_ADDR,UTOP,UIPR,##FIELD)

  #define _UTOP_UIPR_FSET(FIELD,field)\
    _PER_FSET(_UTOP_UIPR_ADDR,UTOP,UIPR,##FIELD,field)

  #define _UTOP_UIPR_FSETS(FIELD,SYM)\
    _PER_FSETS(_UTOP_UIPR_ADDR,UTOP,UIPR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  C D R            |
* |___________________|
*
* CDR   - Clock Detect Register
*
* Fields (msb --> lsb):
* (rw) XCCNT
* (rw) RCCNT
*
\******************************************************************************/
  #define _UTOP_CDR_OFFSET            5

  #define _UTOP_CDR_ADDR              0x01B40014u

  #define _UTOP_CDR_XCCNT_MASK        0x00FF0000u
  #define _UTOP_CDR_XCCNT_SHIFT       0x00000010u
  #define  UTOP_CDR_XCCNT_DEFAULT     0x000000FFu
  #define  UTOP_CDR_XCCNT_OF(x)       _VALUEOF(x)

  #define _UTOP_CDR_RCCNT_MASK        0x000000FFu
  #define _UTOP_CDR_RCCNT_SHIFT       0x00000000u
  #define  UTOP_CDR_RCCNT_DEFAULT     0x000000FFu
  #define  UTOP_CDR_RCCNT_OF(x)       _VALUEOF(x)

  #define  UTOP_CDR_OF(x)             _VALUEOF(x)

  #define UTOP_CDR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(UTOP,CDR,XCCNT)\
    |_PER_FDEFAULT(UTOP,CDR,RCCNT)\
  )

  #define UTOP_CDR_RMK(xccnt,rccnt) (Uint32)(\
     _PER_FMK(UTOP,CDR,XCCNT,xccnt)\
    |_PER_FMK(UTOP,CDR,RCCNT,rccnt)\
  )

  #define _UTOP_CDR_FGET(FIELD)\
    _PER_FGET(_UTOP_CDR_ADDR,UTOP,CDR,##FIELD)

  #define _UTOP_CDR_FSET(FIELD,field)\
    _PER_FSET(_UTOP_CDR_ADDR,UTOP,CDR,##FIELD,field)

  #define _UTOP_CDR_FSETS(FIELD,SYM)\
    _PER_FSETS(_UTOP_CDR_ADDR,UTOP,CDR,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  E I E R          |
* |___________________|
*
* EIER  - Error Interrupt Enable Register
*
* Fields (msb --> lsb):
* (rw) XCPE
* (rw) XCFE
* (rw) XQSE
* (rw) RCPE
* (rw) RCFE
* (rw) RQSE
*
\******************************************************************************/
  #define _UTOP_EIER_OFFSET           6

  #define _UTOP_EIER_ADDR             0x01B40018u
  
  #define _UTOP_EIER_XCPE_MASK        0x00040000u
  #define _UTOP_EIER_XCPE_SHIFT       0x00000012u
  #define  UTOP_EIER_XCPE_DEFAULT     0x00000000u
  #define  UTOP_EIER_XCPE_OF(x)       _VALUEOF(x)
  #define  UTOP_EIER_XCPE_DISABLE     0x00000000u
  #define  UTOP_EIER_XCPE_ENABLE      0x00000001u

  #define _UTOP_EIER_XCFE_MASK        0x00020000u
  #define _UTOP_EIER_XCFE_SHIFT       0x00000011u
  #define  UTOP_EIER_XCFE_DEFAULT     0x00000000u
  #define  UTOP_EIER_XCFE_OF(x)       _VALUEOF(x)
  #define  UTOP_EIER_XCFE_DISABLE     0x00000000u
  #define  UTOP_EIER_XCFE_ENABLE      0x00000001u

  #define _UTOP_EIER_XQSE_MASK        0x00010000u
  #define _UTOP_EIER_XQSE_SHIFT       0x00000010u
  #define  UTOP_EIER_XQSE_DEFAULT     0x00000000u
  #define  UTOP_EIER_XQSE_OF(x)       _VALUEOF(x)
  #define  UTOP_EIER_XQSE_DISABLE     0x00000000u
  #define  UTOP_EIER_XQSE_ENABLE      0x00000001u

  #define _UTOP_EIER_RCPE_MASK        0x00000004u
  #define _UTOP_EIER_RCPE_SHIFT       0x00000002u
  #define  UTOP_EIER_RCPE_DEFAULT     0x00000000u
  #define  UTOP_EIER_RCPE_OF(x)       _VALUEOF(x)
  #define  UTOP_EIER_RCPE_DISABLE     0x00000000u
  #define  UTOP_EIER_RCPE_ENABLE      0x00000001u

  #define _UTOP_EIER_RCFE_MASK        0x00000002u
  #define _UTOP_EIER_RCFE_SHIFT       0x00000001u
  #define  UTOP_EIER_RCFE_DEFAULT     0x00000000u
  #define  UTOP_EIER_RCFE_OF(x)       _VALUEOF(x)
  #define  UTOP_EIER_RCFE_DISABLE     0x00000000u
  #define  UTOP_EIER_RCFE_ENABLE      0x00000001u

  #define _UTOP_EIER_RQSE_MASK        0x00000001u
  #define _UTOP_EIER_RQSE_SHIFT       0x00000000u
  #define  UTOP_EIER_RQSE_DEFAULT     0x00000000u
  #define  UTOP_EIER_RQSE_OF(x)       _VALUEOF(x)
  #define  UTOP_EIER_RQSE_DISABLE     0x00000000u
  #define  UTOP_EIER_RQSE_ENABLE      0x00000001u

  #define  UTOP_EIER_OF(x)            _VALUEOF(x)

  #define UTOP_EIER_DEFAULT (Uint32)(\
     _PER_FDEFAULT(UTOP,EIER,XCPE)\
    |_PER_FDEFAULT(UTOP,EIER,XCFE)\
    |_PER_FDEFAULT(UTOP,EIER,XQSE)\
    |_PER_FDEFAULT(UTOP,EIER,RCPE)\
    |_PER_FDEFAULT(UTOP,EIER,RCFE)\
    |_PER_FDEFAULT(UTOP,EIER,RQSE)\
  )

  #define UTOP_EIER_RMK(xcpe,xcfe,xqse,rcpe,rcfe,rqse) (Uint32)(\
     _PER_FMK(UTOP,EIER,XCPE,xcpe)\
    |_PER_FMK(UTOP,EIER,XCFE,xcfe)\
	|_PER_FMK(UTOP,EIER,XQSE,xqse)\
    |_PER_FMK(UTOP,EIER,RCPE,rcpe)\
    |_PER_FMK(UTOP,EIER,RCFE,rcfe)\
	|_PER_FMK(UTOP,EIER,RQSE,rqse)\
  )

  #define _UTOP_EIER_FGET(FIELD)\
    _PER_FGET(_UTOP_EIER_ADDR,UTOP,EIER,##FIELD)

  #define _UTOP_EIER_FSET(FIELD,field)\
    _PER_FSET(_UTOP_EIER_ADDR,UTOP,EIER,##FIELD,field)

  #define _UTOP_EIER_FSETS(FIELD,SYM)\
    _PER_FSETS(_UTOP_EIER_ADDR,UTOP,EIER,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  E I P R          |
* |___________________|
*
* EIPR  - Error Interrupt Enable Register
*
* Fields (msb --> lsb):
* (rw) XCPP
* (rw) XCFP
* (r)  XQSP
* (rw) RCPP
* (rw) RCFP
* (r)  RQSP
*
\******************************************************************************/
  #define _UTOP_EIPR_OFFSET           7

  #define _UTOP_EIPR_ADDR             0x01B4001Cu
  
  #define _UTOP_EIPR_XCPP_MASK        0x00040000u
  #define _UTOP_EIPR_XCPP_SHIFT       0x00000012u
  #define  UTOP_EIPR_XCPP_DEFAULT     0x00000000u
  #define  UTOP_EIPR_XCPP_OF(x)       _VALUEOF(x)
  #define  UTOP_EIPR_XCPP_CLEAR       0x00000001u

  #define _UTOP_EIPR_XCFP_MASK        0x00020000u
  #define _UTOP_EIPR_XCFP_SHIFT       0x00000011u
  #define  UTOP_EIPR_XCFP_DEFAULT     0x00000000u
  #define  UTOP_EIPR_XCFP_OF(x)       _VALUEOF(x)
  #define  UTOP_EIPR_XCFP_CLEAR       0x00000001u

  #define _UTOP_EIPR_XQSP_MASK        0x00010000u
  #define _UTOP_EIPR_XQSP_SHIFT       0x00000010u
  #define  UTOP_EIPR_XQSP_DEFAULT     0x00000000u
  #define  UTOP_EIPR_XQSP_OF(x)       _VALUEOF(x)

  #define _UTOP_EIPR_RCPP_MASK        0x00000004u
  #define _UTOP_EIPR_RCPP_SHIFT       0x00000002u
  #define  UTOP_EIPR_RCPP_DEFAULT     0x00000000u
  #define  UTOP_EIPR_RCPP_OF(x)       _VALUEOF(x)
  #define  UTOP_EIPR_RCPP_CLEAR       0x00000001u

  #define _UTOP_EIPR_RCFP_MASK        0x00000002u
  #define _UTOP_EIPR_RCFP_SHIFT       0x00000001u
  #define  UTOP_EIPR_RCFP_DEFAULT     0x00000000u
  #define  UTOP_EIPR_RCFP_OF(x)       _VALUEOF(x)
  #define  UTOP_EIPR_RCFP_CLEAR       0x00000001u

  #define _UTOP_EIPR_RQSP_MASK        0x00000001u
  #define _UTOP_EIPR_RQSP_SHIFT       0x00000000u
  #define  UTOP_EIPR_RQSP_DEFAULT     0x00000000u
  #define  UTOP_EIPR_RQSP_OF(x)       _VALUEOF(x)

  #define  UTOP_EIPR_OF(x)            _VALUEOF(x)

  #define UTOP_EIPR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(UTOP,EIPR,XCPP)\
    |_PER_FDEFAULT(UTOP,EIPR,XCFP)\
    |_PER_FDEFAULT(UTOP,EIPR,XQSP)\
    |_PER_FDEFAULT(UTOP,EIPR,RCPP)\
    |_PER_FDEFAULT(UTOP,EIPR,RCFP)\
    |_PER_FDEFAULT(UTOP,EIPR,RQSP)\
  )

  #define UTOP_EIPR_RMK(xcpp,xcfp,rcpp,rcfp) (Uint32)(\
     _PER_FMK(UTOP,EIPR,XCPP,xcpp)\
    |_PER_FMK(UTOP,EIPR,XCFP,xcfp)\
    |_PER_FMK(UTOP,EIPR,RCPP,rcpp)\
    |_PER_FMK(UTOP,EIPR,RCFP,rcfp)\
  )

  #define _UTOP_EIPR_FGET(FIELD)\
    _PER_FGET(_UTOP_EIPR_ADDR,UTOP,EIPR,##FIELD)

  #define _UTOP_EIPR_FSET(FIELD,field)\
    _PER_FSET(_UTOP_EIPR_ADDR,UTOP,EIPR,##FIELD,field)

  #define _UTOP_EIPR_FSETS(FIELD,SYM)\
    _PER_FSETS(_UTOP_EIPR_ADDR,UTOP,EIPR,##FIELD,##SYM)


/*----------------------------------------------------------------------------*/

#endif /* UTOP_SUPPORT */
#endif /* _CSL_UTOPHAL_H_ */
/******************************************************************************\
* End of csl_utophal.h
\******************************************************************************/


csl_vcp.h/      1034315833  0     0     0       12393     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vcp.h
* DATE CREATED.. 04/09/2001 
* LAST MODIFIED. 05/30/2001 
*
\******************************************************************************/
#ifndef _CSL_VCP_H_
#define _CSL_VCP_H_

#include <csl_chip.h>   
#include <csl_stdinc.h>
#include <csl_irq.h>
#include "csl_vcphal.h"

#if (VCP_SUPPORT)
/****************************************\
* VCP scope and inline control macros
\****************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _VCP_MOD_
  #define IDECL extern far
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL extern far
  #endif
#endif

/****************************************\
* VCP global macro declarations
\****************************************/

/****************************************\
* VCP global typedef declarations
\****************************************/
typedef Uint32 VCP_Standard;
typedef Uint32 VCP_Mode;
typedef Uint32 VCP_Map;
typedef Uint32 VCP_Rate;
typedef Uint8  VCP_UserData;
typedef Uint8  VCP_ExtrinsicData;

typedef struct {
   Uint32 ic0;
   Uint32 ic1;
   Uint32 ic2;
   Uint32 ic3;
   Uint32 ic4;
   Uint32 ic5;
} VCP_ConfigIc;

typedef struct {
   VCP_Rate     rate;
   Uint8        constLen;
   Uint8        poly0;
   Uint8        poly1;
   Uint8        poly2;
   Uint8        poly3;
   Uint16       yamTh;
   Uint16       frameLen;
   Uint16       relLen;
   Uint16       convDist;
   Uint16       maxSm;
   Uint16       minSm;
   Uint8        stateNum;
   Uint8        bmBuffLen;
   Uint8        decBuffLen;
   Uint8        traceBack;
   Uint8        readFlag;
   Uint8        decision;
   Uint16       numBranchMetrics;
   Uint16       numDecisions;
   Uint16       numBmFrames;
   Uint16       numDecFrames;
} VCP_Params;
typedef struct {
   VCP_Rate     rate;
   Uint8        constLen;
   Uint16       frameLen;
   Uint16       yamTh;
   Uint8        stateNum;
   Uint8        decision;
   Uint8        readFlag;
} VCP_BaseParams;

/****************************************\
* VCP global ants declarations
\****************************************/
#define VCP_RATE_1_2              2
#define VCP_RATE_1_3              3
#define VCP_RATE_1_4              4
#define VCP_DECISION_HARD         0
#define VCP_DECISION_SOFT         1
#define VCP_TRACEBACK_NONE        0
#define VCP_TRACEBACK_TAILED      1
#define VCP_TRACEBACK_CONVERGENT  2
#define VCP_TRACEBACK_MIXED       3
#define VCP_END_PACKED32          0
#define VCP_END_NATIVE            1
#define VCP_NUM_IC                6
#define VCP_NUM_OP                2

/****************************************\
* VCP global function declarations
\****************************************/
/* Set all icx registers :                                                    */ 
/* Establish all IC register values in the configIc struct based on the       */
/* parameters defined in configParms.                                         */
CSLAPI void VCP_genIc(VCP_Params *restrict configParms,
                      VCP_ConfigIc *restrict configIc);

/* Fill out the necessary TCP parameters.                                     */
CSLAPI void VCP_genParams(VCP_BaseParams *configBase,
                      VCP_Params *configParms);


/****************************************\
* VCP inline function declarations
\****************************************/

/* Master transfer functions */
IDECL void   VCP_start();
IDECL void   VCP_pause();
IDECL void   VCP_unpause();
IDECL void   VCP_stop();
IDECL void   VCP_reset();

IDECL Uint32 VCP_getMinSm();
IDECL Uint32 VCP_getMaxSm();
IDECL Uint32 VCP_getYamBit();
IDECL Uint32 VCP_getIndexState();

IDECL Uint32 VCP_statPause();
IDECL Uint32 VCP_statRun();
IDECL Uint32 VCP_statError();
IDECL Uint32 VCP_statWaitIc();
IDECL Uint32 VCP_statInFifo();
IDECL Uint32 VCP_statOutFifo();

IDECL Uint32 VCP_statSymProc();
IDECL Uint32 VCP_getNumOutFifo();
IDECL Uint32 VCP_getNumInFifo();

IDECL Uint32 VCP_errTest();

IDECL Uint32 VCP_getBmEndian();
IDECL Uint32 VCP_getSdEndian();

IDECL void   VCP_setNativeEndian();
IDECL void   VCP_setPacked32Endian();
IDECL void   VCP_setBmEndian(Uint32 bmEnd);
IDECL void   VCP_setSdEndian(Uint32 sdEnd);

IDECL void VCP_icConfig(VCP_ConfigIc *config);
IDECL void VCP_icConfigArgs(Uint32 ic0, Uint32 ic1, Uint32 ic2,  Uint32 ic3,
                            Uint32 ic4, Uint32 ic5);
IDECL void VCP_getIcConfig(VCP_ConfigIc *config);

/* Ceiling functions */
IDECL Uint32 VCP_ceil(Uint32 a, Uint32 b);

IDECL Uint32 VCP_normalCeil(Uint32 a, Uint32 b);

/****************************************\
* VCP inline function definitions
\****************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void VCP_start(){
   VCP_FSET(EXE,COMMAND,1) ;  
}
/*----------------------------------------------------------------------------*/
IDEF void VCP_pause(){
  VCP_FSET(EXE,COMMAND,2);
}
/*----------------------------------------------------------------------------*/
IDEF void VCP_unpause(){
  VCP_FSET(EXE,COMMAND,4);
}
/*----------------------------------------------------------------------------*/
IDEF void VCP_stop(){
   VCP_FSET(EXE,COMMAND,5) ;  
}
/*----------------------------------------------------------------------------*/
IDEF void VCP_reset(){
  VCP_RSET(IC0,VCP_IC0_DEFAULT);
  VCP_RSET(IC1,VCP_IC1_DEFAULT);
  VCP_RSET(IC2,VCP_IC2_DEFAULT);
  VCP_RSET(IC3,VCP_IC3_DEFAULT);
  VCP_RSET(IC4,VCP_IC4_DEFAULT);
  VCP_RSET(IC5,VCP_IC5_DEFAULT);
  VCP_RSET(EXE,VCP_EXE_DEFAULT);
  VCP_RSET(END,VCP_END_DEFAULT);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_getMinSm(){
  return VCP_FGET(OUT0,FMINS);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_getMaxSm(){
  return VCP_FGET(OUT0,FMAXS);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_getYamBit(){
  return VCP_FGET(OUT1,YAM);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_getIndexState(){
  return VCP_FGET(OUT1,FMAXI);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_statPause(){
  return VCP_FGET(STAT0,PAUS);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_statRun(){
  return VCP_FGET(STAT0,RUN);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_statError(){
  return VCP_FGET(STAT0,ERR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_statWaitIc(){
  return VCP_FGET(STAT0,WIC);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_statInFifo(){
  return VCP_FGET(STAT0,IFEMP);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_statOutFifo(){
  return VCP_FGET(STAT0,OFFUL);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_statSymProc(){
  return VCP_FGET(STAT0,NSYM);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_getNumOutFifo(){
  return VCP_FGET(STAT1,NSYMOF);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_getNumInFifo(){
  return VCP_FGET(STAT1,NSYMIF);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_errTest(){
  return VCP_FGET(ERR,ERROR);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_getBmEndian(){
  return VCP_FGET(END,BM);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VCP_getSdEndian(){
  return VCP_FGET(END,SD);
}
/*----------------------------------------------------------------------------*/
IDEF void   VCP_setNativeEndian(){
  VCP_FSET(END,BM,VCP_END_BM_NATIVE);
  VCP_FSET(END,SD,VCP_END_SD_NATIVE);
}
/*----------------------------------------------------------------------------*/
IDEF void   VCP_setPacked32Endian(){
  VCP_FSET(END,BM,VCP_END_BM_32BIT);
  VCP_FSET(END,SD,VCP_END_SD_32BIT);
}
/*----------------------------------------------------------------------------*/
IDEF void   VCP_setBmEndian(Uint32 bmEnd){
  VCP_FSET(END,BM,bmEnd);
}
/*----------------------------------------------------------------------------*/
IDEF void   VCP_setSdEndian(Uint32 sdEnd){
  VCP_FSET(END,SD,sdEnd);
}
/*----------------------------------------------------------------------------*/
IDEF void VCP_icConfig(VCP_ConfigIc *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _VCP_BASE_IC;
  register int x0,x1,x2,x3,x4,x5;

  gie = IRQ_globalDisable();

   x0 = config->ic0;
   x1 = config->ic1;
   x2 = config->ic2;
   x3 = config->ic3;
   x4 = config->ic4;
   x5 = config->ic5;
  
  base[_VCP_IC0_OFFSET]  = x0;
  base[_VCP_IC1_OFFSET]  = x1;
  base[_VCP_IC2_OFFSET]  = x2;
  base[_VCP_IC3_OFFSET]  = x3;
  base[_VCP_IC4_OFFSET]  = x4;
  base[_VCP_IC5_OFFSET]  = x5;
  
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void VCP_icConfigArgs(Uint32 ic0, Uint32 ic1, Uint32 ic2, Uint32 ic3, Uint32 ic4,
                           Uint32 ic5) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _VCP_BASE_IC;

  gie = IRQ_globalDisable();
  
  base[_VCP_IC0_OFFSET]  = ic0;
  base[_VCP_IC1_OFFSET]  = ic1;
  base[_VCP_IC2_OFFSET]  = ic2;
  base[_VCP_IC3_OFFSET]  = ic3;
  base[_VCP_IC4_OFFSET]  = ic4;
  base[_VCP_IC5_OFFSET]  = ic5;
  
  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void VCP_getIcConfig(VCP_ConfigIc *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *) _VCP_BASE_IC;
  register int x0,x1,x2,x3,x4,x5;

  gie = IRQ_globalDisable();

   x0 = base[_VCP_IC0_OFFSET];
   x1 = base[_VCP_IC1_OFFSET];
   x2 = base[_VCP_IC2_OFFSET];
   x3 = base[_VCP_IC3_OFFSET];
   x4 = base[_VCP_IC4_OFFSET];
   x5 = base[_VCP_IC5_OFFSET];
  
  config->ic0  =  x0;
  config->ic1  =  x1;
  config->ic2  =  x2;
  config->ic3  =  x3;
  config->ic4  =  x4;
  config->ic5  =  x5;
  
  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/

IDEF Uint32 VCP_ceil(Uint32 val, Uint32 pwr2) {
  Uint32 gie;
  Uint32 x;
  
  gie = IRQ_globalDisable();

  /* x^pwr2 = ceil(val, 2^pwr2) */
  /* val is increased (if necessary) to be a multiple of 2^pwr2 */
  x = (((val) - (((val)>>(pwr2)) << (pwr2))) == 0) ?                           \
      ((val)>>(pwr2)):(((val)>>(pwr2))+1);
  
  IRQ_globalRestore(gie);

  return(x);
}

/*----------------------------------------------------------------------------*/

IDEF Uint32 VCP_normalCeil(Uint32 val1, Uint32 val2) {
  Uint32 gie;
  Uint32 x;
  
  gie = IRQ_globalDisable();

  /* x = ceil(val1, val2) */
  /* val is increased (if necessary) to be a multiple of val2 */
  x = ( ((val1)%(val2))!=0  )?( ((val1)/(val2)) + 1 ):((val1)/(val2));
  
  IRQ_globalRestore(gie);

  return(x);
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */

#endif /* VCP_SUPPORT */
#endif /* _CSL_VCP_H_ */
/******************************************************************************\
* End of csl_vcp.h
\******************************************************************************/


csl_vcphal.h/   1092218725  0     0     0       27426     `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vcphal.h
* DATE CREATED.. 02/21/2001 
* LAST MODIFIED. 08/02/2004 - Adding support for C6418
*                04/17/2003
*------------------------------------------------------------------------------
* REGISTERS
*
* IC0   - VCP input configuration register  0
* IC1   - VCP input configuration register  1
* IC2   - VCP input configuration register  2
* IC3   - VCP input configuration register  3
* IC4   - VCP input configuration register  4
* IC5   - VCP input configuration register  5
* EXE   - VCP execution register 
* END   - VCP endian mode register
* OUT0   - VCP output parameters register   0
* OUT1   - VCP output parameters register   1
* STAT0  - VCP status register 0
* STAT1  - VCP status register 1
* ERR   - VCP error register
*
*------------------------------------------------------------------------------
* MEMORY REGIONS
*
* ICMEM - VCP interrupt configuration register space
* OPMEM - VCP output parameter register space
* BMMEM - VCP systematics and parities memory
* HDMEM - VCP hard decisions memory
*
******************************************************************************
*Corrections Made 04/17/2003
*#define  VCP_OPMEM_ADDR           0x50000048u	VCPOUT0	VCP Output Register 0 //Correction was 0x50000024u
*#define _VCP_IC4_IMINS_MASK       0x0FFF0000u	//Correction was 0x00FF0000u
*#define _VCP_IC4_IMAXS_MASK       0x00000FFFu	//Correction was 0x000000FFu
*#define  VCP_IC5_SDHD_SOFT        0x00000001u	//Correction was 0
*#define  VCP_IC5_SDHD_HARD        0x00000000u	//Correction was 1
*#define _VCP_OUT0_ADDR            0x01B80048u	//Correction was 0x01B80024u
*#define _VCP_OUT0_FMINS_MASK      0x0FFF0000u	//Correction was 0x00FF0000u
*#define _VCP_OUT0_FMAXS_MASK      0x00000FFFu	//Correction was 0x00000FFFu
*#define _VCP_ERR_ERROR_MASK       0x00000007u	//Correction was 0x00000400u
*#define _VCP_ERR_ERROR_SHIFT      0x00000000u	//Correction was 0x0000000Au
*#define _VCP_STAT0_NSYM_MASK      0xFFFF0000u
*#define _VCP_STAT0_NSYM_SHIFT     0x00000010u
*#define _VCP_OUT1_FMAXI_MASK      0x00000FFFu	//Correction was 0x00000FFFu
*#define _VCP_OUT1_ADDR            0x01B8004Cu	//Correction was 0x01B80028
\*******************************************************************************/
#ifndef _CSL_VCPHAL_H_
#define _CSL_VCPHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (VCP_SUPPORT)
/******************************************************************************\
* Memory section
\******************************************************************************/

  #define _VCP_BASE_IC               0x01B80000u	/*VCPIC0	VCP Input Configuration Reg 0 Config bus*/
  #define  VCP_ICMEM_ADDR            0x50000000u	/*VCPIC0	VCP Input Configuration Reg 0 EDMA bus*/
  #define  VCP_OPMEM_ADDR            0x50000048u	/*VCPOUT0	VCP Output Register 0 Correction*/
  #define  VCP_BMMEM_ADDR            0x50000080u	/*VCPWBM	VCP Branch Metrics Write Register*/
  #define  VCP_HDMEM_ADDR            0x50000088u	/*VCPRDECS	VCP Decisions Read Register*/


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define VCP_FMK(REG,FIELD,x)\
    _PER_FMK(VCP,##REG,##FIELD,x)

  #define VCP_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(VCP,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define VCP_ADDR(REG)\
    _VCP_##REG##_ADDR

  #define VCP_RGET(REG)\
    _PER_RGET(_VCP_##REG##_ADDR,VCP,##REG)

  #define VCP_RSET(REG,x)\
    _PER_RSET(_VCP_##REG##_ADDR,VCP,##REG,x)

  #define VCP_FGET(REG,FIELD)\
    _VCP_##REG##_FGET(##FIELD)

  #define VCP_FSET(REG,FIELD,x)\
    _VCP_##REG##_FSET(##FIELD,##x)

  #define VCP_FSETS(REG,FIELD,SYM)\
    _VCP_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define VCP_RGETA(addr,REG)\
    _PER_RGET(addr,VCP,##REG)

  #define VCP_RSETA(addr,REG,x)\
    _PER_RSET(addr,VCP,##REG,x)

  #define VCP_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,VCP,##REG,##FIELD)

  #define VCP_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,VCP,##REG,##FIELD,x)

  #define VCP_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,VCP,##REG,##FIELD,##SYM)


  /* ----------------------------------------- */
  /* HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define VCP_ADDRH(h,REG)\
    (Uint32)(&((h)->baseAddr[_VCP_##REG##_OFFSET]))

  #define VCP_RGETH(h,REG)\
    VCP_RGETA(VCP_ADDRH(h,##REG),##REG)


  #define VCP_RSETH(h,REG,x)\
    VCP_RSETA(VCP_ADDRH(h,##REG),##REG,x)


  #define VCP_FGETH(h,REG,FIELD)\
    VCP_FGETA(VCP_ADDRH(h,##REG),##REG,##FIELD)


  #define VCP_FSETH(h,REG,FIELD,x)\
    VCP_FSETA(VCP_ADDRH(h,##REG),##REG,##FIELD,x)


  #define VCP_FSETSH(h,REG,FIELD,SYM)\
    VCP_FSETSA(VCP_ADDRH(h,##REG),##REG,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  I C 0            |
* |___________________|
*
* VCP input configuration register  0
*
* FIELDS (msb -> lsb)
* (rw) POLY3
* (rw) POLY2
* (rw) POLY1
* (rw) POLY0
*
\******************************************************************************/
  #define _VCP_IC0_OFFSET            0

  #define _VCP_IC0_ADDR              0x01B80000u

  #define _VCP_IC0_POLY3_MASK        0xFF000000u
  #define _VCP_IC0_POLY3_SHIFT       0x00000018u
  #define  VCP_IC0_POLY3_DEFAULT     0x00000000u
  #define  VCP_IC0_POLY3_OF(x)       _VALUEOF(x)

  #define _VCP_IC0_POLY2_MASK        0x00FF0000u
  #define _VCP_IC0_POLY2_SHIFT       0x00000010u
  #define  VCP_IC0_POLY2_DEFAULT     0x00000000u
  #define  VCP_IC0_POLY2_OF(x)       _VALUEOF(x)

  #define _VCP_IC0_POLY1_MASK        0x0000FF00u
  #define _VCP_IC0_POLY1_SHIFT       0x00000008u
  #define  VCP_IC0_POLY1_DEFAULT     0x00000000u
  #define  VCP_IC0_POLY1_OF(x)       _VALUEOF(x)

  #define _VCP_IC0_POLY0_MASK        0x000000FFu
  #define _VCP_IC0_POLY0_SHIFT       0x00000000u
  #define  VCP_IC0_POLY0_DEFAULT     0x00000000u
  #define  VCP_IC0_POLY0_OF(x)       _VALUEOF(x)

  #define  VCP_IC0_OF(x)             _VALUEOF(x)

  #define VCP_IC0_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,IC0,POLY3)\
   |_PER_FDEFAULT(VCP,IC0,POLY2)\
   |_PER_FDEFAULT(VCP,IC0,POLY1)\
   |_PER_FDEFAULT(VCP,IC0,POLY0)\
  )

  #define VCP_IC0_RMK(poly3,poly2,poly1,poly0) (Uint32)(\
     _PER_FMK(VCP,IC0,POLY3,poly3)\
    |_PER_FMK(VCP,IC0,POLY2,poly2)\
    |_PER_FMK(VCP,IC0,POLY1,poly1)\
    |_PER_FMK(VCP,IC0,POLY0,poly0)\
  )

  #define _VCP_IC0_FGET(FIELD)\
    _PER_FGET(_VCP_IC0_ADDR,VCP,IC0,##FIELD)

  #define _VCP_IC0_FSET(FIELD,field)\
    _PER_FSET(_VCP_IC0_ADDR,VCP,IC0,##FIELD,field)

  #define _VCP_IC0_FSETS(FIELD,SYM)\
    _PER_FSETS(_VCP_IC0_ADDR,VCP,IC0,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 1            |
* |___________________|
*
* VCP input configuration register  1
*
* FIELDS (msb -> lsb)
* (rw) YAMEN
* (rw) YAMT
* (rw) ZERO
*
\******************************************************************************/
  #define _VCP_IC1_OFFSET            1

  #define _VCP_IC1_ADDR              0x01B80004u

  #define _VCP_IC1_YAMEN_MASK        0x10000000u
  #define _VCP_IC1_YAMEN_SHIFT       0x0000001Cu
  #define  VCP_IC1_YAMEN_DEFAULT     0x00000000u
  #define  VCP_IC1_YAMEN_OF(x)       _VALUEOF(x)
  #define  VCP_IC1_YAMEN_DISABLE     0x00000000u
  #define  VCP_IC1_YAMEN_ENABLE      0x00000001u

  #define _VCP_IC1_YAMT_MASK        0x0FFF0000u
  #define _VCP_IC1_YAMT_SHIFT       0x00000010u
  #define  VCP_IC1_YAMT_DEFAULT     0x00000000u
  #define  VCP_IC1_YAMT_OF(x)       _VALUEOF(x)

  #define _VCP_IC1_ZERO_MASK         0x0000FFFFu
  #define _VCP_IC1_ZERO_SHIFT        0x00000000u
  #define  VCP_IC1_ZERO_DEFAULT      0x00000000u
  #define  VCP_IC1_ZERO_OF(x)        _VALUEOF(x)
  #define  VCP_IC1_ZERO_ZEROS        0x00000000u

  #define  VCP_IC1_OF(x)             _VALUEOF(x)

  #define VCP_IC1_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,IC1,YAMEN)\
   |_PER_FDEFAULT(VCP,IC1,YAMT)\
   |_PER_FDEFAULT(VCP,IC1,ZERO)\
  )

  #define VCP_IC1_RMK(yamen,yamt,zero) (Uint32)(\
     _PER_FMK(VCP,IC1,YAMEN,yamen)\
    |_PER_FMK(VCP,IC1,YAMT,yamt)\
    |_PER_FMK(VCP,IC1,ZERO,zero)\
  )

  #define _VCP_IC1_FGET(FIELD)\
    _PER_FGET(_VCP_IC1_ADDR,VCP,IC1,##FIELD)

  #define _VCP_IC1_FSET(FIELD,field)\
    _PER_FSET(_VCP_IC1_ADDR,VCP,IC1,##FIELD,field)

  #define _VCP_IC1_FSETS(FIELD,SYM)\
    _PER_FSETS(_VCP_IC1_ADDR,VCP,IC1,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 2            |
* |___________________|
*
* VCP input configuration register  2
*
* FIELDS (msb -> lsb)
* (rw) R
* (rw) F
*
\******************************************************************************/
  #define _VCP_IC2_OFFSET            2

  #define _VCP_IC2_ADDR              0x01BA0008u

  #define _VCP_IC2_R_MASK        0xFFFF0000u
  #define _VCP_IC2_R_SHIFT       0x00000010u
  #define  VCP_IC2_R_DEFAULT     0x00000000u
  #define  VCP_IC2_R_OF(x)       _VALUEOF(x)

  #define _VCP_IC2_FL_MASK       0x0000FFFFu
  #define _VCP_IC2_FL_SHIFT      0x00000000u
  #define  VCP_IC2_FL_DEFAULT    0x00000000u
  #define  VCP_IC2_FL_OF(x)      _VALUEOF(x)

  #define  VCP_IC2_OF(x)             _VALUEOF(x)

  #define VCP_IC2_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,IC2,R)\
   |_PER_FDEFAULT(VCP,IC2,FL)\
  )

  #define VCP_IC2_RMK(r,fl) (Uint32)(\
     _PER_FMK(VCP,IC2,R,r)\
    |_PER_FMK(VCP,IC2,FL,fl)\
  )

  #define _VCP_IC2_FGET(FIELD)\
    _PER_FGET(_VCP_IC2_ADDR,VCP,IC2,##FIELD)

  #define _VCP_IC2_FSET(FIELD,field)\
    _PER_FSET(_VCP_IC2_ADDR,VCP,IC2,##FIELD,field)

  #define _VCP_IC2_FSETS(FIELD,SYM)\
    _PER_FSETS(_VCP_IC2_ADDR,VCP,IC2,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 3            |
* |___________________|
*
* VCP input configuration register  3
*
* FIELDS (msb -> lsb)
* (rw) C
*
\******************************************************************************/
  #define _VCP_IC3_OFFSET            3

  #define _VCP_IC3_ADDR              0x01BA000Cu

  #define _VCP_IC3_C_MASK       0x0000FFFFu
  #define _VCP_IC3_C_SHIFT      0x00000000u
  #define  VCP_IC3_C_DEFAULT    0x00000000u
  #define  VCP_IC3_C_OF(x)      _VALUEOF(x)

  #define  VCP_IC3_OF(x)             _VALUEOF(x)

  #define VCP_IC3_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,IC3,C)\
  )

  #define VCP_IC3_RMK(c) (Uint32)(\
     _PER_FMK(VCP,IC3,C,c)\
  )

  #define _VCP_IC3_FGET(FIELD)\
    _PER_FGET(_VCP_IC3_ADDR,VCP,IC3,##FIELD)

  #define _VCP_IC3_FSET(FIELD,field)\
    _PER_FSET(_VCP_IC3_ADDR,VCP,IC3,##FIELD,field)

  #define _VCP_IC3_FSETS(FIELD,SYM)\
    _PER_FSETS(_VCP_IC3_ADDR,VCP,IC3,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 4            |
* |___________________|
*
* VCP input configuration register  4
*
* FIELDS (msb -> lsb)
* (rw) IMINS
* (rw) IMAXS
*
\******************************************************************************/
  #define _VCP_IC4_OFFSET            4

  #define _VCP_IC4_ADDR              0x01BA0010u

  #define _VCP_IC4_IMINS_MASK         0x0FFF0000u	/*Correction*/
  #define _VCP_IC4_IMINS_SHIFT        0x00000010u
  #define  VCP_IC4_IMINS_DEFAULT      0x00000000u
  #define  VCP_IC4_IMINS_OF(x)        _VALUEOF(x)

  #define _VCP_IC4_IMAXS_MASK          0x00000FFFu	/*Correction*/
  #define _VCP_IC4_IMAXS_SHIFT         0x00000000u
  #define  VCP_IC4_IMAXS_DEFAULT       0x00000000u
  #define  VCP_IC4_IMAXS_OF(x)         _VALUEOF(x)

  #define  VCP_IC4_OF(x)             _VALUEOF(x)

  #define VCP_IC4_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,IC4,IMINS)\
   |_PER_FDEFAULT(VCP,IC4,IMAXS)\
  )

  #define VCP_IC4_RMK(imins,imaxs) (Uint32)(\
     _PER_FMK(VCP,IC4,IMINS,imins)\
    |_PER_FMK(VCP,IC4,IMAXS,imaxs)\
  )

  #define _VCP_IC4_FGET(FIELD)\
    _PER_FGET(_VCP_IC4_ADDR,VCP,IC4,##FIELD)

  #define _VCP_IC4_FSET(FIELD,field)\
    _PER_FSET(_VCP_IC4_ADDR,VCP,IC4,##FIELD,field)

  #define _VCP_IC4_FSETS(FIELD,SYM)\
    _PER_FSETS(_VCP_IC4_ADDR,VCP,IC4,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  I C 5            |
* |___________________|
*
* VCP input configuration register  5
*
* FIELDS (msb -> lsb)
* (rw) SDHD
* (rw) OUTF
* (rw) TB
* (rw) SYMR
* (rw) SYMX
* (rw) IMAXI
*
\******************************************************************************/
  #define _VCP_IC5_OFFSET            5

  #define _VCP_IC5_ADDR              0x01BA0014u

  #define _VCP_IC5_SDHD_MASK        0x80000000u
  #define _VCP_IC5_SDHD_SHIFT       0x0000001Fu
  #define  VCP_IC5_SDHD_DEFAULT     0x00000000u
  #define  VCP_IC5_SDHD_OF(x)       _VALUEOF(x)
  #define  VCP_IC5_SDHD_SOFT        0x00000001u	/*Correction was 0*/
  #define  VCP_IC5_SDHD_HARD        0x00000000u	/*Correction was 1*/

  #define _VCP_IC5_OUTF_MASK        0x40000000u
  #define _VCP_IC5_OUTF_SHIFT       0x0000001Eu
  #define  VCP_IC5_OUTF_DEFAULT     0x00000000u
  #define  VCP_IC5_OUTF_OF(x)       _VALUEOF(x)
  #define  VCP_IC5_OUTF_NO          0x00000000u
  #define  VCP_IC5_OUTF_YES         0x00000001u

  #define _VCP_IC5_TB_MASK        0x03000000u
  #define _VCP_IC5_TB_SHIFT       0x00000018u
  #define  VCP_IC5_TB_DEFAULT     0x00000000u
  #define  VCP_IC5_TB_OF(x)       _VALUEOF(x)
  #define  VCP_IC5_TB_NO          0x00000000u
  #define  VCP_IC5_TB_TAIL        0x00000001u
  #define  VCP_IC5_TB_CONV        0x00000002u
  #define  VCP_IC5_TB_MIX         0x00000003u

  #define _VCP_IC5_SYMR_MASK        0x00F00000u
  #define _VCP_IC5_SYMR_SHIFT       0x00000014u
  #define  VCP_IC5_SYMR_DEFAULT     0x00000000u
  #define  VCP_IC5_SYMR_OF(x)       _VALUEOF(x)

  #define _VCP_IC5_SYMX_MASK        0x000F0000u
  #define _VCP_IC5_SYMX_SHIFT       0x00000010u
  #define  VCP_IC5_SYMX_DEFAULT     0x00000000u
  #define  VCP_IC5_SYMX_OF(x)       _VALUEOF(x)

  #define _VCP_IC5_IMAXI_MASK        0x000000FFu
  #define _VCP_IC5_IMAXI_SHIFT       0x00000000u
  #define  VCP_IC5_IMAXI_DEFAULT     0x00000000u
  #define  VCP_IC5_IMAXI_OF(x)       _VALUEOF(x)

  #define  VCP_IC5_OF(x)             _VALUEOF(x)

  #define VCP_IC5_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,IC5,SDHD)\
   |_PER_FDEFAULT(VCP,IC5,OUTF)\
   |_PER_FDEFAULT(VCP,IC5,TB)\
   |_PER_FDEFAULT(VCP,IC5,SYMR)\
   |_PER_FDEFAULT(VCP,IC5,SYMX)\
   |_PER_FDEFAULT(VCP,IC5,IMAXI)\
   |_PER_FDEFAULT(VCP,IC5,IMAXI)\
  )

  #define VCP_IC5_RMK(sdhd,outf,tb,symr,symx,imaxi) (Uint32)(\
     _PER_FMK(VCP,IC5,SDHD,sdhd)\
    |_PER_FMK(VCP,IC5,OUTF,outf)\
    |_PER_FMK(VCP,IC5,TB,tb)\
    |_PER_FMK(VCP,IC5,SYMR,symr)\
    |_PER_FMK(VCP,IC5,SYMX,symx)\
    |_PER_FMK(VCP,IC5,IMAXI,imaxi)\
  )

  #define _VCP_IC5_FGET(FIELD)\
    _PER_FGET(_VCP_IC5_ADDR,VCP,IC5,##FIELD)

  #define _VCP_IC5_FSET(FIELD,field)\
    _PER_FSET(_VCP_IC5_ADDR,VCP,IC5,##FIELD,field)

  #define _VCP_IC5_FSETS(FIELD,SYM)\
    _PER_FSETS(_VCP_IC5_ADDR,VCP,IC5,FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  E X E            |
* |___________________|
*
* VCP execution register
*
* FIELDS (msb -> lsb)
* (rw) COMMAND
*
\******************************************************************************/
  #define _VCP_EXE_OFFSET            6

  #define _VCP_EXE_ADDR              0x01B80018u

  #define _VCP_EXE_COMMAND_MASK      0x000000FFu
  #define _VCP_EXE_COMMAND_SHIFT     0x00000000u
  #define  VCP_EXE_COMMAND_DEFAULT   0x00000000u
  #define  VCP_EXE_COMMAND_OF(x)     _VALUEOF(x)
  #define  VCP_EXE_COMMAND_START     0x00000001u
  #define  VCP_EXE_COMMAND_PAUSE     0x00000002u
  #define  VCP_EXE_COMMAND_UNPAUSE   0x00000004u
  #define  VCP_EXE_COMMAND_STOP      0x00000005u

  #define  VCP_EXE_OF(x)             _VALUEOF(x)

  #define VCP_EXE_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,EXE,COMMAND)\
  )

  #define VCP_EXE_RMK(command) (Uint32)(\
     _PER_FMK(VCP,EXE,COMMAND,command)\
  )

  #define _VCP_EXE_FGET(FIELD)\
    _PER_FGET(_VCP_EXE_ADDR,VCP,EXE,##FIELD)

  #define _VCP_EXE_FSET(FIELD,field)\
    _PER_FSET(_VCP_EXE_ADDR,VCP,EXE,##FIELD,field)

  #define _VCP_EXE_FSETS(FIELD,SYM)\
    _PER_FSETS(_VCP_EXE_ADDR,VCP,EXE,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  E N D            |
* |___________________|
*
* VCP endian mode register
*
* FIELDS (msb -> lsb)
* (rw) SD
* (rw) BM
*
\******************************************************************************/
  #define _VCP_END_OFFSET            8

  #define _VCP_END_ADDR              0x01B80020u

  #define _VCP_END_SD_MASK          0x00000002u
  #define _VCP_END_SD_SHIFT         0x00000001u
  #define  VCP_END_SD_DEFAULT       0x00000000u
  #define  VCP_END_SD_OF(x)         _VALUEOF(x)
  #define  VCP_END_SD_32BIT         0x00000000u
  #define  VCP_END_SD_NATIVE        0x00000001u

  #define _VCP_END_BM_MASK          0x00000001u
  #define _VCP_END_BM_SHIFT         0x00000000u
  #define  VCP_END_BM_DEFAULT       0x00000000u
  #define  VCP_END_BM_OF(x)         _VALUEOF(x)
  #define  VCP_END_BM_32BIT         0x00000000u
  #define  VCP_END_BM_NATIVE        0x00000001u

 

  #define  VCP_END_OF(x)             _VALUEOF(x)

  #define VCP_END_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,END,SD)\
   |_PER_FDEFAULT(VCP,END,BM)\
  )

  #define VCP_END_RMK(sd,bm) (Uint32)(\
     _PER_FMK(VCP,END,SD,sd)\
    |_PER_FMK(VCP,END,BM,bm)\
  )

  #define _VCP_END_FGET(FIELD)\
    _PER_FGET(_VCP_END_ADDR,VCP,END,##FIELD)

  #define _VCP_END_FSET(FIELD,field)\
    _PER_FSET(_VCP_END_ADDR,VCP,END,##FIELD,field)

  #define _VCP_END_FSETS(FIELD,SYM)\
    _PER_FSETS(_VCP_END_ADDR,VCP,END,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  O U T 0          |
* |___________________|
*
* VCP output parameters register 0
*
* FIELDS (msb -> lsb)
* (r) FMINS
* (r) FMAXS
*
\******************************************************************************/
  #define _VCP_OUT0_OFFSET            9

  #define _VCP_OUT0_ADDR              0x01B80048u	/*Correction was 0x01B80024*/

  #define _VCP_OUT0_FMINS_MASK         0x0FFF0000u	/*Correction was 0x00FF0000u*/
  #define _VCP_OUT0_FMINS_SHIFT        0x00000010u
  #define  VCP_OUT0_FMINS_DEFAULT      0x00000000u
  #define  VCP_OUT0_FMINS_OF(x)        _VALUEOF(x)

  #define _VCP_OUT0_FMAXS_MASK          0x00000FFFu	/*Correction was 0x000000FFu*/
  #define _VCP_OUT0_FMAXS_SHIFT         0x00000000u
  #define  VCP_OUT0_FMAXS_DEFAULT       0x00000000u
  #define  VCP_OUT0_FMAXS_OF(x)         _VALUEOF(x)

  #define  VCP_OUT0_OF(x)             _VALUEOF(x)

  #define VCP_OUT0_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,OUT0,FMINS)\
   |_PER_FDEFAULT(VCP,OUT0,FMAXS)\
  )
  #if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
    #define VCP_OUT0_RMK(fmins,fmaxs)(Uint32)(\
       _PER_FMK(VCP,OUT0,FMINS,fmins)\
      |_PER_FMK(VCP,OUT0,FMAXS,fmaxs)\
    )
  #endif 

  #define _VCP_OUT0_FGET(FIELD)\
    _PER_FGET(_VCP_OUT0_ADDR,VCP,OUT0,##FIELD)

/******************************************************************************\
* _____________________
* |                   |
* |  O U T 1          |
* |___________________|
*
* VCP output parameters register 1
*
* FIELDS (msb -> lsb)
* (r) YAM
* (r) FMAXI
*
\******************************************************************************/
  #define _VCP_OUT1_OFFSET            10

  #define _VCP_OUT1_ADDR              0x01B8004Cu	/*Correction was 0x01B80028*/

  #define _VCP_OUT1_YAM_MASK          0x00010000u
  #define _VCP_OUT1_YAM_SHIFT         0x00000010u
  #define  VCP_OUT1_YAM_DEFAULT       0x00000000u
  #define  VCP_OUT1_YAM_OF(x)         _VALUEOF(x)
  #define  VCP_OUT1_YAM_NO            0x00000000u
  #define  VCP_OUT1_YAM_YES           0x00000001u

  #define _VCP_OUT1_FMAXI_MASK          0x00000FFFu	/*Correction was 0x00000FFFu*/
  #define _VCP_OUT1_FMAXI_SHIFT         0x00000000u
  #define  VCP_OUT1_FMAXI_DEFAULT       0x00000000u
  #define  VCP_OUT1_FMAXI_OF(x)         _VALUEOF(x)

  #define  VCP_OUT1_OF(x)             _VALUEOF(x)

  #define VCP_OUT1_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,OUT1,YAM)\
   |_PER_FDEFAULT(VCP,OUT1,FMAXI)\
  )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define VCP_OUT1_RMK(yam,fmaxi) (Uint32)(\
     _PER_FMK(VCP,OUT1,YAM,yam)\
    |_PER_FMK(VCP,OUT1,FMAXI,fmaxi)\
  )    
#endif  
  #define _VCP_OUT1_FGET(FIELD)\
    _PER_FGET(_VCP_OUT1_ADDR,VCP,OUT1,##FIELD)

/******************************************************************************\
* _____________________
* |                   |
* |  S T A T 0        |
* |___________________|
*
* VCP status register 0
*
* FIELDS (msb -> lsb)
* (r) NSYM
* (r) OFFUL
* (r) IFEMP
* (r) WIC
* (r) ERR
* (r) RUN
* (r) PAUS
*
\******************************************************************************/
  #define _VCP_STAT0_OFFSET         16

  #define _VCP_STAT0_ADDR           0x01B80040u

  #define _VCP_STAT0_NSYM_MASK      0xFFFF0000u
  #define _VCP_STAT0_NSYM_SHIFT     0x00000010u
  #define  VCP_STAT0_NSYM_DEFAULT   0x00000000u
  #define  VCP_STAT0_NSYM_OF(x)     _VALUEOF(x)

  #define _VCP_STAT0_OFFUL_MASK       0x00000020u
  #define _VCP_STAT0_OFFUL_SHIFT      0x00000005u
  #define  VCP_STAT0_OFFUL_DEFAULT    0x00000000u
  #define  VCP_STAT0_OFFUL_OF(x)      _VALUEOF(x)
  #define  VCP_STAT0_OFFUL_NO         0x00000000u
  #define  VCP_STAT0_OFFUL_YES        0x00000001u

  #define _VCP_STAT0_IFEMP_MASK       0x00000010u
  #define _VCP_STAT0_IFEMP_SHIFT      0x00000004u
  #define  VCP_STAT0_IFEMP_DEFAULT    0x00000000u
  #define  VCP_STAT0_IFEMP_OF(x)      _VALUEOF(x)
  #define  VCP_STAT0_IFEMP_NO         0x00000000u
  #define  VCP_STAT0_IFEMP_YES        0x00000001u

  #define _VCP_STAT0_WIC_MASK       0x00000008u
  #define _VCP_STAT0_WIC_SHIFT      0x00000003u
  #define  VCP_STAT0_WIC_DEFAULT    0x00000000u
  #define  VCP_STAT0_WIC_OF(x)      _VALUEOF(x)
  #define  VCP_STAT0_WIC_NO         0x00000000u
  #define  VCP_STAT0_WIC_YES        0x00000001u

  #define _VCP_STAT0_ERR_MASK       0x00000004u
  #define _VCP_STAT0_ERR_SHIFT      0x00000002u
  #define  VCP_STAT0_ERR_DEFAULT    0x00000000u
  #define  VCP_STAT0_ERR_OF(x)      _VALUEOF(x)
  #define  VCP_STAT0_ERR_NO         0x00000000u
  #define  VCP_STAT0_ERR_YES        0x00000001u

  #define _VCP_STAT0_RUN_MASK       0x00000002u
  #define _VCP_STAT0_RUN_SHIFT      0x00000001u
  #define  VCP_STAT0_RUN_DEFAULT    0x00000000u
  #define  VCP_STAT0_RUN_OF(x)      _VALUEOF(x)
  #define  VCP_STAT0_RUN_NO         0x00000000u
  #define  VCP_STAT0_RUN_YES        0x00000001u

  #define _VCP_STAT0_PAUS_MASK     0x00000001u
  #define _VCP_STAT0_PAUS_SHIFT    0x00000000u
  #define  VCP_STAT0_PAUS_DEFAULT  0x00000000u
  #define  VCP_STAT0_PAUS_OF(x)    _VALUEOF(x)
  #define  VCP_STAT0_PAUS_NO       0x00000000u
  #define  VCP_STAT0_PAUS_YES      0x00000001u

  #define  VCP_STAT0_OF(x)          _VALUEOF(x)

  #define VCP_STAT0_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,STAT0,NSYM)\
   |_PER_FDEFAULT(VCP,STAT0,OFFUL)\
   |_PER_FDEFAULT(VCP,STAT0,IFEMP)\
   |_PER_FDEFAULT(VCP,STAT0,WIC)\
   |_PER_FDEFAULT(VCP,STAT0,ERR)\
   |_PER_FDEFAULT(VCP,STAT0,RUN)\
   |_PER_FDEFAULT(VCP,STAT0,PAUS)\
  )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define VCP_STAT0_RMK(nsym,offul,ifemp,wic,err,run,paus) (Uint32)(\
     _PER_FMK(VCP,STAT0,NSYM,nsym)\
    |_PER_FMK(VCP,STAT0,OFFUL,offul)\
    |_PER_FMK(VCP,STAT0,IFEMP,ifemp)\
    |_PER_FMK(VCP,STAT0,WIC,wic)\
    |_PER_FMK(VCP,STAT0,ERR,err)\
    |_PER_FMK(VCP,STAT0,RUN,run)\
    |_PER_FMK(VCP,STAT0,PAUS,paus)\
   )  
#endif  
  #define _VCP_STAT0_FGET(FIELD)\
    _PER_FGET(_VCP_STAT0_ADDR,VCP,STAT0,##FIELD)

/******************************************************************************\
* _____________________
* |                   |
* |  S T A T 1        |
* |___________________|
*
* VCP status register 1
*
* FIELDS (msb -> lsb)
* (r) NSYMOF
* (r) NSYMIF
*
\******************************************************************************/
  #define _VCP_STAT1_OFFSET         17

  #define _VCP_STAT1_ADDR           0x01B80044u

  #define _VCP_STAT1_NSYMOF_MASK      0xFFFF0000u
  #define _VCP_STAT1_NSYMOF_SHIFT     0x00000010u
  #define  VCP_STAT1_NSYMOF_DEFAULT   0x00000000u
  #define  VCP_STAT1_NSYMOF_OF(x)     _VALUEOF(x)

  #define _VCP_STAT1_NSYMIF_MASK      0x0000FFFFu
  #define _VCP_STAT1_NSYMIF_SHIFT     0x00000000u
  #define  VCP_STAT1_NSYMIF_DEFAULT   0x00000000u
  #define  VCP_STAT1_NSYMIF_OF(x)     _VALUEOF(x)

  #define  VCP_STAT1_OF(x)          _VALUEOF(x)

  #define VCP_STAT1_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,STAT1,NSYMOF)\
   |_PER_FDEFAULT(VCP,STAT1,NSYMIF)\
  )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define VCP_STAT1_RMK(nsymof,nsymif) (Uint32)(\
     _PER_FMK(VCP,STAT1,NSYMOF,nsymof)\
    |_PER_FMK(VCP,STAT1,NSYMIF,nsymif)\
  )
#endif  
  #define _VCP_STAT1_FGET(FIELD)\
    _PER_FGET(_VCP_STAT1_ADDR,VCP,STAT1,##FIELD)

/******************************************************************************\
* _____________________
* |                   |
* |  E R R            |
* |___________________|
*
* VCP error register
*
* FIELDS (msb -> lsb)
* (r) ERROR
*
\******************************************************************************/
  #define _VCP_ERR_OFFSET          20

  #define _VCP_ERR_ADDR            0x01B80050u

  #define _VCP_ERR_ERROR_MASK      0x00000007u	/*Correction was 0x00000400u*/
  #define _VCP_ERR_ERROR_SHIFT     0x00000000u	/*Correction was 0x0000000Au*/
  #define  VCP_ERR_ERROR_DEFAULT   0x00000000u
  #define  VCP_ERR_ERROR_OF(x)     _VALUEOF(x)
  #define  VCP_ERR_ERROR_NO        0x00000000u
  #define  VCP_ERR_ERROR_TBNA      0x00000001u
  #define  VCP_ERR_ERROR_FTL       0x00000002u
  #define  VCP_ERR_ERROR_FCTL      0x00000003u

  #define  VCP_ERR_OF(x)           _VALUEOF(x)

  #define VCP_ERR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VCP,ERR,ERROR)\
  )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define VCP_ERR_RMK(error) (Uint32)(\
     _PER_FMK(VCP,ERR,ERROR,error)\
  )     
#endif  
  #define _VCP_ERR_FGET(FIELD)\
    _PER_FGET(_VCP_ERR_ADDR,VCP,ERR,##FIELD)

/*----------------------------------------------------------------------------*/
#endif /* VCP_SUPPORT) */
#endif /* _CSL_VCPHAL_H_ */
/******************************************************************************\
* End of csl_vcphal.h
\******************************************************************************/

csl_vic.h/      1052381253  0     0     0       4114      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vic.h
* DATE CREATED.. 02/21/2002 
* LAST MODIFIED. 
\******************************************************************************/
#ifndef _CSL_VIC_H_
#define _CSL_VIC_H_

#include <csl_chip.h>
#include <csl_vichal.h>


#if (VIC_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _VIC_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/


/******************************************************************************\
* global typedef declarations
\******************************************************************************/


/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/


/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 VIC_getPrecision();
IDECL Uint32 VIC_getGo();
IDECL Uint32 VIC_getInputBits();
IDECL Uint32 VIC_getClkDivider();
IDECL void VIC_setPrecision(Uint32 val);
IDECL void VIC_setGo(Uint32 val);
IDECL void VIC_setInputBits(Uint32 val);
IDECL void VIC_setClkDivider(Uint32 val);

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 VIC_getPrecision() {
  return VIC_FGET(VICCTL,PRECISION);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VIC_getGo() {
  return VIC_FGET(VICCTL,GO);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VIC_getInputBits() {
  return VIC_FGET(VICIN,VICINBITS);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VIC_getClkDivider() {
  return VIC_FGET(VICDIV,VICCLKDIV);
}
/*----------------------------------------------------------------------------*/
IDEF void VIC_setPrecision(Uint32 val) {
  VIC_FSET(VICCTL,PRECISION,val);
}
/*----------------------------------------------------------------------------*/
IDEF void VIC_setGo(Uint32 val) {
  VIC_FSET(VICCTL,GO,val);
}
/*----------------------------------------------------------------------------*/
IDEF void VIC_setInputBits(Uint32 val) {
  VIC_FSET(VICIN,VICINBITS,val);
}
/*----------------------------------------------------------------------------*/
IDEF void VIC_setClkDivider(Uint32 val) {
  VIC_FSET(VICDIV,VICCLKDIV,val);
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* VIC_SUPPORT */
#endif /* _CSL_VIC_H_ */
/******************************************************************************\
* End of csl_vic.h
\******************************************************************************/

csl_vichal.h/   1050408837  0     0     0       7215      `
/******************************************************************************\
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vichal.h
* DATE CREATED.. 02/06/2002 
* LAST MODIFIED. 02/06/2002 Initial Draft
*------------------------------------------------------------------------------
* REGISTERS
*
* VICCTL - VIC Control register
* VICIN  - VIC Input register 
* VICDIV - VIC Clock Dividor registrer
*
\******************************************************************************/
#ifndef _CSL_VICHAL_H_
#define _CSL_VICHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (VIC_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/

#define _VIC_BASE_ADDR         0x01C4C000u 

/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define VIC_FMK(REG,FIELD,x)\
    _PER_FMK(VIC,##REG,##FIELD,x)

  #define VIC_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(VIC,##REG,##FIELD,##SYM)
 
 
  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define VIC_ADDR(REG)\
    _VIC_##REG##_ADDR

  #define VIC_RGET(REG)\
    _PER_RGET(_VIC_##REG##_ADDR,VIC,##REG)

  #define VIC_RSET(REG,x)\
    _PER_RSET(_VIC_##REG##_ADDR,VIC,##REG,x)

  #define VIC_FGET(REG,FIELD)\
    _VIC_##REG##_FGET(##FIELD)

  #define VIC_FSET(REG,FIELD,x)\
    _VIC_##REG##_FSET(##FIELD,x)

  #define VIC_FSETS(REG,FIELD,SYM)\
    _VIC_##REG##_FSETS(##FIELD,##SYM)
 
 
  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define VIC_RGETA(addr,REG)\
    _PER_RGET(addr,VIC,##REG)

  #define VIC_RSETA(addr,REG,x)\
    _PER_RSET(addr,VIC,##REG,x)

  #define VIC_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,VIC,##REG,##FIELD)

  #define VIC_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,VIC,##REG,##FIELD,x)

  #define VIC_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,VIC,##REG,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  V I C C T L      |
* |___________________|
*
* VCICTL - VIC control register
*
* FIELDS (msb -> lsb)
* (rw)  PRECISION
* (rw)  GO
*
\******************************************************************************/
  #define _VIC_VICCTL_OFFSET             0
  #define _VIC_VICCTL_ADDR               (_VIC_BASE_ADDR + 4*_VIC_VICCTL_OFFSET) 

  #define _VIC_VICCTL_PRECISION_MASK         0x0000000Eu
  #define _VIC_VICCTL_PRECISION_SHIFT        0x00000001u
  #define  VIC_VICCTL_PRECISION_DEFAULT      0x00000000u
  #define  VIC_VICCTL_PRECISION_OF(x)        _VALUEOF(x)
  #define  VIC_VICCTL_PRECISION_16BITS       0x00000000u
  #define  VIC_VICCTL_PRECISION_15BITS       0x00000001u
  #define  VIC_VICCTL_PRECISION_14BITS       0x00000002u
  #define  VIC_VICCTL_PRECISION_13BITS       0x00000003u
  #define  VIC_VICCTL_PRECISION_12BITS       0x00000004u
  #define  VIC_VICCTL_PRECISION_11BITS       0x00000005u
  #define  VIC_VICCTL_PRECISION_10BITS       0x00000006u
  #define  VIC_VICCTL_PRECISION_9BITS        0x00000007u

  #define _VIC_VICCTL_GO_MASK                0x00000001u
  #define _VIC_VICCTL_GO_SHIFT               0x00000000u
  #define  VIC_VICCTL_GO_DEFAULT             0x00000000u
  #define  VIC_VICCTL_GO_OF(x)               _VALUEOF(x)
  #define  VIC_VICCTL_GO_0                   0x00000000u
  #define  VIC_VICCTL_GO_1                   0x00000001u

  #define  VIC_VICCTL_OF(x)              _VALUEOF(x)

  #define VIC_VICCTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(VIC,VICCTL,PRECISION) \
    |_PER_FDEFAULT(VIC,VICCTL,GO) \
  )

  #define VIC_VICCTL_RMK(precision,go) (Uint32)( \
     _PER_FMK(VIC,VICCTL,PRECISION,precision) \
    |_PER_FMK(VIC,VICCTL,GO,go) \
   )

  #define _VIC_VICCTL_FGET(FIELD)\
    _PER_FGET(_VIC_VICCTL_ADDR,VIC,VICCTL,##FIELD)

  #define _VIC_VICCTL_FSET(FIELD,field)\
    _PER_FSET(_VIC_VICCTL_ADDR,VIC,VICCTL,##FIELD,field)

  #define _VIC_VICCTL_FSETS(FIELD,SYM)\
    _PER_FSETS(_VIC_VICCTL_ADDR,VIC,VICCTL,##FIELD,##SYM)
/******************************************************************************\
* _____________________
* |                   |
* |  V I C I N        |
* |___________________|
*
* VICIN - VIC Input Register
*
* FIELDS (msb -> lsb)
* (rw)  VICINBITS
*
\******************************************************************************/

  #define _VIC_VICIN_OFFSET             1
  #define _VIC_VICIN_ADDR               (_VIC_BASE_ADDR + 4*_VIC_VICIN_OFFSET) 

  #define _VIC_VICIN_VICINBITS_MASK         0x0000FFFFu
  #define _VIC_VICIN_VICINBITS_SHIFT        0x00000000u
  #define  VIC_VICIN_VICINBITS_DEFAULT      0x00000000u
  #define  VIC_VICIN_VICINBITS_OF(x)        _VALUEOF(x)

  #define VIC_VICIN_DEFAULT (Uint32)( \
     _PER_FDEFAULT(VIC,VICIN,VICINBITS) \
  )

  #define VIC_VICIN_RMK(vicinbits) (Uint32)( \
     _PER_FMK(VIC,VICIN,VICINBITS,vicinbits) \
   )

  #define _VIC_VICIN_FGET(FIELD)\
    _PER_FGET(_VIC_VICIN_ADDR,VIC,VICIN,##FIELD)

  #define _VIC_VICIN_FSET(FIELD,field)\
    _PER_FSET(_VIC_VICIN_ADDR,VIC,VICIN,##FIELD,field)

  #define _VIC_VICIN_FSETS(FIELD,SYM)\
    _PER_FSETS(_VIC_VICIN_ADDR,VIC,VICIN,##FIELD,##SYM)

/******************************************************************************\
* _____________________
* |                   |
* |  V I C D I V      |
* |___________________|
*
* VICIN - VIC Clock Divider Register
*
* FIELDS (msb -> lsb)
* (rw)  VICCLKDIV
*
\******************************************************************************/

  #define _VIC_VICDIV_OFFSET             2
  #define _VIC_VICDIV_ADDR               (_VIC_BASE_ADDR + 4*_VIC_VICDIV_OFFSET)

  #define _VIC_VICDIV_VICCLKDIV_MASK         0x0000FFFFu
  #define _VIC_VICDIV_VICCLKDIV_SHIFT        0x00000000u
  #define  VIC_VICDIV_VICCLKDIV_DEFAULT      0x00000001u
  #define  VIC_VICDIV_VICCLKDIV_OF(x)        _VALUEOF(x)

  #define VIC_VICDIV_DEFAULT (Uint32)( \
     _PER_FDEFAULT(VIC,VICDIV,VICCLKDIV) \
  )

  #define VIC_VICDIV_RMK(vicclkdiv) (Uint32)( \
     _PER_FMK(VIC,VICDIV,VICCLKDIV,vicclkdiv) \
   )

  #define _VIC_VICDIV_FGET(FIELD)\
    _PER_FGET(_VIC_VICDIV_ADDR,VIC,VICDIV,##FIELD)

  #define _VIC_VICDIV_FSET(FIELD,field)\
    _PER_FSET(_VIC_VICDIV_ADDR,VIC,VICDIV,##FIELD,field)

  #define _VIC_VICDIV_FSETS(FIELD,SYM)\
    _PER_FSETS(_VIC_VICDIV_ADDR,VIC,VICDIV,##FIELD,##SYM)

/*----------------------------------------------------------------------------*/

#endif /* VIC_SUPPORT */
#endif /* _CSL_VICHAL_H_ */
/******************************************************************************\
* End of csl_vichal.h
\******************************************************************************/


csl_vp.h/       1091195465  0     0     0       42072     `
/******************************************************************************\
*           Copyright (C) 1999-2002 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vp.h
* DATE CREATED.. 02/22/2002 
* LAST MODIFIED. 05/09/2002
*
\******************************************************************************/
#ifndef _CSL_VP_H_
#define _CSL_VP_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_vphal.h>


#if (VP_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/

#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _VP_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif

/******************************************************************************\
* global macro declarations
\******************************************************************************/

/* VP_open() flags */
#define VP_OPEN_RESET     (0x00000001)

/* device identifiers for VP_open() */
#define VP_DEV0    (0)
#if (_VP_PORT_CNT == 3)
  #define VP_DEV1  (1)
  #define VP_DEV2  (2)
#endif

/* device identifiers for VP_open() */
#define VP_PORT0    VP_DEV0
#if (_VP_PORT_CNT == 2)
  #define VP_PORT1    VP_DEV1
  #define VP_PORT2    VP_DEV2
#endif

/******************************************************************************\
* global typedef declarations
\******************************************************************************/
/* device handle object */
#if (CHIP_DM642)
 typedef struct {
  Uint32 allocated;
  Uint32 eventId;
  volatile Uint32 *baseAddr;
  Uint32 ysrcaAddr;
  Uint32 cbsrcaAddr;
  Uint32 crsrcaAddr;
  Uint32 ydstaAddr;
  Uint32 cbdstAddr;
  Uint32 crdstAddr;
  Uint32 ysrcbAddr;
  Uint32 cbsrcbAddr;
  Uint32 crsrcbAddr;
  Uint32 ydstbAddr;
 } VP_Obj, *VP_Handle;
#else
 typedef struct {
  Uint32 allocated;
  Uint32 eventId;
  volatile Uint32 *baseAddr;
  Uint32 ysrcaAddr;
  Uint32 cbsrcaAddr;
  Uint32 crsrcaAddr;
  Uint32 ydstaAddr;
  Uint32 cbdstAddr;
  Uint32 crdstAddr;
 } VP_Obj, *VP_Handle;
#endif

/* device configuration structure */
typedef struct {
	Uint32 vpctl;
	Uint32 vpie;
	Uint32 vpis;
} VP_ConfigPort;

#if (CHIP_DM642)
 typedef struct {
	Uint32 vcactl; 
	Uint32 vcastrt1; 
	Uint32 vcastop1; 
	Uint32 vcastrt2; 
	Uint32 vcastop2; 
	Uint32 vcavint; 
	Uint32 vcathrld; 
	Uint32 vcaevtct; 
	Uint32 vcbctl; 
	Uint32 vcbstrt1; 
	Uint32 vcbstop1; 
	Uint32 vcbstrt2; 
	Uint32 vcbstop2; 
	Uint32 vcbvint; 
	Uint32 vcbthrld; 
	Uint32 vcbevtct; 
	Uint32 tsictl; 
	Uint32 tsiclkinitl; 
	Uint32 tsiclkinitm;
	Uint32 tsistcmpl; 
	Uint32 tsistcmpm;
	Uint32 tsistmskl; 
	Uint32 tsistmskm;
	Uint32 tsiticks; 
 } VP_ConfigCapture;
#else
 typedef struct {
	Uint32 vcactl; 
	Uint32 vcastrt1; 
	Uint32 vcastop1; 
	Uint32 vcastrt2; 
	Uint32 vcastop2; 
	Uint32 vcavint; 
	Uint32 vcathrld; 
	Uint32 vcaevtct; 
	Uint32 tsictl; 
	Uint32 tsiclkinitl; 
	Uint32 tsiclkinitm;
	Uint32 tsistcmpl; 
	Uint32 tsistcmpm;
	Uint32 tsistmskl; 
	Uint32 tsistmskm;
	Uint32 tsiticks; 
 } VP_ConfigCapture;
#endif

typedef struct {
	Uint32 vcactl; 
	Uint32 vcastrt1; 
	Uint32 vcastop1; 
	Uint32 vcastrt2; 
	Uint32 vcastop2; 
	Uint32 vcavint; 
	Uint32 vcathrld; 
	Uint32 vcaevtct; 
} VP_ConfigCaptureChA;

#if (CHIP_DM642)
 typedef struct {
	Uint32 vcbctl; 
	Uint32 vcbstrt1; 
	Uint32 vcbstop1; 
	Uint32 vcbstrt2; 
	Uint32 vcbstop2; 
	Uint32 vcbvint; 
	Uint32 vcbthrld; 
	Uint32 vcbevtct; 
 } VP_ConfigCaptureChB;
#endif

typedef struct {
	Uint32 vcactl; 
	Uint32 tsictl; 
	Uint32 tsiclkinitl; 
	Uint32 tsiclkinitm;
	Uint32 tsistcmpl; 
	Uint32 tsistcmpm;
	Uint32 tsistmskl; 
	Uint32 tsistmskm;
	Uint32 tsiticks; 
} VP_ConfigCaptureTSI;

typedef struct {
	Uint32 vdctl; 
	Uint32 vdfrmsz; 
	Uint32 vdhblnk;
	Uint32 vdvblks1; 
	Uint32 vdvblke1;
	Uint32 vdvblks2; 
	Uint32 vdvblke2;
	Uint32 vdimoff1; 
	Uint32 vdimgsz1; 
	Uint32 vdimoff2; 
	Uint32 vdimgsz2; 
	Uint32 vdfldt1; 
	Uint32 vdfldt2; 
	Uint32 vdthrld; 
	Uint32 vdhsync;
	Uint32 vdvsyns1; 
	Uint32 vdvsyne1; 
	Uint32 vdvsyns2; 
	Uint32 vdvsyne2; 
	Uint32 vdreload; 
	Uint32 vddispevt;
	Uint32 vdclip;
	Uint32 vddefval;
	Uint32 vdvint; 
	Uint32 vdfbit; 
	Uint32 vdvbit1; 
	Uint32 vdvbit2; 
} VP_ConfigDisplay;

typedef struct {
	Uint32 pfunc; 
	Uint32 pdir;
	Uint32 pdout;
	Uint32 pdset;
	Uint32 pdclr;
	Uint32 pien;
	Uint32 pipol;
	Uint32 piclr;
} VP_ConfigGpio;

typedef struct {
	VP_ConfigPort       *port;
	VP_ConfigCapture    *capture;
	VP_ConfigDisplay    *display;
	VP_ConfigGpio       *gpio;
} VP_Config;

/******************************************************************************\
* global variable declarations
\******************************************************************************/

/******************************************************************************\
* global function declarations
\******************************************************************************/
CSLAPI void VP_reset(VP_Handle hVp);
CSLAPI void VP_resetAll();

CSLAPI VP_Handle VP_open(int devNum, Uint32 flags);
CSLAPI void VP_close(VP_Handle hVp);

CSLAPI Uint32 VP_getPins(VP_Handle hVp);
CSLAPI void VP_setPins(VP_Handle hVp, Uint32 val);
CSLAPI void VP_clearPins(VP_Handle hVp, Uint32 val);
CSLAPI void VP_resetCaptureChA(VP_Handle hVp);
#if (CHIP_DM642)
  CSLAPI void VP_resetCaptureChB(VP_Handle hVp);
#endif
CSLAPI void VP_resetDisplay(VP_Handle hVp);

/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL Uint32 VP_getYsrcaAddr(VP_Handle hVp); 
IDECL Uint32 VP_getCbsrcaAddr(VP_Handle hVp); 
IDECL Uint32 VP_getCrsrcaAddr(VP_Handle hVp); 
IDECL Uint32 VP_getYdstaAddr(VP_Handle hVp); 
IDECL Uint32 VP_getCbdstAddr(VP_Handle hVp); 
IDECL Uint32 VP_getCrdstAddr(VP_Handle hVp); 
#if (CHIP_DM642)
  IDECL Uint32 VP_getYsrcbAddr(VP_Handle hVp); 
  IDECL Uint32 VP_getCbsrcbAddr(VP_Handle hVp); 
  IDECL Uint32 VP_getCrsrcbAddr(VP_Handle hVp); 
  IDECL Uint32 VP_getYdstbAddr(VP_Handle hVp); 
#endif
IDECL Uint32 VP_getEventId(VP_Handle hVp);

/******************************************************************************/
IDECL void VP_config(VP_Handle hVp, VP_Config *config);
IDECL void VP_configPort(VP_Handle hVp, VP_ConfigPort *config);
IDECL void VP_configCapture(VP_Handle hVp, VP_ConfigCapture *config);
IDECL void VP_configCaptureChA(VP_Handle hVp, VP_ConfigCaptureChA *config);
#if (CHIP_DM642)
  IDECL void VP_configCaptureChB(VP_Handle hVp, VP_ConfigCaptureChB *config);
#endif
IDECL void VP_configCaptureTSI(VP_Handle hVp, VP_ConfigCaptureTSI *config);
IDECL void VP_configDisplay(VP_Handle hVp, VP_ConfigDisplay *config);
IDECL void VP_configGpio(VP_Handle hVp, VP_ConfigGpio *config);
IDECL void VP_getConfig(VP_Handle hVp, VP_Config *config);

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF Uint32 VP_getYsrcaAddr(VP_Handle hVp) {
  return (Uint32)(hVp->ysrcaAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VP_getCbsrcaAddr(VP_Handle hVp) {
  return (Uint32)(hVp->cbsrcaAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VP_getCrsrcaAddr(VP_Handle hVp) {
  return (Uint32)(hVp->crsrcaAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VP_getYdstaAddr(VP_Handle hVp) {
  return (Uint32)(hVp->ydstaAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VP_getCbdstAddr(VP_Handle hVp) {
  return (Uint32)(hVp->cbdstAddr);
}
/*----------------------------------------------------------------------------*/
IDEF Uint32 VP_getCrdstAddr(VP_Handle hVp) {
  return (Uint32)(hVp->crdstAddr);
}

#if (CHIP_DM642)
  /*----------------------------------------------------------------------------*/
  IDEF Uint32 VP_getYsrcbAddr(VP_Handle hVp) {
    return (Uint32)(hVp->ysrcbAddr);
  }
  /*----------------------------------------------------------------------------*/
  IDEF Uint32 VP_getCbsrcbAddr(VP_Handle hVp) {
    return (Uint32)(hVp->cbsrcbAddr);
  }
  /*----------------------------------------------------------------------------*/
  IDEF Uint32 VP_getCrsrcbAddr(VP_Handle hVp) {
    return (Uint32)(hVp->crsrcbAddr);
  }
  /*----------------------------------------------------------------------------*/
  IDEF Uint32 VP_getYdstbAddr(VP_Handle hVp) {
    return (Uint32)(hVp->ydstbAddr);
  }
#endif
/*----------------------------------------------------------------------------*/
IDEF Uint32 VP_getEventId(VP_Handle hVp) {
  return (hVp->eventId);
}
/*----------------------------------------------------------------------------*/

#if (CHIP_DM642)
 IDEF void VP_config(VP_Handle hVp, VP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36;
  register int x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;
  register int x54,x55,x56,x57,x58,x59,x60,x61;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0  =  config->port->vpctl;
  x1  =  config->port->vpie;
  x2  =  config->port->vpis;
  x3  =  config->capture->vcastrt1; 
  x4  =  config->capture->vcastop1; 
  x5  =  config->capture->vcastrt2; 
  x6  =  config->capture->vcastop2; 
  x7  =  config->capture->vcavint; 
  x8  =  config->capture->vcathrld; 
  x9  =  config->capture->vcaevtct; 
  x10 =  config->capture->vcbstrt1; 
  x11 =  config->capture->vcbstop1; 
  x12 =  config->capture->vcbstrt2; 
  x13 =  config->capture->vcbstop2; 
  x14 =  config->capture->vcbvint; 
  x15 =  config->capture->vcbthrld;
  x16 =  config->capture->vcbevtct;
  x17 =  config->capture->tsictl; 
  x18 =  config->capture->tsiclkinitl; 
  x19 =  config->capture->tsiclkinitm;
  x20 =  config->capture->tsistcmpl; 
  x21 =  config->capture->tsistcmpm;
  x22 =  config->capture->tsistmskl; 
  x23 =  config->capture->tsistmskm;
  x24 =  config->capture->tsiticks; 
  x25 =  config->display->vdfrmsz; 
  x26 =  config->display->vdhblnk;
  x27 =  config->display->vdvblks1;  
  x28 =  config->display->vdvblke1;
  x29 =  config->display->vdvblks2; 
  x30 =  config->display->vdvblke2;
  x31 =  config->display->vdimoff1; 
  x32 =  config->display->vdimgsz1; 
  x33 =  config->display->vdimoff2; 
  x34 =  config->display->vdimgsz2; 
  x35 =  config->display->vdfldt1; 
  x36 =  config->display->vdfldt2; 
  x37 =  config->display->vdthrld; 
  x38 =  config->display->vdhsync;
  x39 =  config->display->vdvsyns1; 
  x40 =  config->display->vdvsyne1; 
  x41 =  config->display->vdvsyns2; 
  x42 =  config->display->vdvsyne2; 
  x43 =  config->display->vdreload; 
  x44 =  config->display->vddispevt;
  x45 =  config->display->vdclip;
  x46 =  config->display->vddefval;
  x47 =  config->display->vdvint; 
  x48 =  config->display->vdfbit; 
  x49 =  config->display->vdvbit1; 
  x50 =  config->display->vdvbit2; 
  x51 =  config->gpio->pfunc; 
  x52 =  config->gpio->pdir;
  x53 =  config->gpio->pdout;
  x54 =  config->gpio->pdset;
  x55 =  config->gpio->pdclr;
  x56 =  config->gpio->pien;
  x57 =  config->gpio->pipol;
  x58 =  config->gpio->piclr;
  x59 =  config->capture->vcactl; 
  x60 =  config->capture->vcbctl; 
  x61 =  config->display->vdctl; 

  base[_VP_VPCTL_OFFSET]       =    x0;
  base[_VP_VPIE_OFFSET]        =    x1;  
  base[_VP_VPIS_OFFSET]        =    x2;  
  base[_VP_VCASTRT1_OFFSET]    =    x3;  
  base[_VP_VCASTOP1_OFFSET]    =    x4;  
  base[_VP_VCASTRT2_OFFSET]    =    x5;  
  base[_VP_VCASTOP2_OFFSET]    =    x6;  
  base[_VP_VCAVINT_OFFSET]     =    x7;  
  base[_VP_VCATHRLD_OFFSET]    =    x8;  
  base[_VP_VCAEVTCT_OFFSET]    =    x9;  
  base[_VP_VCBSTRT1_OFFSET]    =    x10;  
  base[_VP_VCBSTOP1_OFFSET]    =    x11;  
  base[_VP_VCBSTRT2_OFFSET]    =    x12;  
  base[_VP_VCBSTOP2_OFFSET]    =    x13;  
  base[_VP_VCBVINT_OFFSET]     =    x14;  
  base[_VP_VCBTHRLD_OFFSET]    =    x15;  
  base[_VP_VCBEVTCT_OFFSET]    =    x16;  
  base[_VP_TSICTL_OFFSET]       =    x17;  
  base[_VP_TSICLKINITL_OFFSET]  =    x18;  
  base[_VP_TSICLKINITM_OFFSET]  =    x19;  
  base[_VP_TSISTCMPL_OFFSET]    =    x20;  
  base[_VP_TSISTCMPM_OFFSET]    =    x21;  
  base[_VP_TSISTMSKL_OFFSET]    =    x22;  
  base[_VP_TSISTMSKM_OFFSET]    =    x23;  
  base[_VP_TSITICKS_OFFSET]     =    x24;  
  base[_VP_VDFRMSZ_OFFSET]     =    x25;  
  base[_VP_VDHBLNK_OFFSET]     =    x26;  
  base[_VP_VDVBLKS1_OFFSET]    =    x27;  
  base[_VP_VDVBLKE1_OFFSET]    =    x28;  
  base[_VP_VDVBLKS2_OFFSET]    =    x29;  
  base[_VP_VDVBLKE2_OFFSET]    =    x30;  
  base[_VP_VDIMGOFF1_OFFSET]   =    x31;  
  base[_VP_VDIMGSZ1_OFFSET]    =    x32;  
  base[_VP_VDIMGOFF2_OFFSET]   =    x33;  
  base[_VP_VDIMGSZ2_OFFSET]    =    x34;  
  base[_VP_VDFLDT1_OFFSET]     =    x35;  
  base[_VP_VDFLDT2_OFFSET]     =    x36;  
  base[_VP_VDTHRLD_OFFSET]     =    x37;  
  base[_VP_VDHSYNC_OFFSET]     =    x38;  
  base[_VP_VDVSYNS1_OFFSET]    =    x39;  
  base[_VP_VDVSYNE1_OFFSET]    =    x40;  
  base[_VP_VDVSYNS2_OFFSET]    =    x41;  
  base[_VP_VDVSYNE2_OFFSET]    =    x42;  
  base[_VP_VDRELOAD_OFFSET]    =    x43;  
  base[_VP_VDDISPEVT_OFFSET]   =    x44;  
  base[_VP_VDCLIP_OFFSET]      =    x45;  
  base[_VP_VDDEFVAL_OFFSET]    =    x46;  
  base[_VP_VDVINT_OFFSET]      =    x47;  
  base[_VP_VDFBIT_OFFSET]      =    x48;  
  base[_VP_VDVBIT1_OFFSET]     =    x49;  
  base[_VP_VDVBIT2_OFFSET]     =    x50;  
  base[_VP_PFUNC_OFFSET]       =    x51;  
  base[_VP_PDIR_OFFSET]        =    x52;  
  base[_VP_PDOUT_OFFSET]       =    x53;  
  base[_VP_PDSET_OFFSET]       =    x54;  
  base[_VP_PDCLR_OFFSET]       =    x55;  
  base[_VP_PIEN_OFFSET]        =    x56;  
  base[_VP_PIPOL_OFFSET]       =    x57;  
  base[_VP_PICLR_OFFSET]       =    x58;  
  base[_VP_VCACTL_OFFSET]      =    x59;  
  base[_VP_VCBCTL_OFFSET]      =    x60;  
  base[_VP_VDCTL_OFFSET]       =    x61;  

  IRQ_globalRestore(gie);
 }
#else
 IDEF void VP_config(VP_Handle hVp, VP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36;
  register int x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0  =  config->port->vpctl;
  x1  =  config->port->vpie;
  x2  =  config->port->vpis;
  x3  =  config->capture->vcastrt1; 
  x4  =  config->capture->vcastop1; 
  x5  =  config->capture->vcastrt2; 
  x6  =  config->capture->vcastop2; 
  x7  =  config->capture->vcavint; 
  x8  =  config->capture->vcathrld; 
  x9  =  config->capture->vcaevtct; 
  x10 =  config->capture->tsictl; 
  x11 =  config->capture->tsiclkinitl; 
  x12 =  config->capture->tsiclkinitm;
  x13 =  config->capture->tsistcmpl; 
  x14 =  config->capture->tsistcmpm;
  x15 =  config->capture->tsistmskl; 
  x16 =  config->capture->tsistmskm;
  x17 =  config->capture->tsiticks; 
  x18 =  config->display->vdfrmsz; 
  x19 =  config->display->vdhblnk;
  x20 =  config->display->vdvblks1;  
  x21 =  config->display->vdvblke1;
  x22 =  config->display->vdvblks2; 
  x23 =  config->display->vdvblke2;
  x24 =  config->display->vdimoff1; 
  x25 =  config->display->vdimgsz1; 
  x26 =  config->display->vdimoff2; 
  x27 =  config->display->vdimgsz2; 
  x28 =  config->display->vdfldt1; 
  x29 =  config->display->vdfldt2; 
  x30 =  config->display->vdthrld; 
  x31 =  config->display->vdhsync;
  x32 =  config->display->vdvsyns1; 
  x33 =  config->display->vdvsyne1; 
  x34 =  config->display->vdvsyns2; 
  x35 =  config->display->vdvsyne2; 
  x36 =  config->display->vdreload; 
  x37 =  config->display->vddispevt;
  x38 =  config->display->vdclip;
  x39 =  config->display->vddefval;
  x40 =  config->display->vdvint; 
  x41 =  config->display->vdfbit; 
  x42 =  config->display->vdvbit1; 
  x43 =  config->display->vdvbit2; 
  x44 =  config->gpio->pfunc; 
  x45 =  config->gpio->pdir;
  x46 =  config->gpio->pdout;
  x47 =  config->gpio->pdset;
  x48 =  config->gpio->pdclr;
  x49 =  config->gpio->pien;
  x50 =  config->gpio->pipol;
  x51 =  config->gpio->piclr;
  x52 =  config->capture->vcactl; 
  x53 =  config->display->vdctl; 

  base[_VP_VPCTL_OFFSET]        =    x0;
  base[_VP_VPIE_OFFSET]         =    x1;  
  base[_VP_VPIS_OFFSET]         =    x2;  
  base[_VP_VCASTRT1_OFFSET]     =    x3;  
  base[_VP_VCASTOP1_OFFSET]     =    x4;  
  base[_VP_VCASTRT2_OFFSET]     =    x5;  
  base[_VP_VCASTOP2_OFFSET]     =    x6;  
  base[_VP_VCAVINT_OFFSET]      =    x7;  
  base[_VP_VCATHRLD_OFFSET]     =    x8;  
  base[_VP_VCAEVTCT_OFFSET]     =    x9;  
  base[_VP_TSICTL_OFFSET]       =    x10;  
  base[_VP_TSICLKINITL_OFFSET]  =    x11;  
  base[_VP_TSICLKINITM_OFFSET]  =    x12;  
  base[_VP_TSISTCMPL_OFFSET]    =    x13;  
  base[_VP_TSISTCMPM_OFFSET]    =    x14;  
  base[_VP_TSISTMSKL_OFFSET]    =    x15;  
  base[_VP_TSISTMSKM_OFFSET]    =    x16;  
  base[_VP_TSITICKS_OFFSET]     =    x17;  
  base[_VP_VDFRMSZ_OFFSET]      =    x18;  
  base[_VP_VDHBLNK_OFFSET]      =    x19;  
  base[_VP_VDVBLKS1_OFFSET]     =    x20;  
  base[_VP_VDVBLKE1_OFFSET]     =    x21;  
  base[_VP_VDVBLKS2_OFFSET]     =    x22;  
  base[_VP_VDVBLKE2_OFFSET]     =    x23;  
  base[_VP_VDIMGOFF1_OFFSET]    =    x24;  
  base[_VP_VDIMGSZ1_OFFSET]     =    x25;  
  base[_VP_VDIMGOFF2_OFFSET]    =    x26;  
  base[_VP_VDIMGSZ2_OFFSET]     =    x27;  
  base[_VP_VDFLDT1_OFFSET]      =    x28;  
  base[_VP_VDFLDT2_OFFSET]      =    x29;  
  base[_VP_VDTHRLD_OFFSET]      =    x30;  
  base[_VP_VDHSYNC_OFFSET]      =    x31;  
  base[_VP_VDVSYNS1_OFFSET]     =    x32;  
  base[_VP_VDVSYNE1_OFFSET]     =    x33;  
  base[_VP_VDVSYNS2_OFFSET]     =    x34;  
  base[_VP_VDVSYNE2_OFFSET]     =    x35;  
  base[_VP_VDRELOAD_OFFSET]     =    x36;  
  base[_VP_VDDISPEVT_OFFSET]    =    x37;  
  base[_VP_VDCLIP_OFFSET]       =    x38;  
  base[_VP_VDDEFVAL_OFFSET]     =    x39;  
  base[_VP_VDVINT_OFFSET]       =    x40;  
  base[_VP_VDFBIT_OFFSET]       =    x41;  
  base[_VP_VDVBIT1_OFFSET]      =    x42;  
  base[_VP_VDVBIT2_OFFSET]      =    x43;  
  base[_VP_PFUNC_OFFSET]        =    x44;  
  base[_VP_PDIR_OFFSET]         =    x45;  
  base[_VP_PDOUT_OFFSET]        =    x46;  
  base[_VP_PDSET_OFFSET]        =    x47;  
  base[_VP_PDCLR_OFFSET]        =    x48;  
  base[_VP_PIEN_OFFSET]         =    x49;  
  base[_VP_PIPOL_OFFSET]        =    x50;  
  base[_VP_PICLR_OFFSET]        =    x51;  
  base[_VP_VCACTL_OFFSET]       =    x52;  
  base[_VP_VDCTL_OFFSET]        =    x53;  

  IRQ_globalRestore(gie);
 }
#endif
/*----------------------------------------------------------------------------*/
IDEF void VP_configPort(VP_Handle hVp, VP_ConfigPort *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x0,x1,x2;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x0  =  config->vpctl;
  x1  =  config->vpie;
  x2  =  config->vpis;

  base[_VP_VPCTL_OFFSET]  =  x0;
  base[_VP_VPIE_OFFSET]   =  x1;
  base[_VP_VPIS_OFFSET]   =  x2;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#if (CHIP_DM642)
 IDEF void VP_configCapture(VP_Handle hVp, VP_ConfigCapture *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x3  =  config->vcastrt1; 
  x4  =  config->vcastop1; 
  x5  =  config->vcastrt2; 
  x6  =  config->vcastop2; 
  x7  =  config->vcavint; 
  x8  =  config->vcathrld; 
  x9  =  config->vcaevtct; 
  x10 =  config->vcbstrt1; 
  x11 =  config->vcbstop1; 
  x12 =  config->vcbstrt2; 
  x13 =  config->vcbstop2; 
  x14 =  config->vcbvint; 
  x15 =  config->vcbthrld; 
  x16 =  config->vcbevtct; 
  x17 =  config->tsictl; 
  x18 =  config->tsiclkinitl; 
  x19 =  config->tsiclkinitm;
  x20 =  config->tsistcmpl; 
  x21 =  config->tsistcmpm;
  x22 =  config->tsistmskl; 
  x23 =  config->tsistmskm;
  x24 =  config->tsiticks; 
  x25 =  config->vcactl; 
  x26 =  config->vcbctl; 

  base[_VP_VCASTRT1_OFFSET]     =    x3;
  base[_VP_VCASTOP1_OFFSET]     =    x4;  
  base[_VP_VCASTRT2_OFFSET]     =    x5;  
  base[_VP_VCASTOP2_OFFSET]     =    x6;  
  base[_VP_VCAVINT_OFFSET]      =    x7;  
  base[_VP_VCATHRLD_OFFSET]     =    x8;  
  base[_VP_VCAEVTCT_OFFSET]     =    x9;  
  base[_VP_VCBSTRT1_OFFSET]     =    x10;  
  base[_VP_VCBSTOP1_OFFSET]     =    x11;  
  base[_VP_VCBSTRT2_OFFSET]     =    x12;  
  base[_VP_VCBSTOP2_OFFSET]     =    x13;  
  base[_VP_VCBVINT_OFFSET]      =    x14;  
  base[_VP_VCBTHRLD_OFFSET]     =    x15;  
  base[_VP_VCBEVTCT_OFFSET]     =    x16;  
  base[_VP_TSICTL_OFFSET]       =    x17;  
  base[_VP_TSICLKINITL_OFFSET]  =    x18;  
  base[_VP_TSICLKINITM_OFFSET]  =    x19;  
  base[_VP_TSISTCMPL_OFFSET]    =    x20;  
  base[_VP_TSISTCMPM_OFFSET]    =    x21;  
  base[_VP_TSISTMSKL_OFFSET]    =    x22;  
  base[_VP_TSISTMSKM_OFFSET]    =    x23;  
  base[_VP_TSITICKS_OFFSET]     =    x24;  
  base[_VP_VCACTL_OFFSET]       =    x25;  
  base[_VP_VCBCTL_OFFSET]       =    x26;  

  IRQ_globalRestore(gie);
 }
#else
 IDEF void VP_configCapture(VP_Handle hVp, VP_ConfigCapture *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x3  =  config->vcastrt1; 
  x4  =  config->vcastop1; 
  x5  =  config->vcastrt2; 
  x6  =  config->vcastop2; 
  x7  =  config->vcavint; 
  x8  =  config->vcathrld; 
  x9  =  config->vcaevtct; 
  x10 =  config->tsictl; 
  x11 =  config->tsiclkinitl; 
  x12 =  config->tsiclkinitm;
  x13 =  config->tsistcmpl; 
  x14 =  config->tsistcmpm;
  x15 =  config->tsistmskl; 
  x16 =  config->tsistmskm;
  x17 =  config->tsiticks; 
  x18 =  config->vcactl; 

  base[_VP_VCASTRT1_OFFSET]     =    x3;
  base[_VP_VCASTOP1_OFFSET]     =    x4;  
  base[_VP_VCASTRT2_OFFSET]     =    x5;  
  base[_VP_VCASTOP2_OFFSET]     =    x6;  
  base[_VP_VCAVINT_OFFSET]      =    x7;  
  base[_VP_VCATHRLD_OFFSET]     =    x8;  
  base[_VP_VCAEVTCT_OFFSET]     =    x9;  
  base[_VP_TSICTL_OFFSET]       =    x10;  
  base[_VP_TSICLKINITL_OFFSET]  =    x11;  
  base[_VP_TSICLKINITM_OFFSET]  =    x12;  
  base[_VP_TSISTCMPL_OFFSET]    =    x13;  
  base[_VP_TSISTCMPM_OFFSET]    =    x14;  
  base[_VP_TSISTMSKL_OFFSET]    =    x15;  
  base[_VP_TSISTMSKM_OFFSET]    =    x16;  
  base[_VP_TSITICKS_OFFSET]     =    x17;  
  base[_VP_VCACTL_OFFSET]       =    x18;  

  IRQ_globalRestore(gie);
 }
#endif
/*----------------------------------------------------------------------------*/
/* Note: VCACTL is also included in VP_configCaptureTSI();                    */
/*----------------------------------------------------------------------------*/
IDEF void VP_configCaptureChA(VP_Handle hVp, VP_ConfigCaptureChA *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x3,x4,x5,x6,x7,x8,x9,x10;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x3  =  config->vcastrt1; 
  x4  =  config->vcastop1; 
  x5  =  config->vcastrt2; 
  x6  =  config->vcastop2; 
  x7  =  config->vcavint; 
  x8  =  config->vcathrld; 
  x9  =  config->vcaevtct; 
  x10 =  config->vcactl; 

  base[_VP_VCASTRT1_OFFSET]    =    x3;
  base[_VP_VCASTOP1_OFFSET]    =    x4;  
  base[_VP_VCASTRT2_OFFSET]    =    x5;  
  base[_VP_VCASTOP2_OFFSET]    =    x6;  
  base[_VP_VCAVINT_OFFSET]     =    x7;  
  base[_VP_VCATHRLD_OFFSET]    =    x8;  
  base[_VP_VCAEVTCT_OFFSET]    =    x9;  
  base[_VP_VCACTL_OFFSET]      =    x10;  

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
/* Note: VCACTL is also included in VP_configCaptureChannelA();               */
/*----------------------------------------------------------------------------*/
IDEF void VP_configCaptureTSI(VP_Handle hVp, VP_ConfigCaptureTSI *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x15,x16,x17,x18,x19,x20,x21,x22,x23;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x15 =  config->tsictl; 
  x16 =  config->tsiclkinitl; 
  x17 =  config->tsiclkinitm;
  x18 =  config->tsistcmpl; 
  x19 =  config->tsistcmpm;
  x20 =  config->tsistmskl; 
  x21 =  config->tsistmskm;
  x22 =  config->tsiticks; 
  x23 =  config->vcactl; 

  base[_VP_TSICTL_OFFSET]       =    x15;  
  base[_VP_TSICLKINITL_OFFSET]  =    x16;  
  base[_VP_TSICLKINITM_OFFSET]  =    x17;  
  base[_VP_TSISTCMPL_OFFSET]    =    x18;  
  base[_VP_TSISTCMPM_OFFSET]    =    x19;  
  base[_VP_TSISTMSKL_OFFSET]    =    x20;  
  base[_VP_TSISTMSKM_OFFSET]    =    x21;  
  base[_VP_TSITICKS_OFFSET]     =    x22;  
  base[_VP_VCACTL_OFFSET]      =    x23;  

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#if (CHIP_DM642)
 IDEF void VP_configCaptureChB(VP_Handle hVp, VP_ConfigCaptureChB *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x9,x10,x11,x12,x13,x14,x15,x16;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x9  =  config->vcbstrt1; 
  x10 =  config->vcbstop1; 
  x11 =  config->vcbstrt2; 
  x12 =  config->vcbstop2; 
  x13 =  config->vcbvint; 
  x14 =  config->vcbthrld; 
  x15 =  config->vcbevtct; 
  x16 =  config->vcbctl; 

  base[_VP_VCBSTRT1_OFFSET]    =    x9;  
  base[_VP_VCBSTOP1_OFFSET]    =    x10;  
  base[_VP_VCBSTRT2_OFFSET]    =    x11;  
  base[_VP_VCBSTOP2_OFFSET]    =    x12;  
  base[_VP_VCBVINT_OFFSET]     =    x13;  
  base[_VP_VCBTHRLD_OFFSET]    =    x14;  
  base[_VP_VCBEVTCT_OFFSET]    =    x15;  
  base[_VP_VCBCTL_OFFSET]      =    x16;  

  IRQ_globalRestore(gie);
 }
#endif
/*----------------------------------------------------------------------------*/
IDEF void VP_configDisplay(VP_Handle hVp, VP_ConfigDisplay *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38;
  register int x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */

  x25 =  config->vdfrmsz; 
  x26 =  config->vdhblnk;
  x27 =  config->vdvblks1;  
  x28 =  config->vdvblke1;
  x29 =  config->vdvblks2; 
  x30 =  config->vdvblke2;
  x31 =  config->vdimoff1; 
  x32 =  config->vdimgsz1; 
  x33 =  config->vdimoff2; 
  x34 =  config->vdimgsz2; 
  x35 =  config->vdfldt1; 
  x36 =  config->vdfldt2; 
  x37 =  config->vdthrld; 
  x38 =  config->vdhsync;
  x39 =  config->vdvsyns1; 
  x40 =  config->vdvsyne1; 
  x41 =  config->vdvsyns2; 
  x42 =  config->vdvsyne2; 
  x43 =  config->vdreload; 
  x44 =  config->vddispevt;
  x45 =  config->vdclip;
  x46 =  config->vddefval;
  x47 =  config->vdvint;
  x48 =  config->vdfbit; 
  x49 =  config->vdvbit1; 
  x50 =  config->vdvbit2; 
  x51 =  config->vdctl; 

  base[_VP_VDFRMSZ_OFFSET]   =    x25;
  base[_VP_VDHBLNK_OFFSET]   =    x26;  
  base[_VP_VDVBLKS1_OFFSET]  =    x27;  
  base[_VP_VDVBLKE1_OFFSET]  =    x28;  
  base[_VP_VDVBLKS2_OFFSET]  =    x29;  
  base[_VP_VDVBLKE2_OFFSET]  =    x30;  
  base[_VP_VDIMGOFF1_OFFSET] =    x31;  
  base[_VP_VDIMGSZ1_OFFSET]  =    x32;  
  base[_VP_VDIMGOFF2_OFFSET] =    x33;  
  base[_VP_VDIMGSZ2_OFFSET]  =    x34;  
  base[_VP_VDFLDT1_OFFSET]   =    x35;  
  base[_VP_VDFLDT2_OFFSET]   =    x36;  
  base[_VP_VDTHRLD_OFFSET]   =    x37;  
  base[_VP_VDHSYNC_OFFSET]   =    x38;  
  base[_VP_VDVSYNS1_OFFSET]  =    x39;  
  base[_VP_VDVSYNE1_OFFSET]  =    x40;  
  base[_VP_VDVSYNS2_OFFSET]  =    x41;  
  base[_VP_VDVSYNE2_OFFSET]  =    x42;  
  base[_VP_VDRELOAD_OFFSET]  =    x43;  
  base[_VP_VDDISPEVT_OFFSET] =    x44;  
  base[_VP_VDCLIP_OFFSET]    =    x45;  
  base[_VP_VDDEFVAL_OFFSET]  =    x46;  
  base[_VP_VDVINT_OFFSET]    =    x47;  
  base[_VP_VDFBIT_OFFSET]    =    x48;  
  base[_VP_VDVBIT1_OFFSET]   =    x49;  
  base[_VP_VDVBIT2_OFFSET]   =    x50;  
  base[_VP_VDCTL_OFFSET]     =    x51;  

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void VP_configGpio(VP_Handle hVp, VP_ConfigGpio *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
  register int x49,x50,x51,x52,x53,x54,x55,x56;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
  x49 =  config->pfunc; 
  x50 =  config->pdir;
  x51 =  config->pdout;
  x52 =  config->pdset;
  x53 =  config->pdclr;
  x54 =  config->pien;
  x55 =  config->pipol;
  x56 =  config->piclr;

  base[_VP_PFUNC_OFFSET]  =    x49;
  base[_VP_PDIR_OFFSET]   =    x50;
  base[_VP_PDOUT_OFFSET]  =    x51;
  base[_VP_PDSET_OFFSET]  =    x52;
  base[_VP_PDCLR_OFFSET]  =    x53;
  base[_VP_PIEN_OFFSET]   =    x54;
  base[_VP_PIPOL_OFFSET]  =    x55;
  base[_VP_PICLR_OFFSET]  =    x56;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#if (CHIP_DM642)
 IDEF void VP_getConfig(VP_Handle hVp, VP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
//  volatile VP_Config* cfg = (volatile VP_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36;
  register int x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;
  register int x54,x55,x56,x57,x58,x59,x60,x61;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
	
  x0   =   base[_VP_VPCTL_OFFSET];
  x1   =   base[_VP_VPIE_OFFSET];  
  x2   =   base[_VP_VPIS_OFFSET];  
  x3   =   base[_VP_VCACTL_OFFSET];  
  x4   =   base[_VP_VCASTRT1_OFFSET];  
  x5   =   base[_VP_VCASTOP1_OFFSET];  
  x6   =   base[_VP_VCASTRT2_OFFSET];  
  x7   =   base[_VP_VCASTOP2_OFFSET];  
  x8   =   base[_VP_VCAVINT_OFFSET];  
  x9   =   base[_VP_VCATHRLD_OFFSET];  
  x10  =   base[_VP_VCAEVTCT_OFFSET];  
  x11  =   base[_VP_VCBCTL_OFFSET];  
  x12  =   base[_VP_VCBSTRT1_OFFSET];  
  x13  =   base[_VP_VCBSTOP1_OFFSET];  
  x14  =   base[_VP_VCBSTRT2_OFFSET];  
  x15  =   base[_VP_VCBSTOP2_OFFSET];  
  x16  =   base[_VP_VCBVINT_OFFSET];  
  x17  =   base[_VP_VCBTHRLD_OFFSET];  
  x18  =   base[_VP_VCBEVTCT_OFFSET];  
  x19  =   base[_VP_TSICTL_OFFSET];  
  x20  =   base[_VP_TSICLKINITL_OFFSET];  
  x21  =   base[_VP_TSICLKINITM_OFFSET];  
  x22  =   base[_VP_TSISTCMPL_OFFSET];  
  x23  =   base[_VP_TSISTCMPM_OFFSET];  
  x24  =   base[_VP_TSISTMSKL_OFFSET];  
  x25  =   base[_VP_TSISTMSKM_OFFSET];  
  x26  =   base[_VP_TSITICKS_OFFSET];  
  x27  =   base[_VP_VDCTL_OFFSET];  
  x28  =   base[_VP_VDFRMSZ_OFFSET];  
  x29  =   base[_VP_VDHBLNK_OFFSET];  
  x30  =   base[_VP_VDVBLKS1_OFFSET];  
  x31  =   base[_VP_VDVBLKE1_OFFSET];  
  x32  =   base[_VP_VDVBLKS2_OFFSET];  
  x33  =   base[_VP_VDVBLKE2_OFFSET];  
  x34  =   base[_VP_VDIMGOFF1_OFFSET];  
  x35  =   base[_VP_VDIMGSZ1_OFFSET];  
  x36  =   base[_VP_VDIMGOFF2_OFFSET];  
  x37  =   base[_VP_VDIMGSZ2_OFFSET];  
  x38  =   base[_VP_VDFLDT1_OFFSET];  
  x39  =   base[_VP_VDFLDT2_OFFSET];  
  x40  =   base[_VP_VDTHRLD_OFFSET];  
  x41  =   base[_VP_VDHSYNC_OFFSET];  
  x42  =   base[_VP_VDVSYNS1_OFFSET];  
  x43  =   base[_VP_VDVSYNE1_OFFSET];  
  x44  =   base[_VP_VDVSYNS2_OFFSET];  
  x45  =   base[_VP_VDVSYNE2_OFFSET];  
  x46  =   base[_VP_VDRELOAD_OFFSET];  
  x47  =   base[_VP_VDDISPEVT_OFFSET];  
  x48  =   base[_VP_VDCLIP_OFFSET];  
  x49  =   base[_VP_VDDEFVAL_OFFSET];  
  x50  =   base[_VP_VDVINT_OFFSET];  
  x51  =   base[_VP_VDFBIT_OFFSET];  
  x52  =   base[_VP_VDVBIT1_OFFSET];  
  x53  =   base[_VP_VDVBIT2_OFFSET];  
  x54  =   base[_VP_PFUNC_OFFSET];  
  x55  =   base[_VP_PDIR_OFFSET];  
  x56  =   base[_VP_PDOUT_OFFSET];  
  x57  =   base[_VP_PDSET_OFFSET];  
  x58  =   base[_VP_PDCLR_OFFSET];  
  x59  =   base[_VP_PIEN_OFFSET];  
  x60  =   base[_VP_PIPOL_OFFSET];  
  x61  =   base[_VP_PICLR_OFFSET];  
  
  config->port->vpctl         =  x0;
  config->port->vpie          =  x1;  
  config->port->vpis          =  x2;  
  config->capture->vcactl     =  x3;  
  config->capture->vcastrt1   =  x4;  
  config->capture->vcastop1   =  x5;  
  config->capture->vcastrt2   =  x6;  
  config->capture->vcastop2   =  x7;  
  config->capture->vcavint    =  x8;  
  config->capture->vcathrld   =  x9;  
  config->capture->vcaevtct   =  x10;  
  config->capture->vcbctl     =  x11;  
  config->capture->vcbstrt1   =  x12;  
  config->capture->vcbstop1   =  x13;  
  config->capture->vcbstrt2   =  x14;  
  config->capture->vcbstop2   =  x15;  
  config->capture->vcbvint    =  x16;  
  config->capture->vcbthrld   =  x17;  
  config->capture->vcbevtct   =  x18;  
  config->capture->tsictl      =  x19;  
  config->capture->tsiclkinitl =  x20;  
  config->capture->tsiclkinitm =  x21;  
  config->capture->tsistcmpl   =  x22;  
  config->capture->tsistcmpm   =  x23;  
  config->capture->tsistmskl   =  x24;  
  config->capture->tsistmskm   =  x25;  
  config->capture->tsiticks    =  x26;  
  config->display->vdctl      =  x27;  
  config->display->vdfrmsz    =  x28;  
  config->display->vdhblnk    =  x29;  
  config->display->vdvblks1   =  x30;  
  config->display->vdvblke1   =  x31;  
  config->display->vdvblks2   =  x32;  
  config->display->vdvblke2   =  x33;  
  config->display->vdimoff1   =  x34;  
  config->display->vdimgsz1   =  x35;  
  config->display->vdimoff2   =  x36;  
  config->display->vdimgsz2   =  x37;  
  config->display->vdfldt1    =  x38;  
  config->display->vdfldt2    =  x39;  
  config->display->vdthrld    =  x40;  
  config->display->vdhsync    =  x41;  
  config->display->vdvsyns1   =  x42;  
  config->display->vdvsyne1   =  x43;  
  config->display->vdvsyns2   =  x44;  
  config->display->vdvsyne2   =  x45;  
  config->display->vdreload   =  x46;  
  config->display->vddispevt  =  x47;  
  config->display->vdclip     =  x48;  
  config->display->vddefval   =  x49;  
  config->display->vdvint     =  x50;  
  config->display->vdfbit     =  x51;  
  config->display->vdvbit1    =  x52;  
  config->display->vdvbit2    =  x53;  
  config->gpio->pfunc         =  x54;  
  config->gpio->pdir          =  x55;  
  config->gpio->pdout         =  x56;  
  config->gpio->pdset         =  x57;  
  config->gpio->pdclr         =  x58;  
  config->gpio->pien          =  x59;  
  config->gpio->pipol         =  x60;  
  config->gpio->piclr         =  x61;  
                                 
  IRQ_globalRestore(gie);
 }
#else
 IDEF void VP_getConfig(VP_Handle hVp, VP_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)(hVp->baseAddr);
//  volatile VP_Config* cfg = (volatile VP_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19;
  register int x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36;
  register int x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together rather than intermixed  */
	
  x0   =   base[_VP_VPCTL_OFFSET];
  x1   =   base[_VP_VPIE_OFFSET];  
  x2   =   base[_VP_VPIS_OFFSET];  
  x3   =   base[_VP_VCACTL_OFFSET];  
  x4   =   base[_VP_VCASTRT1_OFFSET];  
  x5   =   base[_VP_VCASTOP1_OFFSET];  
  x6   =   base[_VP_VCASTRT2_OFFSET];  
  x7   =   base[_VP_VCASTOP2_OFFSET];  
  x8   =   base[_VP_VCAVINT_OFFSET];  
  x9   =   base[_VP_VCATHRLD_OFFSET];  
  x10  =   base[_VP_VCAEVTCT_OFFSET];  
  x11  =   base[_VP_TSICTL_OFFSET];  
  x12  =   base[_VP_TSICLKINITL_OFFSET];  
  x13  =   base[_VP_TSICLKINITM_OFFSET];  
  x14  =   base[_VP_TSISTCMPL_OFFSET];  
  x15  =   base[_VP_TSISTCMPM_OFFSET];  
  x16  =   base[_VP_TSISTMSKL_OFFSET];  
  x17  =   base[_VP_TSISTMSKM_OFFSET];  
  x18  =   base[_VP_TSITICKS_OFFSET];  
  x19  =   base[_VP_VDCTL_OFFSET];  
  x20  =   base[_VP_VDFRMSZ_OFFSET];  
  x21  =   base[_VP_VDHBLNK_OFFSET];  
  x22  =   base[_VP_VDVBLKS1_OFFSET];  
  x23  =   base[_VP_VDVBLKE1_OFFSET];  
  x24  =   base[_VP_VDVBLKS2_OFFSET];  
  x25  =   base[_VP_VDVBLKE2_OFFSET];  
  x26  =   base[_VP_VDIMGOFF1_OFFSET];  
  x27  =   base[_VP_VDIMGSZ1_OFFSET];  
  x28  =   base[_VP_VDIMGOFF2_OFFSET];  
  x29  =   base[_VP_VDIMGSZ2_OFFSET];  
  x30  =   base[_VP_VDFLDT1_OFFSET];  
  x31  =   base[_VP_VDFLDT2_OFFSET];  
  x32  =   base[_VP_VDTHRLD_OFFSET];  
  x33  =   base[_VP_VDHSYNC_OFFSET];  
  x34  =   base[_VP_VDVSYNS1_OFFSET];  
  x35  =   base[_VP_VDVSYNE1_OFFSET];  
  x36  =   base[_VP_VDVSYNS2_OFFSET];  
  x37  =   base[_VP_VDVSYNE2_OFFSET];  
  x38  =   base[_VP_VDRELOAD_OFFSET];  
  x39  =   base[_VP_VDDISPEVT_OFFSET];  
  x40  =   base[_VP_VDCLIP_OFFSET];  
  x41  =   base[_VP_VDDEFVAL_OFFSET];  
  x42  =   base[_VP_VDVINT_OFFSET];  
  x43  =   base[_VP_VDFBIT_OFFSET];  
  x44  =   base[_VP_VDVBIT1_OFFSET];  
  x45  =   base[_VP_VDVBIT2_OFFSET];  
  x46  =   base[_VP_PFUNC_OFFSET];  
  x47  =   base[_VP_PDIR_OFFSET];  
  x48  =   base[_VP_PDOUT_OFFSET];  
  x49  =   base[_VP_PDSET_OFFSET];  
  x50  =   base[_VP_PDCLR_OFFSET];  
  x51  =   base[_VP_PIEN_OFFSET];  
  x52  =   base[_VP_PIPOL_OFFSET];  
  x53  =   base[_VP_PICLR_OFFSET];  
  
  config->port->vpctl          =  x0;
  config->port->vpie           =  x1;  
  config->port->vpis           =  x2;  
  config->capture->vcactl      =  x3;  
  config->capture->vcastrt1    =  x4;  
  config->capture->vcastop1    =  x5;  
  config->capture->vcastrt2    =  x6;  
  config->capture->vcastop2    =  x7;  
  config->capture->vcavint     =  x8;  
  config->capture->vcathrld    =  x9;  
  config->capture->vcaevtct    =  x10;  
  config->capture->tsictl      =  x11;  
  config->capture->tsiclkinitl =  x12;  
  config->capture->tsiclkinitm =  x13;  
  config->capture->tsistcmpl   =  x14;  
  config->capture->tsistcmpm   =  x15;  
  config->capture->tsistmskl   =  x16;  
  config->capture->tsistmskm   =  x17;  
  config->capture->tsiticks    =  x18;  
  config->display->vdctl       =  x19;  
  config->display->vdfrmsz     =  x20;  
  config->display->vdhblnk     =  x21;  
  config->display->vdvblks1    =  x22;  
  config->display->vdvblke1    =  x23;  
  config->display->vdvblks2    =  x24;  
  config->display->vdvblke2    =  x25;  
  config->display->vdimoff1    =  x26;  
  config->display->vdimgsz1    =  x27;  
  config->display->vdimoff2    =  x28;  
  config->display->vdimgsz2    =  x29;  
  config->display->vdfldt1     =  x30;  
  config->display->vdfldt2     =  x31;  
  config->display->vdthrld     =  x32;  
  config->display->vdhsync     =  x33;  
  config->display->vdvsyns1    =  x34;  
  config->display->vdvsyne1    =  x35;  
  config->display->vdvsyns2    =  x36;  
  config->display->vdvsyne2    =  x37;  
  config->display->vdreload    =  x38;  
  config->display->vddispevt   =  x39;  
  config->display->vdclip      =  x40;  
  config->display->vddefval    =  x41;  
  config->display->vdvint      =  x42;  
  config->display->vdfbit      =  x43;  
  config->display->vdvbit1     =  x44;  
  config->display->vdvbit2     =  x45;  
  config->gpio->pfunc          =  x46;  
  config->gpio->pdir           =  x47;  
  config->gpio->pdout          =  x48;  
  config->gpio->pdset          =  x49;  
  config->gpio->pdclr          =  x50;  
  config->gpio->pien           =  x51;  
  config->gpio->pipol          =  x52;  
  config->gpio->piclr          =  x53;  
                                 
  IRQ_globalRestore(gie);
 }
#endif
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* VP_SUPPORT */
#endif /* _CSL_VP_H_ */
/******************************************************************************\
* End of csl_vp.h
\******************************************************************************/

csl_vphal.h/    1092390312  0     0     0       360499    `
/******************************************************************************\
*           Copyright (C) 2002-2004 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_vphal.h
* DATE CREATED.. 12/06/2001 
*                updated for version 1.3.............01/10/2002
* LAST MODIFIED. 08/12/2004  Fixed defintion error in  _VP_VDIMGOFFxx_ADDR              
*                02/28/2002
*
*------------------------------------------------------------------------------
* REGISTERS
********************************************************************************
* Memory Mapping Register -- Global
*
* VPPID0       -  Video Port 0 Peripheral Identification Register
* VPPID1       -  Video Port 1 Peripheral Identification Register
* VPPID2       -  Video Port 2 Peripheral Identification Register
* PCR0         -  Video Port 0 Peripheral Control                    
* PCR1         -  Video Port 1 Peripheral Control
* PCR2         -  Video Port 2 Peripheral Control
* PFUNC0       -  Video Port 0 Pin Function
* PFUNC1       -  Video Port 1 Pin Function
* PFUNC2       -  Video Port 2 Pin Function
* PDIR0        -  Video Port 0 Pin Direction
* PDIR1        -  Video Port 1 Pin Direction
* PDIR2        -  Video Port 2 Pin Direction
* PDIN0        -  Video Port 0 Pin Data In
* PDIN1        -  Video Port 1 Pin Data In
* PDIN2        -  Video Port 2 Pin Data In
* PDOUT0       -  Video Port 0 Pin Data Out
* PDOUT1       -  Video Port 1 Pin Data Out
* PDOUT2       -  Video Port 2 Pin Data Out
* PDSET0       -  Video Port 0 Pin Data Set
* PDSET1       -  Video Port 1 Pin Data Set
* PDSET2       -  Video Port 2 Pin Data Set
* PDCLR0       -  Video Port 0 Pin Data Clear
* PDCLR1       -  Video Port 1 Pin Data Clear
* PDCLR2       -  Video Port 2 Pin Data Clear
* PIEN0        -  Video Port 0 Pin Interrupt Enable
* PIEN1        -  Video Port 1 Pin Interrupt Enable
* PIEN2        -  Video Port 2 Pin Interrupt Enable
* PIPOL0       -  Video Port 0 Pin Interrupt Polarity
* PIPOL1       -  Video Port 1 Pin Interrupt Polarity
* PIPOL2       -  Video Port 2 Pin Interrupt Polarity
* PISTAT0      -  Video Port 0 Pin Interrupt Status
* PISTAT1      -  Video Port 1 Pin Interrupt Status
* PISTAT2      -  Video Port 2 Pin Interrupt Status
* PICLR0       -  Video Port 0 Pin Interrupt Clear
* PICLR1       -  Video Port 1 Pin Interrupt Clear
* PICLR2       -  Video Port 2 Pin Interrupt Clear
* VPCTL0       -  Video Port 0 Control Register
* VPCTL1       -  Video Port 1 Control Register
* VPCTL2       -  Video Port 2 Control Register
* VPSTAT0      -  Video Port 0 Status Register	
* VPSTAT1      -  Video Port 1 Status Register	
* VPSTAT2      -  Video Port 2 Status Register	
* VPIE0        -  Video Port 0 Interrupt Enable Register
* VPIE1        -  Video Port 1 Interrupt Enable Register
* VPIE2        -  Video Port 2 Interrupt Enable Register
* VPIS0        -  Video Port 0 Interrupt Status Register
* VPIS1        -  Video Port 1 Interrupt Status Register
* VPIS2        -  Video Port 2 Interrupt Status Register
********************************************************************************
* Memory Mapping Register -- Capture
*
* VCASTAT0     -  Video Port 0 Video Capture A Status
* VCASTAT1     -  Video Port 1 Video Capture A Status
* VCASTAT2     -  Video Port 2 Video Capture A Status
* VCACTL0      -  Video Port 0 Video Capture A Control
* VCACTL1      -  Video Port 1 Video Capture A Control
* VCACTL2      -  Video Port 2 Video Capture A Control
* VCASTRT10    -  Video Port 0 Video Capture A Field1 Start
* VCASTRT11    -  Video Port 1 Video Capture A Field1 Start
* VCASTRT12    -  Video Port 2 Video Capture A Field1 Start
* VCASTOP10    -  Video Port 0 Video Capture A Field1 Stop
* VCASTOP11    -  Video Port 1 Video Capture A Field1 Stop
* VCASTOP12    -  Video Port 2 Video Capture A Field1 Stop
* VCASTRT20    -  Video Port 0 Video Capture A Field2 Start
* VCASTRT21    -  Video Port 1 Video Capture A Field2 Start
* VCASTRT22    -  Video Port 2 Video Capture A Field2 Start
* VCASTOP20    -  Video Port 0 Video Capture A Field2 Stop
* VCASTOP21    -  Video Port 1 Video Capture A Field2 Stop
* VCASTOP22    -  Video Port 2 Video Capture A Field2 Stop
* VCAVINT0     -  Video Port 0 Video Capture A Vertical Interrupt
* VCAVINT1     -  Video Port 1 Video Capture A Vertical Interrupt
* VCAVINT2     -  Video Port 2 Video Capture A Vertical Interrupt
* VCATHRLD0    -  Video Port 0 Video Capture A Threshold
* VCATHRLD1    -  Video Port 1 Video Capture A Threshold
* VCATHRLD2    -  Video Port 2 Video Capture A Threshold
* VCAEVTCT0    -  Video Port 0 Video Capture A Event Count
* VCAEVTCT1    -  Video Port 1 Video Capture A Event Count
* VCAEVTCT2    -  Video Port 2 Video Capture A Event Count
*
* VCBSTAT0     -  Video Port 0 Video Capture B Status (only for DM642)
* VCBSTAT1     -  Video Port 1 Video Capture B Status (only for DM642)
* VCBSTAT2     -  Video Port 2 Video Capture B Status (only for DM642)
* VCBCTL0      -  Video Port 0 Video Capture B Control (only for DM642)
* VCBCTL1      -  Video Port 1 Video Capture B Control (only for DM642)
* VCBCTL2      -  Video Port 2 Video Capture B Control (only for DM642)
* VCBSTRT10    -  Video Port 0 Video Capture B Field1 Start (only for DM642)
* VCBSTRT11    -  Video Port 1 Video Capture B Field1 Start (only for DM642)
* VCBSTRT12    -  Video Port 2 Video Capture B Field1 Start (only for DM642)
* VCBSTOP10    -  Video Port 0 Video Capture B Field1Stop (only for DM642)
* VCBSTOP11    -  Video Port 1 Video Capture B Field1Stop (only for DM642)
* VCBSTOP12    -  Video Port 2 Video Capture B Field1Stop (only for DM642)
* VCBSTRT20    -  Video Port 0 Video Capture B Field2 Start (only for DM642)
* VCBSTRT21    -  Video Port 1 Video Capture B Field2 Start (only for DM642)
* VCBSTRT22    -  Video Port 2 Video Capture B Field2 Start (only for DM642)
* VCBSTOP20    -  Video Port 0 Video Capture B Field2Stop (only for DM642)
* VCBSTOP21    -  Video Port 1 Video Capture B Field2Stop (only for DM642)
* VCBSTOP22    -  Video Port 2 Video Capture B Field2Stop (only for DM642)
* VCBVINT0     -  Video Port 0 Video Capture B Vertical Interrupt (only for DM642)
* VCBVINT1     -  Video Port 1 Video Capture B Vertical Interrupt (only for DM642)
* VCBVINT2     -  Video Port 2 Video Capture B Vertical Interrupt (only for DM642)
* VCBTHRLD0    -  Video Port 0 Video Capture B Threshold (only for DM642)
* VCBTHRLD1    -  Video Port 1 Video Capture B Threshold (only for DM642)
* VCBTHRLD2    -  Video Port 2 Video Capture B Threshold (only for DM642)
* VCBEVTCT0    -  Video Port 0 Video Capture B Event Count (only for DM642)
* VCBEVTCT1    -  Video Port 1 Video Capture B Event Count (only for DM642)
* VCBEVTCT2    -  Video Port 2 Video Capture B Event Count (only for DM642)
*
* TSICTL0      -  Video Port 0 Transport Stream Interface Capture Control
* TSICTL1      -  Video Port 1 Transport Stream Interface Capture Control
* TSICTL2      -  Video Port 2 Transport Stream Interface Capture Control
* TSICLKINITL0 -  Video Port 0 Transport Stream Interface Clock Initialization LSB
* TSICLKINITL1 -  Video Port 1 Transport Stream Interface Clock Initialization LSB
* TSICLKINITL2 -  Video Port 2 Transport Stream Interface Clock Initialization LSB
* TSICLKINITM0 -  Video Port 0 Transport Stream Interface Clock Initialization MSB
* TSICLKINITM1 -  Video Port 1 Transport Stream Interface Clock Initialization MSB
* TSICLKINITM2 -  Video Port 2 Transport Stream Interface Clock Initialization MSB
* TSISTCLKL0   -  Video Port 0 Transport Stream Interface System Time Clock LSB
* TSISTCLKL1   -  Video Port 1 Transport Stream Interface System Time Clock LSB
* TSISTCLKL2   -  Video Port 2 Transport Stream Interface System Time Clock LSB
* TSISTCLKM0   -  Video Port 0 Transport Stream Interface System Time Clock  MSB
* TSISTCLKM1   -  Video Port 1 Transport Stream Interface System Time Clock  MSB
* TSISTCLKM2   -  Video Port 2 Transport Stream Interface System Time Clock  MSB
* TSISTCMPL0   -  Video Port 0 Transport Stream Interface STC Compare LSB
* TSISTCMPL1   -  Video Port 1 Transport Stream Interface STC Compare LSB
* TSISTCMPL2   -  Video Port 2 Transport Stream Interface STC Compare LSB
* TSISTCMPM0   -  Video Port 0 Transport Stream Interface STC Compare MSB
* TSISTCMPM1   -  Video Port 1 Transport Stream Interface STC Compare MSB
* TSISTCMPM2   -  Video Port 2 Transport Stream Interface STC Compare MSB
* TSISTMSKL0   -  Video Port 0 Transport Stream Interface STC Compare Mask LSB
* TSISTMSKL1   -  Video Port 1 Transport Stream Interface STC Compare Mask LSB
* TSISTMSKL2   -  Video Port 2 Transport Stream Interface STC Compare Mask LSB
* TSISTMSKM0   -  Video Port 0 Transport Stream Interface STC Compare Mask MSB
* TSISTMSKM1   -  Video Port 1 Transport Stream Interface STC Compare Mask MSB
* TSISTMSKM2   -  Video Port 2 Transport Stream Interface STC Compare Mask MSB
* TSITICKS0    -  Video Port 0 Transport Stream Interface STC Ticks Interrupt
* TSITICKS1    -  Video Port 1 Transport Stream Interface STC Ticks Interrupt
* TSITICKS2    -  Video Port 2 Transport Stream Interface STC Ticks Interrupt
*
********************************************************************************
* Memory Mapping Register -- Display
*
* (DM640 has only one video port, i.e. only Port 0 registers are valid)
* (DM641 has only two video ports, i.e. only Port 0 and Port 1 registers are valid)
* (DM642 has three video ports, i.e. Port 0, Port 1 and Port 2)
*
* VDSTAT0      -  Video Port 0 Video Display Status
* VDSTAT1      -  Video Port 1 Video Display Status
* VDSTAT2      -  Video Port 2 Video Display Status
* VDCTL0       -  Video Port 0 Video Display Control
* VDCTL1       -  Video Port 1 Video Display Control
* VDCTL2       -  Video Port 2 Video Display Control
* VDFRMSZ0     -  Video Port 0 Video Display Frame Size
* VDFRMSZ1     -  Video Port 1 Video Display Frame Size
* VDFRMSZ2     -  Video Port 2 Video Display Frame Size
* VDHBLNK0     -  Video Port 0 Video Display Horizontal Blanking
* VDHBLNK1     -  Video Port 1 Video Display Horizontal Blanking
* VDHBLNK2     -  Video Port 2 Video Display Horizontal Blanking
* VDVBLKS10    -  Video Port 0 Video Display Vertical Blanking Start - Field 1
* VDVBLKS11    -  Video Port 1 Video Display Vertical Blanking Start - Field 1
* VDVBLKS12    -  Video Port 2 Video Display Vertical Blanking Start - Field 1
* VDVBLKE10    -  Video Port 0 Video Display Vertical Blanking End - Field 1
* VDVBLKE11    -  Video Port 1 Video Display Vertical Blanking End - Field 1
* VDVBLKE12    -  Video Port 2 Video Display Vertical Blanking End - Field 1
* VDVBLKS20    -  Video Port 0 Video Display Vertical Blanking Start - Field 2
* VDVBLKS21    -  Video Port 1 Video Display Vertical Blanking Start - Field 2
* VDVBLKS22    -  Video Port 2 Video Display Vertical Blanking Start - Field 2
* VDVBLKE20    -  Video Port 0 Video Display Vertical Blanking End - Field 2
* VDVBLKE21    -  Video Port 1 Video Display Vertical Blanking End - Field 2
* VDVBLKE22    -  Video Port 2 Video Display Vertical Blanking End - Field 2
* VDIMGOFF10   -  Video Port 0 Video Display Image Offset - Field 1
* VDIMGOFF11   -  Video Port 1 Video Display Image Offset - Field 1
* VDIMGOFF12   -  Video Port 2 Video Display Image Offset - Field 1
* VDIMGSZ10    -  Video Port 0 Video Display Image Size - Field 1
* VDIMGSZ11    -  Video Port 1 Video Display Image Size - Field 1
* VDIMGSZ12    -  Video Port 2 Video Display Image Size - Field 1
* VDIMGOFF20   -  Video Port 0 Video Display Image Offset - Field 2
* VDIMGOFF21   -  Video Port 1 Video Display Image Offset - Field 2
* VDIMGOFF22   -  Video Port 2 Video Display Image Offset - Field 2
* VDIMGSZ20    -  Video Port 0 Video Display Image Size - Field 2
* VDIMGSZ21    -  Video Port 1 Video Display Image Size - Field 2
* VDIMGSZ22    -  Video Port 2 Video Display Image Size - Field 2
* VDFLDT10     -  Video Port 0 Video Display Field1 Timing
* VDFLDT11     -  Video Port 1 Video Display Field1 Timing
* VDFLDT12     -  Video Port 2 Video Display Field1 Timing
* VDFLDT20     -  Video Port 0 Video Display Field2 Timing
* VDFLDT21     -  Video Port 1 Video Display Field2 Timing
* VDFLDT22     -  Video Port 2 Video Display Field2 Timing
* VDTHRLD0     -  Video Port 0 Video Display Threshold
* VDTHRLD1     -  Video Port 1 Video Display Threshold
* VDTHRLD2     -  Video Port 2 Video Display Threshold
* VDHSYNC0     -  Video Port 0 Video Display Horizontal Sync
* VDHSYNC1     -  Video Port 1 Video Display Horizontal Sync
* VDHSYNC2     -  Video Port 2 Video Display Horizontal Sync
* VDVSYNS10    -  Video Port 0 Video Display Vertical Synchronization Start - Field 1
* VDVSYNS11    -  Video Port 1 Video Display Vertical Synchronization Start - Field 1
* VDVSYNS12    -  Video Port 2 Video Display Vertical Synchronization Start - Field 1
* VDVSYNE10    -  Video Port 0 Video Display Vertical Synchronization End - Field 1
* VDVSYNE11    -  Video Port 1 Video Display Vertical Synchronization End - Field 1
* VDVSYNE12    -  Video Port 2 Video Display Vertical Synchronization End - Field 1
* VDVSYNS20    -  Video Port 0 Video Display Vertical Synchronization Start - Field 2
* VDVSYNS21    -  Video Port 1 Video Display Vertical Synchronization Start - Field 2
* VDVSYNS22    -  Video Port 2 Video Display Vertical Synchronization Start - Field 2
* VDVSYNE20    -  Video Port 0 Video Display Vertical Synchronization End - Field 2
* VDVSYNE21    -  Video Port 1 Video Display Vertical Synchronization End - Field 2
* VDVSYNE22    -  Video Port 2 Video Display Vertical Synchronization End - Field 2
* VDRELOAD0    -  Video Port 0 Video Display Counter Reload
* VDRELOAD1    -  Video Port 1 Video Display Counter Reload
* VDRELOAD2    -  Video Port 2 Video Display Counter Reload
* VDDISPEVT0   -  Video Port 0 Video Display Display Event Register
* VDDISPEVT1   -  Video Port 1 Video Display Display Event Register
* VDDISPEVT2   -  Video Port 2 Video Display Display Event Register
* VDCLIP0      -  Video Port 0 Video Display Clipping Register
* VDCLIP1      -  Video Port 1 Video Display Clipping Register
* VDCLIP2      -  Video Port 2 Video Display Clipping Register
* VDDEFVAL0    -  Video Port 0 Video Display Default Display Value
* VDDEFVAL1    -  Video Port 1 Video Display Default Display Value
* VDDEFVAL2    -  Video Port 2 Video Display Default Display Value
* VDVINT0      -  Video Port 0 Video Display Vertical Interrupt
* VDVINT1      -  Video Port 1 Video Display Vertical Interrupt
* VDVINT2      -  Video Port 2 Video Display Vertical Interrupt
* VDFBIT0      -  Video Port 0 Video Display Field Bit Register
* VDFBIT1      -  Video Port 1 Video Display Field Bit Register
* VDFBIT2      -  Video Port 2 Video Display Field Bit Register
* VDVBIT10     -  Video Port 0 Video Display Vertical Blank Bit-Field 1 Register
* VDVBIT11     -  Video Port 1 Video Display Vertical Blank Bit-Field 1 Register
* VDVBIT12     -  Video Port 2 Video Display Vertical Blank Bit-Field 1 Register
* VDVBIT20     -  Video Port 0 Video Display Vertical Blank Bit-Field 2 Register
* VDVBIT21     -  Video Port 1 Video Display Vertical Blank Bit-Field 2 Register
* VDVBIT22     -  Video Port 2 Video Display Vertical Blank Bit-Field 2 Register
*
********************************************************************************
* FIFO Mapping
*
* YSRCA0       -  Video Port 0 Y FIFO Source Register A
* YSRCA1       -  Video Port 1 Y FIFO Source Register A
* YSRCA2       -  Video Port 2 Y FIFO Source Register A
* CBSRCA0      -  Video Port 0 Cb FIFO Source Register A
* CBSRCA1      -  Video Port 1 Cb FIFO Source Register A
* CBSRCA2      -  Video Port 2 Cb FIFO Source Register A
* CRSRCA0      -  Video Port 0 Cr FIFO Source Register A
* CRSRCA1      -  Video Port 1 Cr FIFO Source Register A
* CRSRCA2      -  Video Port 2 Cr FIFO Source Register A
* YSRCB0       -  Video Port 0 Y FIFO Source Register B  (only for DM642)
* YSRCB1       -  Video Port 1 Y FIFO Source Register B  (only for DM642)
* YSRCB2       -  Video Port 2 Y FIFO Source Register B  (only for DM642)
* CBSRCB0      -  Video Port 0 Cb FIFO Source Register B (only for DM642)
* CBSRCB1      -  Video Port 1 Cb FIFO Source Register B (only for DM642)
* CBSRCB2      -  Video Port 2 Cb FIFO Source Register B (only for DM642)
* CRSRCB0      -  Video Port 0 Cr FIFO Source Register B (only for DM642)
* CRSRCB1      -  Video Port 1 Cr FIFO Source Register B (only for DM642)
* CRSRCB2      -  Video Port 2 Cr FIFO Source Register B (only for DM642)
* YDSTA0       -  Video Port 0 Y FIFO Destination Register A
* YDSTA1       -  Video Port 1 Y FIFO Destination Register A
* YDSTA2       -  Video Port 2 Y FIFO Destination Register A
* CBDST0       -  Video Port 0 Cb FIFO Destination Register 
* CBDST1       -  Video Port 1 Cb FIFO Destination Register 
* CBDST2       -  Video Port 2 Cb FIFO Destination Register 
* CRDST0       -  Video Port 0 Cr FIFO Destination Register
* CRDST1       -  Video Port 1 Cr FIFO Destination Register
* CRDST2       -  Video Port 2 Cr FIFO Destination Register
* YDSTB0       -  Video Port 0 Y FIFO Destination Register B (only for DM642)
* YDSTB1       -  Video Port 1 Y FIFO Destination Register B (only for DM642)
* YDSTB2       -  Video Port 2 Y FIFO Destination Register B (only for DM642)
*
\******************************************************************************/
#ifndef _CSL_VPHAL_H_
#define _CSL_VPHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>

#if (VP_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/

 #if (CHIP_DM642)
  #define _VP_PORT_CNT        3
 #endif

 #if (CHIP_DM641)
  #define _VP_PORT_CNT        2
 #endif

 #if (CHIP_DM640)
  #define _VP_PORT_CNT        1
 #endif

  #define _VP_BASE_PORT0      0x01C40000u
 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_BASE_PORT1      0x01C44000u
 #endif

 #if (CHIP_DM642)
  #define _VP_BASE_PORT2      0x01C48000u
 #endif

/* Capture Channel A base address */
  #define _VP_BASE_CHAPORT0   _VP_BASE_PORT0 + 0x00000100u

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_BASE_CHAPORT1   _VP_BASE_PORT1 + 0x00000100u
 #endif

 #if (CHIP_DM642)
  #define _VP_BASE_CHAPORT2   _VP_BASE_PORT2 + 0x00000100u
 #endif

/* Capture Channel B base address */
  #define _VP_BASE_CHBPORT0   _VP_BASE_PORT0 + 0x00000140u

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_BASE_CHBPORT1   _VP_BASE_PORT1 + 0x00000140u
 #endif

 #if (CHIP_DM642)
  #define _VP_BASE_CHBPORT2   _VP_BASE_PORT2 + 0x00000140u
 #endif

  #define _VP_AFBASE_PORT0    0x74000000u
  #define _VP_BFBASE_PORT0    0x76000000u

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_AFBASE_PORT1    0x78000000u
  #define _VP_BFBASE_PORT1    0x7A000000u
 #endif

 #if (CHIP_DM642)
  #define _VP_AFBASE_PORT2    0x7C000000u
  #define _VP_BFBASE_PORT2    0x7E000000u
 #endif


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define VP_FMK(REG,FIELD,x)\
    _PER_FMK(VP,##REG,##FIELD,x)

  #define VP_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(VP,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define VP_ADDR(REG)\
    _VP_##REG##_ADDR

  #define VP_RGET(REG)\
    _PER_RGET(_VP_##REG##_ADDR,VP,##REG)

  #define VP_RSET(REG,x)\
    _PER_RSET(_VP_##REG##_ADDR,VP,##REG,x)

  #define VP_FGET(REG,FIELD)\
    _VP_##REG##_FGET(##FIELD)

  #define VP_FSET(REG,FIELD,x)\
    _VP_##REG##_FSET(##FIELD,##x)

  #define VP_FSETS(REG,FIELD,SYM)\
    _VP_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define VP_RGETA(addr,REG)\
    _PER_RGET(addr,VP,##REG)

  #define VP_RSETA(addr,REG,x)\
    _PER_RSET(addr,VP,##REG,x)

  #define VP_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,VP,##REG,##FIELD)

  #define VP_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,VP,##REG,##FIELD,x)

  #define VP_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,VP,##REG,##FIELD,##SYM)


  /* ----------------------------------------- */
  /* HANDLE BASED REGISTER/FIELD ACCESS MACROS */
  /* ----------------------------------------- */

  #define VP_ADDRH(h,REG)\
    (Uint32)(&((h)->baseAddr[_VP_##REG##_OFFSET]))

  #define VP_RGETH(h,REG)\
    VP_RGETA(VP_ADDRH(h,##REG),##REG)


  #define VP_RSETH(h,REG,x)\
    VP_RSETA(VP_ADDRH(h,##REG),##REG,x)


  #define VP_FGETH(h,REG,FIELD)\
    VP_FGETA(VP_ADDRH(h,##REG),##REG,##FIELD)


  #define VP_FSETH(h,REG,FIELD,x)\
    VP_FSETA(VP_ADDRH(h,##REG),##REG,##FIELD,x)


  #define VP_FSETSH(h,REG,FIELD,SYM)\
    VP_FSETSA(VP_ADDRH(h,##REG),##REG,##FIELD,##SYM)



/******************************************************************************\
* _____________________
* |                   |
* |  V P P I D        |
* |___________________|
*
* VPPID0 - Video Port 0 Peripheral Identification Register
* VPPID1 - Video Port 1 Peripheral Identification Register
* VPPID2 - Video Port 2 Peripheral Identification Register
*
*
* FIELDS (msb -> lsb)
* (r) TYPE
* (r) CLASS
* (r) REVISION
*
\******************************************************************************/
  #define _VP_VPPID_OFFSET            0

  #define _VP_VPPID0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VPPID_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPPID1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VPPID_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPPID2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VPPID_OFFSET)
 #endif


  #define _VP_VPPID_TYPE_MASK              0x00FF0000u
  #define _VP_VPPID_TYPE_SHIFT             0x00000010u
  #define  VP_VPPID_TYPE_DEFAULT           0x00000001u /* spec. 1.4 */
  #define  VP_VPPID_TYPE_OF(x)             _VALUEOF(x)

  #define _VP_VPPID_CLASS_MASK             0x0000FF00u
  #define _VP_VPPID_CLASS_SHIFT            0x00000008u
  #define  VP_VPPID_CLASS_DEFAULT          0x00000009u /* spec. 1.4 */
  #define  VP_VPPID_CLASS_OF(x)            _VALUEOF(x)

  #define _VP_VPPID_REVISION_MASK          0x000000FFu
  #define _VP_VPPID_REVISION_SHIFT         0x00000000u
  #define  VP_VPPID_REVISION_DEFAULT       0x00000001u /* temp fix, wait for spec. ??? */
  #define  VP_VPPID_REVISION_OF(x)         _VALUEOF(x)

  #define VP_VPPID_OF(x)               _VALUEOF(x)

  #define VP_VPPID_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VPPID,TYPE)\
    |_PER_FDEFAULT(VP,VPPID,CLASS)\
    |_PER_FDEFAULT(VP,VPPID,REVISION)\
  )
 #if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define VP_VPPID_RMK(type,class,revision) (Uint32)(\
              _PER_FMK(VP,VPPID,TYPE,type)\
	     |_PER_FMK(VP,VPPID,CLASS,class)\
	     |_PER_FMK(VP,VPPID,REVISION,revision)\
  )	     
 #endif  
 
  #define _VP_VPPID_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VPPID##N##_ADDR,VP,VPPID,##FIELD,field)

  #define _VP_VPPID_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VPPID##N##_ADDR,VP,VPPID,##FIELD,##SYM)

  #define _VP_VPPID_FGET(N,FIELD)\
    _PER_FGET(_VP_VPPID##N##_ADDR,VP,VPPID,##FIELD)


  #define _VP_VPPID0_FGET(FIELD)   _VP_VPPID_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPPID1_FGET(FIELD)   _VP_VPPID_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPPID2_FGET(FIELD)   _VP_VPPID_FGET(2,##FIELD)
 #endif


  #define _VP_VPPID0_FSET(FIELD,f)   _VP_VPPID_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPPID1_FSET(FIELD,f)   _VP_VPPID_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPPID2_FSET(FIELD,f)   _VP_VPPID_FSET(2,##FIELD,f)
 #endif


  #define _VP_VPPID0_FSETS(FIELD,SYM)   _VP_VPPID_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPPID1_FSETS(FIELD,SYM)   _VP_VPPID_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPPID2_FSETS(FIELD,SYM)   _VP_VPPID_FSETS(2,##FIELD,##SYM)
 #endif



/******************************************************************************\
* _____________________
* |                   |
* |  P C R            |
* |___________________|
*
* PCR0  - Video Port 0 Peripheral Control Register
* PCR1  - Video Port 1 Peripheral Control Register
* PCR2  - Video Port 2 Peripheral Control Register
*
* FIELDS (msb -> lsb)
* (rw) PEREN
* (r)  SOFT
* (rw) FREE
*
\******************************************************************************/
  #define _VP_PCR_OFFSET            1

  #define _VP_PCR0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PCR_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PCR1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PCR_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PCR2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PCR_OFFSET)
 #endif


  #define _VP_PCR_PEREN_MASK           0x00000004u
  #define _VP_PCR_PEREN_SHIFT          0x00000002u
  #define  VP_PCR_PEREN_DEFAULT        0x00000000u
  #define  VP_PCR_PEREN_OF(x)          _VALUEOF(x)
  #define  VP_PCR_PEREN_DISABLE        0x00000000u
  #define  VP_PCR_PEREN_ENABLE         0x00000001u
  
  #define _VP_PCR_SOFT_MASK           0x00000002u
  #define _VP_PCR_SOFT_SHIFT          0x00000001u
  #define  VP_PCR_SOFT_DEFAULT        0x00000000u
  #define  VP_PCR_SOFT_OF(x)          _VALUEOF(x)
  #define  VP_PCR_SOFT_STOP           0x00000000u
  #define  VP_PCR_SOFT_COMP           0x00000001u
  
  #define _VP_PCR_FREE_MASK           0x00000001u
  #define _VP_PCR_FREE_SHIFT          0x00000000u
  #define  VP_PCR_FREE_DEFAULT        0x00000001u
  #define  VP_PCR_FREE_OF(x)          _VALUEOF(x)
  #define  VP_PCR_FREE_SOFT           0x00000000u
  
  #define  VP_PCR_OF(x)             _VALUEOF(x)

  #define VP_PCR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PCR,PEREN)\
   |_PER_FDEFAULT(VP,PCR,SOFT)\
   |_PER_FDEFAULT(VP,PCR,FREE)\
  )

#define VP_PCR_RMK(peren,free) (Uint32)(\
    _PER_FMK(VP,PCR,PEREN,peren)\
   |_PER_FMK(VP,PCR,FREE,free)\
  )

  #define _VP_PCR_FGET(N,FIELD)\
    _PER_FGET(_VP_PCR##N##_ADDR,VP,PCR,##FIELD)

  #define _VP_PCR_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PCR##N##_ADDR,VP,PCR,##FIELD,field)

  #define _VP_PCR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PCR##N##_ADDR,VP,PCR,##FIELD,##SYM)

  #define _VP_PCR0_FGET(FIELD)   _VP_PCR_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PCR1_FGET(FIELD)   _VP_PCR_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PCR2_FGET(FIELD)   _VP_PCR_FGET(2,##FIELD)
 #endif


  #define _VP_PCR0_FSET(FIELD,f)   _VP_PCR_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PCR1_FSET(FIELD,f)   _VP_PCR_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PCR2_FSET(FIELD,f)   _VP_PCR_FSET(2,##FIELD,f)
 #endif


  #define _VP_PCR0_FSETS(FIELD,SYM)   _VP_PCR_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PCR1_FSETS(FIELD,SYM)   _VP_PCR_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PCR2_FSETS(FIELD,SYM)   _VP_PCR_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P F U N C        |
* |___________________|
*
* PFUNC0  - Video Port 0 Pin Function Register
* PFUNC1  - Video Port 1 Pin Function Register
* PFUNC2  - Video Port 2 Pin Function Register
*
* FIELDS (msb -> lsb)
* (rw) PFUNC22
* (rw) PFUNC21
* (rw) PFUNC20
* (rw) PFUNC10
* (rw) PFUNC0
*
\******************************************************************************/
  #define _VP_PFUNC_OFFSET            8

  #define _VP_PFUNC0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PFUNC_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PFUNC1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PFUNC_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PFUNC2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PFUNC_OFFSET)
 #endif


  #define _VP_PFUNC_PFUNC22_MASK           0x00400000u
  #define _VP_PFUNC_PFUNC22_SHIFT          0x00000016u
  #define  VP_PFUNC_PFUNC22_DEFAULT        0x00000000u
  #define  VP_PFUNC_PFUNC22_OF(x)          _VALUEOF(x)
  #define  VP_PFUNC_PFUNC22_NORMAL         0x00000000u
  #define  VP_PFUNC_PFUNC22_VCTL2      0x00000001u
  
  #define _VP_PFUNC_PFUNC21_MASK           0x00200000u
  #define _VP_PFUNC_PFUNC21_SHIFT          0x00000015u
  #define  VP_PFUNC_PFUNC21_DEFAULT        0x00000000u
  #define  VP_PFUNC_PFUNC21_OF(x)          _VALUEOF(x)
  #define  VP_PFUNC_PFUNC21_NORMAL         0x00000000u
  #define  VP_PFUNC_PFUNC21_VCTL1      0x00000001u
  
  #define _VP_PFUNC_PFUNC20_MASK           0x00100000u
  #define _VP_PFUNC_PFUNC20_SHIFT          0x00000014u
  #define  VP_PFUNC_PFUNC20_DEFAULT        0x00000000u
  #define  VP_PFUNC_PFUNC20_OF(x)          _VALUEOF(x)
  #define  VP_PFUNC_PFUNC20_NORMAL         0x00000000u
  #define  VP_PFUNC_PFUNC20_VCTL0      0x00000001u
  
  #define _VP_PFUNC_PFUNC10_MASK           0x00000400u
  #define _VP_PFUNC_PFUNC10_SHIFT          0x0000000Au
  #define  VP_PFUNC_PFUNC10_DEFAULT        0x00000000u
  #define  VP_PFUNC_PFUNC10_OF(x)          _VALUEOF(x)
  #define  VP_PFUNC_PFUNC10_NORMAL         0x00000000u
  #define  VP_PFUNC_PFUNC10_VDATA10TO19    0x00000001u
  
  #define _VP_PFUNC_PFUNC0_MASK            0x00000001u
  #define _VP_PFUNC_PFUNC0_SHIFT           0x00000000u
  #define  VP_PFUNC_PFUNC0_DEFAULT         0x00000000u
  #define  VP_PFUNC_PFUNC0_OF(x)           _VALUEOF(x)
  #define  VP_PFUNC_PFUNC0_NORMAL          0x00000000u
  #define  VP_PFUNC_PFUNC0_VDATA0TO9       0x00000001u
  
  #define  VP_PFUNC_OF(x)             _VALUEOF(x)

  #define VP_PFUNC_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PFUNC,PFUNC22)\
   |_PER_FDEFAULT(VP,PFUNC,PFUNC21)\
   |_PER_FDEFAULT(VP,PFUNC,PFUNC20)\
   |_PER_FDEFAULT(VP,PFUNC,PFUNC10)\
   |_PER_FDEFAULT(VP,PFUNC,PFUNC0)\
  )

#define VP_PFUNC_RMK(pfunc22,pfunc21,pfunc20,pfunc10,pfunc0) (Uint32)(\
    _PER_FMK(VP,PFUNC,PFUNC22,pfunc22)\
   |_PER_FMK(VP,PFUNC,PFUNC21,pfunc21)\
   |_PER_FMK(VP,PFUNC,PFUNC20,pfunc20)\
   |_PER_FMK(VP,PFUNC,PFUNC10,pfunc10)\
   |_PER_FMK(VP,PFUNC,PFUNC0,pfunc0)\
  )

  #define _VP_PFUNC_FGET(N,FIELD)\
    _PER_FGET(_VP_PFUNC##N##_ADDR,VP,PFUNC,##FIELD)

  #define _VP_PFUNC_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PFUNC##N##_ADDR,VP,PFUNC,##FIELD,field)

  #define _VP_PFUNC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PFUNC##N##_ADDR,VP,PFUNC,##FIELD,##SYM)

  #define _VP_PFUNC0_FGET(FIELD)   _VP_PFUNC_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PFUNC1_FGET(FIELD)   _VP_PFUNC_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PFUNC2_FGET(FIELD)   _VP_PFUNC_FGET(2,##FIELD)
 #endif


  #define _VP_PFUNC0_FSET(FIELD,f)   _VP_PFUNC_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PFUNC1_FSET(FIELD,f)   _VP_PFUNC_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PFUNC2_FSET(FIELD,f)   _VP_PFUNC_FSET(2,##FIELD,f)
 #endif


  #define _VP_PFUNC0_FSETS(FIELD,SYM)   _VP_PFUNC_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PFUNC1_FSETS(FIELD,SYM)   _VP_PFUNC_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PFUNC2_FSETS(FIELD,SYM)   _VP_PFUNC_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P D I R          |
* |___________________|
*
* PDIR0  - Video Port 0 Pin Direction Register
* PDIR1  - Video Port 1 Pin Direction Register
* PDIR2  - Video Port 2 Pin Direction Register
*
* FIELDS (msb -> lsb)
* (rw) PDIR22
* (rw) PDIR21
* (rw) PDIR20
* (rw) PDIR16
* (rw) PDIR12
* (rw) PDIR10
* (rw) PDIR8
* (rw) PDIR4
* (rw) PDIR0
*
\******************************************************************************/
  #define _VP_PDIR_OFFSET            9

  #define _VP_PDIR0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PDIR_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDIR1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PDIR_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDIR2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PDIR_OFFSET)
 #endif


  #define _VP_PDIR_PDIR22_MASK           0x00400000u
  #define _VP_PDIR_PDIR22_SHIFT          0x00000016u
  #define  VP_PDIR_PDIR22_DEFAULT        0x00000000u
  #define  VP_PDIR_PDIR22_OF(x)          _VALUEOF(x)
  #define  VP_PDIR_PDIR22_VCTL2IN        0x00000000u
  #define  VP_PDIR_PDIR22_VCTL2OUT       0x00000001u
  
  #define _VP_PDIR_PDIR21_MASK           0x00200000u
  #define _VP_PDIR_PDIR21_SHIFT          0x00000015u
  #define  VP_PDIR_PDIR21_DEFAULT        0x00000000u
  #define  VP_PDIR_PDIR21_OF(x)          _VALUEOF(x)
  #define  VP_PDIR_PDIR21_VCTL1IN        0x00000000u
  #define  VP_PDIR_PDIR21_VCTL1OUT       0x00000001u
  
  #define _VP_PDIR_PDIR20_MASK           0x00100000u
  #define _VP_PDIR_PDIR20_SHIFT          0x00000014u
  #define  VP_PDIR_PDIR20_DEFAULT        0x00000000u
  #define  VP_PDIR_PDIR20_OF(x)          _VALUEOF(x)
  #define  VP_PDIR_PDIR20_VCTL0IN        0x00000000u
  #define  VP_PDIR_PDIR20_VCTL0OUT       0x00000001u
  
  #define _VP_PDIR_PDIR16_MASK           0x00010000u
  #define _VP_PDIR_PDIR16_SHIFT          0x00000010u
  #define  VP_PDIR_PDIR16_DEFAULT        0x00000000u
  #define  VP_PDIR_PDIR16_OF(x)          _VALUEOF(x)
  #define  VP_PDIR_PDIR16_VDATA16TO19IN  0x00000000u
  #define  VP_PDIR_PDIR16_VDATA16TO19OUT 0x00000001u
  
  #define _VP_PDIR_PDIR12_MASK           0x00001000u
  #define _VP_PDIR_PDIR12_SHIFT          0x0000000Cu
  #define  VP_PDIR_PDIR12_DEFAULT        0x00000000u
  #define  VP_PDIR_PDIR12_OF(x)          _VALUEOF(x)
  #define  VP_PDIR_PDIR12_VDATA12TO15IN  0x00000000u
  #define  VP_PDIR_PDIR12_VDATA12TO15OUT 0x00000001u
  
  #define _VP_PDIR_PDIR10_MASK           0x00000400u
  #define _VP_PDIR_PDIR10_SHIFT          0x0000000Au
  #define  VP_PDIR_PDIR10_DEFAULT        0x00000000u
  #define  VP_PDIR_PDIR10_OF(x)          _VALUEOF(x)
  #define  VP_PDIR_PDIR10_VDATA10TO11IN  0x00000000u
  #define  VP_PDIR_PDIR10_VDATA10TO11OUT 0x00000001u
  
  #define _VP_PDIR_PDIR8_MASK            0x00000100u
  #define _VP_PDIR_PDIR8_SHIFT           0x00000008u
  #define  VP_PDIR_PDIR8_DEFAULT         0x00000000u
  #define  VP_PDIR_PDIR8_OF(x)           _VALUEOF(x)
  #define  VP_PDIR_PDIR8_VDATA8TO9IN     0x00000000u
  #define  VP_PDIR_PDIR8_VDATA8TO9OUT    0x00000001u
  
  #define _VP_PDIR_PDIR4_MASK            0x00000010u
  #define _VP_PDIR_PDIR4_SHIFT           0x00000004u
  #define  VP_PDIR_PDIR4_DEFAULT         0x00000000u
  #define  VP_PDIR_PDIR4_OF(x)           _VALUEOF(x)
  #define  VP_PDIR_PDIR4_VDATA4TO7IN     0x00000000u
  #define  VP_PDIR_PDIR4_VDATA4TO7OUT    0x00000001u
  
  #define _VP_PDIR_PDIR0_MASK            0x00000001u
  #define _VP_PDIR_PDIR0_SHIFT           0x00000000u
  #define  VP_PDIR_PDIR0_DEFAULT         0x00000000u
  #define  VP_PDIR_PDIR0_OF(x)           _VALUEOF(x)
  #define  VP_PDIR_PDIR0_VDATA0TO3IN     0x00000000u
  #define  VP_PDIR_PDIR0_VDATA0TO3OUT    0x00000001u
  
  #define  VP_PDIR_OF(x)             _VALUEOF(x)

  #define VP_PDIR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PDIR,PDIR22)\
   |_PER_FDEFAULT(VP,PDIR,PDIR21)\
   |_PER_FDEFAULT(VP,PDIR,PDIR20)\
   |_PER_FDEFAULT(VP,PDIR,PDIR16)\
   |_PER_FDEFAULT(VP,PDIR,PDIR12)\
   |_PER_FDEFAULT(VP,PDIR,PDIR10)\
   |_PER_FDEFAULT(VP,PDIR,PDIR8)\
   |_PER_FDEFAULT(VP,PDIR,PDIR4)\
   |_PER_FDEFAULT(VP,PDIR,PDIR0)\
  )

#define VP_PDIR_RMK(pdir22,pdir21,pdir20,pdir16,\
  pdir12,pdir10,pdir8,pdir4,pdir0) (Uint32)(\
    _PER_FMK(VP,PDIR,PDIR22,pdir22)\
   |_PER_FMK(VP,PDIR,PDIR21,pdir21)\
   |_PER_FMK(VP,PDIR,PDIR20,pdir20)\
   |_PER_FMK(VP,PDIR,PDIR16,pdir16)\
   |_PER_FMK(VP,PDIR,PDIR12,pdir12)\
   |_PER_FMK(VP,PDIR,PDIR10,pdir10)\
   |_PER_FMK(VP,PDIR,PDIR8,pdir8)\
   |_PER_FMK(VP,PDIR,PDIR4,pdir4)\
   |_PER_FMK(VP,PDIR,PDIR0,pdir0)\
  )

  #define _VP_PDIR_FGET(N,FIELD)\
    _PER_FGET(_VP_PDIR##N##_ADDR,VP,PDIR,##FIELD)

  #define _VP_PDIR_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PDIR##N##_ADDR,VP,PDIR,##FIELD,field)

  #define _VP_PDIR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PDIR##N##_ADDR,VP,PDIR,##FIELD,##SYM)

  #define _VP_PDIR0_FGET(FIELD)   _VP_PDIR_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDIR1_FGET(FIELD)   _VP_PDIR_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDIR2_FGET(FIELD)   _VP_PDIR_FGET(2,##FIELD)
 #endif


  #define _VP_PDIR0_FSET(FIELD,f)   _VP_PDIR_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDIR1_FSET(FIELD,f)   _VP_PDIR_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDIR2_FSET(FIELD,f)   _VP_PDIR_FSET(2,##FIELD,f)
 #endif


  #define _VP_PDIR0_FSETS(FIELD,SYM)   _VP_PDIR_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDIR1_FSETS(FIELD,SYM)   _VP_PDIR_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDIR2_FSETS(FIELD,SYM)   _VP_PDIR_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P D I N          |
* |___________________|
*
* PDIN0  - Video Port 0 Pin Data In Register
* PDIN1  - Video Port 1 Pin Data In Register
* PDIN2  - Video Port 2 Pin Data In Register
*
* FIELDS (msb -> lsb)
* (r) PDIN22
* (r) PDIN21
* (r) PDIN20
* (r) PDIN19
* (r) PDIN18
* (r) PDIN17
* (r) PDIN16
* (r) PDIN15
* (r) PDIN14
* (r) PDIN13
* (r) PDIN12
* (r) PDIN11
* (r) PDIN10
* (r) PDIN9
* (r) PDIN8
* (r) PDIN7
* (r) PDIN6
* (r) PDIN5
* (r) PDIN4
* (r) PDIN3
* (r) PDIN2
* (r) PDIN1
* (r) PDIN0
*
\******************************************************************************/
  #define _VP_PDIN_OFFSET            10

  #define _VP_PDIN0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PDIN_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDIN1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PDIN_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDIN2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PDIN_OFFSET)
 #endif


  #define _VP_PDIN_PDIN22_MASK           0x00400000u
  #define _VP_PDIN_PDIN22_SHIFT          0x00000016u
  #define  VP_PDIN_PDIN22_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN22_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN22_VCTL2LO        0x00000000u
  #define  VP_PDIN_PDIN22_VCTL2HI        0x00000001u
  
  #define _VP_PDIN_PDIN21_MASK           0x00200000u
  #define _VP_PDIN_PDIN21_SHIFT          0x00000015u
  #define  VP_PDIN_PDIN21_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN21_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN21_VCTL1LO        0x00000000u
  #define  VP_PDIN_PDIN21_VCTL1HI        0x00000001u
  
  #define _VP_PDIN_PDIN20_MASK           0x00100000u
  #define _VP_PDIN_PDIN20_SHIFT          0x00000014u
  #define  VP_PDIN_PDIN20_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN20_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN20_VCTL0LO        0x00000000u
  #define  VP_PDIN_PDIN20_VCTL0HI        0x00000001u
  
  #define _VP_PDIN_PDIN19_MASK           0x00080000u
  #define _VP_PDIN_PDIN19_SHIFT          0x00000013u
  #define  VP_PDIN_PDIN19_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN19_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN19_VDATA19LO      0x00000000u
  #define  VP_PDIN_PDIN19_VDATA19HI      0x00000001u
  
  #define _VP_PDIN_PDIN18_MASK           0x00040000u
  #define _VP_PDIN_PDIN18_SHIFT          0x00000012u
  #define  VP_PDIN_PDIN18_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN18_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN18_VDATA18LO      0x00000000u
  #define  VP_PDIN_PDIN18_VDATA18HI      0x00000001u
  
  #define _VP_PDIN_PDIN17_MASK           0x00020000u
  #define _VP_PDIN_PDIN17_SHIFT          0x00000011u
  #define  VP_PDIN_PDIN17_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN17_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN17_VDATA17LO      0x00000000u
  #define  VP_PDIN_PDIN17_VDATA17HI      0x00000001u
  
  #define _VP_PDIN_PDIN16_MASK           0x00010000u
  #define _VP_PDIN_PDIN16_SHIFT          0x00000010u
  #define  VP_PDIN_PDIN16_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN16_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN16_VDATA16LO      0x00000000u
  #define  VP_PDIN_PDIN16_VDATA16HI      0x00000001u
  
  #define _VP_PDIN_PDIN15_MASK           0x00008000u
  #define _VP_PDIN_PDIN15_SHIFT          0x0000000Fu
  #define  VP_PDIN_PDIN15_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN15_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN15_VDATA15LO      0x00000000u
  #define  VP_PDIN_PDIN15_VDATA15HI      0x00000001u
  
  #define _VP_PDIN_PDIN14_MASK           0x00004000u
  #define _VP_PDIN_PDIN14_SHIFT          0x0000000Eu
  #define  VP_PDIN_PDIN14_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN14_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN14_VDATA14LO      0x00000000u
  #define  VP_PDIN_PDIN14_VDATA14HI      0x00000001u
  
  #define _VP_PDIN_PDIN13_MASK           0x00002000u
  #define _VP_PDIN_PDIN13_SHIFT          0x0000000Du
  #define  VP_PDIN_PDIN13_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN13_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN13_VDATA13LO      0x00000000u
  #define  VP_PDIN_PDIN13_VDATA13HI      0x00000001u
  
  #define _VP_PDIN_PDIN12_MASK           0x00001000u
  #define _VP_PDIN_PDIN12_SHIFT          0x0000000Cu
  #define  VP_PDIN_PDIN12_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN12_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN12_VDATA12LO      0x00000000u
  #define  VP_PDIN_PDIN12_VDATA12HI      0x00000001u
  
  #define _VP_PDIN_PDIN11_MASK           0x00000800u
  #define _VP_PDIN_PDIN11_SHIFT          0x0000000Bu
  #define  VP_PDIN_PDIN11_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN11_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN11_VDATA11LO      0x00000000u
  #define  VP_PDIN_PDIN11_VDATA11HI      0x00000001u
  
  #define _VP_PDIN_PDIN10_MASK           0x00000400u
  #define _VP_PDIN_PDIN10_SHIFT          0x0000000Au
  #define  VP_PDIN_PDIN10_DEFAULT        0x00000000u
  #define  VP_PDIN_PDIN10_OF(x)          _VALUEOF(x)
  #define  VP_PDIN_PDIN10_VDATA10LO      0x00000000u
  #define  VP_PDIN_PDIN10_VDATA10HI      0x00000001u
  
  #define _VP_PDIN_PDIN9_MASK            0x00000200u
  #define _VP_PDIN_PDIN9_SHIFT           0x00000009u
  #define  VP_PDIN_PDIN9_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN9_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN9_VDATA9LO        0x00000000u
  #define  VP_PDIN_PDIN9_VDATA9HI        0x00000001u
  
  #define _VP_PDIN_PDIN8_MASK            0x00000100u
  #define _VP_PDIN_PDIN8_SHIFT           0x00000008u
  #define  VP_PDIN_PDIN8_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN8_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN8_VDATA8LO        0x00000000u
  #define  VP_PDIN_PDIN8_VDATA8HI        0x00000001u
  
  #define _VP_PDIN_PDIN7_MASK            0x00000080u
  #define _VP_PDIN_PDIN7_SHIFT           0x00000007u
  #define  VP_PDIN_PDIN7_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN7_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN7_VDATA7LO        0x00000000u
  #define  VP_PDIN_PDIN7_VDATA7HI        0x00000001u
  
  #define _VP_PDIN_PDIN6_MASK            0x00000040u
  #define _VP_PDIN_PDIN6_SHIFT           0x00000006u
  #define  VP_PDIN_PDIN6_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN6_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN6_VDATA6LO        0x00000000u
  #define  VP_PDIN_PDIN6_VDATA6HI        0x00000001u
  
  #define _VP_PDIN_PDIN5_MASK            0x00000020u
  #define _VP_PDIN_PDIN5_SHIFT           0x00000005u
  #define  VP_PDIN_PDIN5_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN5_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN5_VDATA5LO        0x00000000u
  #define  VP_PDIN_PDIN5_VDATA5HI        0x00000001u
  
  #define _VP_PDIN_PDIN4_MASK            0x00000010u
  #define _VP_PDIN_PDIN4_SHIFT           0x00000004u
  #define  VP_PDIN_PDIN4_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN4_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN4_VDATA4LO        0x00000000u
  #define  VP_PDIN_PDIN4_VDATA4HI        0x00000001u
  
  #define _VP_PDIN_PDIN3_MASK            0x00000008u
  #define _VP_PDIN_PDIN3_SHIFT           0x00000003u
  #define  VP_PDIN_PDIN3_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN3_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN3_VDATA3LO        0x00000000u
  #define  VP_PDIN_PDIN3_VDATA3HI        0x00000001u
  
  #define _VP_PDIN_PDIN2_MASK            0x00000004u
  #define _VP_PDIN_PDIN2_SHIFT           0x00000002u
  #define  VP_PDIN_PDIN2_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN2_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN2_VDATA2LO        0x00000000u
  #define  VP_PDIN_PDIN2_VDATA2HI        0x00000001u
  
  #define _VP_PDIN_PDIN1_MASK            0x00000002u
  #define _VP_PDIN_PDIN1_SHIFT           0x00000001u
  #define  VP_PDIN_PDIN1_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN1_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN1_VDATA1LO        0x00000000u
  #define  VP_PDIN_PDIN1_VDATA1HI        0x00000001u
  
  #define _VP_PDIN_PDIN0_MASK            0x00000001u
  #define _VP_PDIN_PDIN0_SHIFT           0x00000000u
  #define  VP_PDIN_PDIN0_DEFAULT         0x00000000u
  #define  VP_PDIN_PDIN0_OF(x)           _VALUEOF(x)
  #define  VP_PDIN_PDIN0_VDATA0LO        0x00000000u
  #define  VP_PDIN_PDIN0_VDATA0HI        0x00000001u
  
  #define  VP_PDIN_OF(x)             _VALUEOF(x)

  #define VP_PDIN_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PDIN,PDIN22)\
   |_PER_FDEFAULT(VP,PDIN,PDIN21)\
   |_PER_FDEFAULT(VP,PDIN,PDIN20)\
   |_PER_FDEFAULT(VP,PDIN,PDIN19)\
   |_PER_FDEFAULT(VP,PDIN,PDIN18)\
   |_PER_FDEFAULT(VP,PDIN,PDIN17)\
   |_PER_FDEFAULT(VP,PDIN,PDIN16)\
   |_PER_FDEFAULT(VP,PDIN,PDIN15)\
   |_PER_FDEFAULT(VP,PDIN,PDIN14)\
   |_PER_FDEFAULT(VP,PDIN,PDIN13)\
   |_PER_FDEFAULT(VP,PDIN,PDIN12)\
   |_PER_FDEFAULT(VP,PDIN,PDIN11)\
   |_PER_FDEFAULT(VP,PDIN,PDIN10)\
   |_PER_FDEFAULT(VP,PDIN,PDIN9)\
   |_PER_FDEFAULT(VP,PDIN,PDIN8)\
   |_PER_FDEFAULT(VP,PDIN,PDIN7)\
   |_PER_FDEFAULT(VP,PDIN,PDIN6)\
   |_PER_FDEFAULT(VP,PDIN,PDIN5)\
   |_PER_FDEFAULT(VP,PDIN,PDIN4)\
   |_PER_FDEFAULT(VP,PDIN,PDIN3)\
   |_PER_FDEFAULT(VP,PDIN,PDIN2)\
   |_PER_FDEFAULT(VP,PDIN,PDIN1)\
   |_PER_FDEFAULT(VP,PDIN,PDIN0)\
  )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define VP_PDIN_RMK(pdin22,pdin21,pdin20,pdin19,pdin18,pdin17,pdin16,\
  pdin15,pdin14,pdin13,pdin12,pdin11,pdin10,pdin9,pdin8,pdin7,\
  pdin6,pdin5,pdin4,pdin3,pdin2,pdin1,pdin0) (Uint32)(\
    _PER_FMK(VP,PDIN,PDIN22,pdin22)\
   |_PER_FMK(VP,PDIN,PDIN21,pdin21)\
   |_PER_FMK(VP,PDIN,PDIN20,pdin20)\
   |_PER_FMK(VP,PDIN,PDIN19,pdin19)\
   |_PER_FMK(VP,PDIN,PDIN18,pdin18)\
   |_PER_FMK(VP,PDIN,PDIN17,pdin17)\
   |_PER_FMK(VP,PDIN,PDIN16,pdin16)\
   |_PER_FMK(VP,PDIN,PDIN15,pdin15)\
   |_PER_FMK(VP,PDIN,PDIN14,pdin14)\
   |_PER_FMK(VP,PDIN,PDIN13,pdin13)\
   |_PER_FMK(VP,PDIN,PDIN12,pdin12)\
   |_PER_FMK(VP,PDIN,PDIN11,pdin11)\
   |_PER_FMK(VP,PDIN,PDIN10,pdin10)\
   |_PER_FMK(VP,PDIN,PDIN9,pdin9)\
   |_PER_FMK(VP,PDIN,PDIN8,pdin8)\
   |_PER_FMK(VP,PDIN,PDIN7,pdin7)\
   |_PER_FMK(VP,PDIN,PDIN6,pdin6)\
   |_PER_FMK(VP,PDIN,PDIN5,pdin5)\
   |_PER_FMK(VP,PDIN,PDIN4,pdin4)\
   |_PER_FMK(VP,PDIN,PDIN3,pdin3)\
   |_PER_FMK(VP,PDIN,PDIN2,pdin2)\
   |_PER_FMK(VP,PDIN,PDIN1,pdin1)\
   |_PER_FMK(VP,PDIN,PDIN0,pdin0)\
   )
#endif   
  #define _VP_PDIN_FGET(N,FIELD)\
    _PER_FGET(_VP_PDIN##N##_ADDR,VP,PDIN,##FIELD)

  #define _VP_PDIN_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PDIN##N##_ADDR,VP,PDIN,##FIELD,field)

  #define _VP_PDIN_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PDIN##N##_ADDR,VP,PDIN,##FIELD,##SYM)

  #define _VP_PDIN0_FGET(FIELD)   _VP_PDIN_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDIN1_FGET(FIELD)   _VP_PDIN_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDIN2_FGET(FIELD)   _VP_PDIN_FGET(2,##FIELD)
 #endif


  #define _VP_PDIN0_FSET(FIELD,f)   _VP_PDIN_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDIN1_FSET(FIELD,f)   _VP_PDIN_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDIN2_FSET(FIELD,f)   _VP_PDIN_FSET(2,##FIELD,f)
 #endif


  #define _VP_PDIN0_FSETS(FIELD,SYM)   _VP_PDIN_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDIN1_FSETS(FIELD,SYM)   _VP_PDIN_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDIN2_FSETS(FIELD,SYM)   _VP_PDIN_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P D O U T        |
* |___________________|
*
* PDOUT0  - Video Port 0 Pin Data Out Register
* PDOUT1  - Video Port 1 Pin Data Out Register
* PDOUT2  - Video Port 2 Pin Data Out Register
*
* FIELDS (msb -> lsb)
* (rw) PDOUT22
* (rw) PDOUT21
* (rw) PDOUT20
* (rw) PDOUT19
* (rw) PDOUT18
* (rw) PDOUT17
* (rw) PDOUT16
* (rw) PDOUT15
* (rw) PDOUT14
* (rw) PDOUT13
* (rw) PDOUT12
* (rw) PDOUT11
* (rw) PDOUT10
* (rw) PDOUT9
* (rw) PDOUT8
* (rw) PDOUT7
* (rw) PDOUT6
* (rw) PDOUT5
* (rw) PDOUT4
* (rw) PDOUT3
* (rw) PDOUT2
* (rw) PDOUT1
* (rw) PDOUT0
*
\******************************************************************************/
  #define _VP_PDOUT_OFFSET            11

  #define _VP_PDOUT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PDOUT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDOUT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PDOUT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDOUT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PDOUT_OFFSET)
 #endif


  #define _VP_PDOUT_PDOUT22_MASK           0x00400000u
  #define _VP_PDOUT_PDOUT22_SHIFT          0x00000016u
  #define  VP_PDOUT_PDOUT22_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT22_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT22_VCTL2LO        0x00000000u
  #define  VP_PDOUT_PDOUT22_VCTL2HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT21_MASK           0x00200000u
  #define _VP_PDOUT_PDOUT21_SHIFT          0x00000015u
  #define  VP_PDOUT_PDOUT21_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT21_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT21_VCTL1LO        0x00000000u
  #define  VP_PDOUT_PDOUT21_VCTL1HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT20_MASK           0x00100000u
  #define _VP_PDOUT_PDOUT20_SHIFT          0x00000014u
  #define  VP_PDOUT_PDOUT20_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT20_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT20_VCTL0LO        0x00000000u
  #define  VP_PDOUT_PDOUT20_VCTL0HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT19_MASK           0x00080000u
  #define _VP_PDOUT_PDOUT19_SHIFT          0x00000013u
  #define  VP_PDOUT_PDOUT19_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT19_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT19_VDATA19LO      0x00000000u
  #define  VP_PDOUT_PDOUT19_VDATA19HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT18_MASK           0x00040000u
  #define _VP_PDOUT_PDOUT18_SHIFT          0x00000012u
  #define  VP_PDOUT_PDOUT18_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT18_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT18_VDATA18LO      0x00000000u
  #define  VP_PDOUT_PDOUT18_VDATA18HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT17_MASK           0x00020000u
  #define _VP_PDOUT_PDOUT17_SHIFT          0x00000011u
  #define  VP_PDOUT_PDOUT17_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT17_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT17_VDATA17LO      0x00000000u
  #define  VP_PDOUT_PDOUT17_VDATA17HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT16_MASK           0x00010000u
  #define _VP_PDOUT_PDOUT16_SHIFT          0x00000010u
  #define  VP_PDOUT_PDOUT16_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT16_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT16_VDATA16LO      0x00000000u
  #define  VP_PDOUT_PDOUT16_VDATA16HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT15_MASK           0x00008000u
  #define _VP_PDOUT_PDOUT15_SHIFT          0x0000000Fu
  #define  VP_PDOUT_PDOUT15_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT15_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT15_VDATA15LO      0x00000000u
  #define  VP_PDOUT_PDOUT15_VDATA15HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT14_MASK           0x00004000u
  #define _VP_PDOUT_PDOUT14_SHIFT          0x0000000Eu
  #define  VP_PDOUT_PDOUT14_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT14_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT14_VDATA14LO      0x00000000u
  #define  VP_PDOUT_PDOUT14_VDATA14HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT13_MASK           0x00002000u
  #define _VP_PDOUT_PDOUT13_SHIFT          0x0000000Du
  #define  VP_PDOUT_PDOUT13_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT13_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT13_VDATA13LO      0x00000000u
  #define  VP_PDOUT_PDOUT13_VDATA13HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT12_MASK           0x00001000u
  #define _VP_PDOUT_PDOUT12_SHIFT          0x0000000Cu
  #define  VP_PDOUT_PDOUT12_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT12_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT12_VDATA12LO      0x00000000u
  #define  VP_PDOUT_PDOUT12_VDATA12HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT11_MASK           0x00000800u
  #define _VP_PDOUT_PDOUT11_SHIFT          0x0000000Bu
  #define  VP_PDOUT_PDOUT11_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT11_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT11_VDATA11LO      0x00000000u
  #define  VP_PDOUT_PDOUT11_VDATA11HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT10_MASK           0x00000400u
  #define _VP_PDOUT_PDOUT10_SHIFT          0x0000000Au
  #define  VP_PDOUT_PDOUT10_DEFAULT        0x00000000u
  #define  VP_PDOUT_PDOUT10_OF(x)          _VALUEOF(x)
  #define  VP_PDOUT_PDOUT10_VDATA10LO      0x00000000u
  #define  VP_PDOUT_PDOUT10_VDATA10HI      0x00000001u
  
  #define _VP_PDOUT_PDOUT9_MASK            0x00000200u
  #define _VP_PDOUT_PDOUT9_SHIFT           0x00000009u
  #define  VP_PDOUT_PDOUT9_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT9_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT9_VDATA9LO        0x00000000u
  #define  VP_PDOUT_PDOUT9_VDATA9HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT8_MASK            0x00000100u
  #define _VP_PDOUT_PDOUT8_SHIFT           0x00000008u
  #define  VP_PDOUT_PDOUT8_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT8_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT8_VDATA8LO        0x00000000u
  #define  VP_PDOUT_PDOUT8_VDATA8HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT7_MASK            0x00000080u
  #define _VP_PDOUT_PDOUT7_SHIFT           0x00000007u
  #define  VP_PDOUT_PDOUT7_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT7_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT7_VDATA7LO        0x00000000u
  #define  VP_PDOUT_PDOUT7_VDATA7HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT6_MASK            0x00000040u
  #define _VP_PDOUT_PDOUT6_SHIFT           0x00000006u
  #define  VP_PDOUT_PDOUT6_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT6_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT6_VDATA6LO        0x00000000u
  #define  VP_PDOUT_PDOUT6_VDATA6HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT5_MASK            0x00000020u
  #define _VP_PDOUT_PDOUT5_SHIFT           0x00000005u
  #define  VP_PDOUT_PDOUT5_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT5_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT5_VDATA5LO        0x00000000u
  #define  VP_PDOUT_PDOUT5_VDATA5HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT4_MASK            0x00000010u
  #define _VP_PDOUT_PDOUT4_SHIFT           0x00000004u
  #define  VP_PDOUT_PDOUT4_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT4_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT4_VDATA4LO        0x00000000u
  #define  VP_PDOUT_PDOUT4_VDATA4HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT3_MASK            0x00000008u
  #define _VP_PDOUT_PDOUT3_SHIFT           0x00000003u
  #define  VP_PDOUT_PDOUT3_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT3_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT3_VDATA3LO        0x00000000u
  #define  VP_PDOUT_PDOUT3_VDATA3HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT2_MASK            0x00000004u
  #define _VP_PDOUT_PDOUT2_SHIFT           0x00000002u
  #define  VP_PDOUT_PDOUT2_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT2_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT2_VDATA2LO        0x00000000u
  #define  VP_PDOUT_PDOUT2_VDATA2HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT1_MASK            0x00000002u
  #define _VP_PDOUT_PDOUT1_SHIFT           0x00000001u
  #define  VP_PDOUT_PDOUT1_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT1_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT1_VDATA1LO        0x00000000u
  #define  VP_PDOUT_PDOUT1_VDATA1HI        0x00000001u
  
  #define _VP_PDOUT_PDOUT0_MASK            0x00000001u
  #define _VP_PDOUT_PDOUT0_SHIFT           0x00000000u
  #define  VP_PDOUT_PDOUT0_DEFAULT         0x00000000u
  #define  VP_PDOUT_PDOUT0_OF(x)           _VALUEOF(x)
  #define  VP_PDOUT_PDOUT0_VDATA0LO        0x00000000u
  #define  VP_PDOUT_PDOUT0_VDATA0HI        0x00000001u
  
  #define  VP_PDOUT_OF(x)             _VALUEOF(x)

  #define VP_PDOUT_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PDOUT,PDOUT22)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT21)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT20)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT19)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT18)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT17)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT16)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT15)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT14)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT13)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT12)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT11)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT10)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT9)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT8)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT7)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT6)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT5)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT4)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT3)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT2)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT1)\
   |_PER_FDEFAULT(VP,PDOUT,PDOUT0)\
  )

#define VP_PDOUT_RMK(pdout22,pdout21,pdout20,pdout19,pdout18,pdout17,pdout16,\
  pdout15,pdout14,pdout13,pdout12,pdout11,pdout10,pdout9,pdout8,pdout7,\
  pdout6,pdout5,pdout4,pdout3,pdout2,pdout1,pdout0) (Uint32)(\
    _PER_FMK(VP,PDOUT,PDOUT22,pdout22)\
   |_PER_FMK(VP,PDOUT,PDOUT21,pdout21)\
   |_PER_FMK(VP,PDOUT,PDOUT20,pdout20)\
   |_PER_FMK(VP,PDOUT,PDOUT19,pdout19)\
   |_PER_FMK(VP,PDOUT,PDOUT18,pdout18)\
   |_PER_FMK(VP,PDOUT,PDOUT17,pdout17)\
   |_PER_FMK(VP,PDOUT,PDOUT16,pdout16)\
   |_PER_FMK(VP,PDOUT,PDOUT15,pdout15)\
   |_PER_FMK(VP,PDOUT,PDOUT14,pdout14)\
   |_PER_FMK(VP,PDOUT,PDOUT13,pdout13)\
   |_PER_FMK(VP,PDOUT,PDOUT12,pdout12)\
   |_PER_FMK(VP,PDOUT,PDOUT11,pdout11)\
   |_PER_FMK(VP,PDOUT,PDOUT10,pdout10)\
   |_PER_FMK(VP,PDOUT,PDOUT9,pdout9)\
   |_PER_FMK(VP,PDOUT,PDOUT8,pdout8)\
   |_PER_FMK(VP,PDOUT,PDOUT7,pdout7)\
   |_PER_FMK(VP,PDOUT,PDOUT6,pdout6)\
   |_PER_FMK(VP,PDOUT,PDOUT5,pdout5)\
   |_PER_FMK(VP,PDOUT,PDOUT4,pdout4)\
   |_PER_FMK(VP,PDOUT,PDOUT3,pdout3)\
   |_PER_FMK(VP,PDOUT,PDOUT2,pdout2)\
   |_PER_FMK(VP,PDOUT,PDOUT1,pdout1)\
   |_PER_FMK(VP,PDOUT,PDOUT0,pdout0)\
  )

  #define _VP_PDOUT_FGET(N,FIELD)\
    _PER_FGET(_VP_PDOUT##N##_ADDR,VP,PDOUT,##FIELD)

  #define _VP_PDOUT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PDOUT##N##_ADDR,VP,PDOUT,##FIELD,field)

  #define _VP_PDOUT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PDOUT##N##_ADDR,VP,PDOUT,##FIELD,##SYM)

  #define _VP_PDOUT0_FGET(FIELD)   _VP_PDOUT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDOUT1_FGET(FIELD)   _VP_PDOUT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDOUT2_FGET(FIELD)   _VP_PDOUT_FGET(2,##FIELD)
 #endif


  #define _VP_PDOUT0_FSET(FIELD,f)   _VP_PDOUT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDOUT1_FSET(FIELD,f)   _VP_PDOUT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDOUT2_FSET(FIELD,f)   _VP_PDOUT_FSET(2,##FIELD,f)
 #endif


  #define _VP_PDOUT0_FSETS(FIELD,SYM)   _VP_PDOUT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDOUT1_FSETS(FIELD,SYM)   _VP_PDOUT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDOUT2_FSETS(FIELD,SYM)   _VP_PDOUT_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P D S E T        |
* |___________________|
*
* PDSET0  - Video Port 0 Pin Data Set Register
* PDSET1  - Video Port 1 Pin Data Set Register
* PDSET2  - Video Port 2 Pin Data Set Register
*
* FIELDS (msb -> lsb)
* (w) PDSET22
* (w) PDSET21
* (w) PDSET20
* (w) PDSET19
* (w) PDSET18
* (w) PDSET17
* (w) PDSET16
* (w) PDSET15
* (w) PDSET14
* (w) PDSET13
* (w) PDSET12
* (w) PDSET11
* (w) PDSET10
* (w) PDSET9
* (w) PDSET8
* (w) PDSET7
* (w) PDSET6
* (w) PDSET5
* (w) PDSET4
* (w) PDSET3
* (w) PDSET2
* (w) PDSET1
* (w) PDSET0
*
\******************************************************************************/
  #define _VP_PDSET_OFFSET            12

  #define _VP_PDSET0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PDSET_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDSET1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PDSET_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDSET2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PDSET_OFFSET)
 #endif


  #define _VP_PDSET_PDSET22_MASK           0x00400000u
  #define _VP_PDSET_PDSET22_SHIFT          0x00000016u
  #define  VP_PDSET_PDSET22_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET22_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET22_NONE           0x00000000u
  #define  VP_PDSET_PDSET22_VCTL2HI        0x00000001u
  
  #define _VP_PDSET_PDSET21_MASK           0x00200000u
  #define _VP_PDSET_PDSET21_SHIFT          0x00000015u
  #define  VP_PDSET_PDSET21_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET21_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET21_NONE           0x00000000u
  #define  VP_PDSET_PDSET21_VCTL1HI        0x00000001u
  
  #define _VP_PDSET_PDSET20_MASK           0x00100000u
  #define _VP_PDSET_PDSET20_SHIFT          0x00000014u
  #define  VP_PDSET_PDSET20_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET20_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET20_NONE           0x00000000u
  #define  VP_PDSET_PDSET20_VCTL0HI        0x00000001u
  
  #define _VP_PDSET_PDSET19_MASK           0x00080000u
  #define _VP_PDSET_PDSET19_SHIFT          0x00000013u
  #define  VP_PDSET_PDSET19_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET19_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET19_NONE           0x00000000u
  #define  VP_PDSET_PDSET19_VDATA19HI      0x00000001u
  
  #define _VP_PDSET_PDSET18_MASK           0x00040000u
  #define _VP_PDSET_PDSET18_SHIFT          0x00000012u
  #define  VP_PDSET_PDSET18_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET18_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET18_NONE           0x00000000u
  #define  VP_PDSET_PDSET18_VDATA18HI      0x00000001u
  
  #define _VP_PDSET_PDSET17_MASK           0x00020000u
  #define _VP_PDSET_PDSET17_SHIFT          0x00000011u
  #define  VP_PDSET_PDSET17_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET17_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET17_NONE           0x00000000u
  #define  VP_PDSET_PDSET17_VDATA17HI      0x00000001u
  
  #define _VP_PDSET_PDSET16_MASK           0x00010000u
  #define _VP_PDSET_PDSET16_SHIFT          0x00000010u
  #define  VP_PDSET_PDSET16_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET16_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET16_NONE           0x00000000u
  #define  VP_PDSET_PDSET16_VDATA16HI      0x00000001u
  
  #define _VP_PDSET_PDSET15_MASK           0x00008000u
  #define _VP_PDSET_PDSET15_SHIFT          0x0000000Fu
  #define  VP_PDSET_PDSET15_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET15_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET15_NONE           0x00000000u
  #define  VP_PDSET_PDSET15_VDATA15HI      0x00000001u
  
  #define _VP_PDSET_PDSET14_MASK           0x00004000u
  #define _VP_PDSET_PDSET14_SHIFT          0x0000000Eu
  #define  VP_PDSET_PDSET14_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET14_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET14_NONE           0x00000000u
  #define  VP_PDSET_PDSET14_VDATA14HI      0x00000001u
  
  #define _VP_PDSET_PDSET13_MASK           0x00002000u
  #define _VP_PDSET_PDSET13_SHIFT          0x0000000Du
  #define  VP_PDSET_PDSET13_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET13_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET13_NONE           0x00000000u
  #define  VP_PDSET_PDSET13_VDATA13HI      0x00000001u
  
  #define _VP_PDSET_PDSET12_MASK           0x00001000u
  #define _VP_PDSET_PDSET12_SHIFT          0x0000000Cu
  #define  VP_PDSET_PDSET12_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET12_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET12_NONE           0x00000000u
  #define  VP_PDSET_PDSET12_VDATA12HI      0x00000001u
  
  #define _VP_PDSET_PDSET11_MASK           0x00000800u
  #define _VP_PDSET_PDSET11_SHIFT          0x0000000Bu
  #define  VP_PDSET_PDSET11_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET11_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET11_NONE           0x00000000u
  #define  VP_PDSET_PDSET11_VDATA11HI      0x00000001u
  
  #define _VP_PDSET_PDSET10_MASK           0x00000400u
  #define _VP_PDSET_PDSET10_SHIFT          0x0000000Au
  #define  VP_PDSET_PDSET10_DEFAULT        0x00000000u
  #define  VP_PDSET_PDSET10_OF(x)          _VALUEOF(x)
  #define  VP_PDSET_PDSET10_NONE           0x00000000u
  #define  VP_PDSET_PDSET10_VDATA10HI      0x00000001u
  
  #define _VP_PDSET_PDSET9_MASK            0x00000200u
  #define _VP_PDSET_PDSET9_SHIFT           0x00000009u
  #define  VP_PDSET_PDSET9_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET9_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET9_NONE            0x00000000u
  #define  VP_PDSET_PDSET9_VDATA9HI        0x00000001u
  
  #define _VP_PDSET_PDSET8_MASK            0x00000100u
  #define _VP_PDSET_PDSET8_SHIFT           0x00000008u
  #define  VP_PDSET_PDSET8_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET8_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET8_NONE            0x00000000u
  #define  VP_PDSET_PDSET8_VDATA8HI        0x00000001u
  
  #define _VP_PDSET_PDSET7_MASK            0x00000080u
  #define _VP_PDSET_PDSET7_SHIFT           0x00000007u
  #define  VP_PDSET_PDSET7_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET7_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET7_NONE            0x00000000u
  #define  VP_PDSET_PDSET7_VDATA7HI        0x00000001u
  
  #define _VP_PDSET_PDSET6_MASK            0x00000040u
  #define _VP_PDSET_PDSET6_SHIFT           0x00000006u
  #define  VP_PDSET_PDSET6_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET6_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET6_NONE            0x00000000u
  #define  VP_PDSET_PDSET6_VDATA6HI        0x00000001u
  
  #define _VP_PDSET_PDSET5_MASK            0x00000020u
  #define _VP_PDSET_PDSET5_SHIFT           0x00000005u
  #define  VP_PDSET_PDSET5_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET5_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET5_NONE            0x00000000u
  #define  VP_PDSET_PDSET5_VDATA5HI        0x00000001u
  
  #define _VP_PDSET_PDSET4_MASK            0x00000010u
  #define _VP_PDSET_PDSET4_SHIFT           0x00000004u
  #define  VP_PDSET_PDSET4_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET4_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET4_NONE            0x00000000u
  #define  VP_PDSET_PDSET4_VDATA4HI        0x00000001u
  
  #define _VP_PDSET_PDSET3_MASK            0x00000008u
  #define _VP_PDSET_PDSET3_SHIFT           0x00000003u
  #define  VP_PDSET_PDSET3_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET3_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET3_NONE            0x00000000u
  #define  VP_PDSET_PDSET3_VDATA3HI        0x00000001u
  
  #define _VP_PDSET_PDSET2_MASK            0x00000004u
  #define _VP_PDSET_PDSET2_SHIFT           0x00000002u
  #define  VP_PDSET_PDSET2_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET2_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET2_NONE            0x00000000u
  #define  VP_PDSET_PDSET2_VDATA2HI        0x00000001u
  
  #define _VP_PDSET_PDSET1_MASK            0x00000002u
  #define _VP_PDSET_PDSET1_SHIFT           0x00000001u
  #define  VP_PDSET_PDSET1_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET1_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET1_NONE            0x00000000u
  #define  VP_PDSET_PDSET1_VDATA1HI        0x00000001u
  
  #define _VP_PDSET_PDSET0_MASK            0x00000001u
  #define _VP_PDSET_PDSET0_SHIFT           0x00000000u
  #define  VP_PDSET_PDSET0_DEFAULT         0x00000000u
  #define  VP_PDSET_PDSET0_OF(x)           _VALUEOF(x)
  #define  VP_PDSET_PDSET0_NONE            0x00000000u
  #define  VP_PDSET_PDSET0_VDATA0HI        0x00000001u
  
  #define  VP_PDSET_OF(x)             _VALUEOF(x)

  #define VP_PDSET_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PDSET,PDSET22)\
   |_PER_FDEFAULT(VP,PDSET,PDSET21)\
   |_PER_FDEFAULT(VP,PDSET,PDSET20)\
   |_PER_FDEFAULT(VP,PDSET,PDSET19)\
   |_PER_FDEFAULT(VP,PDSET,PDSET18)\
   |_PER_FDEFAULT(VP,PDSET,PDSET17)\
   |_PER_FDEFAULT(VP,PDSET,PDSET16)\
   |_PER_FDEFAULT(VP,PDSET,PDSET15)\
   |_PER_FDEFAULT(VP,PDSET,PDSET14)\
   |_PER_FDEFAULT(VP,PDSET,PDSET13)\
   |_PER_FDEFAULT(VP,PDSET,PDSET12)\
   |_PER_FDEFAULT(VP,PDSET,PDSET11)\
   |_PER_FDEFAULT(VP,PDSET,PDSET10)\
   |_PER_FDEFAULT(VP,PDSET,PDSET9)\
   |_PER_FDEFAULT(VP,PDSET,PDSET8)\
   |_PER_FDEFAULT(VP,PDSET,PDSET7)\
   |_PER_FDEFAULT(VP,PDSET,PDSET6)\
   |_PER_FDEFAULT(VP,PDSET,PDSET5)\
   |_PER_FDEFAULT(VP,PDSET,PDSET4)\
   |_PER_FDEFAULT(VP,PDSET,PDSET3)\
   |_PER_FDEFAULT(VP,PDSET,PDSET2)\
   |_PER_FDEFAULT(VP,PDSET,PDSET1)\
   |_PER_FDEFAULT(VP,PDSET,PDSET0)\
  )

#define VP_PDSET_RMK(pdset22,pdset21,pdset20,pdset19,pdset18,pdset17,pdset16,\
  pdset15,pdset14,pdset13,pdset12,pdset11,pdset10,pdset9,pdset8,pdset7,\
  pdset6,pdset5,pdset4,pdset3,pdset2,pdset1,pdset0) (Uint32)(\
    _PER_FMK(VP,PDSET,PDSET22,pdset22)\
   |_PER_FMK(VP,PDSET,PDSET21,pdset21)\
   |_PER_FMK(VP,PDSET,PDSET20,pdset20)\
   |_PER_FMK(VP,PDSET,PDSET19,pdset19)\
   |_PER_FMK(VP,PDSET,PDSET18,pdset18)\
   |_PER_FMK(VP,PDSET,PDSET17,pdset17)\
   |_PER_FMK(VP,PDSET,PDSET16,pdset16)\
   |_PER_FMK(VP,PDSET,PDSET15,pdset15)\
   |_PER_FMK(VP,PDSET,PDSET14,pdset14)\
   |_PER_FMK(VP,PDSET,PDSET13,pdset13)\
   |_PER_FMK(VP,PDSET,PDSET12,pdset12)\
   |_PER_FMK(VP,PDSET,PDSET11,pdset11)\
   |_PER_FMK(VP,PDSET,PDSET10,pdset10)\
   |_PER_FMK(VP,PDSET,PDSET9,pdset9)\
   |_PER_FMK(VP,PDSET,PDSET8,pdset8)\
   |_PER_FMK(VP,PDSET,PDSET7,pdset7)\
   |_PER_FMK(VP,PDSET,PDSET6,pdset6)\
   |_PER_FMK(VP,PDSET,PDSET5,pdset5)\
   |_PER_FMK(VP,PDSET,PDSET4,pdset4)\
   |_PER_FMK(VP,PDSET,PDSET3,pdset3)\
   |_PER_FMK(VP,PDSET,PDSET2,pdset2)\
   |_PER_FMK(VP,PDSET,PDSET1,pdset1)\
   |_PER_FMK(VP,PDSET,PDSET0,pdset0)\
  )

  #define _VP_PDSET_FGET(N,FIELD)\
    _PER_FGET(_VP_PDSET##N##_ADDR,VP,PDSET,##FIELD)

  #define _VP_PDSET_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PDSET##N##_ADDR,VP,PDSET,##FIELD,field)

  #define _VP_PDSET_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PDSET##N##_ADDR,VP,PDSET,##FIELD,##SYM)

  #define _VP_PDSET0_FGET(FIELD)   _VP_PDSET_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDSET1_FGET(FIELD)   _VP_PDSET_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDSET2_FGET(FIELD)   _VP_PDSET_FGET(2,##FIELD)
 #endif


  #define _VP_PDSET0_FSET(FIELD,f)   _VP_PDSET_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDSET1_FSET(FIELD,f)   _VP_PDSET_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDSET2_FSET(FIELD,f)   _VP_PDSET_FSET(2,##FIELD,f)
 #endif


  #define _VP_PDSET0_FSETS(FIELD,SYM)   _VP_PDSET_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDSET1_FSETS(FIELD,SYM)   _VP_PDSET_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDSET2_FSETS(FIELD,SYM)   _VP_PDSET_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P D C L R        |
* |___________________|
*
* PDCLR0  - Video Port 0 Pin Data Clear Register
* PDCLR1  - Video Port 1 Pin Data Clear Register
* PDCLR2  - Video Port 2 Pin Data Clear Register
*
* FIELDS (msb -> lsb)
* (w) PDCLR22
* (w) PDCLR21
* (w) PDCLR20
* (w) PDCLR19
* (w) PDCLR18
* (w) PDCLR17
* (w) PDCLR16
* (w) PDCLR15
* (w) PDCLR14
* (w) PDCLR13
* (w) PDCLR12
* (w) PDCLR11
* (w) PDCLR10
* (w) PDCLR9
* (w) PDCLR8
* (w) PDCLR7
* (w) PDCLR6
* (w) PDCLR5
* (w) PDCLR4
* (w) PDCLR3
* (w) PDCLR2
* (w) PDCLR1
* (w) PDCLR0
*
\******************************************************************************/
  #define _VP_PDCLR_OFFSET            13

  #define _VP_PDCLR0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PDCLR_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDCLR1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PDCLR_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDCLR2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PDCLR_OFFSET)
 #endif


  #define _VP_PDCLR_PDCLR22_MASK           0x00400000u
  #define _VP_PDCLR_PDCLR22_SHIFT          0x00000016u
  #define  VP_PDCLR_PDCLR22_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR22_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR22_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR22_VCTL2CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR21_MASK           0x00200000u
  #define _VP_PDCLR_PDCLR21_SHIFT          0x00000015u
  #define  VP_PDCLR_PDCLR21_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR21_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR21_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR21_VCTL1CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR20_MASK           0x00100000u
  #define _VP_PDCLR_PDCLR20_SHIFT          0x00000014u
  #define  VP_PDCLR_PDCLR20_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR20_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR20_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR20_VCTL0CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR19_MASK           0x00080000u
  #define _VP_PDCLR_PDCLR19_SHIFT          0x00000013u
  #define  VP_PDCLR_PDCLR19_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR19_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR19_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR19_VDATA19CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR18_MASK           0x00040000u
  #define _VP_PDCLR_PDCLR18_SHIFT          0x00000012u
  #define  VP_PDCLR_PDCLR18_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR18_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR18_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR18_VDATA18CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR17_MASK           0x00020000u
  #define _VP_PDCLR_PDCLR17_SHIFT          0x00000011u
  #define  VP_PDCLR_PDCLR17_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR17_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR17_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR17_VDATA17CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR16_MASK           0x00010000u
  #define _VP_PDCLR_PDCLR16_SHIFT          0x00000010u
  #define  VP_PDCLR_PDCLR16_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR16_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR16_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR16_VDATA16CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR15_MASK           0x00008000u
  #define _VP_PDCLR_PDCLR15_SHIFT          0x0000000Fu
  #define  VP_PDCLR_PDCLR15_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR15_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR15_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR15_VDATA15CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR14_MASK           0x00004000u
  #define _VP_PDCLR_PDCLR14_SHIFT          0x0000000Eu
  #define  VP_PDCLR_PDCLR14_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR14_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR14_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR14_VDATA14CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR13_MASK           0x00002000u
  #define _VP_PDCLR_PDCLR13_SHIFT          0x0000000Du
  #define  VP_PDCLR_PDCLR13_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR13_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR13_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR13_VDATA13CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR12_MASK           0x00001000u
  #define _VP_PDCLR_PDCLR12_SHIFT          0x0000000Cu
  #define  VP_PDCLR_PDCLR12_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR12_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR12_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR12_VDATA12CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR11_MASK           0x00000800u
  #define _VP_PDCLR_PDCLR11_SHIFT          0x0000000Bu
  #define  VP_PDCLR_PDCLR11_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR11_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR11_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR11_VDATA11CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR10_MASK           0x00000400u
  #define _VP_PDCLR_PDCLR10_SHIFT          0x0000000Au
  #define  VP_PDCLR_PDCLR10_DEFAULT        0x00000000u
  #define  VP_PDCLR_PDCLR10_OF(x)          _VALUEOF(x)
  #define  VP_PDCLR_PDCLR10_NONE           0x00000000u
  #define  VP_PDCLR_PDCLR10_VDATA10CLR     0x00000001u
  
  #define _VP_PDCLR_PDCLR9_MASK            0x00000200u
  #define _VP_PDCLR_PDCLR9_SHIFT           0x00000009u
  #define  VP_PDCLR_PDCLR9_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR9_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR9_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR9_VDATA9CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR8_MASK            0x00000100u
  #define _VP_PDCLR_PDCLR8_SHIFT           0x00000008u
  #define  VP_PDCLR_PDCLR8_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR8_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR8_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR8_VDATA8CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR7_MASK            0x00000080u
  #define _VP_PDCLR_PDCLR7_SHIFT           0x00000007u
  #define  VP_PDCLR_PDCLR7_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR7_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR7_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR7_VDATA7CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR6_MASK            0x00000040u
  #define _VP_PDCLR_PDCLR6_SHIFT           0x00000006u
  #define  VP_PDCLR_PDCLR6_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR6_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR6_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR6_VDATA6CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR5_MASK            0x00000020u
  #define _VP_PDCLR_PDCLR5_SHIFT           0x00000005u
  #define  VP_PDCLR_PDCLR5_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR5_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR5_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR5_VDATA5CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR4_MASK            0x00000010u
  #define _VP_PDCLR_PDCLR4_SHIFT           0x00000004u
  #define  VP_PDCLR_PDCLR4_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR4_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR4_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR4_VDATA4CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR3_MASK            0x00000008u
  #define _VP_PDCLR_PDCLR3_SHIFT           0x00000003u
  #define  VP_PDCLR_PDCLR3_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR3_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR3_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR3_VDATA3CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR2_MASK            0x00000004u
  #define _VP_PDCLR_PDCLR2_SHIFT           0x00000002u
  #define  VP_PDCLR_PDCLR2_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR2_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR2_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR2_VDATA2CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR1_MASK            0x00000002u
  #define _VP_PDCLR_PDCLR1_SHIFT           0x00000001u
  #define  VP_PDCLR_PDCLR1_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR1_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR1_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR1_VDATA1CLR       0x00000001u
  
  #define _VP_PDCLR_PDCLR0_MASK            0x00000001u
  #define _VP_PDCLR_PDCLR0_SHIFT           0x00000000u
  #define  VP_PDCLR_PDCLR0_DEFAULT         0x00000000u
  #define  VP_PDCLR_PDCLR0_OF(x)           _VALUEOF(x)
  #define  VP_PDCLR_PDCLR0_NONE            0x00000000u
  #define  VP_PDCLR_PDCLR0_VDATA0CLR       0x00000001u
  
  #define  VP_PDCLR_OF(x)             _VALUEOF(x)

  #define VP_PDCLR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PDCLR,PDCLR22)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR21)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR20)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR19)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR18)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR17)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR16)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR15)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR14)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR13)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR12)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR11)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR10)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR9)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR8)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR7)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR6)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR5)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR4)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR3)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR2)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR1)\
   |_PER_FDEFAULT(VP,PDCLR,PDCLR0)\
  )

#define VP_PDCLR_RMK(pdclr22,pdclr21,pdclr20,pdclr19,pdclr18,pdclr17,pdclr16,\
  pdclr15,pdclr14,pdclr13,pdclr12,pdclr11,pdclr10,pdclr9,pdclr8,pdclr7,\
  pdclr6,pdclr5,pdclr4,pdclr3,pdclr2,pdclr1,pdclr0) (Uint32)(\
    _PER_FMK(VP,PDCLR,PDCLR22,pdclr22)\
   |_PER_FMK(VP,PDCLR,PDCLR21,pdclr21)\
   |_PER_FMK(VP,PDCLR,PDCLR20,pdclr20)\
   |_PER_FMK(VP,PDCLR,PDCLR19,pdclr19)\
   |_PER_FMK(VP,PDCLR,PDCLR18,pdclr18)\
   |_PER_FMK(VP,PDCLR,PDCLR17,pdclr17)\
   |_PER_FMK(VP,PDCLR,PDCLR16,pdclr16)\
   |_PER_FMK(VP,PDCLR,PDCLR15,pdclr15)\
   |_PER_FMK(VP,PDCLR,PDCLR14,pdclr14)\
   |_PER_FMK(VP,PDCLR,PDCLR13,pdclr13)\
   |_PER_FMK(VP,PDCLR,PDCLR12,pdclr12)\
   |_PER_FMK(VP,PDCLR,PDCLR11,pdclr11)\
   |_PER_FMK(VP,PDCLR,PDCLR10,pdclr10)\
   |_PER_FMK(VP,PDCLR,PDCLR9,pdclr9)\
   |_PER_FMK(VP,PDCLR,PDCLR8,pdclr8)\
   |_PER_FMK(VP,PDCLR,PDCLR7,pdclr7)\
   |_PER_FMK(VP,PDCLR,PDCLR6,pdclr6)\
   |_PER_FMK(VP,PDCLR,PDCLR5,pdclr5)\
   |_PER_FMK(VP,PDCLR,PDCLR4,pdclr4)\
   |_PER_FMK(VP,PDCLR,PDCLR3,pdclr3)\
   |_PER_FMK(VP,PDCLR,PDCLR2,pdclr2)\
   |_PER_FMK(VP,PDCLR,PDCLR1,pdclr1)\
   |_PER_FMK(VP,PDCLR,PDCLR0,pdclr0)\
  )

  #define _VP_PDCLR_FGET(N,FIELD)\
    _PER_FGET(_VP_PDCLR##N##_ADDR,VP,PDCLR,##FIELD)

  #define _VP_PDCLR_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PDCLR##N##_ADDR,VP,PDCLR,##FIELD,field)

  #define _VP_PDCLR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PDCLR##N##_ADDR,VP,PDCLR,##FIELD,##SYM)

  #define _VP_PDCLR0_FGET(FIELD)   _VP_PDCLR_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDCLR1_FGET(FIELD)   _VP_PDCLR_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDCLR2_FGET(FIELD)   _VP_PDCLR_FGET(2,##FIELD)
 #endif


  #define _VP_PDCLR0_FSET(FIELD,f)   _VP_PDCLR_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDCLR1_FSET(FIELD,f)   _VP_PDCLR_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDCLR2_FSET(FIELD,f)   _VP_PDCLR_FSET(2,##FIELD,f)
 #endif


  #define _VP_PDCLR0_FSETS(FIELD,SYM)   _VP_PDCLR_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PDCLR1_FSETS(FIELD,SYM)   _VP_PDCLR_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PDCLR2_FSETS(FIELD,SYM)   _VP_PDCLR_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P I E N          |
* |___________________|
*
* PIEN0  - Video Port 0 Pin Interrupt Enable Register
* PIEN1  - Video Port 1 Pin Interrupt Enable Register
* PIEN2  - Video Port 2 Pin Interrupt Enable Register
*
* FIELDS (msb -> lsb)
* (w) PIEN22
* (w) PIEN21
* (w) PIEN20
* (w) PIEN19
* (w) PIEN18
* (w) PIEN17
* (w) PIEN16
* (w) PIEN15
* (w) PIEN14
* (w) PIEN13
* (w) PIEN12
* (w) PIEN11
* (w) PIEN10
* (w) PIEN9
* (w) PIEN8
* (w) PIEN7
* (w) PIEN6
* (w) PIEN5
* (w) PIEN4
* (w) PIEN3
* (w) PIEN2
* (w) PIEN1
* (w) PIEN0
*
\******************************************************************************/
  #define _VP_PIEN_OFFSET            14

  #define _VP_PIEN0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PIEN_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PIEN1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PIEN_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PIEN2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PIEN_OFFSET)
 #endif


  #define _VP_PIEN_PIEN22_MASK           0x00400000u
  #define _VP_PIEN_PIEN22_SHIFT          0x00000016u
  #define  VP_PIEN_PIEN22_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN22_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN22_VCTL2LO        0x00000000u
  #define  VP_PIEN_PIEN22_VCTL2HI        0x00000001u
  
  #define _VP_PIEN_PIEN21_MASK           0x00200000u
  #define _VP_PIEN_PIEN21_SHIFT          0x00000015u
  #define  VP_PIEN_PIEN21_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN21_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN21_VCTL1LO        0x00000000u
  #define  VP_PIEN_PIEN21_VCTL1HI        0x00000001u
  
  #define _VP_PIEN_PIEN20_MASK           0x00100000u
  #define _VP_PIEN_PIEN20_SHIFT          0x00000014u
  #define  VP_PIEN_PIEN20_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN20_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN20_VCTL0LO        0x00000000u
  #define  VP_PIEN_PIEN20_VCTL0HI        0x00000001u
  
  #define _VP_PIEN_PIEN19_MASK           0x00080000u
  #define _VP_PIEN_PIEN19_SHIFT          0x00000013u
  #define  VP_PIEN_PIEN19_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN19_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN19_VDATA19LO      0x00000000u
  #define  VP_PIEN_PIEN19_VDATA19HI      0x00000001u
  
  #define _VP_PIEN_PIEN18_MASK           0x00040000u
  #define _VP_PIEN_PIEN18_SHIFT          0x00000012u
  #define  VP_PIEN_PIEN18_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN18_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN18_VDATA18LO      0x00000000u
  #define  VP_PIEN_PIEN18_VDATA18HI      0x00000001u
  
  #define _VP_PIEN_PIEN17_MASK           0x00020000u
  #define _VP_PIEN_PIEN17_SHIFT          0x00000011u
  #define  VP_PIEN_PIEN17_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN17_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN17_VDATA17LO      0x00000000u
  #define  VP_PIEN_PIEN17_VDATA17HI      0x00000001u
  
  #define _VP_PIEN_PIEN16_MASK           0x00010000u
  #define _VP_PIEN_PIEN16_SHIFT          0x00000010u
  #define  VP_PIEN_PIEN16_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN16_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN16_VDATA16LO      0x00000000u
  #define  VP_PIEN_PIEN16_VDATA16HI      0x00000001u
  
  #define _VP_PIEN_PIEN15_MASK           0x00008000u
  #define _VP_PIEN_PIEN15_SHIFT          0x0000000Fu
  #define  VP_PIEN_PIEN15_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN15_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN15_VDATA15LO      0x00000000u
  #define  VP_PIEN_PIEN15_VDATA15HI      0x00000001u
  
  #define _VP_PIEN_PIEN14_MASK           0x00004000u
  #define _VP_PIEN_PIEN14_SHIFT          0x0000000Eu
  #define  VP_PIEN_PIEN14_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN14_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN14_VDATA14LO      0x00000000u
  #define  VP_PIEN_PIEN14_VDATA14HI      0x00000001u
  
  #define _VP_PIEN_PIEN13_MASK           0x00002000u
  #define _VP_PIEN_PIEN13_SHIFT          0x0000000Du
  #define  VP_PIEN_PIEN13_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN13_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN13_VDATA13LO      0x00000000u
  #define  VP_PIEN_PIEN13_VDATA13HI      0x00000001u
  
  #define _VP_PIEN_PIEN12_MASK           0x00001000u
  #define _VP_PIEN_PIEN12_SHIFT          0x0000000Cu
  #define  VP_PIEN_PIEN12_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN12_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN12_VDATA12LO      0x00000000u
  #define  VP_PIEN_PIEN12_VDATA12HI      0x00000001u
  
  #define _VP_PIEN_PIEN11_MASK           0x00000800u
  #define _VP_PIEN_PIEN11_SHIFT          0x0000000Bu
  #define  VP_PIEN_PIEN11_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN11_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN11_VDATA11LO      0x00000000u
  #define  VP_PIEN_PIEN11_VDATA11HI      0x00000001u
  
  #define _VP_PIEN_PIEN10_MASK           0x00000400u
  #define _VP_PIEN_PIEN10_SHIFT          0x0000000Au
  #define  VP_PIEN_PIEN10_DEFAULT        0x00000000u
  #define  VP_PIEN_PIEN10_OF(x)          _VALUEOF(x)
  #define  VP_PIEN_PIEN10_VDATA10LO      0x00000000u
  #define  VP_PIEN_PIEN10_VDATA10HI      0x00000001u
  
  #define _VP_PIEN_PIEN9_MASK            0x00000200u
  #define _VP_PIEN_PIEN9_SHIFT           0x00000009u
  #define  VP_PIEN_PIEN9_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN9_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN9_VDATA9LO        0x00000000u
  #define  VP_PIEN_PIEN9_VDATA9HI        0x00000001u
  
  #define _VP_PIEN_PIEN8_MASK            0x00000100u
  #define _VP_PIEN_PIEN8_SHIFT           0x00000008u
  #define  VP_PIEN_PIEN8_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN8_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN8_VDATA8LO        0x00000000u
  #define  VP_PIEN_PIEN8_VDATA8HI        0x00000001u
  
  #define _VP_PIEN_PIEN7_MASK            0x00000080u
  #define _VP_PIEN_PIEN7_SHIFT           0x00000007u
  #define  VP_PIEN_PIEN7_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN7_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN7_VDATA7LO        0x00000000u
  #define  VP_PIEN_PIEN7_VDATA7HI        0x00000001u
  
  #define _VP_PIEN_PIEN6_MASK            0x00000040u
  #define _VP_PIEN_PIEN6_SHIFT           0x00000006u
  #define  VP_PIEN_PIEN6_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN6_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN6_VDATA6LO        0x00000000u
  #define  VP_PIEN_PIEN6_VDATA6HI        0x00000001u
  
  #define _VP_PIEN_PIEN5_MASK            0x00000020u
  #define _VP_PIEN_PIEN5_SHIFT           0x00000005u
  #define  VP_PIEN_PIEN5_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN5_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN5_VDATA5LO        0x00000000u
  #define  VP_PIEN_PIEN5_VDATA5HI        0x00000001u
  
  #define _VP_PIEN_PIEN4_MASK            0x00000010u
  #define _VP_PIEN_PIEN4_SHIFT           0x00000004u
  #define  VP_PIEN_PIEN4_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN4_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN4_VDATA4LO        0x00000000u
  #define  VP_PIEN_PIEN4_VDATA4HI        0x00000001u
  
  #define _VP_PIEN_PIEN3_MASK            0x00000008u
  #define _VP_PIEN_PIEN3_SHIFT           0x00000003u
  #define  VP_PIEN_PIEN3_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN3_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN3_VDATA3LO        0x00000000u
  #define  VP_PIEN_PIEN3_VDATA3HI        0x00000001u
  
  #define _VP_PIEN_PIEN2_MASK            0x00000004u
  #define _VP_PIEN_PIEN2_SHIFT           0x00000002u
  #define  VP_PIEN_PIEN2_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN2_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN2_VDATA2LO        0x00000000u
  #define  VP_PIEN_PIEN2_VDATA2HI        0x00000001u
  
  #define _VP_PIEN_PIEN1_MASK            0x00000002u
  #define _VP_PIEN_PIEN1_SHIFT           0x00000001u
  #define  VP_PIEN_PIEN1_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN1_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN1_VDATA1LO        0x00000000u
  #define  VP_PIEN_PIEN1_VDATA1HI        0x00000001u
  
  #define _VP_PIEN_PIEN0_MASK            0x00000001u
  #define _VP_PIEN_PIEN0_SHIFT           0x00000000u
  #define  VP_PIEN_PIEN0_DEFAULT         0x00000000u
  #define  VP_PIEN_PIEN0_OF(x)           _VALUEOF(x)
  #define  VP_PIEN_PIEN0_VDATA0LO        0x00000000u
  #define  VP_PIEN_PIEN0_VDATA0HI        0x00000001u
  
  #define  VP_PIEN_OF(x)             _VALUEOF(x)

  #define VP_PIEN_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PIEN,PIEN22)\
   |_PER_FDEFAULT(VP,PIEN,PIEN21)\
   |_PER_FDEFAULT(VP,PIEN,PIEN20)\
   |_PER_FDEFAULT(VP,PIEN,PIEN19)\
   |_PER_FDEFAULT(VP,PIEN,PIEN18)\
   |_PER_FDEFAULT(VP,PIEN,PIEN17)\
   |_PER_FDEFAULT(VP,PIEN,PIEN16)\
   |_PER_FDEFAULT(VP,PIEN,PIEN15)\
   |_PER_FDEFAULT(VP,PIEN,PIEN14)\
   |_PER_FDEFAULT(VP,PIEN,PIEN13)\
   |_PER_FDEFAULT(VP,PIEN,PIEN12)\
   |_PER_FDEFAULT(VP,PIEN,PIEN11)\
   |_PER_FDEFAULT(VP,PIEN,PIEN10)\
   |_PER_FDEFAULT(VP,PIEN,PIEN9)\
   |_PER_FDEFAULT(VP,PIEN,PIEN8)\
   |_PER_FDEFAULT(VP,PIEN,PIEN7)\
   |_PER_FDEFAULT(VP,PIEN,PIEN6)\
   |_PER_FDEFAULT(VP,PIEN,PIEN5)\
   |_PER_FDEFAULT(VP,PIEN,PIEN4)\
   |_PER_FDEFAULT(VP,PIEN,PIEN3)\
   |_PER_FDEFAULT(VP,PIEN,PIEN2)\
   |_PER_FDEFAULT(VP,PIEN,PIEN1)\
   |_PER_FDEFAULT(VP,PIEN,PIEN0)\
  )

#define VP_PIEN_RMK(pien22,pien21,pien20,pien19,pien18,pien17,pien16,\
  pien15,pien14,pien13,pien12,pien11,pien10,pien9,pien8,pien7,\
  pien6,pien5,pien4,pien3,pien2,pien1,pien0) (Uint32)(\
    _PER_FMK(VP,PIEN,PIEN22,pien22)\
   |_PER_FMK(VP,PIEN,PIEN21,pien21)\
   |_PER_FMK(VP,PIEN,PIEN20,pien20)\
   |_PER_FMK(VP,PIEN,PIEN19,pien19)\
   |_PER_FMK(VP,PIEN,PIEN18,pien18)\
   |_PER_FMK(VP,PIEN,PIEN17,pien17)\
   |_PER_FMK(VP,PIEN,PIEN16,pien16)\
   |_PER_FMK(VP,PIEN,PIEN15,pien15)\
   |_PER_FMK(VP,PIEN,PIEN14,pien14)\
   |_PER_FMK(VP,PIEN,PIEN13,pien13)\
   |_PER_FMK(VP,PIEN,PIEN12,pien12)\
   |_PER_FMK(VP,PIEN,PIEN11,pien11)\
   |_PER_FMK(VP,PIEN,PIEN10,pien10)\
   |_PER_FMK(VP,PIEN,PIEN9,pien9)\
   |_PER_FMK(VP,PIEN,PIEN8,pien8)\
   |_PER_FMK(VP,PIEN,PIEN7,pien7)\
   |_PER_FMK(VP,PIEN,PIEN6,pien6)\
   |_PER_FMK(VP,PIEN,PIEN5,pien5)\
   |_PER_FMK(VP,PIEN,PIEN4,pien4)\
   |_PER_FMK(VP,PIEN,PIEN3,pien3)\
   |_PER_FMK(VP,PIEN,PIEN2,pien2)\
   |_PER_FMK(VP,PIEN,PIEN1,pien1)\
   |_PER_FMK(VP,PIEN,PIEN0,pien0)\
  )

  #define _VP_PIEN_FGET(N,FIELD)\
    _PER_FGET(_VP_PIEN##N##_ADDR,VP,PIEN,##FIELD)

  #define _VP_PIEN_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PIEN##N##_ADDR,VP,PIEN,##FIELD,field)

  #define _VP_PIEN_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PIEN##N##_ADDR,VP,PIEN,##FIELD,##SYM)

  #define _VP_PIEN0_FGET(FIELD)   _VP_PIEN_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PIEN1_FGET(FIELD)   _VP_PIEN_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PIEN2_FGET(FIELD)   _VP_PIEN_FGET(2,##FIELD)
 #endif


  #define _VP_PIEN0_FSET(FIELD,f)   _VP_PIEN_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PIEN1_FSET(FIELD,f)   _VP_PIEN_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PIEN2_FSET(FIELD,f)   _VP_PIEN_FSET(2,##FIELD,f)
 #endif


  #define _VP_PIEN0_FSETS(FIELD,SYM)   _VP_PIEN_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PIEN1_FSETS(FIELD,SYM)   _VP_PIEN_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PIEN2_FSETS(FIELD,SYM)   _VP_PIEN_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P I P O L        |
* |___________________|
*
* PIPOL0  - Video Port 0 Pin Interrupt Polarity Register
* PIPOL1  - Video Port 1 Pin Interrupt Polarity Register
* PIPOL2  - Video Port 2 Pin Interrupt Polarity Register
*
* FIELDS (msb -> lsb)
* (rw) PIPOL22
* (rw) PIPOL21
* (rw) PIPOL20
* (rw) PIPOL19
* (rw) PIPOL18
* (rw) PIPOL17
* (rw) PIPOL16
* (rw) PIPOL15
* (rw) PIPOL14
* (rw) PIPOL13
* (rw) PIPOL12
* (rw) PIPOL11
* (rw) PIPOL10
* (rw) PIPOL9
* (rw) PIPOL8
* (rw) PIPOL7
* (rw) PIPOL6
* (rw) PIPOL5
* (rw) PIPOL4
* (rw) PIPOL3
* (rw) PIPOL2
* (rw) PIPOL1
* (rw) PIPOL0
*
\******************************************************************************/
  #define _VP_PIPOL_OFFSET            15

  #define _VP_PIPOL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PIPOL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PIPOL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PIPOL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PIPOL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PIPOL_OFFSET)
 #endif


  #define _VP_PIPOL_PIPOL22_MASK           0x00400000u
  #define _VP_PIPOL_PIPOL22_SHIFT          0x00000016u
  #define  VP_PIPOL_PIPOL22_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL22_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL22_VCTL2ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL22_VCTL2ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL21_MASK           0x00200000u
  #define _VP_PIPOL_PIPOL21_SHIFT          0x00000015u
  #define  VP_PIPOL_PIPOL21_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL21_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL21_VCTL1ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL21_VCTL1ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL20_MASK           0x00100000u
  #define _VP_PIPOL_PIPOL20_SHIFT          0x00000014u
  #define  VP_PIPOL_PIPOL20_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL20_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL20_VCTL0ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL20_VCTL0ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL19_MASK           0x00080000u
  #define _VP_PIPOL_PIPOL19_SHIFT          0x00000013u
  #define  VP_PIPOL_PIPOL19_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL19_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL19_VDATA19ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL19_VDATA19ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL18_MASK           0x00040000u
  #define _VP_PIPOL_PIPOL18_SHIFT          0x00000012u
  #define  VP_PIPOL_PIPOL18_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL18_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL18_VDATA18ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL18_VDATA18ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL17_MASK           0x00020000u
  #define _VP_PIPOL_PIPOL17_SHIFT          0x00000011u
  #define  VP_PIPOL_PIPOL17_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL17_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL17_VDATA17ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL17_VDATA17ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL16_MASK           0x00010000u
  #define _VP_PIPOL_PIPOL16_SHIFT          0x00000010u
  #define  VP_PIPOL_PIPOL16_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL16_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL16_VDATA16ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL16_VDATA16ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL15_MASK           0x00008000u
  #define _VP_PIPOL_PIPOL15_SHIFT          0x0000000Fu
  #define  VP_PIPOL_PIPOL15_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL15_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL15_VDATA15ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL15_VDATA15ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL14_MASK           0x00004000u
  #define _VP_PIPOL_PIPOL14_SHIFT          0x0000000Eu
  #define  VP_PIPOL_PIPOL14_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL14_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL14_VDATA14ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL14_VDATA14ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL13_MASK           0x00002000u
  #define _VP_PIPOL_PIPOL13_SHIFT          0x0000000Du
  #define  VP_PIPOL_PIPOL13_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL13_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL13_VDATA13ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL13_VDATA13ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL12_MASK           0x00001000u
  #define _VP_PIPOL_PIPOL12_SHIFT          0x0000000Cu
  #define  VP_PIPOL_PIPOL12_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL12_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL12_VDATA12ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL12_VDATA12ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL11_MASK           0x00000800u
  #define _VP_PIPOL_PIPOL11_SHIFT          0x0000000Bu
  #define  VP_PIPOL_PIPOL11_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL11_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL11_VDATA11ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL11_VDATA11ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL10_MASK           0x00000400u
  #define _VP_PIPOL_PIPOL10_SHIFT          0x0000000Au
  #define  VP_PIPOL_PIPOL10_DEFAULT        0x00000000u
  #define  VP_PIPOL_PIPOL10_OF(x)          _VALUEOF(x)
  #define  VP_PIPOL_PIPOL10_VDATA10ACTHI   0x00000000u
  #define  VP_PIPOL_PIPOL10_VDATA10ACTLO   0x00000001u
  
  #define _VP_PIPOL_PIPOL9_MASK            0x00000200u
  #define _VP_PIPOL_PIPOL9_SHIFT           0x00000009u
  #define  VP_PIPOL_PIPOL9_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL9_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL9_VDATA9ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL9_VDATA9ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL8_MASK            0x00000100u
  #define _VP_PIPOL_PIPOL8_SHIFT           0x00000008u
  #define  VP_PIPOL_PIPOL8_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL8_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL8_VDATA8ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL8_VDATA8ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL7_MASK            0x00000080u
  #define _VP_PIPOL_PIPOL7_SHIFT           0x00000007u
  #define  VP_PIPOL_PIPOL7_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL7_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL7_VDATA7ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL7_VDATA7ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL6_MASK            0x00000040u
  #define _VP_PIPOL_PIPOL6_SHIFT           0x00000006u
  #define  VP_PIPOL_PIPOL6_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL6_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL6_VDATA6ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL6_VDATA6ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL5_MASK            0x00000020u
  #define _VP_PIPOL_PIPOL5_SHIFT           0x00000005u
  #define  VP_PIPOL_PIPOL5_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL5_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL5_VDATA5ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL5_VDATA5ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL4_MASK            0x00000010u
  #define _VP_PIPOL_PIPOL4_SHIFT           0x00000004u
  #define  VP_PIPOL_PIPOL4_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL4_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL4_VDATA4ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL4_VDATA4ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL3_MASK            0x00000008u
  #define _VP_PIPOL_PIPOL3_SHIFT           0x00000003u
  #define  VP_PIPOL_PIPOL3_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL3_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL3_VDATA3ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL3_VDATA3ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL2_MASK            0x00000004u
  #define _VP_PIPOL_PIPOL2_SHIFT           0x00000002u
  #define  VP_PIPOL_PIPOL2_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL2_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL2_VDATA2ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL2_VDATA2ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL1_MASK            0x00000002u
  #define _VP_PIPOL_PIPOL1_SHIFT           0x00000001u
  #define  VP_PIPOL_PIPOL1_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL1_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL1_VDATA1ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL1_VDATA1ACTLO     0x00000001u
  
  #define _VP_PIPOL_PIPOL0_MASK            0x00000001u
  #define _VP_PIPOL_PIPOL0_SHIFT           0x00000000u
  #define  VP_PIPOL_PIPOL0_DEFAULT         0x00000000u
  #define  VP_PIPOL_PIPOL0_OF(x)           _VALUEOF(x)
  #define  VP_PIPOL_PIPOL0_VDATA0ACTHI     0x00000000u
  #define  VP_PIPOL_PIPOL0_VDATA0ACTLO     0x00000001u
  
  #define  VP_PIPOL_OF(x)             _VALUEOF(x)

  #define VP_PIPOL_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PIPOL,PIPOL22)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL21)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL20)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL19)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL18)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL17)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL16)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL15)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL14)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL13)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL12)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL11)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL10)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL9)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL8)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL7)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL6)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL5)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL4)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL3)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL2)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL1)\
   |_PER_FDEFAULT(VP,PIPOL,PIPOL0)\
  )

#define VP_PIPOL_RMK(pipol22,pipol21,pipol20,pipol19,pipol18,pipol17,pipol16,\
  pipol15,pipol14,pipol13,pipol12,pipol11,pipol10,pipol9,pipol8,pipol7,\
  pipol6,pipol5,pipol4,pipol3,pipol2,pipol1,pipol0) (Uint32)(\
    _PER_FMK(VP,PIPOL,PIPOL22,pipol22)\
   |_PER_FMK(VP,PIPOL,PIPOL21,pipol21)\
   |_PER_FMK(VP,PIPOL,PIPOL20,pipol20)\
   |_PER_FMK(VP,PIPOL,PIPOL19,pipol19)\
   |_PER_FMK(VP,PIPOL,PIPOL18,pipol18)\
   |_PER_FMK(VP,PIPOL,PIPOL17,pipol17)\
   |_PER_FMK(VP,PIPOL,PIPOL16,pipol16)\
   |_PER_FMK(VP,PIPOL,PIPOL15,pipol15)\
   |_PER_FMK(VP,PIPOL,PIPOL14,pipol14)\
   |_PER_FMK(VP,PIPOL,PIPOL13,pipol13)\
   |_PER_FMK(VP,PIPOL,PIPOL12,pipol12)\
   |_PER_FMK(VP,PIPOL,PIPOL11,pipol11)\
   |_PER_FMK(VP,PIPOL,PIPOL10,pipol10)\
   |_PER_FMK(VP,PIPOL,PIPOL9,pipol9)\
   |_PER_FMK(VP,PIPOL,PIPOL8,pipol8)\
   |_PER_FMK(VP,PIPOL,PIPOL7,pipol7)\
   |_PER_FMK(VP,PIPOL,PIPOL6,pipol6)\
   |_PER_FMK(VP,PIPOL,PIPOL5,pipol5)\
   |_PER_FMK(VP,PIPOL,PIPOL4,pipol4)\
   |_PER_FMK(VP,PIPOL,PIPOL3,pipol3)\
   |_PER_FMK(VP,PIPOL,PIPOL2,pipol2)\
   |_PER_FMK(VP,PIPOL,PIPOL1,pipol1)\
   |_PER_FMK(VP,PIPOL,PIPOL0,pipol0)\
  )

  #define _VP_PIPOL_FGET(N,FIELD)\
    _PER_FGET(_VP_PIPOL##N##_ADDR,VP,PIPOL,##FIELD)

  #define _VP_PIPOL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PIPOL##N##_ADDR,VP,PIPOL,##FIELD,field)

  #define _VP_PIPOL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PIPOL##N##_ADDR,VP,PIPOL,##FIELD,##SYM)

  #define _VP_PIPOL0_FGET(FIELD)   _VP_PIPOL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PIPOL1_FGET(FIELD)   _VP_PIPOL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PIPOL2_FGET(FIELD)   _VP_PIPOL_FGET(2,##FIELD)
 #endif


  #define _VP_PIPOL0_FSET(FIELD,f)   _VP_PIPOL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PIPOL1_FSET(FIELD,f)   _VP_PIPOL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PIPOL2_FSET(FIELD,f)   _VP_PIPOL_FSET(2,##FIELD,f)
 #endif


  #define _VP_PIPOL0_FSETS(FIELD,SYM)   _VP_PIPOL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PIPOL1_FSETS(FIELD,SYM)   _VP_PIPOL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PIPOL2_FSETS(FIELD,SYM)   _VP_PIPOL_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  P I S T A T      |
* |___________________|
*
* PISTAT0  - Video Port 0 Pin Interrupt Status Register
* PISTAT1  - Video Port 1 Pin Interrupt Status Register
* PISTAT2  - Video Port 2 Pin Interrupt Status Register
*
* FIELDS (msb -> lsb)
* (r) PISTAT22
* (r) PISTAT21
* (r) PISTAT20
* (r) PISTAT19
* (r) PISTAT18
* (r) PISTAT17
* (r) PISTAT16
* (r) PISTAT15
* (r) PISTAT14
* (r) PISTAT13
* (r) PISTAT12
* (r) PISTAT11
* (r) PISTAT10
* (r) PISTAT9
* (r) PISTAT8
* (r) PISTAT7
* (r) PISTAT6
* (r) PISTAT5
* (r) PISTAT4
* (r) PISTAT3
* (r) PISTAT2
* (r) PISTAT1
* (r) PISTAT0
*
\******************************************************************************/
  #define _VP_PISTAT_OFFSET            16

  #define _VP_PISTAT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PISTAT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PISTAT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PISTAT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PISTAT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PISTAT_OFFSET)
 #endif


  #define _VP_PISTAT_PISTAT22_MASK           0x00400000u
  #define _VP_PISTAT_PISTAT22_SHIFT          0x00000016u
  #define  VP_PISTAT_PISTAT22_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT22_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT22_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT22_VCTL2INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT21_MASK           0x00200000u
  #define _VP_PISTAT_PISTAT21_SHIFT          0x00000015u
  #define  VP_PISTAT_PISTAT21_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT21_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT21_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT21_VCTL1INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT20_MASK           0x00100000u
  #define _VP_PISTAT_PISTAT20_SHIFT          0x00000014u
  #define  VP_PISTAT_PISTAT20_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT20_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT20_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT20_VCTL0INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT19_MASK           0x00080000u
  #define _VP_PISTAT_PISTAT19_SHIFT          0x00000013u
  #define  VP_PISTAT_PISTAT19_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT19_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT19_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT19_VDATA19INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT18_MASK           0x00040000u
  #define _VP_PISTAT_PISTAT18_SHIFT          0x00000012u
  #define  VP_PISTAT_PISTAT18_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT18_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT18_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT18_VDATA18INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT17_MASK           0x00020000u
  #define _VP_PISTAT_PISTAT17_SHIFT          0x00000011u
  #define  VP_PISTAT_PISTAT17_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT17_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT17_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT17_VDATA17INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT16_MASK           0x00010000u
  #define _VP_PISTAT_PISTAT16_SHIFT          0x00000010u
  #define  VP_PISTAT_PISTAT16_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT16_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT16_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT16_VDATA16INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT15_MASK           0x00008000u
  #define _VP_PISTAT_PISTAT15_SHIFT          0x0000000Fu
  #define  VP_PISTAT_PISTAT15_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT15_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT15_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT15_VDATA15INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT14_MASK           0x00004000u
  #define _VP_PISTAT_PISTAT14_SHIFT          0x0000000Eu
  #define  VP_PISTAT_PISTAT14_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT14_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT14_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT14_VDATA14INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT13_MASK           0x00002000u
  #define _VP_PISTAT_PISTAT13_SHIFT          0x0000000Du
  #define  VP_PISTAT_PISTAT13_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT13_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT13_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT13_VDATA13INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT12_MASK           0x00001000u
  #define _VP_PISTAT_PISTAT12_SHIFT          0x0000000Cu
  #define  VP_PISTAT_PISTAT12_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT12_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT12_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT12_VDATA12INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT11_MASK           0x00000800u
  #define _VP_PISTAT_PISTAT11_SHIFT          0x0000000Bu
  #define  VP_PISTAT_PISTAT11_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT11_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT11_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT11_VDATA11INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT10_MASK           0x00000400u
  #define _VP_PISTAT_PISTAT10_SHIFT          0x0000000Au
  #define  VP_PISTAT_PISTAT10_DEFAULT        0x00000000u
  #define  VP_PISTAT_PISTAT10_OF(x)          _VALUEOF(x)
  #define  VP_PISTAT_PISTAT10_NONE           0x00000000u
  #define  VP_PISTAT_PISTAT10_VDATA10INT     0x00000001u
  
  #define _VP_PISTAT_PISTAT9_MASK            0x00000200u
  #define _VP_PISTAT_PISTAT9_SHIFT           0x00000009u
  #define  VP_PISTAT_PISTAT9_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT9_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT9_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT9_VDATA9INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT8_MASK            0x00000100u
  #define _VP_PISTAT_PISTAT8_SHIFT           0x00000008u
  #define  VP_PISTAT_PISTAT8_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT8_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT8_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT8_VDATA8INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT7_MASK            0x00000080u
  #define _VP_PISTAT_PISTAT7_SHIFT           0x00000007u
  #define  VP_PISTAT_PISTAT7_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT7_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT7_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT7_VDATA7INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT6_MASK            0x00000040u
  #define _VP_PISTAT_PISTAT6_SHIFT           0x00000006u
  #define  VP_PISTAT_PISTAT6_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT6_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT6_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT6_VDATA6INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT5_MASK            0x00000020u
  #define _VP_PISTAT_PISTAT5_SHIFT           0x00000005u
  #define  VP_PISTAT_PISTAT5_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT5_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT5_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT5_VDATA5INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT4_MASK            0x00000010u
  #define _VP_PISTAT_PISTAT4_SHIFT           0x00000004u
  #define  VP_PISTAT_PISTAT4_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT4_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT4_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT4_VDATA4INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT3_MASK            0x00000008u
  #define _VP_PISTAT_PISTAT3_SHIFT           0x00000003u
  #define  VP_PISTAT_PISTAT3_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT3_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT3_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT3_VDATA3INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT2_MASK            0x00000004u
  #define _VP_PISTAT_PISTAT2_SHIFT           0x00000002u
  #define  VP_PISTAT_PISTAT2_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT2_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT2_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT2_VDATA2INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT1_MASK            0x00000002u
  #define _VP_PISTAT_PISTAT1_SHIFT           0x00000001u
  #define  VP_PISTAT_PISTAT1_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT1_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT1_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT1_VDATA1INT       0x00000001u
  
  #define _VP_PISTAT_PISTAT0_MASK            0x00000001u
  #define _VP_PISTAT_PISTAT0_SHIFT           0x00000000u
  #define  VP_PISTAT_PISTAT0_DEFAULT         0x00000000u
  #define  VP_PISTAT_PISTAT0_OF(x)           _VALUEOF(x)
  #define  VP_PISTAT_PISTAT0_NONE            0x00000000u
  #define  VP_PISTAT_PISTAT0_VDATA0INT       0x00000001u
  
  #define  VP_PISTAT_OF(x)             _VALUEOF(x)

  #define VP_PISTAT_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PISTAT,PISTAT22)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT21)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT20)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT19)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT18)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT17)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT16)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT15)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT14)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT13)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT12)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT11)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT10)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT9)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT8)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT7)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT6)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT5)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT4)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT3)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT2)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT1)\
   |_PER_FDEFAULT(VP,PISTAT,PISTAT0)\
  )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
   #define VP_PISTAT_RMK(pistat22,pistat21,pistat20,pistat19,pistat18,pistat17,pistat16,\
  pistat15,pistat14,pistat13,pistat12,pistat11,pistat10,pistat9,pistat8,pistat7,\
  pistat6,pistat5,pistat4,pistat3,pistat2,pistat1,pistat0) (Uint32)(\
    _PER_FMK(VP,PISTAT,PISTAT22,pistat22)\
   |_PER_FMK(VP,PISTAT,PISTAT21,pistat21)\
   |_PER_FMK(VP,PISTAT,PISTAT20,pistat20)\
   |_PER_FMK(VP,PISTAT,PISTAT19,pistat19)\
   |_PER_FMK(VP,PISTAT,PISTAT18,pistat18)\
   |_PER_FMK(VP,PISTAT,PISTAT17,pistat17)\
   |_PER_FMK(VP,PISTAT,PISTAT16,pistat16)\
   |_PER_FMK(VP,PISTAT,PISTAT15,pistat15)\
   |_PER_FMK(VP,PISTAT,PISTAT14,pistat14)\
   |_PER_FMK(VP,PISTAT,PISTAT13,pistat13)\
   |_PER_FMK(VP,PISTAT,PISTAT12,pistat12)\
   |_PER_FMK(VP,PISTAT,PISTAT11,pistat11)\
   |_PER_FMK(VP,PISTAT,PISTAT10,pistat10)\
   |_PER_FMK(VP,PISTAT,PISTAT9,pistat9)\
   |_PER_FMK(VP,PISTAT,PISTAT8,pistat8)\
   |_PER_FMK(VP,PISTAT,PISTAT7,pistat7)\
   |_PER_FMK(VP,PISTAT,PISTAT6,pistat6)\
   |_PER_FMK(VP,PISTAT,PISTAT5,pistat5)\
   |_PER_FMK(VP,PISTAT,PISTAT4,pistat4)\
   |_PER_FMK(VP,PISTAT,PISTAT3,pistat3)\
   |_PER_FMK(VP,PISTAT,PISTAT2,pistat2)\
   |_PER_FMK(VP,PISTAT,PISTAT1,pistat1)\
   |_PER_FMK(VP,PISTAT,PISTAT0,pistat0)\
  )
#endif  
	
  #define _VP_PISTAT_FGET(N,FIELD)\
    _PER_FGET(_VP_PISTAT##N##_ADDR,VP,PISTAT,##FIELD)

  #define _VP_PISTAT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PISTAT##N##_ADDR,VP,PISTAT,##FIELD,field)

  #define _VP_PISTAT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PISTAT##N##_ADDR,VP,PISTAT,##FIELD,##SYM)
   
  #define _VP_PISTAT0_FGET(FIELD)   _VP_PISTAT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PISTAT1_FGET(FIELD)   _VP_PISTAT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PISTAT2_FGET(FIELD)   _VP_PISTAT_FGET(2,##FIELD)		
 #endif

  
  #define _VP_PISTAT0_FSET(FIELD,f)   _VP_PISTAT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PISTAT1_FSET(FIELD,f)   _VP_PISTAT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PISTAT2_FSET(FIELD,f)   _VP_PISTAT_FSET(2,##FIELD,f)
 #endif


  #define _VP_PISTAT0_FSETS(FIELD,SYM)   _VP_PISTAT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PISTAT1_FSETS(FIELD,SYM)   _VP_PISTAT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PISTAT2_FSETS(FIELD,SYM)   _VP_PISTAT_FSETS(2,##FIELD,##SYM)
 #endif

  

/**************************************************************\
* ___________________
* |                   |
* |  P I C L R        |
* |___________________|
*
* PICLR0  - Video Port 0 Pin Interrupt Clear Register
* PICLR1  - Video Port 1 Pin Interrupt Clear Register
* PICLR2  - Video Port 2 Pin Interrupt Clear Register
*
* FIELDS (msb -> lsb)
* (w) PICLR22
* (w) PICLR21
* (w) PICLR20
* (w) PICLR19
* (w) PICLR18
* (w) PICLR17
* (w) PICLR16
* (w) PICLR15
* (w) PICLR14
* (w) PICLR13
* (w) PICLR12
* (w) PICLR11
* (w) PICLR10
* (w) PICLR9
* (w) PICLR8
* (w) PICLR7
* (w) PICLR6
* (w) PICLR5
* (w) PICLR4
* (w) PICLR3
* (w) PICLR2
* (w) PICLR1
* (w) PICLR0
*
\******************************************************************************/
  #define _VP_PICLR_OFFSET            17

  #define _VP_PICLR0_ADDR   (_VP_BASE_PORT0 + 4*_VP_PICLR_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PICLR1_ADDR   (_VP_BASE_PORT1 + 4*_VP_PICLR_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_PICLR2_ADDR   (_VP_BASE_PORT2 + 4*_VP_PICLR_OFFSET)
 #endif


  #define _VP_PICLR_PICLR22_MASK           0x00400000u
  #define _VP_PICLR_PICLR22_SHIFT          0x00000016u
  #define  VP_PICLR_PICLR22_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR22_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR22_NONE           0x00000000u
  #define  VP_PICLR_PICLR22_VCTL2CLR       0x00000001u
  
  #define _VP_PICLR_PICLR21_MASK           0x00200000u
  #define _VP_PICLR_PICLR21_SHIFT          0x00000015u
  #define  VP_PICLR_PICLR21_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR21_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR21_NONE           0x00000000u
  #define  VP_PICLR_PICLR21_VCTL1CLR       0x00000001u
  
  #define _VP_PICLR_PICLR20_MASK           0x00100000u
  #define _VP_PICLR_PICLR20_SHIFT          0x00000014u
  #define  VP_PICLR_PICLR20_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR20_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR20_NONE           0x00000000u
  #define  VP_PICLR_PICLR20_VCTL0CLR       0x00000001u
  
  #define _VP_PICLR_PICLR19_MASK           0x00080000u
  #define _VP_PICLR_PICLR19_SHIFT          0x00000013u
  #define  VP_PICLR_PICLR19_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR19_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR19_NONE           0x00000000u
  #define  VP_PICLR_PICLR19_VDATA19CLR     0x00000001u
  
  #define _VP_PICLR_PICLR18_MASK           0x00040000u
  #define _VP_PICLR_PICLR18_SHIFT          0x00000012u
  #define  VP_PICLR_PICLR18_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR18_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR18_NONE           0x00000000u
  #define  VP_PICLR_PICLR18_VDATA18CLR     0x00000001u
  
  #define _VP_PICLR_PICLR17_MASK           0x00020000u
  #define _VP_PICLR_PICLR17_SHIFT          0x00000011u
  #define  VP_PICLR_PICLR17_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR17_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR17_NONE           0x00000000u
  #define  VP_PICLR_PICLR17_VDATA17CLR     0x00000001u
  
  #define _VP_PICLR_PICLR16_MASK           0x00010000u
  #define _VP_PICLR_PICLR16_SHIFT          0x00000010u
  #define  VP_PICLR_PICLR16_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR16_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR16_NONE           0x00000000u
  #define  VP_PICLR_PICLR16_VDATA16CLR     0x00000001u
  
  #define _VP_PICLR_PICLR15_MASK           0x00008000u
  #define _VP_PICLR_PICLR15_SHIFT          0x0000000Fu
  #define  VP_PICLR_PICLR15_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR15_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR15_NONE           0x00000000u
  #define  VP_PICLR_PICLR15_VDATA15CLR     0x00000001u
  
  #define _VP_PICLR_PICLR14_MASK           0x00004000u
  #define _VP_PICLR_PICLR14_SHIFT          0x0000000Eu
  #define  VP_PICLR_PICLR14_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR14_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR14_NONE           0x00000000u
  #define  VP_PICLR_PICLR14_VDATA14CLR     0x00000001u
  
  #define _VP_PICLR_PICLR13_MASK           0x00002000u
  #define _VP_PICLR_PICLR13_SHIFT          0x0000000Du
  #define  VP_PICLR_PICLR13_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR13_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR13_NONE           0x00000000u
  #define  VP_PICLR_PICLR13_VDATA13CLR     0x00000001u
  
  #define _VP_PICLR_PICLR12_MASK           0x00001000u
  #define _VP_PICLR_PICLR12_SHIFT          0x0000000Cu
  #define  VP_PICLR_PICLR12_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR12_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR12_NONE           0x00000000u
  #define  VP_PICLR_PICLR12_VDATA12CLR     0x00000001u
  
  #define _VP_PICLR_PICLR11_MASK           0x00000800u
  #define _VP_PICLR_PICLR11_SHIFT          0x0000000Bu
  #define  VP_PICLR_PICLR11_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR11_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR11_NONE           0x00000000u
  #define  VP_PICLR_PICLR11_VDATA11CLR     0x00000001u
  
  #define _VP_PICLR_PICLR10_MASK           0x00000400u
  #define _VP_PICLR_PICLR10_SHIFT          0x0000000Au
  #define  VP_PICLR_PICLR10_DEFAULT        0x00000000u
  #define  VP_PICLR_PICLR10_OF(x)          _VALUEOF(x)
  #define  VP_PICLR_PICLR10_NONE           0x00000000u
  #define  VP_PICLR_PICLR10_VDATA10CLR     0x00000001u
  
  #define _VP_PICLR_PICLR9_MASK            0x00000200u
  #define _VP_PICLR_PICLR9_SHIFT           0x00000009u
  #define  VP_PICLR_PICLR9_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR9_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR9_NONE            0x00000000u
  #define  VP_PICLR_PICLR9_VDATA9CLR       0x00000001u
  
  #define _VP_PICLR_PICLR8_MASK            0x00000100u
  #define _VP_PICLR_PICLR8_SHIFT           0x00000008u
  #define  VP_PICLR_PICLR8_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR8_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR8_NONE            0x00000000u
  #define  VP_PICLR_PICLR8_VDATA8CLR       0x00000001u
  
  #define _VP_PICLR_PICLR7_MASK            0x00000080u
  #define _VP_PICLR_PICLR7_SHIFT           0x00000007u
  #define  VP_PICLR_PICLR7_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR7_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR7_NONE            0x00000000u
  #define  VP_PICLR_PICLR7_VDATA7CLR       0x00000001u
  
  #define _VP_PICLR_PICLR6_MASK            0x00000040u
  #define _VP_PICLR_PICLR6_SHIFT           0x00000006u
  #define  VP_PICLR_PICLR6_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR6_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR6_NONE            0x00000000u
  #define  VP_PICLR_PICLR6_VDATA6CLR       0x00000001u
  
  #define _VP_PICLR_PICLR5_MASK            0x00000020u
  #define _VP_PICLR_PICLR5_SHIFT           0x00000005u
  #define  VP_PICLR_PICLR5_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR5_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR5_NONE            0x00000000u
  #define  VP_PICLR_PICLR5_VDATA5CLR       0x00000001u
  
  #define _VP_PICLR_PICLR4_MASK            0x00000010u
  #define _VP_PICLR_PICLR4_SHIFT           0x00000004u
  #define  VP_PICLR_PICLR4_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR4_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR4_NONE            0x00000000u
  #define  VP_PICLR_PICLR4_VDATA4CLR       0x00000001u
  
  #define _VP_PICLR_PICLR3_MASK            0x00000008u
  #define _VP_PICLR_PICLR3_SHIFT           0x00000003u
  #define  VP_PICLR_PICLR3_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR3_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR3_NONE            0x00000000u
  #define  VP_PICLR_PICLR3_VDATA3CLR       0x00000001u
  
  #define _VP_PICLR_PICLR2_MASK            0x00000004u
  #define _VP_PICLR_PICLR2_SHIFT           0x00000002u
  #define  VP_PICLR_PICLR2_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR2_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR2_NONE            0x00000000u
  #define  VP_PICLR_PICLR2_VDATA2CLR       0x00000001u
  
  #define _VP_PICLR_PICLR1_MASK            0x00000002u
  #define _VP_PICLR_PICLR1_SHIFT           0x00000001u
  #define  VP_PICLR_PICLR1_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR1_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR1_NONE            0x00000000u
  #define  VP_PICLR_PICLR1_VDATA1CLR       0x00000001u
  
  #define _VP_PICLR_PICLR0_MASK            0x00000001u
  #define _VP_PICLR_PICLR0_SHIFT           0x00000000u
  #define  VP_PICLR_PICLR0_DEFAULT         0x00000000u
  #define  VP_PICLR_PICLR0_OF(x)           _VALUEOF(x)
  #define  VP_PICLR_PICLR0_NONE            0x00000000u
  #define  VP_PICLR_PICLR0_VDATA0CLR       0x00000001u
  
  #define  VP_PICLR_OF(x)             _VALUEOF(x)

  #define VP_PICLR_DEFAULT (Uint32)(\
    _PER_FDEFAULT(VP,PICLR,PICLR22)\
   |_PER_FDEFAULT(VP,PICLR,PICLR21)\
   |_PER_FDEFAULT(VP,PICLR,PICLR20)\
   |_PER_FDEFAULT(VP,PICLR,PICLR19)\
   |_PER_FDEFAULT(VP,PICLR,PICLR18)\
   |_PER_FDEFAULT(VP,PICLR,PICLR17)\
   |_PER_FDEFAULT(VP,PICLR,PICLR16)\
   |_PER_FDEFAULT(VP,PICLR,PICLR15)\
   |_PER_FDEFAULT(VP,PICLR,PICLR14)\
   |_PER_FDEFAULT(VP,PICLR,PICLR13)\
   |_PER_FDEFAULT(VP,PICLR,PICLR12)\
   |_PER_FDEFAULT(VP,PICLR,PICLR11)\
   |_PER_FDEFAULT(VP,PICLR,PICLR10)\
   |_PER_FDEFAULT(VP,PICLR,PICLR9)\
   |_PER_FDEFAULT(VP,PICLR,PICLR8)\
   |_PER_FDEFAULT(VP,PICLR,PICLR7)\
   |_PER_FDEFAULT(VP,PICLR,PICLR6)\
   |_PER_FDEFAULT(VP,PICLR,PICLR5)\
   |_PER_FDEFAULT(VP,PICLR,PICLR4)\
   |_PER_FDEFAULT(VP,PICLR,PICLR3)\
   |_PER_FDEFAULT(VP,PICLR,PICLR2)\
   |_PER_FDEFAULT(VP,PICLR,PICLR1)\
   |_PER_FDEFAULT(VP,PICLR,PICLR0)\
  )

#define VP_PICLR_RMK(piclr22,piclr21,piclr20,piclr19,piclr18,piclr17,piclr16,\
  piclr15,piclr14,piclr13,piclr12,piclr11,piclr10,piclr9,piclr8,piclr7,\
  piclr6,piclr5,piclr4,piclr3,piclr2,piclr1,piclr0) (Uint32)(\
    _PER_FMK(VP,PICLR,PICLR22,piclr22)\
   |_PER_FMK(VP,PICLR,PICLR21,piclr21)\
   |_PER_FMK(VP,PICLR,PICLR20,piclr20)\
   |_PER_FMK(VP,PICLR,PICLR19,piclr19)\
   |_PER_FMK(VP,PICLR,PICLR18,piclr18)\
   |_PER_FMK(VP,PICLR,PICLR17,piclr17)\
   |_PER_FMK(VP,PICLR,PICLR16,piclr16)\
   |_PER_FMK(VP,PICLR,PICLR15,piclr15)\
   |_PER_FMK(VP,PICLR,PICLR14,piclr14)\
   |_PER_FMK(VP,PICLR,PICLR13,piclr13)\
   |_PER_FMK(VP,PICLR,PICLR12,piclr12)\
   |_PER_FMK(VP,PICLR,PICLR11,piclr11)\
   |_PER_FMK(VP,PICLR,PICLR10,piclr10)\
   |_PER_FMK(VP,PICLR,PICLR9,piclr9)\
   |_PER_FMK(VP,PICLR,PICLR8,piclr8)\
   |_PER_FMK(VP,PICLR,PICLR7,piclr7)\
   |_PER_FMK(VP,PICLR,PICLR6,piclr6)\
   |_PER_FMK(VP,PICLR,PICLR5,piclr5)\
   |_PER_FMK(VP,PICLR,PICLR4,piclr4)\
   |_PER_FMK(VP,PICLR,PICLR3,piclr3)\
   |_PER_FMK(VP,PICLR,PICLR2,piclr2)\
   |_PER_FMK(VP,PICLR,PICLR1,piclr1)\
   |_PER_FMK(VP,PICLR,PICLR0,piclr0)\
  )

  #define _VP_PICLR_FGET(N,FIELD)\
    _PER_FGET(_VP_PICLR##N##_ADDR,VP,PICLR,##FIELD)

  #define _VP_PICLR_FSET(N,FIELD,field)\
    _PER_FSET(_VP_PICLR##N##_ADDR,VP,PICLR,##FIELD,field)

  #define _VP_PICLR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_PICLR##N##_ADDR,VP,PICLR,##FIELD,##SYM)

  #define _VP_PICLR0_FGET(FIELD)   _VP_PICLR_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PICLR1_FGET(FIELD)   _VP_PICLR_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_PICLR2_FGET(FIELD)   _VP_PICLR_FGET(2,##FIELD)
 #endif


  #define _VP_PICLR0_FSET(FIELD,f)   _VP_PICLR_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PICLR1_FSET(FIELD,f)   _VP_PICLR_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_PICLR2_FSET(FIELD,f)   _VP_PICLR_FSET(2,##FIELD,f)
 #endif


  #define _VP_PICLR0_FSETS(FIELD,SYM)   _VP_PICLR_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_PICLR1_FSETS(FIELD,SYM)   _VP_PICLR_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_PICLR2_FSETS(FIELD,SYM)   _VP_PICLR_FSETS(2,##FIELD,##SYM)
 #endif

  
/******************************************************************************\
* _____________________
* |                   |
* |  V P C T L        |
* |___________________|
*
* VPCTL0  -  Video Port 0 Control Register
* VPCTL1  -  Video Port 1 Control Register
* VPCTL2  -  Video Port 2 Control Register
*
* FIELDS (msb -> lsb)
* (rs) VPRST
* (rc) VPHLT
* (rw) VCLK2P
* (rw) VCT2P
* (rw) VCT1P
* (rw) VCT0P
* (rw) TSI
* (rw) DISP
* (rw) DCHNL   ???
*
\******************************************************************************/
  #define _VP_VPCTL_OFFSET           48

  #define _VP_VPCTL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VPCTL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPCTL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VPCTL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPCTL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VPCTL_OFFSET)
 #endif


  #define _VP_VPCTL_VPRST_MASK        0x00008000u
  #define _VP_VPCTL_VPRST_SHIFT       0x0000000Fu
  #define  VP_VPCTL_VPRST_DEFAULT     0x00000000u
  #define  VP_VPCTL_VPRST_OF(x)       _VALUEOF(x)
  #define  VP_VPCTL_VPRST_NO          0x00000000u
  #define  VP_VPCTL_VPRST_RESET       0x00000001u

  #define _VP_VPCTL_VPHLT_MASK        0x00004000u
  #define _VP_VPCTL_VPHLT_SHIFT       0x0000000Eu
  #define  VP_VPCTL_VPHLT_DEFAULT     0x00000001u
  #define  VP_VPCTL_VPHLT_OF(x)       _VALUEOF(x)
  #define  VP_VPCTL_VPHLT_NONE        0x00000000u
  #define  VP_VPCTL_VPHLT_CLEAR       0x00000001u

  #define _VP_VPCTL_VCLK2P_MASK       0x00000080u
  #define _VP_VPCTL_VCLK2P_SHIFT      0x00000007u
  #define  VP_VPCTL_VCLK2P_DEFAULT    0x00000000u
  #define  VP_VPCTL_VCLK2P_OF(x)      _VALUEOF(x)
  #define  VP_VPCTL_VCLK2P_NONE       0x00000000u
  #define  VP_VPCTL_VCLK2P_REVERSE    0x00000001u

  #define _VP_VPCTL_VCT2P_MASK       0x00000040u
  #define _VP_VPCTL_VCT2P_SHIFT      0x00000006u
  #define  VP_VPCTL_VCT2P_DEFAULT    0x00000000u
  #define  VP_VPCTL_VCT2P_OF(x)      _VALUEOF(x)
  #define  VP_VPCTL_VCT2P_NONE       0x00000000u
  #define  VP_VPCTL_VCT2P_ACTIVELOW  0x00000001u

  #define _VP_VPCTL_VCT1P_MASK       0x00000020u
  #define _VP_VPCTL_VCT1P_SHIFT      0x00000005u
  #define  VP_VPCTL_VCT1P_DEFAULT    0x00000000u
  #define  VP_VPCTL_VCT1P_OF(x)      _VALUEOF(x)
  #define  VP_VPCTL_VCT1P_NONE       0x00000000u
  #define  VP_VPCTL_VCT1P_ACTIVELOW  0x00000001u

  #define _VP_VPCTL_VCT0P_MASK       0x00000010u
  #define _VP_VPCTL_VCT0P_SHIFT      0x00000004u
  #define  VP_VPCTL_VCT0P_DEFAULT    0x00000000u
  #define  VP_VPCTL_VCT0P_OF(x)      _VALUEOF(x)
  #define  VP_VPCTL_VCT0P_NONE       0x00000000u
  #define  VP_VPCTL_VCT0P_ACTIVELOW  0x00000001u

  #define _VP_VPCTL_TSI_MASK         0x00000004u
  #define _VP_VPCTL_TSI_SHIFT        0x00000002u
  #define  VP_VPCTL_TSI_DEFAULT      0x00000000u
  #define  VP_VPCTL_TSI_OF(x)        _VALUEOF(x)
  #define  VP_VPCTL_TSI_NONE         0x00000000u
  #define  VP_VPCTL_TSI_CAPTURE      0x00000001u

  #define _VP_VPCTL_DISP_MASK      0x00000002u
  #define _VP_VPCTL_DISP_SHIFT     0x00000001u
  #define  VP_VPCTL_DISP_DEFAULT   0x00000000u
  #define  VP_VPCTL_DISP_OF(x)     _VALUEOF(x)
  #define  VP_VPCTL_DISP_CAPTURE   0x00000000u
  #define  VP_VPCTL_DISP_DISPLAY   0x00000001u

/* Changed 2CHNL to DCHNL ??? */
  #define _VP_VPCTL_DCHNL_MASK      0x00000001u
  #define _VP_VPCTL_DCHNL_SHIFT     0x00000000u
  #define  VP_VPCTL_DCHNL_DEFAULT   0x00000000u
  #define  VP_VPCTL_DCHNL_OF(x)     _VALUEOF(x)
  #define  VP_VPCTL_DCHNL_SINGLE    0x00000000u
  #define  VP_VPCTL_DCHNL_DUAL      0x00000001u

  #define  VP_VPCTL_OF(x)            _VALUEOF(x)

  #define VP_VPCTL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VPCTL,VPRST)\
    |_PER_FDEFAULT(VP,VPCTL,VPHLT)\
    |_PER_FDEFAULT(VP,VPCTL,VCLK2P)\
    |_PER_FDEFAULT(VP,VPCTL,VCT2P)\
    |_PER_FDEFAULT(VP,VPCTL,VCT1P)\
    |_PER_FDEFAULT(VP,VPCTL,VCT0P)\
    |_PER_FDEFAULT(VP,VPCTL,TSI)\
    |_PER_FDEFAULT(VP,VPCTL,DISP)\
    |_PER_FDEFAULT(VP,VPCTL,DCHNL)\
  )

  #define VP_VPCTL_RMK(vprst,vphlt,vclk2p,vct2p,vct1p,vct0p,\
    tsi,disp,dchnl) (Uint32)(\
     _PER_FMK(VP,VPCTL,VPRST,vprst)\
    |_PER_FMK(VP,VPCTL,VPHLT,vphlt)\
    |_PER_FMK(VP,VPCTL,VCLK2P,vclk2p)\
    |_PER_FMK(VP,VPCTL,VCT2P,vct2p)\
    |_PER_FMK(VP,VPCTL,VCT1P,vct1p)\
    |_PER_FMK(VP,VPCTL,VCT0P,vct0p)\
    |_PER_FMK(VP,VPCTL,TSI,tsi)\
    |_PER_FMK(VP,VPCTL,DISP,disp)\
    |_PER_FMK(VP,VPCTL,DCHNL,dchnl)\
  )

  #define _VP_VPCTL_FGET(N,FIELD)\
    _PER_FGET(_VP_VPCTL##N##_ADDR,VP,VPCTL,##FIELD)

  #define _VP_VPCTL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VPCTL##N##_ADDR,VP,VPCTL,##FIELD,field)

  #define _VP_VPCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VPCTL##N##_ADDR,VP,VPCTL,##FIELD,##SYM)

  #define _VP_VPCTL0_FGET(FIELD)   _VP_VPCTL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPCTL1_FGET(FIELD)   _VP_VPCTL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPCTL2_FGET(FIELD)   _VP_VPCTL_FGET(2,##FIELD)
 #endif


  #define _VP_VPCTL0_FSET(FIELD,f)   _VP_VPCTL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPCTL1_FSET(FIELD,f)   _VP_VPCTL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPCTL2_FSET(FIELD,f)   _VP_VPCTL_FSET(2,##FIELD,f)
 #endif


  #define _VP_VPCTL0_FSETS(FIELD,SYM)   _VP_VPCTL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPCTL1_FSETS(FIELD,SYM)   _VP_VPCTL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPCTL2_FSETS(FIELD,SYM)   _VP_VPCTL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V P S T A T      |
* |___________________|
*
* VPSTAT0  -  Video Port 0 Status Register
* VPSTAT1  -  Video Port 1 Status Register
* VPSTAT2  -  Video Port 2 Status Register
*
* FIELDS (msb -> lsb)
* (r) DCDIS
* (r) HIDATA
* (r) PWDTH
*
\******************************************************************************/
  #define _VP_VPSTAT_OFFSET           49

  #define _VP_VPSTAT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VPSTAT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPSTAT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VPSTAT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPSTAT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VPSTAT_OFFSET)
 #endif


/* Change 2CDIS to DCDIS ??? */
  #define _VP_VPSTAT_DCDIS_MASK        0x00000008u
  #define _VP_VPSTAT_DCDIS_SHIFT       0x00000003u
  #define  VP_VPSTAT_DCDIS_DEFAULT     0x00000000u
  #define  VP_VPSTAT_DCDIS_OF(x)       _VALUEOF(x)
  #define  VP_VPSTAT_DCDIS_ENABLE      0x00000000u
  #define  VP_VPSTAT_DCDIS_DISABLE     0x00000001u

  #define _VP_VPSTAT_HIDATA_MASK       0x00000004u
  #define _VP_VPSTAT_HIDATA_SHIFT      0x00000002u
  #define  VP_VPSTAT_HIDATA_DEFAULT    0x00000000u
  #define  VP_VPSTAT_HIDATA_OF(x)      _VALUEOF(x)
  #define  VP_VPSTAT_HIDATA_NONE       0x00000000u
  #define  VP_VPSTAT_HIDATA_USE        0x00000001u

  #define _VP_VPSTAT_PWDTH_MASK        0x00000003u
  #define _VP_VPSTAT_PWDTH_SHIFT       0x00000000u
  #define  VP_VPSTAT_PWDTH_DEFAULT     0x00000000u
  #define  VP_VPSTAT_PWDTH_OF(x)       _VALUEOF(x)
  #define  VP_VPSTAT_PWDTH_20BITS      0x00000000u
  #define  VP_VPSTAT_PWDTH_10BITS      0x00000002u
  #define  VP_VPSTAT_PWDTH_8BITS       0x00000003u

  #define  VP_VPSTAT_OF(x)            _VALUEOF(x)

  #define VP_VPSTAT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VPSTAT,DCDIS)\
    |_PER_FDEFAULT(VP,VPSTAT,HIDATA)\
    |_PER_FDEFAULT(VP,VPSTAT,PWDTH)\
  )
#if (!(CHIP_6413 | CHIP_6418 | CHIP_6410))
  #define VP_VPSTAT_RMK(dcdis,hidata,pwdth) (Uint32)(\
	       _PER_FMK(VP,VPSTAT,DCDIS,dcdis)\
	      |_PER_FMK(VP,VPSTAT,HIDATA,hidata)\
	      |_PER_FMK(VP,VPSTAT,PWDTH,pwdth)\
  )	      
#endif  
  #define _VP_VPSTAT_FGET(N,FIELD)\
    _PER_FGET(_VP_VPSTAT##N##_ADDR,VP,VPSTAT,##FIELD)

  #define _VP_VPSTAT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VPSTAT##N##_ADDR,VP,VPSTAT,##FIELD,field)

  #define _VP_VPSTAT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VPSTAT##N##_ADDR,VP,VPSTAT,##FIELD,##SYM)

  #define _VP_VPSTAT0_FGET(FIELD)   _VP_VPSTAT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPSTAT1_FGET(FIELD)   _VP_VPSTAT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPSTAT2_FGET(FIELD)   _VP_VPSTAT_FGET(2,##FIELD)
 #endif


  #define _VP_VPSTAT0_FSET(FIELD,f)   _VP_VPSTAT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPSTAT1_FSET(FIELD,f)   _VP_VPSTAT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPSTAT2_FSET(FIELD,f)   _VP_VPSTAT_FSET(2,##FIELD,f)
 #endif


  #define _VP_VPSTAT0_FSETS(FIELD,SYM)   _VP_VPSTAT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPSTAT1_FSETS(FIELD,SYM)   _VP_VPSTAT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPSTAT2_FSETS(FIELD,SYM)   _VP_VPSTAT_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V P I E          |
* |___________________|
*
* VPIE0 - Video Port 0 Interrupt Enable Register
* VPIE1 - Video Port 1 Interrupt Enable Register
* VPIE2 - Video Port 2 Interrupt Enable Register
*
* FIELDS (msb -> lsb)
*
* (rw) LFDB
* (rw) SFDB
* (rw) VINTB2
* (rw) VINTB1
* (rw) SERRB
* (rw) CCMPB
* (rw) COVRB
* (rw) GPIO
* (rw) DCNA
* (rw) DCMP
* (rw) DUND
* (rw) TICK
* (rw) STC
* (rw) LFDA
* (rw) SFDA
* (rw) VINTA2
* (rw) VINTA1
* (rw) SERRA
* (rw) CCMPA
* (rw) COVRA
* (rw) VIE
*
\******************************************************************************/
  #define _VP_VPIE_OFFSET           50

  #define _VP_VPIE0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VPIE_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPIE1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VPIE_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPIE2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VPIE_OFFSET)
 #endif


  #define _VP_VPIE_LFDB_MASK         0x00800000u
  #define _VP_VPIE_LFDB_SHIFT        0x00000017u
  #define  VP_VPIE_LFDB_DEFAULT      0x00000000u
  #define  VP_VPIE_LFDB_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_LFDB_DISABLE      0x00000000u
  #define  VP_VPIE_LFDB_ENABLE       0x00000001u

  #define _VP_VPIE_SFDB_MASK         0x00400000u
  #define _VP_VPIE_SFDB_SHIFT        0x00000016u
  #define  VP_VPIE_SFDB_DEFAULT      0x00000000u
  #define  VP_VPIE_SFDB_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_SFDB_DISABLE      0x00000000u
  #define  VP_VPIE_SFDB_ENABLE       0x00000001u

  #define _VP_VPIE_VINTB2_MASK         0x00200000u
  #define _VP_VPIE_VINTB2_SHIFT        0x00000015u
  #define  VP_VPIE_VINTB2_DEFAULT      0x00000000u
  #define  VP_VPIE_VINTB2_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_VINTB2_DISABLE      0x00000000u
  #define  VP_VPIE_VINTB2_ENABLE       0x00000001u

  #define _VP_VPIE_VINTB1_MASK         0x00100000u
  #define _VP_VPIE_VINTB1_SHIFT        0x00000014u
  #define  VP_VPIE_VINTB1_DEFAULT      0x00000000u
  #define  VP_VPIE_VINTB1_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_VINTB1_DISABLE      0x00000000u
  #define  VP_VPIE_VINTB1_ENABLE       0x00000001u

  #define _VP_VPIE_SERRB_MASK         0x00080000u
  #define _VP_VPIE_SERRB_SHIFT        0x00000013u
  #define  VP_VPIE_SERRB_DEFAULT      0x00000000u
  #define  VP_VPIE_SERRB_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_SERRB_DISABLE      0x00000000u
  #define  VP_VPIE_SERRB_ENABLE       0x00000001u

  #define _VP_VPIE_CCMPB_MASK         0x00040000u
  #define _VP_VPIE_CCMPB_SHIFT        0x00000012u
  #define  VP_VPIE_CCMPB_DEFAULT      0x00000000u
  #define  VP_VPIE_CCMPB_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_CCMPB_DISABLE      0x00000000u
  #define  VP_VPIE_CCMPB_ENABLE       0x00000001u

  #define _VP_VPIE_COVRB_MASK         0x00020000u
  #define _VP_VPIE_COVRB_SHIFT        0x00000011u
  #define  VP_VPIE_COVRB_DEFAULT      0x00000000u
  #define  VP_VPIE_COVRB_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_COVRB_DISABLE      0x00000000u
  #define  VP_VPIE_COVRB_ENABLE       0x00000001u

  #define _VP_VPIE_GPIO_MASK         0x00010000u
  #define _VP_VPIE_GPIO_SHIFT        0x00000010u
  #define  VP_VPIE_GPIO_DEFAULT      0x00000000u
  #define  VP_VPIE_GPIO_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_GPIO_DISABLE      0x00000000u
  #define  VP_VPIE_GPIO_ENABLE       0x00000001u

  #define _VP_VPIE_DCNA_MASK         0x00004000u
  #define _VP_VPIE_DCNA_SHIFT        0x0000000Eu
  #define  VP_VPIE_DCNA_DEFAULT      0x00000000u
  #define  VP_VPIE_DCNA_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_DCNA_DISABLE      0x00000000u
  #define  VP_VPIE_DCNA_ENABLE       0x00000001u

  #define _VP_VPIE_DCMP_MASK         0x00002000u
  #define _VP_VPIE_DCMP_SHIFT        0x0000000Du
  #define  VP_VPIE_DCMP_DEFAULT      0x00000000u
  #define  VP_VPIE_DCMP_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_DCMP_DISABLE      0x00000000u
  #define  VP_VPIE_DCMP_ENABLE       0x00000001u

  #define _VP_VPIE_DUND_MASK         0x00001000u
  #define _VP_VPIE_DUND_SHIFT        0x0000000Cu
  #define  VP_VPIE_DUND_DEFAULT      0x00000000u
  #define  VP_VPIE_DUND_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_DUND_DISABLE      0x00000000u
  #define  VP_VPIE_DUND_ENABLE       0x00000001u

  #define _VP_VPIE_TICK_MASK         0x00000800u
  #define _VP_VPIE_TICK_SHIFT        0x0000000Bu
  #define  VP_VPIE_TICK_DEFAULT      0x00000000u
  #define  VP_VPIE_TICK_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_TICK_DISABLE      0x00000000u
  #define  VP_VPIE_TICK_ENABLE       0x00000001u

  #define _VP_VPIE_STC_MASK         0x00000400u
  #define _VP_VPIE_STC_SHIFT        0x0000000Au
  #define  VP_VPIE_STC_DEFAULT      0x00000000u
  #define  VP_VPIE_STC_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_STC_DISABLE      0x00000000u
  #define  VP_VPIE_STC_ENABLE       0x00000001u

  #define _VP_VPIE_LFDA_MASK         0x00000080u
  #define _VP_VPIE_LFDA_SHIFT        0x00000007u
  #define  VP_VPIE_LFDA_DEFAULT      0x00000000u
  #define  VP_VPIE_LFDA_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_LFDA_DISABLE      0x00000000u
  #define  VP_VPIE_LFDA_ENABLE       0x00000001u

  #define _VP_VPIE_SFDA_MASK         0x00000040u
  #define _VP_VPIE_SFDA_SHIFT        0x00000006u
  #define  VP_VPIE_SFDA_DEFAULT      0x00000000u
  #define  VP_VPIE_SFDA_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_SFDA_DISABLE      0x00000000u
  #define  VP_VPIE_SFDA_ENABLE       0x00000001u

  #define _VP_VPIE_VINTA2_MASK         0x00000020u
  #define _VP_VPIE_VINTA2_SHIFT        0x00000005u
  #define  VP_VPIE_VINTA2_DEFAULT      0x00000000u
  #define  VP_VPIE_VINTA2_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_VINTA2_DISABLE      0x00000000u
  #define  VP_VPIE_VINTA2_ENABLE       0x00000001u

  #define _VP_VPIE_VINTA1_MASK         0x00000010u
  #define _VP_VPIE_VINTA1_SHIFT        0x00000004u
  #define  VP_VPIE_VINTA1_DEFAULT      0x00000000u
  #define  VP_VPIE_VINTA1_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_VINTA1_DISABLE      0x00000000u
  #define  VP_VPIE_VINTA1_ENABLE       0x00000001u

  #define _VP_VPIE_SERRA_MASK         0x00000008u
  #define _VP_VPIE_SERRA_SHIFT        0x00000003u
  #define  VP_VPIE_SERRA_DEFAULT      0x00000000u
  #define  VP_VPIE_SERRA_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_SERRA_DISABLE      0x00000000u
  #define  VP_VPIE_SERRA_ENABLE       0x00000001u

  #define _VP_VPIE_CCMPA_MASK         0x00000004u
  #define _VP_VPIE_CCMPA_SHIFT        0x00000002u
  #define  VP_VPIE_CCMPA_DEFAULT      0x00000000u
  #define  VP_VPIE_CCMPA_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_CCMPA_DISABLE      0x00000000u
  #define  VP_VPIE_CCMPA_ENABLE       0x00000001u

  #define _VP_VPIE_COVRA_MASK         0x00000002u
  #define _VP_VPIE_COVRA_SHIFT        0x00000001u
  #define  VP_VPIE_COVRA_DEFAULT      0x00000000u
  #define  VP_VPIE_COVRA_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_COVRA_DISABLE      0x00000000u
  #define  VP_VPIE_COVRA_ENABLE       0x00000001u

  #define _VP_VPIE_VIE_MASK         0x00000001u
  #define _VP_VPIE_VIE_SHIFT        0x00000000u
  #define  VP_VPIE_VIE_DEFAULT      0x00000000u
  #define  VP_VPIE_VIE_OF(x)        _VALUEOF(x)
  #define  VP_VPIE_VIE_DISABLE      0x00000000u
  #define  VP_VPIE_VIE_ENABLE       0x00000001u

  #define  VP_VPIE_OF(x)            _VALUEOF(x)

  #define VP_VPIE_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VPIE,LFDB)\
    |_PER_FDEFAULT(VP,VPIE,SFDB)\
    |_PER_FDEFAULT(VP,VPIE,VINTB2)\
    |_PER_FDEFAULT(VP,VPIE,VINTB1)\
    |_PER_FDEFAULT(VP,VPIE,SERRB)\
    |_PER_FDEFAULT(VP,VPIE,CCMPB)\
    |_PER_FDEFAULT(VP,VPIE,COVRB)\
    |_PER_FDEFAULT(VP,VPIE,GPIO)\
    |_PER_FDEFAULT(VP,VPIE,DCNA)\
    |_PER_FDEFAULT(VP,VPIE,DCMP)\
    |_PER_FDEFAULT(VP,VPIE,DUND)\
    |_PER_FDEFAULT(VP,VPIE,TICK)\
    |_PER_FDEFAULT(VP,VPIE,STC)\
    |_PER_FDEFAULT(VP,VPIE,LFDA)\
    |_PER_FDEFAULT(VP,VPIE,SFDA)\
    |_PER_FDEFAULT(VP,VPIE,VINTA2)\
    |_PER_FDEFAULT(VP,VPIE,VINTA1)\
    |_PER_FDEFAULT(VP,VPIE,SERRA)\
    |_PER_FDEFAULT(VP,VPIE,CCMPA)\
    |_PER_FDEFAULT(VP,VPIE,COVRA)\
    |_PER_FDEFAULT(VP,VPIE,VIE)\
  )

  #define VP_VPIE_RMK(lfdb,sfdb,vintb2,vintb1,serrb,ccmpb,covrb,gpio,\
    dcna,dcmp,dund,tick,stc,lfda,sfda,vinta2,vinta1,serra,ccmpa,covra,\
	vie) (Uint32)(\
     _PER_FMK(VP,VPIE,LFDB,lfdb)\
    |_PER_FMK(VP,VPIE,SFDB,sfdb)\
    |_PER_FMK(VP,VPIE,VINTB2,vintb2)\
    |_PER_FMK(VP,VPIE,VINTB1,vintb1)\
    |_PER_FMK(VP,VPIE,SERRB,serrb)\
    |_PER_FMK(VP,VPIE,CCMPB,ccmpb)\
    |_PER_FMK(VP,VPIE,COVRB,covrb)\
    |_PER_FMK(VP,VPIE,GPIO,gpio)\
    |_PER_FMK(VP,VPIE,DCNA,dcna)\
    |_PER_FMK(VP,VPIE,DCMP,dcmp)\
    |_PER_FMK(VP,VPIE,DUND,dund)\
    |_PER_FMK(VP,VPIE,TICK,tick)\
    |_PER_FMK(VP,VPIE,STC,stc)\
    |_PER_FMK(VP,VPIE,LFDA,lfda)\
    |_PER_FMK(VP,VPIE,SFDA,sfda)\
    |_PER_FMK(VP,VPIE,VINTA2,vinta2)\
    |_PER_FMK(VP,VPIE,VINTA1,vinta1)\
    |_PER_FMK(VP,VPIE,SERRA,serra)\
    |_PER_FMK(VP,VPIE,CCMPA,ccmpa)\
    |_PER_FMK(VP,VPIE,COVRA,covra)\
    |_PER_FMK(VP,VPIE,VIE,vie)\
  )

  #define _VP_VPIE_FGET(N,FIELD)\
    _PER_FGET(_VP_VPIE##N##_ADDR,VP,VPIE,##FIELD)

  #define _VP_VPIE_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VPIE##N##_ADDR,VP,VPIE,##FIELD,field)

  #define _VP_VPIE_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VPIE##N##_ADDR,VP,VPIE,##FIELD,##SYM)

  #define _VP_VPIE0_FGET(FIELD)   _VP_VPIE_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPIE1_FGET(FIELD)   _VP_VPIE_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPIE2_FGET(FIELD)   _VP_VPIE_FGET(2,##FIELD)
 #endif


  #define _VP_VPIE0_FSET(FIELD,f)   _VP_VPIE_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPIE1_FSET(FIELD,f)   _VP_VPIE_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPIE2_FSET(FIELD,f)   _VP_VPIE_FSET(2,##FIELD,f)
 #endif


  #define _VP_VPIE0_FSETS(FIELD,SYM)   _VP_VPIE_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPIE1_FSETS(FIELD,SYM)   _VP_VPIE_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPIE2_FSETS(FIELD,SYM)   _VP_VPIE_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V P I S          |
* |___________________|
*
* VPIS0 - Video Port 0 Interrupt Status Register
* VPIS1 - Video Port 1 Interrupt Status Register
* VPIS2 - Video Port 2 Interrupt Status Register
*
* FIELDS (msb -> lsb)
*
* (rc) LFDB
* (rc) SFDB
* (rc) VINTB2
* (rc) VINTB1
* (rc) SERRB
* (rc) CCMPB
* (rc) COVRB
* (rc) GPIO
* (rc) DCNA
* (rc) DCMP
* (rc) DUND
* (rc) TICK
* (rc) STC
* (rc) LFDA
* (rc) SFDA
* (rc) VINTA2
* (rc) VINTA1
* (rc) SERRA
* (rc) CCMPA
* (rc) COVRA
*
\******************************************************************************/
  #define _VP_VPIS_OFFSET           51

  #define _VP_VPIS0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VPIS_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPIS1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VPIS_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPIS2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VPIS_OFFSET)
 #endif


  #define _VP_VPIS_LFDB_MASK         0x00800000u
  #define _VP_VPIS_LFDB_SHIFT        0x00000017u
  #define  VP_VPIS_LFDB_DEFAULT      0x00000000u
  #define  VP_VPIS_LFDB_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_LFDB_NONE         0x00000000u
  #define  VP_VPIS_LFDB_CLEAR        0x00000001u

  #define _VP_VPIS_SFDB_MASK         0x00400000u
  #define _VP_VPIS_SFDB_SHIFT        0x00000016u
  #define  VP_VPIS_SFDB_DEFAULT      0x00000000u
  #define  VP_VPIS_SFDB_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_SFDB_NONE         0x00000000u
  #define  VP_VPIS_SFDB_CLEAR        0x00000001u

  #define _VP_VPIS_VINTB2_MASK         0x00200000u
  #define _VP_VPIS_VINTB2_SHIFT        0x00000015u
  #define  VP_VPIS_VINTB2_DEFAULT      0x00000000u
  #define  VP_VPIS_VINTB2_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_VINTB2_NONE         0x00000000u
  #define  VP_VPIS_VINTB2_CLEAR        0x00000001u

  #define _VP_VPIS_VINTB1_MASK         0x00100000u
  #define _VP_VPIS_VINTB1_SHIFT        0x00000014u
  #define  VP_VPIS_VINTB1_DEFAULT      0x00000000u
  #define  VP_VPIS_VINTB1_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_VINTB1_NONE         0x00000000u
  #define  VP_VPIS_VINTB1_CLEAR        0x00000001u

  #define _VP_VPIS_SERRB_MASK         0x00080000u
  #define _VP_VPIS_SERRB_SHIFT        0x00000013u
  #define  VP_VPIS_SERRB_DEFAULT      0x00000000u
  #define  VP_VPIS_SERRB_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_SERRB_NONE         0x00000000u
  #define  VP_VPIS_SERRB_CLEAR        0x00000001u

  #define _VP_VPIS_CCMPB_MASK         0x00040000u
  #define _VP_VPIS_CCMPB_SHIFT        0x00000012u
  #define  VP_VPIS_CCMPB_DEFAULT      0x00000000u
  #define  VP_VPIS_CCMPB_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_CCMPB_NONE         0x00000000u
  #define  VP_VPIS_CCMPB_CLEAR        0x00000001u

  #define _VP_VPIS_COVRB_MASK         0x00020000u
  #define _VP_VPIS_COVRB_SHIFT        0x00000011u
  #define  VP_VPIS_COVRB_DEFAULT      0x00000000u
  #define  VP_VPIS_COVRB_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_COVRB_NONE         0x00000000u
  #define  VP_VPIS_COVRB_CLEAR        0x00000001u

  #define _VP_VPIS_GPIO_MASK         0x00010000u
  #define _VP_VPIS_GPIO_SHIFT        0x00000010u
  #define  VP_VPIS_GPIO_DEFAULT      0x00000000u
  #define  VP_VPIS_GPIO_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_GPIO_NONE         0x00000000u
  #define  VP_VPIS_GPIO_CLEAR        0x00000001u

  #define _VP_VPIS_DCNA_MASK         0x00004000u
  #define _VP_VPIS_DCNA_SHIFT        0x0000000Eu
  #define  VP_VPIS_DCNA_DEFAULT      0x00000000u
  #define  VP_VPIS_DCNA_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_DCNA_NONE         0x00000000u
  #define  VP_VPIS_DCNA_CLEAR        0x00000001u

  #define _VP_VPIS_DCMP_MASK         0x00002000u
  #define _VP_VPIS_DCMP_SHIFT        0x0000000Du
  #define  VP_VPIS_DCMP_DEFAULT      0x00000000u
  #define  VP_VPIS_DCMP_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_DCMP_NONE         0x00000000u
  #define  VP_VPIS_DCMP_CLEAR        0x00000001u

  #define _VP_VPIS_DUND_MASK         0x00001000u
  #define _VP_VPIS_DUND_SHIFT        0x0000000Cu
  #define  VP_VPIS_DUND_DEFAULT      0x00000000u
  #define  VP_VPIS_DUND_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_DUND_NONE         0x00000000u
  #define  VP_VPIS_DUND_CLEAR        0x00000001u

  #define _VP_VPIS_TICK_MASK         0x00000800u
  #define _VP_VPIS_TICK_SHIFT        0x0000000Bu
  #define  VP_VPIS_TICK_DEFAULT      0x00000000u
  #define  VP_VPIS_TICK_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_TICK_NONE         0x00000000u
  #define  VP_VPIS_TICK_CLEAR        0x00000001u

  #define _VP_VPIS_STC_MASK         0x00000400u
  #define _VP_VPIS_STC_SHIFT        0x0000000Au
  #define  VP_VPIS_STC_DEFAULT      0x00000000u
  #define  VP_VPIS_STC_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_STC_NONE         0x00000000u
  #define  VP_VPIS_STC_CLEAR        0x00000001u

  #define _VP_VPIS_LFDA_MASK         0x00000080u
  #define _VP_VPIS_LFDA_SHIFT        0x00000007u
  #define  VP_VPIS_LFDA_DEFAULT      0x00000000u
  #define  VP_VPIS_LFDA_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_LFDA_NONE         0x00000000u
  #define  VP_VPIS_LFDA_CLEAR        0x00000001u

  #define _VP_VPIS_SFDA_MASK         0x00000040u
  #define _VP_VPIS_SFDA_SHIFT        0x00000006u
  #define  VP_VPIS_SFDA_DEFAULT      0x00000000u
  #define  VP_VPIS_SFDA_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_SFDA_NONE         0x00000000u
  #define  VP_VPIS_SFDA_CLEAR        0x00000001u

  #define _VP_VPIS_VINTA2_MASK         0x00000020u
  #define _VP_VPIS_VINTA2_SHIFT        0x00000005u
  #define  VP_VPIS_VINTA2_DEFAULT      0x00000000u
  #define  VP_VPIS_VINTA2_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_VINTA2_NONE         0x00000000u
  #define  VP_VPIS_VINTA2_CLEAR        0x00000001u

  #define _VP_VPIS_VINTA1_MASK         0x00000010u
  #define _VP_VPIS_VINTA1_SHIFT        0x00000004u
  #define  VP_VPIS_VINTA1_DEFAULT      0x00000000u
  #define  VP_VPIS_VINTA1_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_VINTA1_NONE         0x00000000u
  #define  VP_VPIS_VINTA1_CLEAR        0x00000001u

  #define _VP_VPIS_SERRA_MASK         0x00000008u
  #define _VP_VPIS_SERRA_SHIFT        0x00000003u
  #define  VP_VPIS_SERRA_DEFAULT      0x00000000u
  #define  VP_VPIS_SERRA_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_SERRA_NONE         0x00000000u
  #define  VP_VPIS_SERRA_CLEAR        0x00000001u

  #define _VP_VPIS_CCMPA_MASK         0x00000004u
  #define _VP_VPIS_CCMPA_SHIFT        0x00000002u
  #define  VP_VPIS_CCMPA_DEFAULT      0x00000000u
  #define  VP_VPIS_CCMPA_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_CCMPA_NONE         0x00000000u
  #define  VP_VPIS_CCMPA_CLEAR        0x00000001u

  #define _VP_VPIS_COVRA_MASK         0x00000002u
  #define _VP_VPIS_COVRA_SHIFT        0x00000001u
  #define  VP_VPIS_COVRA_DEFAULT      0x00000000u
  #define  VP_VPIS_COVRA_OF(x)        _VALUEOF(x)
  #define  VP_VPIS_COVRA_NONE         0x00000000u
  #define  VP_VPIS_COVRA_CLEAR        0x00000001u

  #define  VP_VPIS_OF(x)            _VALUEOF(x)

  #define VP_VPIS_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VPIS,LFDB)\
    |_PER_FDEFAULT(VP,VPIS,SFDB)\
    |_PER_FDEFAULT(VP,VPIS,VINTB2)\
    |_PER_FDEFAULT(VP,VPIS,VINTB1)\
    |_PER_FDEFAULT(VP,VPIS,SERRB)\
    |_PER_FDEFAULT(VP,VPIS,CCMPB)\
    |_PER_FDEFAULT(VP,VPIS,COVRB)\
    |_PER_FDEFAULT(VP,VPIS,GPIO)\
    |_PER_FDEFAULT(VP,VPIS,DCNA)\
    |_PER_FDEFAULT(VP,VPIS,DCMP)\
    |_PER_FDEFAULT(VP,VPIS,DUND)\
    |_PER_FDEFAULT(VP,VPIS,TICK)\
    |_PER_FDEFAULT(VP,VPIS,STC)\
    |_PER_FDEFAULT(VP,VPIS,LFDA)\
    |_PER_FDEFAULT(VP,VPIS,SFDA)\
    |_PER_FDEFAULT(VP,VPIS,VINTA2)\
    |_PER_FDEFAULT(VP,VPIS,VINTA1)\
    |_PER_FDEFAULT(VP,VPIS,SERRA)\
    |_PER_FDEFAULT(VP,VPIS,CCMPA)\
    |_PER_FDEFAULT(VP,VPIS,COVRA)\
  )

  #define VP_VPIS_RMK(lfdb,sfdb,vintb2,vintb1,serrb,ccmpb,covrb,gpio,\
    dcna,dcmp,dund,tick,stc,lfda,sfda,vinta2,vinta1,serra,ccmpa,\
	covra) (Uint32)(\
     _PER_FMK(VP,VPIS,LFDB,lfdb)\
    |_PER_FMK(VP,VPIS,SFDB,sfdb)\
    |_PER_FMK(VP,VPIS,VINTB2,vintb2)\
    |_PER_FMK(VP,VPIS,VINTB1,vintb1)\
    |_PER_FMK(VP,VPIS,SERRB,serrb)\
    |_PER_FMK(VP,VPIS,CCMPB,ccmpb)\
    |_PER_FMK(VP,VPIS,COVRB,covrb)\
    |_PER_FMK(VP,VPIS,GPIO,gpio)\
    |_PER_FMK(VP,VPIS,DCNA,dcna)\
    |_PER_FMK(VP,VPIS,DCMP,dcmp)\
    |_PER_FMK(VP,VPIS,DUND,dund)\
    |_PER_FMK(VP,VPIS,TICK,tick)\
    |_PER_FMK(VP,VPIS,STC,stc)\
    |_PER_FMK(VP,VPIS,LFDA,lfda)\
    |_PER_FMK(VP,VPIS,SFDA,sfda)\
    |_PER_FMK(VP,VPIS,VINTA2,vinta2)\
    |_PER_FMK(VP,VPIS,VINTA1,vinta1)\
    |_PER_FMK(VP,VPIS,SERRA,serra)\
    |_PER_FMK(VP,VPIS,CCMPA,ccmpa)\
    |_PER_FMK(VP,VPIS,COVRA,covra)\
  )

  #define _VP_VPIS_FGET(N,FIELD)\
    _PER_FGET(_VP_VPIS##N##_ADDR,VP,VPIS,##FIELD)

  #define _VP_VPIS_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VPIS##N##_ADDR,VP,VPIS,##FIELD,field)

  #define _VP_VPIS_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VPIS##N##_ADDR,VP,VPIS,##FIELD,##SYM)

  #define _VP_VPIS0_FGET(FIELD)   _VP_VPIS_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPIS1_FGET(FIELD)   _VP_VPIS_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPIS2_FGET(FIELD)   _VP_VPIS_FGET(2,##FIELD)
 #endif


  #define _VP_VPIS0_FSET(FIELD,f)   _VP_VPIS_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPIS1_FSET(FIELD,f)   _VP_VPIS_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPIS2_FSET(FIELD,f)   _VP_VPIS_FSET(2,##FIELD,f)
 #endif


  #define _VP_VPIS0_FSETS(FIELD,SYM)   _VP_VPIS_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VPIS1_FSETS(FIELD,SYM)   _VP_VPIS_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VPIS2_FSETS(FIELD,SYM)   _VP_VPIS_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A S T A T    |
* |___________________|
*
* VCASTAT0 - Video Port 0 Video Capture A Status
* VCASTAT1 - Video Port 1 Video Capture A Status
* VCASTAT2 - Video Port 2 Video Capture A Status
*
* FIELDS (msb -> lsb)
*
* (r)  FSYNC
* (rc) FRMC
* (rc) F2C
* (rc) F1C
* (r)  VCYPOS
* (r)  VCFLD
* (r)  VCXPOS
*
\******************************************************************************/
  #define _VP_VCASTAT_OFFSET           64
  #define _VP_VCASTAT_OFFSETA           0

  #define _VP_VCASTAT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCASTAT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTAT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCASTAT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTAT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCASTAT_OFFSET)
 #endif


  #define _VP_VCASTAT0_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCASTAT_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTAT1_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCASTAT_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTAT2_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCASTAT_OFFSETA)
 #endif


  #define _VP_VCASTAT_FSYNC_MASK        0x80000000u
  #define _VP_VCASTAT_FSYNC_SHIFT       0x0000001Fu
  #define  VP_VCASTAT_FSYNC_DEFAULT     0x00000000u
  #define  VP_VCASTAT_FSYNC_OF(x)       _VALUEOF(x)
  #define  VP_VCASTAT_FSYNC_CLEARD      0x00000000u
  #define  VP_VCASTAT_FSYNC_SET         0x00000001u

  #define _VP_VCASTAT_FRMC_MASK        0x40000000u
  #define _VP_VCASTAT_FRMC_SHIFT       0x0000001Eu
  #define  VP_VCASTAT_FRMC_DEFAULT     0x00000000u
  #define  VP_VCASTAT_FRMC_OF(x)       _VALUEOF(x)
  #define  VP_VCASTAT_FRMC_NONE        0x00000000u
  #define  VP_VCASTAT_FRMC_CAPTURED    0x00000001u
  #define  VP_VCASTAT_FRMC_CLEAR       0x00000001u

  #define _VP_VCASTAT_F2C_MASK        0x20000000u
  #define _VP_VCASTAT_F2C_SHIFT       0x0000001Du
  #define  VP_VCASTAT_F2C_DEFAULT     0x00000000u
  #define  VP_VCASTAT_F2C_OF(x)       _VALUEOF(x)
  #define  VP_VCASTAT_F2C_NONE        0x00000000u
  #define  VP_VCASTAT_F2C_CAPTURED    0x00000001u
  #define  VP_VCASTAT_F2C_CLEAR       0x00000001u

  #define _VP_VCASTAT_F1C_MASK        0x10000000u
  #define _VP_VCASTAT_F1C_SHIFT       0x0000001Cu
  #define  VP_VCASTAT_F1C_DEFAULT     0x00000000u
  #define  VP_VCASTAT_F1C_OF(x)       _VALUEOF(x)
  #define  VP_VCASTAT_F1C_NONE        0x00000000u
  #define  VP_VCASTAT_F1C_CAPTURED    0x00000001u
  #define  VP_VCASTAT_F1C_CLEAR       0x00000001u

  #define _VP_VCASTAT_VCYPOS_MASK        0x0FFF0000u
  #define _VP_VCASTAT_VCYPOS_SHIFT       0x00000010u
  #define  VP_VCASTAT_VCYPOS_DEFAULT     0x00000000u
  #define  VP_VCASTAT_VCYPOS_OF(x)       _VALUEOF(x)

  #define _VP_VCASTAT_VCFLD_MASK        0x00001000u
  #define _VP_VCASTAT_VCFLD_SHIFT       0x0000000Cu
  #define  VP_VCASTAT_VCFLD_DEFAULT     0x00000000u
  #define  VP_VCASTAT_VCFLD_OF(x)       _VALUEOF(x)
  #define  VP_VCASTAT_VCFLD_NONE        0x00000000u
  #define  VP_VCASTAT_VCFLD_DETECTED    0x00000001u

  #define _VP_VCASTAT_VCXPOS_MASK        0x00000FFFu
  #define _VP_VCASTAT_VCXPOS_SHIFT       0x00000000u
  #define  VP_VCASTAT_VCXPOS_DEFAULT     0x00000000u
  #define  VP_VCASTAT_VCXPOS_OF(x)       _VALUEOF(x)


  #define  VP_VCASTAT_OF(x)            _VALUEOF(x)

  #define VP_VCASTAT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCASTAT,FSYNC)\
    |_PER_FDEFAULT(VP,VCASTAT,FRMC)\
    |_PER_FDEFAULT(VP,VCASTAT,F2C)\
    |_PER_FDEFAULT(VP,VCASTAT,F1C)\
    |_PER_FDEFAULT(VP,VCASTAT,VCYPOS)\
    |_PER_FDEFAULT(VP,VCASTAT,VCFLD)\
    |_PER_FDEFAULT(VP,VCASTAT,VCXPOS)\
  )

  #define VP_VCASTAT_RMK(frmc,f2c,f1c) (Uint32)(\
     _PER_FMK(VP,VCASTAT,FRMC,frmc)\
    |_PER_FMK(VP,VCASTAT,F2C,f2c)\
    |_PER_FMK(VP,VCASTAT,F1C,f1c)\
  )

  #define _VP_VCASTAT_FGET(N,FIELD)\
    _PER_FGET(_VP_VCASTAT##N##_ADDR,VP,VCASTAT,##FIELD)

  #define _VP_VCASTAT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCASTAT##N##_ADDR,VP,VCASTAT,##FIELD,field)

  #define _VP_VCASTAT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCASTAT##N##_ADDR,VP,VCASTAT,##FIELD,##SYM)

  #define _VP_VCASTAT0_FGET(FIELD)   _VP_VCASTAT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTAT1_FGET(FIELD)   _VP_VCASTAT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTAT2_FGET(FIELD)   _VP_VCASTAT_FGET(2,##FIELD)
 #endif


  #define _VP_VCASTAT0_FSET(FIELD,f)   _VP_VCASTAT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTAT1_FSET(FIELD,f)   _VP_VCASTAT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTAT2_FSET(FIELD,f)   _VP_VCASTAT_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCASTAT0_FSETS(FIELD,SYM)   _VP_VCASTAT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTAT1_FSETS(FIELD,SYM)   _VP_VCASTAT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTAT2_FSETS(FIELD,SYM)   _VP_VCASTAT_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A C T L      |
* |___________________|
*
* VCACTL0 -  Video Port 0 Video Capture A Control
* VCACTL1 -  Video Port 1 Video Capture A Control
* VCACTL2 -  Video Port 2 Video Capture A Control
*
* FIELDS (msb -> lsb)
*
* (rw) RSTCH
* (rw) BLKCAP
* (rw) RDFE
* (rw) FINV
* (rw) EXC
* (rw) FLDD
* (rw) VRST
* (rw) HRST
* (rw) VCEN
* (rw) PK10B
* (rw) LFDE
* (rw) SFDE
* (rw) RESMPL
* (rw) SCALE
* (rw) CON
* (rw) FRAME
* (rw) CF2
* (rw) CF1
* (rw) CMODE
*
\******************************************************************************/
  #define _VP_VCACTL_OFFSET            65
  #define _VP_VCACTL_OFFSETA           1

  #define _VP_VCACTL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCACTL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCACTL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCACTL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCACTL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCACTL_OFFSET)
 #endif


  #define _VP_VCACTL0_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCACTL_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCACTL1_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCACTL_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCACTL2_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCACTL_OFFSETA)
 #endif



  #define _VP_VCACTL_RSTCH_MASK        0x80000000u
  #define _VP_VCACTL_RSTCH_SHIFT       0x0000001Fu
  #define  VP_VCACTL_RSTCH_DEFAULT     0x00000000u
  #define  VP_VCACTL_RSTCH_OF(x)       _VALUEOF(x)
  #define  VP_VCACTL_RSTCH_NONE        0x00000000u
  #define  VP_VCACTL_RSTCH_RESET       0x00000001u

  #define _VP_VCACTL_BLKCAP_MASK       0x40000000u
  #define _VP_VCACTL_BLKCAP_SHIFT      0x0000001Eu
  #define  VP_VCACTL_BLKCAP_DEFAULT    0x00000001u
  #define  VP_VCACTL_BLKCAP_OF(x)      _VALUEOF(x)
  #define  VP_VCACTL_BLKCAP_CLEAR      0x00000000u
  #define  VP_VCACTL_BLKCAP_BLOCK      0x00000001u

  #define _VP_VCACTL_RDFE_MASK         0x00200000u
  #define _VP_VCACTL_RDFE_SHIFT        0x00000015u
  #define  VP_VCACTL_RDFE_DEFAULT      0x00000000u
  #define  VP_VCACTL_RDFE_OF(x)        _VALUEOF(x)
  #define  VP_VCACTL_RDFE_DISABLE      0x00000000u
  #define  VP_VCACTL_RDFE_ENABLE       0x00000001u

  #define _VP_VCACTL_FINV_MASK         0x00100000u
  #define _VP_VCACTL_FINV_SHIFT        0x00000014u
  #define  VP_VCACTL_FINV_DEFAULT      0x00000000u
  #define  VP_VCACTL_FINV_OF(x)        _VALUEOF(x)
  #define  VP_VCACTL_FINV_FIELD1       0x00000000u
  #define  VP_VCACTL_FINV_FIELD2       0x00000001u

  #define _VP_VCACTL_EXC_MASK          0x00080000u
  #define _VP_VCACTL_EXC_SHIFT         0x00000013u
  #define  VP_VCACTL_EXC_DEFAULT       0x00000000u
  #define  VP_VCACTL_EXC_OF(x)         _VALUEOF(x)
  #define  VP_VCACTL_EXC_EAVSAV        0x00000000u
  #define  VP_VCACTL_EXC_EXTERN        0x00000001u

  #define _VP_VCACTL_FLDD_MASK         0x00040000u
  #define _VP_VCACTL_FLDD_SHIFT        0x00000012u
  #define  VP_VCACTL_FLDD_DEFAULT      0x00000000u
  #define  VP_VCACTL_FLDD_OF(x)        _VALUEOF(x)
  #define  VP_VCACTL_FLDD_EAVFID       0x00000000u
  #define  VP_VCACTL_FLDD_FDL          0x00000001u

  #define _VP_VCACTL_VRST_MASK         0x00020000u
  #define _VP_VCACTL_VRST_SHIFT        0x00000011u
  #define  VP_VCACTL_VRST_DEFAULT      0x00000001u
  #define  VP_VCACTL_VRST_OF(x)        _VALUEOF(x)
  #define  VP_VCACTL_VRST_V1EAV        0x00000000u
  #define  VP_VCACTL_VRST_V0EAV        0x00000001u

  #define _VP_VCACTL_HRST_MASK         0x00010000u
  #define _VP_VCACTL_HRST_SHIFT        0x00000010u
  #define  VP_VCACTL_HRST_DEFAULT      0x00000000u
  #define  VP_VCACTL_HRST_OF(x)        _VALUEOF(x)
  #define  VP_VCACTL_HRST_EAV          0x00000000u
  #define  VP_VCACTL_HRST_SAV          0x00000001u

  #define _VP_VCACTL_VCEN_MASK         0x00008000u
  #define _VP_VCACTL_VCEN_SHIFT        0x0000000Fu
  #define  VP_VCACTL_VCEN_DEFAULT      0x00000000u
  #define  VP_VCACTL_VCEN_OF(x)        _VALUEOF(x)
  #define  VP_VCACTL_VCEN_DISABLE      0x00000000u
  #define  VP_VCACTL_VCEN_ENABLE       0x00000001u

  #define _VP_VCACTL_PK10B_MASK        0x00006000u
  #define _VP_VCACTL_PK10B_SHIFT       0x0000000Du
  #define  VP_VCACTL_PK10B_DEFAULT     0x00000000u
  #define  VP_VCACTL_PK10B_OF(x)       _VALUEOF(x)
  #define  VP_VCACTL_PK10B_ZERO        0x00000000u
  #define  VP_VCACTL_PK10B_SIGN        0x00000001u
  #define  VP_VCACTL_PK10B_DENSEPK     0x00000002u

  #define _VP_VCACTL_LFDE_MASK         0x00001000u
  #define _VP_VCACTL_LFDE_SHIFT        0x0000000Cu
  #define  VP_VCACTL_LFDE_DEFAULT      0x00000000u
  #define  VP_VCACTL_LFDE_OF(x)        _VALUEOF(x)
  #define  VP_VCACTL_LFDE_DISABLE      0x00000000u
  #define  VP_VCACTL_LFDE_ENABLE       0x00000001u

  #define _VP_VCACTL_SFDE_MASK         0x00000800u
  #define _VP_VCACTL_SFDE_SHIFT        0x0000000Bu
  #define  VP_VCACTL_SFDE_DEFAULT      0x00000000u
  #define  VP_VCACTL_SFDE_OF(x)        _VALUEOF(x)
  #define  VP_VCACTL_SFDE_DISABLE      0x00000000u
  #define  VP_VCACTL_SFDE_ENABLE       0x00000001u

  #define _VP_VCACTL_RESMPL_MASK       0x00000400u
  #define _VP_VCACTL_RESMPL_SHIFT      0x0000000Au
  #define  VP_VCACTL_RESMPL_DEFAULT    0x00000000u
  #define  VP_VCACTL_RESMPL_OF(x)      _VALUEOF(x)
  #define  VP_VCACTL_RESMPL_DISABLE    0x00000000u
  #define  VP_VCACTL_RESMPL_ENABLE     0x00000001u

  #define _VP_VCACTL_SCALE_MASK        0x00000100u
  #define _VP_VCACTL_SCALE_SHIFT       0x00000008u
  #define  VP_VCACTL_SCALE_DEFAULT     0x00000000u
  #define  VP_VCACTL_SCALE_OF(x)       _VALUEOF(x)
  #define  VP_VCACTL_SCALE_NONE        0x00000000u
  #define  VP_VCACTL_SCALE_HALF        0x00000001u

  #define _VP_VCACTL_CON_MASK          0x00000080u
  #define _VP_VCACTL_CON_SHIFT         0x00000007u
  #define  VP_VCACTL_CON_DEFAULT       0x00000000u
  #define  VP_VCACTL_CON_OF(x)         _VALUEOF(x)
  #define  VP_VCACTL_CON_DISABLE       0x00000000u
  #define  VP_VCACTL_CON_ENABLE        0x00000001u

  #define _VP_VCACTL_FRAME_MASK        0x00000040u
  #define _VP_VCACTL_FRAME_SHIFT       0x00000006u
  #define  VP_VCACTL_FRAME_DEFAULT     0x00000000u
  #define  VP_VCACTL_FRAME_OF(x)       _VALUEOF(x)
  #define  VP_VCACTL_FRAME_NONE        0x00000000u
  #define  VP_VCACTL_FRAME_FRMCAP      0x00000001u

  #define _VP_VCACTL_CF2_MASK          0x00000020u
  #define _VP_VCACTL_CF2_SHIFT         0x00000005u
  #define  VP_VCACTL_CF2_DEFAULT       0x00000001u
  #define  VP_VCACTL_CF2_OF(x)         _VALUEOF(x)
  #define  VP_VCACTL_CF2_NONE          0x00000000u
  #define  VP_VCACTL_CF2_FLDCAP        0x00000001u

  #define _VP_VCACTL_CF1_MASK          0x00000010u
  #define _VP_VCACTL_CF1_SHIFT         0x00000004u
  #define  VP_VCACTL_CF1_DEFAULT       0x00000001u
  #define  VP_VCACTL_CF1_OF(x)         _VALUEOF(x)
  #define  VP_VCACTL_CF1_NONE          0x00000000u
  #define  VP_VCACTL_CF1_FLDCAP        0x00000001u

  #define _VP_VCACTL_CMODE_MASK        0x00000007u
  #define _VP_VCACTL_CMODE_SHIFT       0x00000000u
  #define  VP_VCACTL_CMODE_DEFAULT     0x00000000u
  #define  VP_VCACTL_CMODE_OF(x)       _VALUEOF(x)
  #define  VP_VCACTL_CMODE_BT656B      0x00000000u
  #define  VP_VCACTL_CMODE_BT656D      0x00000001u
  #define  VP_VCACTL_CMODE_RAWB        0x00000002u
  #define  VP_VCACTL_CMODE_RAWD        0x00000003u
  #define  VP_VCACTL_CMODE_YCB         0x00000004u
  #define  VP_VCACTL_CMODE_YCD         0x00000005u
  #define  VP_VCACTL_CMODE_RAW16       0x00000006u
  #define  VP_VCACTL_CMODE_RAW20       0x00000007u

  #define  VP_VCACTL_OF(x)            _VALUEOF(x)

  #define VP_VCACTL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCACTL,RSTCH)\
    |_PER_FDEFAULT(VP,VCACTL,BLKCAP)\
    |_PER_FDEFAULT(VP,VCACTL,RDFE)\
    |_PER_FDEFAULT(VP,VCACTL,FINV)\
    |_PER_FDEFAULT(VP,VCACTL,EXC)\
    |_PER_FDEFAULT(VP,VCACTL,FLDD)\
    |_PER_FDEFAULT(VP,VCACTL,VRST)\
    |_PER_FDEFAULT(VP,VCACTL,HRST)\
    |_PER_FDEFAULT(VP,VCACTL,VCEN)\
    |_PER_FDEFAULT(VP,VCACTL,PK10B)\
    |_PER_FDEFAULT(VP,VCACTL,LFDE)\
    |_PER_FDEFAULT(VP,VCACTL,SFDE)\
    |_PER_FDEFAULT(VP,VCACTL,RESMPL)\
    |_PER_FDEFAULT(VP,VCACTL,SCALE)\
    |_PER_FDEFAULT(VP,VCACTL,CON)\
    |_PER_FDEFAULT(VP,VCACTL,FRAME)\
    |_PER_FDEFAULT(VP,VCACTL,CF2)\
    |_PER_FDEFAULT(VP,VCACTL,CF1)\
    |_PER_FDEFAULT(VP,VCACTL,CMODE)\
  )

  #define VP_VCACTL_RMK(rstch,blkcap,rdfe,finv,exc,fldd,vrst,\
    hrst,vcen,pk10b,lfde,sfde,resmpl,scale,con,frame,cf2,cf1,cmode) (Uint32)(\
     _PER_FMK(VP,VCACTL,RSTCH,rstch)\
    |_PER_FMK(VP,VCACTL,BLKCAP,blkcap)\
    |_PER_FMK(VP,VCACTL,RDFE,rdfe)\
    |_PER_FMK(VP,VCACTL,FINV,finv)\
    |_PER_FMK(VP,VCACTL,EXC,exc)\
    |_PER_FMK(VP,VCACTL,FLDD,fldd)\
    |_PER_FMK(VP,VCACTL,VRST,vrst)\
    |_PER_FMK(VP,VCACTL,HRST,hrst)\
    |_PER_FMK(VP,VCACTL,VCEN,vcen)\
    |_PER_FMK(VP,VCACTL,PK10B,pk10b)\
    |_PER_FMK(VP,VCACTL,LFDE,lfde)\
    |_PER_FMK(VP,VCACTL,SFDE,sfde)\
    |_PER_FMK(VP,VCACTL,RESMPL,resmpl)\
    |_PER_FMK(VP,VCACTL,SCALE,scale)\
    |_PER_FMK(VP,VCACTL,CON,con)\
    |_PER_FMK(VP,VCACTL,FRAME,frame)\
    |_PER_FMK(VP,VCACTL,CF2,cf2)\
    |_PER_FMK(VP,VCACTL,CF1,cf1)\
    |_PER_FMK(VP,VCACTL,CMODE,cmode)\
  )

  #define _VP_VCACTL_FGET(N,FIELD)\
    _PER_FGET(_VP_VCACTL##N##_ADDR,VP,VCACTL,##FIELD)

  #define _VP_VCACTL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCACTL##N##_ADDR,VP,VCACTL,##FIELD,field)

  #define _VP_VCACTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCACTL##N##_ADDR,VP,VCACTL,##FIELD,##SYM)

  #define _VP_VCACTL0_FGET(FIELD)   _VP_VCACTL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCACTL1_FGET(FIELD)   _VP_VCACTL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCACTL2_FGET(FIELD)   _VP_VCACTL_FGET(2,##FIELD)
 #endif


  #define _VP_VCACTL0_FSET(FIELD,f)   _VP_VCACTL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCACTL1_FSET(FIELD,f)   _VP_VCACTL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCACTL2_FSET(FIELD,f)   _VP_VCACTL_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCACTL0_FSETS(FIELD,SYM)   _VP_VCACTL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCACTL1_FSETS(FIELD,SYM)   _VP_VCACTL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCACTL2_FSETS(FIELD,SYM)   _VP_VCACTL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A S T R T 1  |
* |___________________|
*
* VCASTRT10 -  Video Port 0 Video Capture A Field1 Start
* VCASTRT11 -  Video Port 1 Video Capture A Field1 Start
* VCASTRT12 -  Video Port 2 Video Capture A Field1 Start
*
* FIELDS (msb -> lsb)
* (rw) VCYSTART
* (rw) SSE
* (rw) VCXSTART/VCVBLNKP
*
\******************************************************************************/
  #define _VP_VCASTRT1_OFFSET           66
  #define _VP_VCASTRT1_OFFSETA           2

  #define _VP_VCASTRT10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCASTRT1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCASTRT1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCASTRT1_OFFSET)
 #endif


  #define _VP_VCASTRT10_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCASTRT1_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT11_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCASTRT1_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT12_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCASTRT1_OFFSETA)
 #endif


  #define _VP_VCASTRT1_VCYSTART_MASK        0x0FFF0000u
  #define _VP_VCASTRT1_VCYSTART_SHIFT       0x00000010u
  #define  VP_VCASTRT1_VCYSTART_DEFAULT     0x00000000u
  #define  VP_VCASTRT1_VCYSTART_OF(x)       _VALUEOF(x)

  #define _VP_VCASTRT1_SSE_MASK             0x00008000u
  #define _VP_VCASTRT1_SSE_SHIFT            0x0000000Fu
  #define  VP_VCASTRT1_SSE_DEFAULT          0x00000001u
  #define  VP_VCASTRT1_SSE_OF(x)            _VALUEOF(x)
  #define  VP_VCASTRT1_SSE_DISABLE          0x00000000u
  #define  VP_VCASTRT1_SSE_ENABLE           0x00000001u

  #define _VP_VCASTRT1_VCXSTART_MASK        0x00000FFFu
  #define _VP_VCASTRT1_VCXSTART_SHIFT       0x00000000u
  #define  VP_VCASTRT1_VCXSTART_DEFAULT     0x00000000u
  #define  VP_VCASTRT1_VCXSTART_OF(x)       _VALUEOF(x)

  #define _VP_VCASTRT1_VCVBLNKP_MASK        0x00000FFFu
  #define _VP_VCASTRT1_VCVBLNKP_SHIFT       0x00000000u
  #define  VP_VCASTRT1_VCVBLNKP_DEFAULT     0x00000000u
  #define  VP_VCASTRT1_VCVBLNKP_OF(x)       _VALUEOF(x)

  #define  VP_VCASTRT1_OF(x)            _VALUEOF(x)

  #define VP_VCASTRT1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCASTRT1,VCYSTART)\
    |_PER_FDEFAULT(VP,VCASTRT1,SSE)\
    |_PER_FDEFAULT(VP,VCASTRT1,VCXSTART)\
  )

  #define VP_VCASTRT1_RMK(vcystart,sse,vcxstart) (Uint32)(\
     _PER_FMK(VP,VCASTRT1,VCYSTART,vcystart)\
    |_PER_FMK(VP,VCASTRT1,SSE,sse)\
    |_PER_FMK(VP,VCASTRT1,VCXSTART,vcxstart)\
  )

  #define _VP_VCASTRT1_FGET(N,FIELD)\
    _PER_FGET(_VP_VCASTRT1##N##_ADDR,VP,VCASTRT1,##FIELD)

  #define _VP_VCASTRT1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCASTRT1##N##_ADDR,VP,VCASTRT1,##FIELD,field)

  #define _VP_VCASTRT1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCASTRT1##N##_ADDR,VP,VCASTRT1,##FIELD,##SYM)

  #define _VP_VCASTRT10_FGET(FIELD)   _VP_VCASTRT1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT11_FGET(FIELD)   _VP_VCASTRT1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT12_FGET(FIELD)   _VP_VCASTRT1_FGET(2,##FIELD)
 #endif


  #define _VP_VCASTRT10_FSET(FIELD,f)   _VP_VCASTRT1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT11_FSET(FIELD,f)   _VP_VCASTRT1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT12_FSET(FIELD,f)   _VP_VCASTRT1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCASTRT10_FSETS(FIELD,SYM)   _VP_VCASTRT1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT11_FSETS(FIELD,SYM)   _VP_VCASTRT1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT12_FSETS(FIELD,SYM)   _VP_VCASTRT1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A S T O P 1  |
* |___________________|
*
* VCASTOP10 -  Video Port 0 Video Capture A Field1 Stop
* VCASTOP11 -  Video Port 1 Video Capture A Field1 Stop
* VCASTOP12 -  Video Port 2 Video Capture A Field1 Stop
*
* FIELDS (msb -> lsb)
* (rw) VCYSTOP
* (rw) VCXSTOP
*
\******************************************************************************/
  #define _VP_VCASTOP1_OFFSET           67
  #define _VP_VCASTOP1_OFFSETA           3

  #define _VP_VCASTOP10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCASTOP1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCASTOP1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCASTOP1_OFFSET)
 #endif


  #define _VP_VCASTOP10_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCASTOP1_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP11_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCASTOP1_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP12_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCASTOP1_OFFSETA)
 #endif


  #define _VP_VCASTOP1_VCYSTOP_MASK        0x0FFF0000u
  #define _VP_VCASTOP1_VCYSTOP_SHIFT       0x00000010u
  #define  VP_VCASTOP1_VCYSTOP_DEFAULT     0x00000000u
  #define  VP_VCASTOP1_VCYSTOP_OF(x)       _VALUEOF(x)

  #define _VP_VCASTOP1_VCXSTOP_MASK        0x00000FFFu
  #define _VP_VCASTOP1_VCXSTOP_SHIFT       0x00000000u
  #define  VP_VCASTOP1_VCXSTOP_DEFAULT     0x00000000u
  #define  VP_VCASTOP1_VCXSTOP_OF(x)       _VALUEOF(x)

  #define  VP_VCASTOP1_OF(x)            _VALUEOF(x)

  #define VP_VCASTOP1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCASTOP1,VCYSTOP)\
    |_PER_FDEFAULT(VP,VCASTOP1,VCXSTOP)\
  )

  #define VP_VCASTOP1_RMK(vcystop,vcxstop) (Uint32)(\
     _PER_FMK(VP,VCASTOP1,VCYSTOP,vcystop)\
    |_PER_FMK(VP,VCASTOP1,VCXSTOP,vcxstop)\
  )

  #define _VP_VCASTOP1_FGET(N,FIELD)\
    _PER_FGET(_VP_VCASTOP1##N##_ADDR,VP,VCASTOP1,##FIELD)

  #define _VP_VCASTOP1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCASTOP1##N##_ADDR,VP,VCASTOP1,##FIELD,field)

  #define _VP_VCASTOP1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCASTOP1##N##_ADDR,VP,VCASTOP1,##FIELD,##SYM)

  #define _VP_VCASTOP10_FGET(FIELD)   _VP_VCASTOP1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP11_FGET(FIELD)   _VP_VCASTOP1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP12_FGET(FIELD)   _VP_VCASTOP1_FGET(2,##FIELD)
 #endif


  #define _VP_VCASTOP10_FSET(FIELD,f)   _VP_VCASTOP1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP11_FSET(FIELD,f)   _VP_VCASTOP1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP12_FSET(FIELD,f)   _VP_VCASTOP1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCASTOP10_FSETS(FIELD,SYM)   _VP_VCASTOP1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP11_FSETS(FIELD,SYM)   _VP_VCASTOP1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP12_FSETS(FIELD,SYM)   _VP_VCASTOP1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A S T R T 2  |
* |___________________|
*
* VCASTRT20 -  Video Port 0 Video Capture A Field2 Start
* VCASTRT21 -  Video Port 1 Video Capture A Field2 Start
* VCASTRT22 -  Video Port 2 Video Capture A Field2 Start
*
* FIELDS (msb -> lsb)
* (rw) VCYSTART
* (rw) VCXSTART
*
\******************************************************************************/
  #define _VP_VCASTRT2_OFFSET           68
  #define _VP_VCASTRT2_OFFSETA           4

  #define _VP_VCASTRT20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCASTRT2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCASTRT2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCASTRT2_OFFSET)
 #endif


  #define _VP_VCASTRT20_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCASTRT2_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT21_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCASTRT2_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT22_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCASTRT2_OFFSETA)
 #endif


  #define _VP_VCASTRT2_VCYSTART_MASK        0x0FFF0000u
  #define _VP_VCASTRT2_VCYSTART_SHIFT       0x00000010u
  #define  VP_VCASTRT2_VCYSTART_DEFAULT     0x00000000u
  #define  VP_VCASTRT2_VCYSTART_OF(x)       _VALUEOF(x)

  #define _VP_VCASTRT2_VCXSTART_MASK        0x00000FFFu
  #define _VP_VCASTRT2_VCXSTART_SHIFT       0x00000000u
  #define  VP_VCASTRT2_VCXSTART_DEFAULT     0x00000000u
  #define  VP_VCASTRT2_VCXSTART_OF(x)       _VALUEOF(x)

  #define  VP_VCASTRT2_OF(x)            _VALUEOF(x)

  #define VP_VCASTRT2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCASTRT2,VCYSTART)\
    |_PER_FDEFAULT(VP,VCASTRT2,VCXSTART)\
  )

  #define VP_VCASTRT2_RMK(vcystart,vcxstart) (Uint32)(\
     _PER_FMK(VP,VCASTRT2,VCYSTART,vcystart)\
    |_PER_FMK(VP,VCASTRT2,VCXSTART,vcxstart)\
  )

  #define _VP_VCASTRT2_FGET(N,FIELD)\
    _PER_FGET(_VP_VCASTRT2##N##_ADDR,VP,VCASTRT2,##FIELD)

  #define _VP_VCASTRT2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCASTRT2##N##_ADDR,VP,VCASTRT2,##FIELD,field)

  #define _VP_VCASTRT2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCASTRT2##N##_ADDR,VP,VCASTRT2,##FIELD,##SYM)

  #define _VP_VCASTRT20_FGET(FIELD)   _VP_VCASTRT2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT21_FGET(FIELD)   _VP_VCASTRT2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT22_FGET(FIELD)   _VP_VCASTRT2_FGET(2,##FIELD)
 #endif


  #define _VP_VCASTRT20_FSET(FIELD,f)   _VP_VCASTRT2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT21_FSET(FIELD,f)   _VP_VCASTRT2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT22_FSET(FIELD,f)   _VP_VCASTRT2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCASTRT20_FSETS(FIELD,SYM)   _VP_VCASTRT2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTRT21_FSETS(FIELD,SYM)   _VP_VCASTRT2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTRT22_FSETS(FIELD,SYM)   _VP_VCASTRT2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A S T O P 2  |
* |___________________|
*
* VCASTOP20 -  Video Port 0 Video Capture A Field2 Stop
* VCASTOP21 -  Video Port 1 Video Capture A Field2 Stop
* VCASTOP22 -  Video Port 2 Video Capture A Field2 Stop
*
* FIELDS (msb -> lsb)
* (rw) VCYSTOP
* (rw) VCXSTOP
*
\******************************************************************************/
  #define _VP_VCASTOP2_OFFSET           69
  #define _VP_VCASTOP2_OFFSETA           5

  #define _VP_VCASTOP20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCASTOP2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCASTOP2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCASTOP2_OFFSET)
 #endif


  #define _VP_VCASTOP20_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCASTOP2_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP21_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCASTOP2_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP22_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCASTOP2_OFFSETA)
 #endif


  #define _VP_VCASTOP2_VCYSTOP_MASK        0x0FFF0000u
  #define _VP_VCASTOP2_VCYSTOP_SHIFT       0x00000010u
  #define  VP_VCASTOP2_VCYSTOP_DEFAULT     0x00000000u
  #define  VP_VCASTOP2_VCYSTOP_OF(x)       _VALUEOF(x)

  #define _VP_VCASTOP2_VCXSTOP_MASK        0x00000FFFu
  #define _VP_VCASTOP2_VCXSTOP_SHIFT       0x00000000u
  #define  VP_VCASTOP2_VCXSTOP_DEFAULT     0x00000000u
  #define  VP_VCASTOP2_VCXSTOP_OF(x)       _VALUEOF(x)

  #define  VP_VCASTOP2_OF(x)            _VALUEOF(x)

  #define VP_VCASTOP2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCASTOP2,VCYSTOP)\
    |_PER_FDEFAULT(VP,VCASTOP2,VCXSTOP)\
  )

  #define VP_VCASTOP2_RMK(vcystop,vcxstop) (Uint32)(\
     _PER_FMK(VP,VCASTOP2,VCYSTOP,vcystop)\
    |_PER_FMK(VP,VCASTOP2,VCXSTOP,vcxstop)\
  )

  #define _VP_VCASTOP2_FGET(N,FIELD)\
    _PER_FGET(_VP_VCASTOP2##N##_ADDR,VP,VCASTOP2,##FIELD)

  #define _VP_VCASTOP2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCASTOP2##N##_ADDR,VP,VCASTOP2,##FIELD,field)

  #define _VP_VCASTOP2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCASTOP2##N##_ADDR,VP,VCASTOP2,##FIELD,##SYM)

  #define _VP_VCASTOP20_FGET(FIELD)   _VP_VCASTOP2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP21_FGET(FIELD)   _VP_VCASTOP2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP22_FGET(FIELD)   _VP_VCASTOP2_FGET(2,##FIELD)
 #endif


  #define _VP_VCASTOP20_FSET(FIELD,f)   _VP_VCASTOP2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP21_FSET(FIELD,f)   _VP_VCASTOP2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP22_FSET(FIELD,f)   _VP_VCASTOP2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCASTOP20_FSETS(FIELD,SYM)   _VP_VCASTOP2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCASTOP21_FSETS(FIELD,SYM)   _VP_VCASTOP2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCASTOP22_FSETS(FIELD,SYM)   _VP_VCASTOP2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A V I N T    |
* |___________________|
*
* VCAVINT0 -  Video Port 0 Video Capture A Vertical Interrupt
* VCAVINT1 -  Video Port 1 Video Capture A Vertical Interrupt
* VCAVINT2 -  Video Port 2 Video Capture A Vertical Interrupt
*
* FIELDS (msb -> lsb)
* (rw) VIF2 
* (rw) FSCL2
* (rw) VINT2
* (rw) VIF1 
* (rw) VINT1
*
\******************************************************************************/
  #define _VP_VCAVINT_OFFSET            70
  #define _VP_VCAVINT_OFFSETA            6

  #define _VP_VCAVINT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCAVINT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAVINT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCAVINT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAVINT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCAVINT_OFFSET)
 #endif


  #define _VP_VCAVINT0_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCAVINT_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAVINT1_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCAVINT_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAVINT2_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCAVINT_OFFSETA)
 #endif


  #define _VP_VCAVINT_VIF2_MASK        0x80000000u
  #define _VP_VCAVINT_VIF2_SHIFT       0x0000001Fu
  #define  VP_VCAVINT_VIF2_DEFAULT     0x00000000u
  #define  VP_VCAVINT_VIF2_OF(x)       _VALUEOF(x)
  #define  VP_VCAVINT_VIF2_DISABLE     0x00000000u
  #define  VP_VCAVINT_VIF2_ENABLE      0x00000001u

  #define _VP_VCAVINT_FSCL2_MASK         0x40000000u
  #define _VP_VCAVINT_FSCL2_SHIFT        0x0000001Eu
  #define  VP_VCAVINT_FSCL2_DEFAULT      0x00000000u
  #define  VP_VCAVINT_FSCL2_OF(x)        _VALUEOF(x)
  #define  VP_VCAVINT_FSCL2_NONE         0x00000000u
  #define  VP_VCAVINT_FSCL2_FIELD2       0x00000001u

  #define _VP_VCAVINT_VINT2_MASK         0x0FFF0000u
  #define _VP_VCAVINT_VINT2_SHIFT        0x00000010u
  #define  VP_VCAVINT_VINT2_DEFAULT      0x00000000u
  #define  VP_VCAVINT_VINT2_OF(x)        _VALUEOF(x)

  #define _VP_VCAVINT_VIF1_MASK        0x00008000u
  #define _VP_VCAVINT_VIF1_SHIFT       0x0000000Fu
  #define  VP_VCAVINT_VIF1_DEFAULT     0x00000000u
  #define  VP_VCAVINT_VIF1_OF(x)       _VALUEOF(x)
  #define  VP_VCAVINT_VIF1_DISABLE     0x00000000u
  #define  VP_VCAVINT_VIF1_ENABLE      0x00000001u

  #define _VP_VCAVINT_VINT1_MASK         0x00000FFFu
  #define _VP_VCAVINT_VINT1_SHIFT        0x00000000u
  #define  VP_VCAVINT_VINT1_DEFAULT      0x00000000u
  #define  VP_VCAVINT_VINT1_OF(x)        _VALUEOF(x)

  #define  VP_VCAVINT_OF(x)            _VALUEOF(x)

  #define VP_VCAVINT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCAVINT,VIF2)\
    |_PER_FDEFAULT(VP,VCAVINT,FSCL2)\
    |_PER_FDEFAULT(VP,VCAVINT,VINT2)\
    |_PER_FDEFAULT(VP,VCAVINT,VIF1)\
    |_PER_FDEFAULT(VP,VCAVINT,VINT1)\
  )

  #define VP_VCAVINT_RMK(vif2,fscl2,vint2,vif1,vint1) (Uint32)(\
     _PER_FMK(VP,VCAVINT,VIF2,vif2)\
    |_PER_FMK(VP,VCAVINT,FSCL2,fscl2)\
    |_PER_FMK(VP,VCAVINT,VINT2,vint2)\
    |_PER_FMK(VP,VCAVINT,VIF1,vif1)\
    |_PER_FMK(VP,VCAVINT,VINT1,vint1)\
  )

  #define _VP_VCAVINT_FGET(N,FIELD)\
    _PER_FGET(_VP_VCAVINT##N##_ADDR,VP,VCAVINT,##FIELD)

  #define _VP_VCAVINT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCAVINT##N##_ADDR,VP,VCAVINT,##FIELD,field)

  #define _VP_VCAVINT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCAVINT##N##_ADDR,VP,VCAVINT,##FIELD,##SYM)

  #define _VP_VCAVINT0_FGET(FIELD)   _VP_VCAVINT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAVINT1_FGET(FIELD)   _VP_VCAVINT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAVINT2_FGET(FIELD)   _VP_VCAVINT_FGET(2,##FIELD)
 #endif


  #define _VP_VCAVINT0_FSET(FIELD,f)   _VP_VCAVINT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAVINT1_FSET(FIELD,f)   _VP_VCAVINT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAVINT2_FSET(FIELD,f)   _VP_VCAVINT_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCAVINT0_FSETS(FIELD,SYM)   _VP_VCAVINT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAVINT1_FSETS(FIELD,SYM)   _VP_VCAVINT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAVINT2_FSETS(FIELD,SYM)   _VP_VCAVINT_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A T H R L D  |
* |___________________|
*
* VCATHRLD0    -  Video Port 0 Video Capture A Threshold
* VCATHRLD1    -  Video Port 1 Video Capture A Threshold
* VCATHRLD2    -  Video Port 2 Video Capture A Threshold
*
* FIELDS (msb -> lsb)
* (rw) VCTHRLD2
* (rw) VCTHRLD1
*
\******************************************************************************/
  #define _VP_VCATHRLD_OFFSET           71
  #define _VP_VCATHRLD_OFFSETA           7

  #define _VP_VCATHRLD0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCATHRLD_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCATHRLD1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCATHRLD_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCATHRLD2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCATHRLD_OFFSET)
 #endif


  #define _VP_VCATHRLD0_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCATHRLD_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCATHRLD1_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCATHRLD_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCATHRLD2_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCATHRLD_OFFSETA)
 #endif


  #define _VP_VCATHRLD_VCTHRLD2_MASK         0x03FF0000u
  #define _VP_VCATHRLD_VCTHRLD2_SHIFT        0x00000010u
  #define  VP_VCATHRLD_VCTHRLD2_DEFAULT      0x00000000u
  #define  VP_VCATHRLD_VCTHRLD2_OF(x)        _VALUEOF(x)

  #define _VP_VCATHRLD_VCTHRLD1_MASK         0x000003FFu
  #define _VP_VCATHRLD_VCTHRLD1_SHIFT        0x00000000u
  #define  VP_VCATHRLD_VCTHRLD1_DEFAULT      0x00000000u
  #define  VP_VCATHRLD_VCTHRLD1_OF(x)        _VALUEOF(x)

  #define  VP_VCATHRLD_OF(x)            _VALUEOF(x)

  #define VP_VCATHRLD_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCATHRLD,VCTHRLD2)\
    |_PER_FDEFAULT(VP,VCATHRLD,VCTHRLD1)\
  )

  #define VP_VCATHRLD_RMK(vcthrld2,vcthrld1) (Uint32)(\
     _PER_FMK(VP,VCATHRLD,VCTHRLD2,vcthrld2)\
    |_PER_FMK(VP,VCATHRLD,VCTHRLD1,vcthrld1)\
  )

  #define _VP_VCATHRLD_FGET(N,FIELD)\
    _PER_FGET(_VP_VCATHRLD##N##_ADDR,VP,VCATHRLD,##FIELD)

  #define _VP_VCATHRLD_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCATHRLD##N##_ADDR,VP,VCATHRLD,##FIELD,field)

  #define _VP_VCATHRLD_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCATHRLD##N##_ADDR,VP,VCATHRLD,##FIELD,##SYM)

  #define _VP_VCATHRLD0_FGET(FIELD)   _VP_VCATHRLD_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCATHRLD1_FGET(FIELD)   _VP_VCATHRLD_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCATHRLD2_FGET(FIELD)   _VP_VCATHRLD_FGET(2,##FIELD)
 #endif


  #define _VP_VCATHRLD0_FSET(FIELD,f)   _VP_VCATHRLD_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCATHRLD1_FSET(FIELD,f)   _VP_VCATHRLD_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCATHRLD2_FSET(FIELD,f)   _VP_VCATHRLD_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCATHRLD0_FSETS(FIELD,SYM)   _VP_VCATHRLD_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCATHRLD1_FSETS(FIELD,SYM)   _VP_VCATHRLD_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCATHRLD2_FSETS(FIELD,SYM)   _VP_VCATHRLD_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C A E V T C T  |
* |___________________|
*
* VCAEVTCT0    -  Video Port 0 Video Capture A Event Count
* VCAEVTCT1    -  Video Port 1 Video Capture A Event Count
* VCAEVTCT2    -  Video Port 2 Video Capture A Event Count
*
* FIELDS (msb -> lsb)
* (rw) CAPEVTCT2
* (rw) CAPEVTCT1
*
\******************************************************************************/
  #define _VP_VCAEVTCT_OFFSET           72
  #define _VP_VCAEVTCT_OFFSETA           8

  #define _VP_VCAEVTCT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCAEVTCT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAEVTCT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCAEVTCT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAEVTCT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCAEVTCT_OFFSET)
 #endif


  #define _VP_VCAEVTCT0_ADDRA   (_VP_BASE_CHAPORT0 + 4*_VP_VCAEVTCT_OFFSETA)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAEVTCT1_ADDRA   (_VP_BASE_CHAPORT1 + 4*_VP_VCAEVTCT_OFFSETA)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAEVTCT2_ADDRA   (_VP_BASE_CHAPORT2 + 4*_VP_VCAEVTCT_OFFSETA)
 #endif


  #define _VP_VCAEVTCT_CAPEVTCT2_MASK         0x0FFF0000u
  #define _VP_VCAEVTCT_CAPEVTCT2_SHIFT        0x00000010u
  #define  VP_VCAEVTCT_CAPEVTCT2_DEFAULT      0x00000000u
  #define  VP_VCAEVTCT_CAPEVTCT2_OF(x)        _VALUEOF(x)

  #define _VP_VCAEVTCT_CAPEVTCT1_MASK         0x00000FFFu
  #define _VP_VCAEVTCT_CAPEVTCT1_SHIFT        0x00000000u
  #define  VP_VCAEVTCT_CAPEVTCT1_DEFAULT      0x00000000u
  #define  VP_VCAEVTCT_CAPEVTCT1_OF(x)        _VALUEOF(x)

  #define  VP_VCAEVTCT_OF(x)            _VALUEOF(x)

  #define VP_VCAEVTCT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCAEVTCT,CAPEVTCT2)\
    |_PER_FDEFAULT(VP,VCAEVTCT,CAPEVTCT1)\
  )

  #define VP_VCAEVTCT_RMK(capevtct2,capevtct1) (Uint32)(\
     _PER_FMK(VP,VCAEVTCT,CAPEVTCT2,capevtct2)\
    |_PER_FMK(VP,VCAEVTCT,CAPEVTCT1,capevtct1)\
  )

  #define _VP_VCAEVTCT_FGET(N,FIELD)\
    _PER_FGET(_VP_VCAEVTCT##N##_ADDR,VP,VCAEVTCT,##FIELD)

  #define _VP_VCAEVTCT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCAEVTCT##N##_ADDR,VP,VCAEVTCT,##FIELD,field)

  #define _VP_VCAEVTCT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCAEVTCT##N##_ADDR,VP,VCAEVTCT,##FIELD,##SYM)

  #define _VP_VCAEVTCT0_FGET(FIELD)   _VP_VCAEVTCT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAEVTCT1_FGET(FIELD)   _VP_VCAEVTCT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAEVTCT2_FGET(FIELD)   _VP_VCAEVTCT_FGET(2,##FIELD)
 #endif


  #define _VP_VCAEVTCT0_FSET(FIELD,f)   _VP_VCAEVTCT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAEVTCT1_FSET(FIELD,f)   _VP_VCAEVTCT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAEVTCT2_FSET(FIELD,f)   _VP_VCAEVTCT_FSET(2,##FIELD,f)
 #endif


  #define _VP_VCAEVTCT0_FSETS(FIELD,SYM)   _VP_VCAEVTCT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VCAEVTCT1_FSETS(FIELD,SYM)   _VP_VCAEVTCT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VCAEVTCT2_FSETS(FIELD,SYM)   _VP_VCAEVTCT_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C B S T A T    |
* |___________________|
*
* VCBSTAT0 - Video Port 0 Video Capture B Status
* VCBSTAT1 - Video Port 1 Video Capture B Status
* VCBSTAT2 - Video Port 2 Video Capture B Status
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
*
* (r)  FSYNC
* (rc) FRMC
* (rc) F2C
* (rc) F1C
* (r)  VCYPOS
* (r)  VCFLD
* (r)  VCXPOS
*
\******************************************************************************/
#if (CHIP_DM642)
  #define _VP_VCBSTAT_OFFSET           80
  #define _VP_VCBSTAT_OFFSETB           0

  #define _VP_VCBSTAT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBSTAT_OFFSET)
  #define _VP_VCBSTAT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBSTAT_OFFSET)
  #define _VP_VCBSTAT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBSTAT_OFFSET)


  #define _VP_VCBSTAT0_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBSTAT_OFFSETB)
  #define _VP_VCBSTAT1_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBSTAT_OFFSETB)
  #define _VP_VCBSTAT2_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBSTAT_OFFSETB)

  #define _VP_VCBSTAT_FSYNC_MASK        0x80000000u
  #define _VP_VCBSTAT_FSYNC_SHIFT       0x0000001Fu
  #define  VP_VCBSTAT_FSYNC_DEFAULT     0x00000000u
  #define  VP_VCBSTAT_FSYNC_OF(x)       _VALUEOF(x)
  #define  VP_VCBSTAT_FSYNC_CLEARD      0x00000000u
  #define  VP_VCBSTAT_FSYNC_SET         0x00000001u

  #define _VP_VCBSTAT_FRMC_MASK        0x40000000u
  #define _VP_VCBSTAT_FRMC_SHIFT       0x0000001Eu
  #define  VP_VCBSTAT_FRMC_DEFAULT     0x00000000u
  #define  VP_VCBSTAT_FRMC_OF(x)       _VALUEOF(x)
  #define  VP_VCBSTAT_FRMC_NONE        0x00000000u
  #define  VP_VCBSTAT_FRMC_CAPTURED    0x00000001u
  #define  VP_VCBSTAT_FRMC_CLEAR       0x00000001u

  #define _VP_VCBSTAT_F2C_MASK        0x20000000u
  #define _VP_VCBSTAT_F2C_SHIFT       0x0000001Du
  #define  VP_VCBSTAT_F2C_DEFAULT     0x00000000u
  #define  VP_VCBSTAT_F2C_OF(x)       _VALUEOF(x)
  #define  VP_VCBSTAT_F2C_NONE        0x00000000u
  #define  VP_VCBSTAT_F2C_CAPTURED    0x00000001u
  #define  VP_VCBSTAT_F2C_CLEAR       0x00000001u

  #define _VP_VCBSTAT_F1C_MASK        0x10000000u
  #define _VP_VCBSTAT_F1C_SHIFT       0x0000001Cu
  #define  VP_VCBSTAT_F1C_DEFAULT     0x00000000u
  #define  VP_VCBSTAT_F1C_OF(x)       _VALUEOF(x)
  #define  VP_VCBSTAT_F1C_NONE        0x00000000u
  #define  VP_VCBSTAT_F1C_CAPTURED    0x00000001u
  #define  VP_VCBSTAT_F1C_CLEAR       0x00000001u

  #define _VP_VCBSTAT_VCYPOS_MASK        0x0FFF0000u
  #define _VP_VCBSTAT_VCYPOS_SHIFT       0x00000010u
  #define  VP_VCBSTAT_VCYPOS_DEFAULT     0x00000000u
  #define  VP_VCBSTAT_VCYPOS_OF(x)       _VALUEOF(x)

  #define _VP_VCBSTAT_VCFLD_MASK        0x00001000u
  #define _VP_VCBSTAT_VCFLD_SHIFT       0x0000000Cu
  #define  VP_VCBSTAT_VCFLD_DEFAULT     0x00000000u
  #define  VP_VCBSTAT_VCFLD_OF(x)       _VALUEOF(x)
  #define  VP_VCBSTAT_VCFLD_NONE        0x00000000u
  #define  VP_VCBSTAT_VCFLD_DETECTED    0x00000001u

  #define _VP_VCBSTAT_VCXPOS_MASK        0x00000FFFu
  #define _VP_VCBSTAT_VCXPOS_SHIFT       0x00000000u
  #define  VP_VCBSTAT_VCXPOS_DEFAULT     0x00000000u
  #define  VP_VCBSTAT_VCXPOS_OF(x)       _VALUEOF(x)


  #define  VP_VCBSTAT_OF(x)            _VALUEOF(x)

  #define VP_VCBSTAT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBSTAT,FSYNC)\
    |_PER_FDEFAULT(VP,VCBSTAT,FRMC)\
    |_PER_FDEFAULT(VP,VCBSTAT,F2C)\
    |_PER_FDEFAULT(VP,VCBSTAT,F1C)\
    |_PER_FDEFAULT(VP,VCBSTAT,VCYPOS)\
    |_PER_FDEFAULT(VP,VCBSTAT,VCFLD)\
    |_PER_FDEFAULT(VP,VCBSTAT,VCXPOS)\
  )

  #define VP_VCBSTAT_RMK(frmc,f2c,f1c) (Uint32)(\
     _PER_FMK(VP,VCBSTAT,FRMC,frmc)\
    |_PER_FMK(VP,VCBSTAT,F2C,f2c)\
    |_PER_FMK(VP,VCBSTAT,F1C,f1c)\
  )

  #define _VP_VCBSTAT_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBSTAT##N##_ADDR,VP,VCBSTAT,##FIELD)

  #define _VP_VCBSTAT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBSTAT##N##_ADDR,VP,VCBSTAT,##FIELD,field)

  #define _VP_VCBSTAT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBSTAT##N##_ADDR,VP,VCBSTAT,##FIELD,##SYM)

  #define _VP_VCBSTAT0_FGET(FIELD)   _VP_VCBSTAT_FGET(0,##FIELD)
  #define _VP_VCBSTAT1_FGET(FIELD)   _VP_VCBSTAT_FGET(1,##FIELD)
  #define _VP_VCBSTAT2_FGET(FIELD)   _VP_VCBSTAT_FGET(2,##FIELD)


  #define _VP_VCBSTAT0_FSET(FIELD,f)   _VP_VCBSTAT_FSET(0,##FIELD,f)
  #define _VP_VCBSTAT1_FSET(FIELD,f)   _VP_VCBSTAT_FSET(1,##FIELD,f)
  #define _VP_VCBSTAT2_FSET(FIELD,f)   _VP_VCBSTAT_FSET(2,##FIELD,f)

  #define _VP_VCBSTAT0_FSETS(FIELD,SYM)   _VP_VCBSTAT_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBSTAT1_FSETS(FIELD,SYM)   _VP_VCBSTAT_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBSTAT2_FSETS(FIELD,SYM)   _VP_VCBSTAT_FSETS(2,##FIELD,##SYM)
#endif

/******************************************************************************\
* _____________________
* |                   |
* |  V C B C T L      |
* |___________________|
*
* VCBCTL0 -  Video Port 0 Video Capture A Control
* VCBCTL1 -  Video Port 1 Video Capture A Control
* VCBCTL2 -  Video Port 2 Video Capture A Control
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
*
* (rw) RSTCH
* (rw) BLKCAP
* (rw) FINV
* (rw) VRST
* (rw) HRST
* (rw) VCEN
* (rw) 10BPK
* (rw) LFDE
* (rw) SFDE
* (rw) RESMPL
* (rw) SCALE
* (rw) CON
* (rw) FRAME
* (rw) CF2
* (rw) CF1
* (rw) CMODE
*
\******************************************************************************/
 #if (CHIP_DM642)
  #define _VP_VCBCTL_OFFSET           81
  #define _VP_VCBCTL_OFFSETB           1

  #define _VP_VCBCTL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBCTL_OFFSET)
  #define _VP_VCBCTL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBCTL_OFFSET)
  #define _VP_VCBCTL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBCTL_OFFSET)


  #define _VP_VCBCTL0_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBCTL_OFFSETB)
  #define _VP_VCBCTL1_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBCTL_OFFSETB)
  #define _VP_VCBCTL2_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBCTL_OFFSETB)


  #define _VP_VCBCTL_RSTCH_MASK        0x80000000u
  #define _VP_VCBCTL_RSTCH_SHIFT       0x0000001Fu
  #define  VP_VCBCTL_RSTCH_DEFAULT     0x00000000u
  #define  VP_VCBCTL_RSTCH_OF(x)       _VALUEOF(x)
  #define  VP_VCBCTL_RSTCH_NONE        0x00000000u
  #define  VP_VCBCTL_RSTCH_RESET       0x00000001u

  #define _VP_VCBCTL_BLKCAP_MASK         0x40000000u
  #define _VP_VCBCTL_BLKCAP_SHIFT        0x0000001Eu
  #define  VP_VCBCTL_BLKCAP_DEFAULT      0x00000001u
  #define  VP_VCBCTL_BLKCAP_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_BLKCAP_CLEAR        0x00000000u
  #define  VP_VCBCTL_BLKCAP_BLOCK        0x00000001u

  #define _VP_VCBCTL_FINV_MASK           0x00100000u
  #define _VP_VCBCTL_FINV_SHIFT          0x00000014u
  #define  VP_VCBCTL_FINV_DEFAULT        0x00000000u
  #define  VP_VCBCTL_FINV_OF(x)          _VALUEOF(x)
  #define  VP_VCBCTL_FINV_FIELD1         0x00000000u
  #define  VP_VCBCTL_FINV_FIELD2         0x00000001u

  #define _VP_VCBCTL_VRST_MASK           0x00020000u
  #define _VP_VCBCTL_VRST_SHIFT          0x00000011u
  #define  VP_VCBCTL_VRST_DEFAULT        0x00000001u
  #define  VP_VCBCTL_VRST_OF(x)          _VALUEOF(x)
  #define  VP_VCBCTL_VRST_V1EAV          0x00000000u
  #define  VP_VCBCTL_VRST_V0EAV          0x00000001u

  #define _VP_VCBCTL_HRST_MASK           0x00010000u
  #define _VP_VCBCTL_HRST_SHIFT          0x00000010u
  #define  VP_VCBCTL_HRST_DEFAULT        0x00000000u
  #define  VP_VCBCTL_HRST_OF(x)          _VALUEOF(x)
  #define  VP_VCBCTL_HRST_EAV            0x00000000u
  #define  VP_VCBCTL_HRST_SAV            0x00000001u

  #define _VP_VCBCTL_VCEN_MASK         0x00008000u
  #define _VP_VCBCTL_VCEN_SHIFT        0x0000000Fu
  #define  VP_VCBCTL_VCEN_DEFAULT      0x00000000u
  #define  VP_VCBCTL_VCEN_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_VCEN_DISABLE      0x00000000u
  #define  VP_VCBCTL_VCEN_ENABLE       0x00000001u

  #define _VP_VCBCTL_PK10B_MASK         0x00006000u
  #define _VP_VCBCTL_PK10B_SHIFT        0x0000000Du
  #define  VP_VCBCTL_PK10B_DEFAULT      0x00000000u
  #define  VP_VCBCTL_PK10B_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_PK10B_ZERO         0x00000000u
  #define  VP_VCBCTL_PK10B_SIGN         0x00000001u
  #define  VP_VCBCTL_PK10B_DENSEPK      0x00000002u

  #define _VP_VCBCTL_LFDE_MASK         0x00001000u
  #define _VP_VCBCTL_LFDE_SHIFT        0x0000000Cu
  #define  VP_VCBCTL_LFDE_DEFAULT      0x00000000u
  #define  VP_VCBCTL_LFDE_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_LFDE_DISABLE      0x00000000u
  #define  VP_VCBCTL_LFDE_ENABLE       0x00000001u

  #define _VP_VCBCTL_SFDE_MASK         0x00000800u
  #define _VP_VCBCTL_SFDE_SHIFT        0x0000000Bu
  #define  VP_VCBCTL_SFDE_DEFAULT      0x00000000u
  #define  VP_VCBCTL_SFDE_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_SFDE_DISABLE      0x00000000u
  #define  VP_VCBCTL_SFDE_ENABLE       0x00000001u

  #define _VP_VCBCTL_RESMPL_MASK         0x00000400u
  #define _VP_VCBCTL_RESMPL_SHIFT        0x0000000Au
  #define  VP_VCBCTL_RESMPL_DEFAULT      0x00000000u
  #define  VP_VCBCTL_RESMPL_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_RESMPL_DISABLE      0x00000000u
  #define  VP_VCBCTL_RESMPL_ENABLE       0x00000001u

  #define _VP_VCBCTL_SCALE_MASK         0x00000100u
  #define _VP_VCBCTL_SCALE_SHIFT        0x00000008u
  #define  VP_VCBCTL_SCALE_DEFAULT      0x00000000u
  #define  VP_VCBCTL_SCALE_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_SCALE_NONE         0x00000000u
  #define  VP_VCBCTL_SCALE_HALF         0x00000001u

  #define _VP_VCBCTL_CON_MASK         0x00000080u
  #define _VP_VCBCTL_CON_SHIFT        0x00000007u
  #define  VP_VCBCTL_CON_DEFAULT      0x00000000u
  #define  VP_VCBCTL_CON_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_CON_DISABLE      0x00000000u
  #define  VP_VCBCTL_CON_ENABLE        0x00000001u

  #define _VP_VCBCTL_FRAME_MASK         0x00000040u
  #define _VP_VCBCTL_FRAME_SHIFT        0x00000006u
  #define  VP_VCBCTL_FRAME_DEFAULT      0x00000000u
  #define  VP_VCBCTL_FRAME_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_FRAME_NONE         0x00000000u
  #define  VP_VCBCTL_FRAME_FRMCAP       0x00000001u

  #define _VP_VCBCTL_CF2_MASK         0x00000020u
  #define _VP_VCBCTL_CF2_SHIFT        0x00000005u
  #define  VP_VCBCTL_CF2_DEFAULT      0x00000001u
  #define  VP_VCBCTL_CF2_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_CF2_NONE         0x00000000u
  #define  VP_VCBCTL_CF2_FLDCAP       0x00000001u

  #define _VP_VCBCTL_CF1_MASK         0x00000010u
  #define _VP_VCBCTL_CF1_SHIFT        0x00000004u
  #define  VP_VCBCTL_CF1_DEFAULT      0x00000001u
  #define  VP_VCBCTL_CF1_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_CF1_NONE         0x00000000u
  #define  VP_VCBCTL_CF1_FLDCAP       0x00000001u

  #define _VP_VCBCTL_CMODE_MASK         0x00000003u
  #define _VP_VCBCTL_CMODE_SHIFT        0x00000000u
  #define  VP_VCBCTL_CMODE_DEFAULT      0x00000000u
  #define  VP_VCBCTL_CMODE_OF(x)        _VALUEOF(x)
  #define  VP_VCBCTL_CMODE_BT656B       0x00000000u
  #define  VP_VCBCTL_CMODE_BT656D       0x00000001u
  #define  VP_VCBCTL_CMODE_RAWB         0x00000002u
  #define  VP_VCBCTL_CMODE_RAWD         0x00000003u

  #define  VP_VCBCTL_OF(x)            _VALUEOF(x)

  #define VP_VCBCTL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBCTL,RSTCH)\
    |_PER_FDEFAULT(VP,VCBCTL,BLKCAP)\
    |_PER_FDEFAULT(VP,VCBCTL,FINV)\
    |_PER_FDEFAULT(VP,VCBCTL,VRST)\
    |_PER_FDEFAULT(VP,VCBCTL,HRST)\
    |_PER_FDEFAULT(VP,VCBCTL,VCEN)\
    |_PER_FDEFAULT(VP,VCBCTL,PK10B)\
    |_PER_FDEFAULT(VP,VCBCTL,LFDE)\
    |_PER_FDEFAULT(VP,VCBCTL,SFDE)\
    |_PER_FDEFAULT(VP,VCBCTL,RESMPL)\
    |_PER_FDEFAULT(VP,VCBCTL,SCALE)\
    |_PER_FDEFAULT(VP,VCBCTL,CON)\
    |_PER_FDEFAULT(VP,VCBCTL,FRAME)\
    |_PER_FDEFAULT(VP,VCBCTL,CF2)\
    |_PER_FDEFAULT(VP,VCBCTL,CF1)\
    |_PER_FDEFAULT(VP,VCBCTL,CMODE)\
  )

  #define VP_VCBCTL_RMK(rstch,blkcap,finv,vrst,hrst,\
    vcen,pk10b,lfde,sfde,resmpl,scale,con,frame,cf2,cf1,cmode) (Uint32)(\
     _PER_FMK(VP,VCBCTL,RSTCH,rstch)\
    |_PER_FMK(VP,VCBCTL,BLKCAP,blkcap)\
    |_PER_FMK(VP,VCBCTL,RDFE,rdfe)\
    |_PER_FMK(VP,VCBCTL,FINV,finv)\
    |_PER_FMK(VP,VCBCTL,FLDD,fldd)\
    |_PER_FMK(VP,VCBCTL,VRST,vrst)\
    |_PER_FMK(VP,VCBCTL,HRST,hrst)\
    |_PER_FMK(VP,VCBCTL,VCEN,vcen)\
    |_PER_FMK(VP,VCBCTL,PK10B,pk10b)\
    |_PER_FMK(VP,VCBCTL,LFDE,lfde)\
    |_PER_FMK(VP,VCBCTL,SFDE,sfde)\
    |_PER_FMK(VP,VCBCTL,RESMPL,resmpl)\
    |_PER_FMK(VP,VCBCTL,SCALE,scale)\
    |_PER_FMK(VP,VCBCTL,CON,con)\
    |_PER_FMK(VP,VCBCTL,FRAME,frame)\
    |_PER_FMK(VP,VCBCTL,CF2,cf2)\
    |_PER_FMK(VP,VCBCTL,CF1,cf1)\
    |_PER_FMK(VP,VCBCTL,CMODE,cmode)\
  )

  #define _VP_VCBCTL_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBCTL##N##_ADDR,VP,VCBCTL,##FIELD)

  #define _VP_VCBCTL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBCTL##N##_ADDR,VP,VCBCTL,##FIELD,field)

  #define _VP_VCBCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBCTL##N##_ADDR,VP,VCBCTL,##FIELD,##SYM)

  #define _VP_VCBCTL0_FGET(FIELD)   _VP_VCBCTL_FGET(0,##FIELD)
  #define _VP_VCBCTL1_FGET(FIELD)   _VP_VCBCTL_FGET(1,##FIELD)
  #define _VP_VCBCTL2_FGET(FIELD)   _VP_VCBCTL_FGET(2,##FIELD)


  #define _VP_VCBCTL0_FSET(FIELD,f)   _VP_VCBCTL_FSET(0,##FIELD,f)
  #define _VP_VCBCTL1_FSET(FIELD,f)   _VP_VCBCTL_FSET(1,##FIELD,f)
  #define _VP_VCBCTL2_FSET(FIELD,f)   _VP_VCBCTL_FSET(2,##FIELD,f)

  #define _VP_VCBCTL0_FSETS(FIELD,SYM)   _VP_VCBCTL_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBCTL1_FSETS(FIELD,SYM)   _VP_VCBCTL_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBCTL2_FSETS(FIELD,SYM)   _VP_VCBCTL_FSETS(2,##FIELD,##SYM)
 #endif

/******************************************************************************\
* _____________________
* |                   |
* |  V C B S T R T 1  |
* |___________________|
*
* VCBSTRT10 -  Video Port 0 Video Capture B Field1 Start
* VCBSTRT11 -  Video Port 1 Video Capture B Field1 Start
* VCBSTRT12 -  Video Port 2 Video Capture B Field1 Start
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
* (rw) VCYSTART
* (rw) SSE
* (rw) VCXSTART/VCVBLNKP
*
\******************************************************************************/
 #if (CHIP_DM642)
  #define _VP_VCBSTRT1_OFFSET           82
  #define _VP_VCBSTRT1_OFFSETB           2

  #define _VP_VCBSTRT10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBSTRT1_OFFSET)
  #define _VP_VCBSTRT11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBSTRT1_OFFSET)
  #define _VP_VCBSTRT12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBSTRT1_OFFSET)

  #define _VP_VCBSTRT10_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBSTRT1_OFFSETB)
  #define _VP_VCBSTRT11_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBSTRT1_OFFSETB)
  #define _VP_VCBSTRT12_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBSTRT1_OFFSETB)

  #define _VP_VCBSTRT1_VCYSTART_MASK        0x0FFF0000u
  #define _VP_VCBSTRT1_VCYSTART_SHIFT       0x00000010u
  #define  VP_VCBSTRT1_VCYSTART_DEFAULT     0x00000000u
  #define  VP_VCBSTRT1_VCYSTART_OF(x)       _VALUEOF(x)

  #define _VP_VCBSTRT1_SSE_MASK             0x00008000u
  #define _VP_VCBSTRT1_SSE_SHIFT            0x0000000Fu
  #define  VP_VCBSTRT1_SSE_DEFAULT          0x00000001u
  #define  VP_VCBSTRT1_SSE_OF(x)            _VALUEOF(x)
  #define  VP_VCBSTRT1_SSE_DISABLE          0x00000000u
  #define  VP_VCBSTRT1_SSE_ENABLE           0x00000001u

  #define _VP_VCBSTRT1_VCXSTART_MASK        0x00000FFFu
  #define _VP_VCBSTRT1_VCXSTART_SHIFT       0x00000000u
  #define  VP_VCBSTRT1_VCXSTART_DEFAULT     0x00000000u
  #define  VP_VCBSTRT1_VCXSTART_OF(x)       _VALUEOF(x)

  #define _VP_VCBSTRT1_VCVBLNKP_MASK        0x00000FFFu
  #define _VP_VCBSTRT1_VCVBLNKP_SHIFT       0x00000000u
  #define  VP_VCBSTRT1_VCVBLNKP_DEFAULT     0x00000000u
  #define  VP_VCBSTRT1_VCVBLNKP_OF(x)       _VALUEOF(x)

  #define  VP_VCBSTRT1_OF(x)            _VALUEOF(x)

  #define VP_VCBSTRT1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBSTRT1,VCYSTART)\
    |_PER_FDEFAULT(VP,VCBSTRT1,SSE)\
    |_PER_FDEFAULT(VP,VCBSTRT1,VCXSTART)\
  )

  #define VP_VCBSTRT1_RMK(vcystart,sse,vcxstart) (Uint32)(\
     _PER_FMK(VP,VCBSTRT1,VCYSTART,vcystart)\
    |_PER_FMK(VP,VCBSTRT1,SSE,sse)\
    |_PER_FMK(VP,VCBSTRT1,VCXSTART,vcxstart)\
  )

  #define _VP_VCBSTRT1_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBSTRT1##N##_ADDR,VP,VCBSTRT1,##FIELD)

  #define _VP_VCBSTRT1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBSTRT1##N##_ADDR,VP,VCBSTRT1,##FIELD,field)

  #define _VP_VCBSTRT1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBSTRT1##N##_ADDR,VP,VCBSTRT1,##FIELD,##SYM)

  #define _VP_VCBSTRT10_FGET(FIELD)   _VP_VCBSTRT1_FGET(0,##FIELD)
  #define _VP_VCBSTRT11_FGET(FIELD)   _VP_VCBSTRT1_FGET(1,##FIELD)
  #define _VP_VCBSTRT12_FGET(FIELD)   _VP_VCBSTRT1_FGET(2,##FIELD)

  #define _VP_VCBSTRT10_FSET(FIELD,f)   _VP_VCBSTRT1_FSET(0,##FIELD,f)
  #define _VP_VCBSTRT11_FSET(FIELD,f)   _VP_VCBSTRT1_FSET(1,##FIELD,f)
  #define _VP_VCBSTRT12_FSET(FIELD,f)   _VP_VCBSTRT1_FSET(2,##FIELD,f)

  #define _VP_VCBSTRT10_FSETS(FIELD,SYM)   _VP_VCBSTRT1_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBSTRT11_FSETS(FIELD,SYM)   _VP_VCBSTRT1_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBSTRT12_FSETS(FIELD,SYM)   _VP_VCBSTRT1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C B S T O P 1  |
* |___________________|
*
* VCBSTOP10 -  Video Port 0 Video Capture B Field1 Stop
* VCBSTOP11 -  Video Port 1 Video Capture B Field1 Stop
* VCBSTOP12 -  Video Port 2 Video Capture B Field1 Stop
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
* (rw) VCYSTOP
* (rw) VCXSTOP
*
\******************************************************************************/
 #if (CHIP_DM642)
  #define _VP_VCBSTOP1_OFFSET           83
  #define _VP_VCBSTOP1_OFFSETB           3

  #define _VP_VCBSTOP10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBSTOP1_OFFSET)
  #define _VP_VCBSTOP11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBSTOP1_OFFSET)
  #define _VP_VCBSTOP12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBSTOP1_OFFSET)

  #define _VP_VCBSTOP10_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBSTOP1_OFFSETB)
  #define _VP_VCBSTOP11_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBSTOP1_OFFSETB)
  #define _VP_VCBSTOP12_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBSTOP1_OFFSETB)

  #define _VP_VCBSTOP1_VCYSTOP_MASK        0x0FFF0000u
  #define _VP_VCBSTOP1_VCYSTOP_SHIFT       0x00000010u
  #define  VP_VCBSTOP1_VCYSTOP_DEFAULT     0x00000000u
  #define  VP_VCBSTOP1_VCYSTOP_OF(x)       _VALUEOF(x)

  #define _VP_VCBSTOP1_VCXSTOP_MASK        0x00000FFFu
  #define _VP_VCBSTOP1_VCXSTOP_SHIFT       0x00000000u
  #define  VP_VCBSTOP1_VCXSTOP_DEFAULT     0x00000000u
  #define  VP_VCBSTOP1_VCXSTOP_OF(x)       _VALUEOF(x)

  #define  VP_VCBSTOP1_OF(x)            _VALUEOF(x)

  #define VP_VCBSTOP1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBSTOP1,VCYSTOP)\
    |_PER_FDEFAULT(VP,VCBSTOP1,VCXSTOP)\
  )

  #define VP_VCBSTOP1_RMK(vcystop,vcxstop) (Uint32)(\
     _PER_FMK(VP,VCBSTOP1,VCYSTOP,vcystop)\
    |_PER_FMK(VP,VCBSTOP1,VCXSTOP,vcxstop)\
  )

  #define _VP_VCBSTOP1_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBSTOP1##N##_ADDR,VP,VCBSTOP1,##FIELD)

  #define _VP_VCBSTOP1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBSTOP1##N##_ADDR,VP,VCBSTOP1,##FIELD,field)

  #define _VP_VCBSTOP1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBSTOP1##N##_ADDR,VP,VCBSTOP1,##FIELD,##SYM)

  #define _VP_VCBSTOP10_FGET(FIELD)   _VP_VCBSTOP1_FGET(0,##FIELD)
  #define _VP_VCBSTOP11_FGET(FIELD)   _VP_VCBSTOP1_FGET(1,##FIELD)
  #define _VP_VCBSTOP12_FGET(FIELD)   _VP_VCBSTOP1_FGET(2,##FIELD)

  #define _VP_VCBSTOP10_FSET(FIELD,f)   _VP_VCBSTOP1_FSET(0,##FIELD,f)
  #define _VP_VCBSTOP11_FSET(FIELD,f)   _VP_VCBSTOP1_FSET(1,##FIELD,f)
  #define _VP_VCBSTOP12_FSET(FIELD,f)   _VP_VCBSTOP1_FSET(2,##FIELD,f)

  #define _VP_VCBSTOP10_FSETS(FIELD,SYM)   _VP_VCBSTOP1_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBSTOP11_FSETS(FIELD,SYM)   _VP_VCBSTOP1_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBSTOP12_FSETS(FIELD,SYM)   _VP_VCBSTOP1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C B S T R T 2  |
* |___________________|
*
* VCBSTRT20 -  Video Port 0 Video Capture B Field2 Start
* VCBSTRT21 -  Video Port 1 Video Capture B Field2 Start
* VCBSTRT22 -  Video Port 2 Video Capture B Field2 Start
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
* (rw) VCYSTART
* (rw) VCXSTART
*
\******************************************************************************/
 #if (CHIP_DM642)
  #define _VP_VCBSTRT2_OFFSET           84
  #define _VP_VCBSTRT2_OFFSETB           4

  #define _VP_VCBSTRT20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBSTRT2_OFFSET)
  #define _VP_VCBSTRT21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBSTRT2_OFFSET)
  #define _VP_VCBSTRT22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBSTRT2_OFFSET)

  #define _VP_VCBSTRT20_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBSTRT2_OFFSETB)
  #define _VP_VCBSTRT21_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBSTRT2_OFFSETB)
  #define _VP_VCBSTRT22_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBSTRT2_OFFSETB)

  #define _VP_VCBSTRT2_VCYSTART_MASK        0x0FFF0000u
  #define _VP_VCBSTRT2_VCYSTART_SHIFT       0x00000010u
  #define  VP_VCBSTRT2_VCYSTART_DEFAULT     0x00000000u
  #define  VP_VCBSTRT2_VCYSTART_OF(x)       _VALUEOF(x)

  #define _VP_VCBSTRT2_VCXSTART_MASK        0x00000FFFu
  #define _VP_VCBSTRT2_VCXSTART_SHIFT       0x00000000u
  #define  VP_VCBSTRT2_VCXSTART_DEFAULT     0x00000000u
  #define  VP_VCBSTRT2_VCXSTART_OF(x)       _VALUEOF(x)

  #define  VP_VCBSTRT2_OF(x)            _VALUEOF(x)

  #define VP_VCBSTRT2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBSTRT2,VCYSTART)\
    |_PER_FDEFAULT(VP,VCBSTRT2,VCXSTART)\
  )

  #define VP_VCBSTRT2_RMK(vcystart,vcxstart) (Uint32)(\
     _PER_FMK(VP,VCBSTRT2,VCYSTART,vcystart)\
    |_PER_FMK(VP,VCBSTRT2,VCXSTART,vcxstart)\
  )

  #define _VP_VCBSTRT2_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBSTRT2##N##_ADDR,VP,VCBSTRT2,##FIELD)

  #define _VP_VCBSTRT2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBSTRT2##N##_ADDR,VP,VCBSTRT2,##FIELD,field)

  #define _VP_VCBSTRT2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBSTRT2##N##_ADDR,VP,VCBSTRT2,##FIELD,##SYM)

  #define _VP_VCBSTRT20_FGET(FIELD)   _VP_VCBSTRT2_FGET(0,##FIELD)
  #define _VP_VCBSTRT21_FGET(FIELD)   _VP_VCBSTRT2_FGET(1,##FIELD)
  #define _VP_VCBSTRT22_FGET(FIELD)   _VP_VCBSTRT2_FGET(2,##FIELD)

  #define _VP_VCBSTRT20_FSET(FIELD,f)   _VP_VCBSTRT2_FSET(0,##FIELD,f)
  #define _VP_VCBSTRT21_FSET(FIELD,f)   _VP_VCBSTRT2_FSET(1,##FIELD,f)
  #define _VP_VCBSTRT22_FSET(FIELD,f)   _VP_VCBSTRT2_FSET(2,##FIELD,f)

  #define _VP_VCBSTRT20_FSETS(FIELD,SYM)   _VP_VCBSTRT2_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBSTRT21_FSETS(FIELD,SYM)   _VP_VCBSTRT2_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBSTRT22_FSETS(FIELD,SYM)   _VP_VCBSTRT2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C B S T O P 2  |
* |___________________|
*
* VCBSTOP20 -  Video Port 0 Video Capture B Field2 Stop
* VCBSTOP21 -  Video Port 1 Video Capture B Field2 Stop
* VCBSTOP22 -  Video Port 2 Video Capture B Field2 Stop
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
* (rw) VCYSTOP
* (rw) VCXSTOP
*
\******************************************************************************/
 #if (CHIP_DM642)
  #define _VP_VCBSTOP2_OFFSET           85
  #define _VP_VCBSTOP2_OFFSETB           5

  #define _VP_VCBSTOP20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBSTOP2_OFFSET)
  #define _VP_VCBSTOP21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBSTOP2_OFFSET)
  #define _VP_VCBSTOP22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBSTOP2_OFFSET)

  #define _VP_VCBSTOP20_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBSTOP2_OFFSETB)
  #define _VP_VCBSTOP21_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBSTOP2_OFFSETB)
  #define _VP_VCBSTOP22_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBSTOP2_OFFSETB)

  #define _VP_VCBSTOP2_VCYSTOP_MASK        0x0FFF0000u
  #define _VP_VCBSTOP2_VCYSTOP_SHIFT       0x00000010u
  #define  VP_VCBSTOP2_VCYSTOP_DEFAULT     0x00000000u
  #define  VP_VCBSTOP2_VCYSTOP_OF(x)       _VALUEOF(x)

  #define _VP_VCBSTOP2_VCXSTOP_MASK        0x00000FFFu
  #define _VP_VCBSTOP2_VCXSTOP_SHIFT       0x00000000u
  #define  VP_VCBSTOP2_VCXSTOP_DEFAULT     0x00000000u
  #define  VP_VCBSTOP2_VCXSTOP_OF(x)       _VALUEOF(x)

  #define  VP_VCBSTOP2_OF(x)            _VALUEOF(x)

  #define VP_VCBSTOP2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBSTOP2,VCYSTOP)\
    |_PER_FDEFAULT(VP,VCBSTOP2,VCXSTOP)\
  )

  #define VP_VCBSTOP2_RMK(vcystop,vcxstop) (Uint32)(\
     _PER_FMK(VP,VCBSTOP2,VCYSTOP,vcystop)\
    |_PER_FMK(VP,VCBSTOP2,VCXSTOP,vcxstop)\
  )

  #define _VP_VCBSTOP2_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBSTOP2##N##_ADDR,VP,VCBSTOP2,##FIELD)

  #define _VP_VCBSTOP2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBSTOP2##N##_ADDR,VP,VCBSTOP2,##FIELD,field)

  #define _VP_VCBSTOP2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBSTOP2##N##_ADDR,VP,VCBSTOP2,##FIELD,##SYM)

  #define _VP_VCBSTOP20_FGET(FIELD)   _VP_VCBSTOP2_FGET(0,##FIELD)
  #define _VP_VCBSTOP21_FGET(FIELD)   _VP_VCBSTOP2_FGET(1,##FIELD)
  #define _VP_VCBSTOP22_FGET(FIELD)   _VP_VCBSTOP2_FGET(2,##FIELD)

  #define _VP_VCBSTOP20_FSET(FIELD,f)   _VP_VCBSTOP2_FSET(0,##FIELD,f)
  #define _VP_VCBSTOP21_FSET(FIELD,f)   _VP_VCBSTOP2_FSET(1,##FIELD,f)
  #define _VP_VCBSTOP22_FSET(FIELD,f)   _VP_VCBSTOP2_FSET(2,##FIELD,f)

  #define _VP_VCBSTOP20_FSETS(FIELD,SYM)   _VP_VCBSTOP2_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBSTOP21_FSETS(FIELD,SYM)   _VP_VCBSTOP2_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBSTOP22_FSETS(FIELD,SYM)   _VP_VCBSTOP2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V C B V I N T    |
* |___________________|
*
* VCBVINT0 -  Video Port 0 Video Capture B Vertical Interrupt
* VCBVINT1 -  Video Port 1 Video Capture B Vertical Interrupt
* VCBVINT2 -  Video Port 2 Video Capture B Vertical Interrupt
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
* (rw) VIF2 
* (rw) FSCL2
* (rw) VINT2
* (rw) VIF1 
* (rw) VINT1
*
\******************************************************************************/
 #if (CHIP_DM642)
  #define _VP_VCBVINT_OFFSET           86
  #define _VP_VCBVINT_OFFSETB           6

  #define _VP_VCBVINT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBVINT_OFFSET)
  #define _VP_VCBVINT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBVINT_OFFSET)
  #define _VP_VCBVINT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBVINT_OFFSET)

  #define _VP_VCBVINT0_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBVINT_OFFSETB)
  #define _VP_VCBVINT1_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBVINT_OFFSETB)
  #define _VP_VCBVINT2_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBVINT_OFFSETB)

  #define _VP_VCBVINT_VIF2_MASK        0x80000000u
  #define _VP_VCBVINT_VIF2_SHIFT       0x0000001Fu
  #define  VP_VCBVINT_VIF2_DEFAULT     0x00000000u
  #define  VP_VCBVINT_VIF2_OF(x)       _VALUEOF(x)
  #define  VP_VCBVINT_VIF2_DISABLE     0x00000000u
  #define  VP_VCBVINT_VIF2_ENABLE      0x00000001u

  #define _VP_VCBVINT_FSCL2_MASK         0x40000000u
  #define _VP_VCBVINT_FSCL2_SHIFT        0x0000001Eu
  #define  VP_VCBVINT_FSCL2_DEFAULT      0x00000000u
  #define  VP_VCBVINT_FSCL2_OF(x)        _VALUEOF(x)
  #define  VP_VCBVINT_FSCL2_NONE         0x00000000u
  #define  VP_VCBVINT_FSCL2_FIELD2       0x00000001u

  #define _VP_VCBVINT_VINT2_MASK         0x0FFF0000u
  #define _VP_VCBVINT_VINT2_SHIFT        0x00000010u
  #define  VP_VCBVINT_VINT2_DEFAULT      0x00000000u
  #define  VP_VCBVINT_VINT2_OF(x)        _VALUEOF(x)

  #define _VP_VCBVINT_VIF1_MASK        0x00008000u
  #define _VP_VCBVINT_VIF1_SHIFT       0x0000000Fu
  #define  VP_VCBVINT_VIF1_DEFAULT     0x00000000u
  #define  VP_VCBVINT_VIF1_OF(x)       _VALUEOF(x)
  #define  VP_VCBVINT_VIF1_DISABLE     0x00000000u
  #define  VP_VCBVINT_VIF1_ENABLE      0x00000001u

  #define _VP_VCBVINT_VINT1_MASK         0x00000FFFu
  #define _VP_VCBVINT_VINT1_SHIFT        0x00000000u
  #define  VP_VCBVINT_VINT1_DEFAULT      0x00000000u
  #define  VP_VCBVINT_VINT1_OF(x)        _VALUEOF(x)

  #define  VP_VCBVINT_OF(x)            _VALUEOF(x)

  #define VP_VCBVINT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBVINT,VIF2)\
    |_PER_FDEFAULT(VP,VCBVINT,FSCL2)\
    |_PER_FDEFAULT(VP,VCBVINT,VINT2)\
    |_PER_FDEFAULT(VP,VCBVINT,VIF1)\
    |_PER_FDEFAULT(VP,VCBVINT,VINT1)\
  )

  #define VP_VCBVINT_RMK(vif2,fscl2,vint2,vif1,vint1) (Uint32)(\
     _PER_FMK(VP,VCBVINT,VIF2,vif2)\
    |_PER_FMK(VP,VCBVINT,FSCL2,fscl2)\
    |_PER_FMK(VP,VCBVINT,VINT2,vint2)\
    |_PER_FMK(VP,VCBVINT,VIF1,vif1)\
    |_PER_FMK(VP,VCBVINT,VINT1,vint1)\
  )

  #define _VP_VCBVINT_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBVINT##N##_ADDR,VP,VCBVINT,##FIELD)

  #define _VP_VCBVINT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBVINT##N##_ADDR,VP,VCBVINT,##FIELD,field)

  #define _VP_VCBVINT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBVINT##N##_ADDR,VP,VCBVINT,##FIELD,##SYM)

  #define _VP_VCBVINT0_FGET(FIELD)   _VP_VCBVINT_FGET(0,##FIELD)
  #define _VP_VCBVINT1_FGET(FIELD)   _VP_VCBVINT_FGET(1,##FIELD)
  #define _VP_VCBVINT2_FGET(FIELD)   _VP_VCBVINT_FGET(2,##FIELD)

  #define _VP_VCBVINT0_FSET(FIELD,f)   _VP_VCBVINT_FSET(0,##FIELD,f)
  #define _VP_VCBVINT1_FSET(FIELD,f)   _VP_VCBVINT_FSET(1,##FIELD,f)
  #define _VP_VCBVINT2_FSET(FIELD,f)   _VP_VCBVINT_FSET(2,##FIELD,f)

  #define _VP_VCBVINT0_FSETS(FIELD,SYM)   _VP_VCBVINT_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBVINT1_FSETS(FIELD,SYM)   _VP_VCBVINT_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBVINT2_FSETS(FIELD,SYM)   _VP_VCBVINT_FSETS(2,##FIELD,##SYM)
 #endif

/******************************************************************************\
* _____________________
* |                   |
* |  V C B T H R L D  |
* |___________________|
*
* VCBTHRLD0    -  Video Port 0 Video Capture B Threshold
* VCBTHRLD1    -  Video Port 1 Video Capture B Threshold
* VCBTHRLD2    -  Video Port 2 Video Capture B Threshold
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
* (rw) VCTHRLD2
* (rw) VCTHRLD1
*
\******************************************************************************/
 #if (CHIP_DM642)
  #define _VP_VCBTHRLD_OFFSET           87
  #define _VP_VCBTHRLD_OFFSETB           7

  #define _VP_VCBTHRLD0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBTHRLD_OFFSET)
  #define _VP_VCBTHRLD1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBTHRLD_OFFSET)
  #define _VP_VCBTHRLD2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBTHRLD_OFFSET)

  #define _VP_VCBTHRLD0_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBTHRLD_OFFSETB)
  #define _VP_VCBTHRLD1_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBTHRLD_OFFSETB)
  #define _VP_VCBTHRLD2_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBTHRLD_OFFSETB)

  #define _VP_VCBTHRLD_VCTHRLD2_MASK         0x03FF0000u
  #define _VP_VCBTHRLD_VCTHRLD2_SHIFT        0x00000010u
  #define  VP_VCBTHRLD_VCTHRLD2_DEFAULT      0x00000000u
  #define  VP_VCBTHRLD_VCTHRLD2_OF(x)        _VALUEOF(x)

  #define _VP_VCBTHRLD_VCTHRLD1_MASK         0x000003FFu
  #define _VP_VCBTHRLD_VCTHRLD1_SHIFT        0x00000000u
  #define  VP_VCBTHRLD_VCTHRLD1_DEFAULT      0x00000000u
  #define  VP_VCBTHRLD_VCTHRLD1_OF(x)        _VALUEOF(x)

  #define  VP_VCBTHRLD_OF(x)            _VALUEOF(x)

  #define VP_VCBTHRLD_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBTHRLD,VCTHRLD2)\
    |_PER_FDEFAULT(VP,VCBTHRLD,VCTHRLD1)\
  )

  #define VP_VCBTHRLD_RMK(vcthrld2,vcthrld1) (Uint32)(\
     _PER_FMK(VP,VCBTHRLD,VCTHRLD2,vcthrld2)\
    |_PER_FMK(VP,VCBTHRLD,VCTHRLD1,vcthrld1)\
  )

  #define _VP_VCBTHRLD_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBTHRLD##N##_ADDR,VP,VCBTHRLD,##FIELD)

  #define _VP_VCBTHRLD_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBTHRLD##N##_ADDR,VP,VCBTHRLD,##FIELD,field)

  #define _VP_VCBTHRLD_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBTHRLD##N##_ADDR,VP,VCBTHRLD,##FIELD,##SYM)

  #define _VP_VCBTHRLD0_FGET(FIELD)   _VP_VCBTHRLD_FGET(0,##FIELD)
  #define _VP_VCBTHRLD1_FGET(FIELD)   _VP_VCBTHRLD_FGET(1,##FIELD)
  #define _VP_VCBTHRLD2_FGET(FIELD)   _VP_VCBTHRLD_FGET(2,##FIELD)

  #define _VP_VCBTHRLD0_FSET(FIELD,f)   _VP_VCBTHRLD_FSET(0,##FIELD,f)
  #define _VP_VCBTHRLD1_FSET(FIELD,f)   _VP_VCBTHRLD_FSET(1,##FIELD,f)
  #define _VP_VCBTHRLD2_FSET(FIELD,f)   _VP_VCBTHRLD_FSET(2,##FIELD,f)

  #define _VP_VCBTHRLD0_FSETS(FIELD,SYM)   _VP_VCBTHRLD_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBTHRLD1_FSETS(FIELD,SYM)   _VP_VCBTHRLD_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBTHRLD2_FSETS(FIELD,SYM)   _VP_VCBTHRLD_FSETS(2,##FIELD,##SYM)
 #endif

/******************************************************************************\
* _____________________
* |                   |
* |  V C B E V T C T  |
* |___________________|
*
* VCBEVTCT0    -  Video Port 0 Video Capture B Event Count
* VCBEVTCT1    -  Video Port 1 Video Capture B Event Count
* VCBEVTCT2    -  Video Port 2 Video Capture B Event Count
*
* Defined only for DM642
*
* FIELDS (msb -> lsb)
* (rw) CAPEVTCT2
* (rw) CAPEVTCT1
*
\******************************************************************************/
 #if (CHIP_DM642)
  #define _VP_VCBEVTCT_OFFSET           88
  #define _VP_VCBEVTCT_OFFSETB           8

  #define _VP_VCBEVTCT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VCBEVTCT_OFFSET)
  #define _VP_VCBEVTCT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VCBEVTCT_OFFSET)
  #define _VP_VCBEVTCT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VCBEVTCT_OFFSET)

  #define _VP_VCBEVTCT0_ADDRB   (_VP_BASE_CHBPORT0 + 4*_VP_VCBEVTCT_OFFSETB)
  #define _VP_VCBEVTCT1_ADDRB   (_VP_BASE_CHBPORT1 + 4*_VP_VCBEVTCT_OFFSETB)
  #define _VP_VCBEVTCT2_ADDRB   (_VP_BASE_CHBPORT2 + 4*_VP_VCBEVTCT_OFFSETB)

  #define _VP_VCBEVTCT_CAPEVTCT2_MASK         0x0FFF0000u
  #define _VP_VCBEVTCT_CAPEVTCT2_SHIFT        0x00000010u
  #define  VP_VCBEVTCT_CAPEVTCT2_DEFAULT      0x00000000u
  #define  VP_VCBEVTCT_CAPEVTCT2_OF(x)        _VALUEOF(x)

  #define _VP_VCBEVTCT_CAPEVTCT1_MASK         0x00000FFFu
  #define _VP_VCBEVTCT_CAPEVTCT1_SHIFT        0x00000000u
  #define  VP_VCBEVTCT_CAPEVTCT1_DEFAULT      0x00000000u
  #define  VP_VCBEVTCT_CAPEVTCT1_OF(x)        _VALUEOF(x)

  #define  VP_VCBEVTCT_OF(x)            _VALUEOF(x)

  #define VP_VCBEVTCT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VCBEVTCT,CAPEVTCT2)\
    |_PER_FDEFAULT(VP,VCBEVTCT,CAPEVTCT1)\
  )

  #define VP_VCBEVTCT_RMK(capevtct2,capevtct1) (Uint32)(\
     _PER_FMK(VP,VCBEVTCT,CAPEVTCT2,capevtct2)\
    |_PER_FMK(VP,VCBEVTCT,CAPEVTCT1,capevtct1)\
  )

  #define _VP_VCBEVTCT_FGET(N,FIELD)\
    _PER_FGET(_VP_VCBEVTCT##N##_ADDR,VP,VCBEVTCT,##FIELD)

  #define _VP_VCBEVTCT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VCBEVTCT##N##_ADDR,VP,VCBEVTCT,##FIELD,field)

  #define _VP_VCBEVTCT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VCBEVTCT##N##_ADDR,VP,VCBEVTCT,##FIELD,##SYM)

  #define _VP_VCBEVTCT0_FGET(FIELD)   _VP_VCBEVTCT_FGET(0,##FIELD)
  #define _VP_VCBEVTCT1_FGET(FIELD)   _VP_VCBEVTCT_FGET(1,##FIELD)
  #define _VP_VCBEVTCT2_FGET(FIELD)   _VP_VCBEVTCT_FGET(2,##FIELD)

  #define _VP_VCBEVTCT0_FSET(FIELD,f)   _VP_VCBEVTCT_FSET(0,##FIELD,f)
  #define _VP_VCBEVTCT1_FSET(FIELD,f)   _VP_VCBEVTCT_FSET(1,##FIELD,f)
  #define _VP_VCBEVTCT2_FSET(FIELD,f)   _VP_VCBEVTCT_FSET(2,##FIELD,f)

  #define _VP_VCBEVTCT0_FSETS(FIELD,SYM)   _VP_VCBEVTCT_FSETS(0,##FIELD,##SYM)
  #define _VP_VCBEVTCT1_FSETS(FIELD,SYM)   _VP_VCBEVTCT_FSETS(1,##FIELD,##SYM)
  #define _VP_VCBEVTCT2_FSETS(FIELD,SYM)   _VP_VCBEVTCT_FSETS(2,##FIELD,##SYM)
 #endif

/******************************************************************************\
* _____________________
* |                   |
* |  T S I C T L      |
* |___________________|
*
* TSICTL0 -  Video Port 0 Transport Stream Interface Capture Control
* TSICTL1 -  Video Port 1 Transport Stream Interface Capture Control
* TSICTL2 -  Video Port 2 Transport Stream Interface Capture Control
*
* FIELDS (msb -> lsb)
* (rw) ENSTC
* (rw) TCKEN
* (rw) STEN
* (rw) CTMODE
* (rw) ERRFILT
*
\******************************************************************************/
  #define _VP_TSICTL_OFFSET           96

  #define _VP_TSICTL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSICTL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICTL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSICTL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICTL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSICTL_OFFSET)
 #endif


  #define _VP_TSICTL_ENSTC_MASK        0x00000020u
  #define _VP_TSICTL_ENSTC_SHIFT       0x00000005u
  #define  VP_TSICTL_ENSTC_DEFAULT     0x00000000u
  #define  VP_TSICTL_ENSTC_OF(x)       _VALUEOF(x)
  #define  VP_TSICTL_ENSTC_HALTED      0x00000000u
  #define  VP_TSICTL_ENSTC_CLKED       0x00000001u

  #define _VP_TSICTL_TCKEN_MASK        0x00000010u
  #define _VP_TSICTL_TCKEN_SHIFT       0x00000004u
  #define  VP_TSICTL_TCKEN_DEFAULT     0x00000000u
  #define  VP_TSICTL_TCKEN_OF(x)       _VALUEOF(x)
  #define  VP_TSICTL_TCKEN_DISABLE     0x00000000u
  #define  VP_TSICTL_TCKEN_SET         0x00000001u

  #define _VP_TSICTL_STEN_MASK        0x00000008u
  #define _VP_TSICTL_STEN_SHIFT       0x00000003u
  #define  VP_TSICTL_STEN_DEFAULT     0x00000000u
  #define  VP_TSICTL_STEN_OF(x)       _VALUEOF(x)
  #define  VP_TSICTL_STEN_DISABLE     0x00000000u
  #define  VP_TSICTL_STEN_SET         0x00000001u

  #define _VP_TSICTL_CTMODE_MASK        0x00000004u
  #define _VP_TSICTL_CTMODE_SHIFT       0x00000002u
  #define  VP_TSICTL_CTMODE_DEFAULT     0x00000000u
  #define  VP_TSICTL_CTMODE_OF(x)       _VALUEOF(x)
  #define  VP_TSICTL_CTMODE_90KHZ       0x00000000u
  #define  VP_TSICTL_CTMODE_STCLK       0x00000001u

  #define _VP_TSICTL_ERRFILT_MASK        0x00000002u
  #define _VP_TSICTL_ERRFILT_SHIFT       0x00000001u
  #define  VP_TSICTL_ERRFILT_DEFAULT     0x00000000u
  #define  VP_TSICTL_ERRFILT_OF(x)       _VALUEOF(x)
  #define  VP_TSICTL_ERRFILT_ACCEPT      0x00000000u
  #define  VP_TSICTL_ERRFILT_REJECT      0x00000001u

  #define  VP_TSICTL_OF(x)            _VALUEOF(x)

  #define VP_TSICTL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSICTL,ENSTC)\
    |_PER_FDEFAULT(VP,TSICTL,TCKEN)\
    |_PER_FDEFAULT(VP,TSICTL,STEN)\
    |_PER_FDEFAULT(VP,TSICTL,CTMODE)\
    |_PER_FDEFAULT(VP,TSICTL,ERRFILT)\
  )

  #define VP_TSICTL_RMK(enstc,tcken,sten,ctmode,errfilt) (Uint32)(\
     _PER_FMK(VP,TSICTL,ENSTC,enstc)\
    |_PER_FMK(VP,TSICTL,TCKEN,tcken)\
    |_PER_FMK(VP,TSICTL,STEN,sten)\
    |_PER_FMK(VP,TSICTL,CTMODE,ctmode)\
    |_PER_FMK(VP,TSICTL,ERRFILT,errfilt)\
  )

  #define _VP_TSICTL_FGET(N,FIELD)\
    _PER_FGET(_VP_TSICTL##N##_ADDR,VP,TSICTL,##FIELD)

  #define _VP_TSICTL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSICTL##N##_ADDR,VP,TSICTL,##FIELD,field)

  #define _VP_TSICTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSICTL##N##_ADDR,VP,TSICTL,##FIELD,##SYM)

  #define _VP_TSICTL0_FGET(FIELD)   _VP_TSICTL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICTL1_FGET(FIELD)   _VP_TSICTL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICTL2_FGET(FIELD)   _VP_TSICTL_FGET(2,##FIELD)
 #endif


  #define _VP_TSICTL0_FSET(FIELD,f)   _VP_TSICTL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICTL1_FSET(FIELD,f)   _VP_TSICTL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICTL2_FSET(FIELD,f)   _VP_TSICTL_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSICTL0_FSETS(FIELD,SYM)   _VP_TSICTL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICTL1_FSETS(FIELD,SYM)   _VP_TSICTL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICTL2_FSETS(FIELD,SYM)   _VP_TSICTL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* ___________________________
* |                         |
* |  T S I C L K I N I T L  |
* |_________________________|
*
* TSICLKINITL0  -  Video Port 0 Transport Stream Interface Clock Initialization LSB
* TSICLKINITL1  -  Video Port 1 Transport Stream Interface Clock Initialization LSB
* TSICLKINITL2  -  Video Port 2 Transport Stream Interface Clock Initialization LSB
*
* FIELDS (msb -> lsb)
* (rw) INPCR 
*
\******************************************************************************/
  #define _VP_TSICLKINITL_OFFSET           97

  #define _VP_TSICLKINITL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSICLKINITL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICLKINITL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSICLKINITL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICLKINITL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSICLKINITL_OFFSET)
 #endif


  #define _VP_TSICLKINITL_INPCR_MASK         0xFFFFFFFFu
  #define _VP_TSICLKINITL_INPCR_SHIFT        0x00000000u
  #define  VP_TSICLKINITL_INPCR_DEFAULT      0x00000000u
  #define  VP_TSICLKINITL_INPCR_OF(x)        _VALUEOF(x)

  #define  VP_TSICLKINITL_OF(x)            _VALUEOF(x)

  #define VP_TSICLKINITL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSICLKINITL,INPCR)\
  )

  #define VP_TSICLKINITL_RMK(inpcr) (Uint32)(\
     _PER_FMK(VP,TSICLKINITL,INPCR,inpcr)\
  )

  #define _VP_TSICLKINITL_FGET(N,FIELD)\
    _PER_FGET(_VP_TSICLKINITL##N##_ADDR,VP,TSICLKINITL,##FIELD)

  #define _VP_TSICLKINITL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSICLKINITL##N##_ADDR,VP,TSICLKINITL,##FIELD,field)

  #define _VP_TSICLKINITL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSICLKINITL##N##_ADDR,VP,TSICLKINITL,##FIELD,##SYM)

  #define _VP_TSICLKINITL0_FGET(FIELD)   _VP_TSICLKINITL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICLKINITL1_FGET(FIELD)   _VP_TSICLKINITL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICLKINITL2_FGET(FIELD)   _VP_TSICLKINITL_FGET(2,##FIELD)
 #endif


  #define _VP_TSICLKINITL0_FSET(FIELD,f)   _VP_TSICLKINITL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICLKINITL1_FSET(FIELD,f)   _VP_TSICLKINITL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICLKINITL2_FSET(FIELD,f)   _VP_TSICLKINITL_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSICLKINITL0_FSETS(FIELD,SYM)   _VP_TSICLKINITL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICLKINITL1_FSETS(FIELD,SYM)   _VP_TSICLKINITL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICLKINITL2_FSETS(FIELD,SYM)   _VP_TSICLKINITL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* ___________________________
* |                         |
* |  T S I C L K I N I T M  |
* |_________________________|
*
* TSICLKINITM0  -  Video Port 0 Transport Stream Interface Clock Initialization MSB
* TSICLKINITM1  -  Video Port 1 Transport Stream Interface Clock Initialization MSB
* TSICLKINITM2  -  Video Port 2 Transport Stream Interface Clock Initialization MSB
*
* FIELDS (msb -> lsb)
* (rw) INPCRE 
* (rw) INPCRM 
*
\******************************************************************************/
  #define _VP_TSICLKINITM_OFFSET           98

  #define _VP_TSICLKINITM0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSICLKINITM_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICLKINITM1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSICLKINITM_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICLKINITM2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSICLKINITM_OFFSET)
 #endif


  #define _VP_TSICLKINITM_INPCRE_MASK         0x000003FEu
  #define _VP_TSICLKINITM_INPCRE_SHIFT        0x00000001u
  #define  VP_TSICLKINITM_INPCRE_DEFAULT      0x00000000u
  #define  VP_TSICLKINITM_INPCRE_OF(x)        _VALUEOF(x)

  #define _VP_TSICLKINITM_INPCRM_MASK         0x00000001u
  #define _VP_TSICLKINITM_INPCRM_SHIFT        0x00000000u
  #define  VP_TSICLKINITM_INPCRM_DEFAULT      0x00000000u
  #define  VP_TSICLKINITM_INPCRM_OF(x)        _VALUEOF(x)

  #define  VP_TSICLKINITM_OF(x)            _VALUEOF(x)

  #define VP_TSICLKINITM_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSICLKINITM,INPCRE)\
    |_PER_FDEFAULT(VP,TSICLKINITM,INPCRM)\
  )

  #define VP_TSICLKINITM_RMK(inpcre,inpcrm) (Uint32)(\
     _PER_FMK(VP,TSICLKINITM,INPCRE,inpcre)\
    |_PER_FMK(VP,TSICLKINITM,INPCRM,inpcrm)\
  )

  #define _VP_TSICLKINITM_FGET(N,FIELD)\
    _PER_FGET(_VP_TSICLKINITM##N##_ADDR,VP,TSICLKINITM,##FIELD)

  #define _VP_TSICLKINITM_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSICLKINITM##N##_ADDR,VP,TSICLKINITM,##FIELD,field)

  #define _VP_TSICLKINITM_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSICLKINITM##N##_ADDR,VP,TSICLKINITM,##FIELD,##SYM)

  #define _VP_TSICLKINITM0_FGET(FIELD)   _VP_TSICLKINITM_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICLKINITM1_FGET(FIELD)   _VP_TSICLKINITM_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICLKINITM2_FGET(FIELD)   _VP_TSICLKINITM_FGET(2,##FIELD)
 #endif


  #define _VP_TSICLKINITM0_FSET(FIELD,f)   _VP_TSICLKINITM_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICLKINITM1_FSET(FIELD,f)   _VP_TSICLKINITM_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICLKINITM2_FSET(FIELD,f)   _VP_TSICLKINITM_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSICLKINITM0_FSETS(FIELD,SYM)   _VP_TSICLKINITM_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSICLKINITM1_FSETS(FIELD,SYM)   _VP_TSICLKINITM_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSICLKINITM2_FSETS(FIELD,SYM)   _VP_TSICLKINITM_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _______________________
* |                     |
* |  T S I S T C L K L  |
* |_____________________|
*
* TSISTCLKL0    -  Video Port 0 Transport Stream Interface System Time Clock LSB
* TSISTCLKL1    -  Video Port 1 Transport Stream Interface System Time Clock LSB
* TSISTCLKL2    -  Video Port 2 Transport Stream Interface System Time Clock LSB
*
* FIELDS (msb -> lsb)
* (rw) PCR 
*
\******************************************************************************/
  #define _VP_TSISTCLKL_OFFSET           99

  #define _VP_TSISTCLKL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSISTCLKL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCLKL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSISTCLKL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCLKL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSISTCLKL_OFFSET)
 #endif


  #define _VP_TSISTCLKL_PCR_MASK         0xFFFFFFFFu
  #define _VP_TSISTCLKL_PCR_SHIFT        0x00000000u
  #define  VP_TSISTCLKL_PCR_DEFAULT      0x00000000u
  #define  VP_TSISTCLKL_PCR_OF(x)        _VALUEOF(x)

  #define  VP_TSISTCLKL_OF(x)            _VALUEOF(x)

  #define VP_TSISTCLKL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSISTCLKL,PCR)\
  )

  #define VP_TSISTCLKL_RMK(pcr) (Uint32)(\
     _PER_FMK(VP,TSISTCLKL,PCR,pcr)\
  )

  #define _VP_TSISTCLKL_FGET(N,FIELD)\
    _PER_FGET(_VP_TSISTCLKL##N##_ADDR,VP,TSISTCLKL,##FIELD)

  #define _VP_TSISTCLKL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSISTCLKL##N##_ADDR,VP,TSISTCLKL,##FIELD,field)

  #define _VP_TSISTCLKL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSISTCLKL##N##_ADDR,VP,TSISTCLKL,##FIELD,##SYM)

  #define _VP_TSISTCLKL0_FGET(FIELD)   _VP_TSISTCLKL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCLKL1_FGET(FIELD)   _VP_TSISTCLKL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCLKL2_FGET(FIELD)   _VP_TSISTCLKL_FGET(2,##FIELD)
 #endif


  #define _VP_TSISTCLKL0_FSET(FIELD,f)   _VP_TSISTCLKL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCLKL1_FSET(FIELD,f)   _VP_TSISTCLKL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCLKL2_FSET(FIELD,f)   _VP_TSISTCLKL_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSISTCLKL0_FSETS(FIELD,SYM)   _VP_TSISTCLKL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCLKL1_FSETS(FIELD,SYM)   _VP_TSISTCLKL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCLKL2_FSETS(FIELD,SYM)   _VP_TSISTCLKL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _______________________
* |                     |
* |  T S I S T C L K M  |
* |_____________________|
*
* TSISTCLKM0 -  Video Port 0 Transport Stream Interface System Time Clock  MSB
* TSISTCLKM1 -  Video Port 1 Transport Stream Interface System Time Clock  MSB
* TSISTCLKM2 -  Video Port 2 Transport Stream Interface System Time Clock  MSB
*
* FIELDS (msb -> lsb)
* (rw) PCRE 
* (rw) PCRM 
*
\******************************************************************************/
  #define _VP_TSISTCLKM_OFFSET           100

  #define _VP_TSISTCLKM0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSISTCLKM_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCLKM1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSISTCLKM_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCLKM2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSISTCLKM_OFFSET)
 #endif


  #define _VP_TSISTCLKM_PCRE_MASK         0x000003FEu
  #define _VP_TSISTCLKM_PCRE_SHIFT        0x00000001u
  #define  VP_TSISTCLKM_PCRE_DEFAULT      0x00000000u
  #define  VP_TSISTCLKM_PCRE_OF(x)        _VALUEOF(x)

  #define _VP_TSISTCLKM_PCRM_MASK         0x00000001u
  #define _VP_TSISTCLKM_PCRM_SHIFT        0x00000000u
  #define  VP_TSISTCLKM_PCRM_DEFAULT      0x00000000u
  #define  VP_TSISTCLKM_PCRM_OF(x)        _VALUEOF(x)

  #define  VP_TSISTCLKM_OF(x)            _VALUEOF(x)

  #define VP_TSISTCLKM_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSISTCLKM,PCRE)\
    |_PER_FDEFAULT(VP,TSISTCLKM,PCRM)\
  )

  #define VP_TSISTCLKM_RMK(pcre,pcrm) (Uint32)(\
     _PER_FMK(VP,TSISTCLKM,PCRE,pcre)\
    |_PER_FMK(VP,TSISTCLKM,PCRM,pcrm)\
  )

  #define _VP_TSISTCLKM_FGET(N,FIELD)\
    _PER_FGET(_VP_TSISTCLKM##N##_ADDR,VP,TSISTCLKM,##FIELD)

  #define _VP_TSISTCLKM_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSISTCLKM##N##_ADDR,VP,TSISTCLKM,##FIELD,field)

  #define _VP_TSISTCLKM_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSISTCLKM##N##_ADDR,VP,TSISTCLKM,##FIELD,##SYM)

  #define _VP_TSISTCLKM0_FGET(FIELD)   _VP_TSISTCLKM_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCLKM1_FGET(FIELD)   _VP_TSISTCLKM_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCLKM2_FGET(FIELD)   _VP_TSISTCLKM_FGET(2,##FIELD)
 #endif


  #define _VP_TSISTCLKM0_FSET(FIELD,f)   _VP_TSISTCLKM_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCLKM1_FSET(FIELD,f)   _VP_TSISTCLKM_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCLKM2_FSET(FIELD,f)   _VP_TSISTCLKM_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSISTCLKM0_FSETS(FIELD,SYM)   _VP_TSISTCLKM_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCLKM1_FSETS(FIELD,SYM)   _VP_TSISTCLKM_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCLKM2_FSETS(FIELD,SYM)   _VP_TSISTCLKM_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _______________________
* |                     |
* |  T S I S T C M P L  |
* |_____________________|
*
* TSISTCMPL0 -  Video Port 0 Transport Stream Interface STC Compare LSB
* TSISTCMPL1 -  Video Port 1 Transport Stream Interface STC Compare LSB
* TSISTCMPL2 -  Video Port 2 Transport Stream Interface STC Compare LSB
*
* FIELDS (msb -> lsb)
* (r) ATC 
*
\******************************************************************************/
  #define _VP_TSISTCMPL_OFFSET           101

  #define _VP_TSISTCMPL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSISTCMPL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCMPL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSISTCMPL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCMPL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSISTCMPL_OFFSET)
 #endif


  #define _VP_TSISTCMPL_ATC_MASK         0xFFFFFFFFu
  #define _VP_TSISTCMPL_ATC_SHIFT        0x00000000u
  #define  VP_TSISTCMPL_ATC_DEFAULT      0x00000000u
  #define  VP_TSISTCMPL_ATC_OF(x)        _VALUEOF(x)

  #define  VP_TSISTCMPL_OF(x)            _VALUEOF(x)

  #define VP_TSISTCMPL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSISTCMPL,ATC)\
  )

  #define VP_TSISTCMPL_RMK(atc) (Uint32)(\
     _PER_FMK(VP,TSISTCMPL,ATC,atc)\
  )

  #define _VP_TSISTCMPL_FGET(N,FIELD)\
    _PER_FGET(_VP_TSISTCMPL##N##_ADDR,VP,TSISTCMPL,##FIELD)

  #define _VP_TSISTCMPL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSISTCMPL##N##_ADDR,VP,TSISTCMPL,##FIELD,field)

  #define _VP_TSISTCMPL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSISTCMPL##N##_ADDR,VP,TSISTCMPL,##FIELD,##SYM)

  #define _VP_TSISTCMPL0_FGET(FIELD)   _VP_TSISTCMPL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCMPL1_FGET(FIELD)   _VP_TSISTCMPL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCMPL2_FGET(FIELD)   _VP_TSISTCMPL_FGET(2,##FIELD)
 #endif


  #define _VP_TSISTCMPL0_FSET(FIELD,f)   _VP_TSISTCMPL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCMPL1_FSET(FIELD,f)   _VP_TSISTCMPL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCMPL2_FSET(FIELD,f)   _VP_TSISTCMPL_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSISTCMPL0_FSETS(FIELD,SYM)   _VP_TSISTCMPL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCMPL1_FSETS(FIELD,SYM)   _VP_TSISTCMPL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCMPL2_FSETS(FIELD,SYM)   _VP_TSISTCMPL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _______________________
* |                     |
* |  T S I S T C M P M  |
* |_____________________|
*
* TSISTCMPM0    -  Video Port 0 Transport Stream Interface STC Compare MSB
* TSISTCMPM1    -  Video Port 1 Transport Stream Interface STC Compare MSB
* TSISTCMPM2    -  Video Port 2 Transport Stream Interface STC Compare MSB
*
* FIELDS (msb -> lsb)
* (rw) ATC
*
\******************************************************************************/
  #define _VP_TSISTCMPM_OFFSET           102

  #define _VP_TSISTCMPM0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSISTCMPM_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCMPM1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSISTCMPM_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCMPM2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSISTCMPM_OFFSET)
 #endif


  #define _VP_TSISTCMPM_ATC_MASK         0x00000001u
  #define _VP_TSISTCMPM_ATC_SHIFT        0x00000000u
  #define  VP_TSISTCMPM_ATC_DEFAULT      0x00000000u
  #define  VP_TSISTCMPM_ATC_OF(x)        _VALUEOF(x)

  #define  VP_TSISTCMPM_OF(x)            _VALUEOF(x)

  #define VP_TSISTCMPM_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSISTCMPM,ATC)\
  )

  #define VP_TSISTCMPM_RMK(atc) (Uint32)(\
     _PER_FMK(VP,TSISTCMPM,ATC,atc)\
  )

  #define _VP_TSISTCMPM_FGET(N,FIELD)\
    _PER_FGET(_VP_TSISTCMPM##N##_ADDR,VP,TSISTCMPM,##FIELD)

  #define _VP_TSISTCMPM_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSISTCMPM##N##_ADDR,VP,TSISTCMPM,##FIELD,field)

  #define _VP_TSISTCMPM_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSISTCMPM##N##_ADDR,VP,TSISTCMPM,##FIELD,##SYM)

  #define _VP_TSISTCMPM0_FGET(FIELD)   _VP_TSISTCMPM_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCMPM1_FGET(FIELD)   _VP_TSISTCMPM_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCMPM2_FGET(FIELD)   _VP_TSISTCMPM_FGET(2,##FIELD)
 #endif


  #define _VP_TSISTCMPM0_FSET(FIELD,f)   _VP_TSISTCMPM_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCMPM1_FSET(FIELD,f)   _VP_TSISTCMPM_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCMPM2_FSET(FIELD,f)   _VP_TSISTCMPM_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSISTCMPM0_FSETS(FIELD,SYM)   _VP_TSISTCMPM_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTCMPM1_FSETS(FIELD,SYM)   _VP_TSISTCMPM_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTCMPM2_FSETS(FIELD,SYM)   _VP_TSISTCMPM_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _______________________
* |                     |
* |  T S I S T M S K L  |
* |_____________________|
*
* TSISTMSKL0 -  Video Port 0 Transport Stream Interface STC Compare Mask LSB
* TSISTMSKL1 -  Video Port 1 Transport Stream Interface STC Compare Mask LSB
* TSISTMSKL2 -  Video Port 2 Transport Stream Interface STC Compare Mask LSB
*
* FIELDS (msb -> lsb)
* (r) ATCM 
*
\******************************************************************************/
  #define _VP_TSISTMSKL_OFFSET           103

  #define _VP_TSISTMSKL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSISTMSKL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTMSKL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSISTMSKL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTMSKL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSISTMSKL_OFFSET)
 #endif


  #define _VP_TSISTMSKL_ATCM_MASK         0xFFFFFFFFu
  #define _VP_TSISTMSKL_ATCM_SHIFT        0x00000000u
  #define  VP_TSISTMSKL_ATCM_DEFAULT      0x00000000u
  #define  VP_TSISTMSKL_ATCM_OF(x)        _VALUEOF(x)

  #define  VP_TSISTMSKL_OF(x)            _VALUEOF(x)

  #define VP_TSISTMSKL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSISTMSKL,ATCM)\
  )

/**** read only bit field ****/
  #define VP_TSISTMSKL_RMK(atcm) (Uint32)(\
     _PER_FMK(VP,TSISTMSKL,ATCM,atcm)\
  )

  #define _VP_TSISTMSKL_FGET(N,FIELD)\
    _PER_FGET(_VP_TSISTMSKL##N##_ADDR,VP,TSISTMSKL,##FIELD)

  #define _VP_TSISTMSKL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSISTMSKL##N##_ADDR,VP,TSISTMSKL,##FIELD,field)

  #define _VP_TSISTMSKL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSISTMSKL##N##_ADDR,VP,TSISTMSKL,##FIELD,##SYM)

  #define _VP_TSISTMSKL0_FGET(FIELD)   _VP_TSISTMSKL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTMSKL1_FGET(FIELD)   _VP_TSISTMSKL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTMSKL2_FGET(FIELD)   _VP_TSISTMSKL_FGET(2,##FIELD)
 #endif


  #define _VP_TSISTMSKL0_FSET(FIELD,f)   _VP_TSISTMSKL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTMSKL1_FSET(FIELD,f)   _VP_TSISTMSKL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTMSKL2_FSET(FIELD,f)   _VP_TSISTMSKL_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSISTMSKL0_FSETS(FIELD,SYM)   _VP_TSISTMSKL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTMSKL1_FSETS(FIELD,SYM)   _VP_TSISTMSKL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTMSKL2_FSETS(FIELD,SYM)   _VP_TSISTMSKL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _______________________
* |                     |
* |  T S I S T M S K M  |
* |_____________________|
*
* TSISTMSKM0 -  Video Port 0 Transport Stream Interface STC Compare Mask MSB
* TSISTMSKM1 -  Video Port 1 Transport Stream Interface STC Compare Mask MSB
* TSISTMSKM2 -  Video Port 2 Transport Stream Interface STC Compare Mask MSB
*
* FIELDS (msb -> lsb)
* (rw) ATCM
*
\******************************************************************************/
  #define _VP_TSISTMSKM_OFFSET           104

  #define _VP_TSISTMSKM0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSISTMSKM_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTMSKM1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSISTMSKM_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTMSKM2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSISTMSKM_OFFSET)
 #endif


  #define _VP_TSISTMSKM_ATCM_MASK         0x00000001u
  #define _VP_TSISTMSKM_ATCM_SHIFT        0x00000000u
  #define  VP_TSISTMSKM_ATCM_DEFAULT      0x00000000u
  #define  VP_TSISTMSKM_ATCM_OF(x)        _VALUEOF(x)

  #define  VP_TSISTMSKM_OF(x)            _VALUEOF(x)

  #define VP_TSISTMSKM_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSISTMSKM,ATCM)\
  )

  #define VP_TSISTMSKM_RMK(atcm) (Uint32)(\
     _PER_FMK(VP,TSISTMSKM,ATCM,atcm)\
  )

  #define _VP_TSISTMSKM_FGET(N,FIELD)\
    _PER_FGET(_VP_TSISTMSKM##N##_ADDR,VP,TSISTMSKM,##FIELD)

  #define _VP_TSISTMSKM_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSISTMSKM##N##_ADDR,VP,TSISTMSKM,##FIELD,field)

  #define _VP_TSISTMSKM_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSISTMSKM##N##_ADDR,VP,TSISTMSKM,##FIELD,##SYM)

  #define _VP_TSISTMSKM0_FGET(FIELD)   _VP_TSISTMSKM_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTMSKM1_FGET(FIELD)   _VP_TSISTMSKM_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTMSKM2_FGET(FIELD)   _VP_TSISTMSKM_FGET(2,##FIELD)
 #endif


  #define _VP_TSISTMSKM0_FSET(FIELD,f)   _VP_TSISTMSKM_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTMSKM1_FSET(FIELD,f)   _VP_TSISTMSKM_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTMSKM2_FSET(FIELD,f)   _VP_TSISTMSKM_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSISTMSKM0_FSETS(FIELD,SYM)   _VP_TSISTMSKM_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSISTMSKM1_FSETS(FIELD,SYM)   _VP_TSISTMSKM_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSISTMSKM2_FSETS(FIELD,SYM)   _VP_TSISTMSKM_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _______________________
* |                     |
* |  T S I T I C K S    |
* |_____________________|
*
* TSITICKS0 -  Video Port 0 Transport Stream Interface STC Ticks Interrupt
* TSITICKS1 -  Video Port 1 Transport Stream Interface STC Ticks Interrupt
* TSITICKS2 -  Video Port 2 Transport Stream Interface STC Ticks Interrupt
*
* FIELDS (msb -> lsb)
* (rw) TICKCT
*
\******************************************************************************/
  #define _VP_TSITICKS_OFFSET           105

  #define _VP_TSITICKS0_ADDR   (_VP_BASE_PORT0 + 4*_VP_TSITICKS_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSITICKS1_ADDR   (_VP_BASE_PORT1 + 4*_VP_TSITICKS_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSITICKS2_ADDR   (_VP_BASE_PORT2 + 4*_VP_TSITICKS_OFFSET)
 #endif


  #define _VP_TSITICKS_TICKCT_MASK         0xFFFFFFFFu
  #define _VP_TSITICKS_TICKCT_SHIFT        0x00000000u
  #define  VP_TSITICKS_TICKCT_DEFAULT      0x00000000u
  #define  VP_TSITICKS_TICKCT_OF(x)        _VALUEOF(x)

  #define  VP_TSITICKS_OF(x)            _VALUEOF(x)

  #define VP_TSITICKS_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,TSITICKS,TICKCT)\
  )

  #define VP_TSITICKS_RMK(tickct) (Uint32)(\
     _PER_FMK(VP,TSITICKS,TICKCT,tickct)\
  )

  #define _VP_TSITICKS_FGET(N,FIELD)\
    _PER_FGET(_VP_TSITICKS##N##_ADDR,VP,TSITICKS,##FIELD)

  #define _VP_TSITICKS_FSET(N,FIELD,field)\
    _PER_FSET(_VP_TSITICKS##N##_ADDR,VP,TSITICKS,##FIELD,field)

  #define _VP_TSITICKS_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_TSITICKS##N##_ADDR,VP,TSITICKS,##FIELD,##SYM)

  #define _VP_TSITICKS0_FGET(FIELD)   _VP_TSITICKS_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSITICKS1_FGET(FIELD)   _VP_TSITICKS_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSITICKS2_FGET(FIELD)   _VP_TSITICKS_FGET(2,##FIELD)
 #endif


  #define _VP_TSITICKS0_FSET(FIELD,f)   _VP_TSITICKS_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSITICKS1_FSET(FIELD,f)   _VP_TSITICKS_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSITICKS2_FSET(FIELD,f)   _VP_TSITICKS_FSET(2,##FIELD,f)
 #endif


  #define _VP_TSITICKS0_FSETS(FIELD,SYM)   _VP_TSITICKS_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_TSITICKS1_FSETS(FIELD,SYM)   _VP_TSITICKS_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_TSITICKS2_FSETS(FIELD,SYM)   _VP_TSITICKS_FSETS(2,##FIELD,##SYM)
 #endif



/******************************************************************************\
* _____________________
* |                   |
* |  V D S T A T      |
* |___________________|
*
* VDSTAT0 -  Video Port 0 Video Display Status
* VDSTAT1 -  Video Port 1 Video Display Status
* VDSTAT2 -  Video Port 2 Video Display Status
*
* FIELDS (msb -> lsb)
*
* (rc) FRMD
* (rc) F2D
* (rc) F1D
* (r)  VDYPOS
* (r)  VBLNK
* (r)  VDFLD
* (r)  VDXPOS
*
\******************************************************************************/
  #define _VP_VDSTAT_OFFSET           128

  #define _VP_VDSTAT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDSTAT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDSTAT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDSTAT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDSTAT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDSTAT_OFFSET)
 #endif


  #define _VP_VDSTAT_FRMD_MASK        0x40000000u
  #define _VP_VDSTAT_FRMD_SHIFT       0x0000001Eu
  #define  VP_VDSTAT_FRMD_DEFAULT     0x00000000u
  #define  VP_VDSTAT_FRMD_OF(x)       _VALUEOF(x)
  #define  VP_VDSTAT_FRMD_NONE        0x00000000u
  #define  VP_VDSTAT_FRMD_DISPLAYED   0x00000001u
  #define  VP_VDSTAT_FRMD_CLEAR       0x00000001u

  #define _VP_VDSTAT_F2D_MASK        0x20000000u
  #define _VP_VDSTAT_F2D_SHIFT       0x0000001Du
  #define  VP_VDSTAT_F2D_DEFAULT     0x00000000u
  #define  VP_VDSTAT_F2D_OF(x)       _VALUEOF(x)
  #define  VP_VDSTAT_F2D_NONE        0x00000000u
  #define  VP_VDSTAT_F2D_DISPLAYED    0x00000001u
  #define  VP_VDSTAT_F2D_CLEAR       0x00000001u

  #define _VP_VDSTAT_F1D_MASK        0x10000000u
  #define _VP_VDSTAT_F1D_SHIFT       0x0000001Cu
  #define  VP_VDSTAT_F1D_DEFAULT     0x00000000u
  #define  VP_VDSTAT_F1D_OF(x)       _VALUEOF(x)
  #define  VP_VDSTAT_F1D_NONE        0x00000000u
  #define  VP_VDSTAT_F1D_DISPLAYED   0x00000001u
  #define  VP_VDSTAT_F1D_CLEAR       0x00000001u

  #define _VP_VDSTAT_VDYPOS_MASK        0x0FFF0000u
  #define _VP_VDSTAT_VDYPOS_SHIFT       0x00000010u
  #define  VP_VDSTAT_VDYPOS_DEFAULT     0x00000000u
  #define  VP_VDSTAT_VDYPOS_OF(x)       _VALUEOF(x)

  #define _VP_VDSTAT_VBLNK_MASK        0x00002000u
  #define _VP_VDSTAT_VBLNK_SHIFT       0x0000000Du
  #define  VP_VDSTAT_VBLNK_DEFAULT     0x00000000u
  #define  VP_VDSTAT_VBLNK_OF(x)       _VALUEOF(x)
  #define  VP_VDSTAT_VBLNK_EMPTY       0x00000000u
  #define  VP_VDSTAT_VBLNK_NOTEMPTY    0x00000001u

  #define _VP_VDSTAT_VDFLD_MASK        0x00001000u
  #define _VP_VDSTAT_VDFLD_SHIFT       0x0000000Cu
  #define  VP_VDSTAT_VDFLD_DEFAULT     0x00000000u
  #define  VP_VDSTAT_VDFLD_OF(x)       _VALUEOF(x)
  #define  VP_VDSTAT_VDFLD_FIELD1ACT   0x00000000u
  #define  VP_VDSTAT_VDFLD_FIELD2ACT   0x00000001u

  #define _VP_VDSTAT_VDXPOS_MASK        0x00000FFFu
  #define _VP_VDSTAT_VDXPOS_SHIFT       0x00000000u
  #define  VP_VDSTAT_VDXPOS_DEFAULT     0x00000000u
  #define  VP_VDSTAT_VDXPOS_OF(x)       _VALUEOF(x)


  #define  VP_VDSTAT_OF(x)            _VALUEOF(x)

  #define VP_VDSTAT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDSTAT,FRMD)\
    |_PER_FDEFAULT(VP,VDSTAT,F2D)\
    |_PER_FDEFAULT(VP,VDSTAT,F1D)\
    |_PER_FDEFAULT(VP,VDSTAT,VDYPOS)\
    |_PER_FDEFAULT(VP,VDSTAT,VBLNK)\
    |_PER_FDEFAULT(VP,VDSTAT,VDFLD)\
    |_PER_FDEFAULT(VP,VDSTAT,VDXPOS)\
  )

  #define VP_VDSTAT_RMK(frmd,f2d,f1d) (Uint32)(\
     _PER_FMK(VP,VDSTAT,FRMD,frmd)\
    |_PER_FMK(VP,VDSTAT,F2D,f2d)\
    |_PER_FMK(VP,VDSTAT,F1D,f1d)\
  )

  #define _VP_VDSTAT_FGET(N,FIELD)\
    _PER_FGET(_VP_VDSTAT##N##_ADDR,VP,VDSTAT,##FIELD)

  #define _VP_VDSTAT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDSTAT##N##_ADDR,VP,VDSTAT,##FIELD,field)

  #define _VP_VDSTAT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDSTAT##N##_ADDR,VP,VDSTAT,##FIELD,##SYM)

  #define _VP_VDSTAT0_FGET(FIELD)   _VP_VDSTAT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDSTAT1_FGET(FIELD)   _VP_VDSTAT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDSTAT2_FGET(FIELD)   _VP_VDSTAT_FGET(2,##FIELD)
 #endif


  #define _VP_VDSTAT0_FSET(FIELD,f)   _VP_VDSTAT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDSTAT1_FSET(FIELD,f)   _VP_VDSTAT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDSTAT2_FSET(FIELD,f)   _VP_VDSTAT_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDSTAT0_FSETS(FIELD,SYM)   _VP_VDSTAT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDSTAT1_FSETS(FIELD,SYM)   _VP_VDSTAT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDSTAT2_FSETS(FIELD,SYM)   _VP_VDSTAT_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D C T L        |
* |___________________|
*
* VDCTL0 -  Video Port 0 Video Display Control
* VDCTL1 -  Video Port 1 Video Display Control
* VDCTL2 -  Video Port 2 Video Display Control
*
* FIELDS (msb -> lsb)
*
* (rw) RSTCH
* (rw) BLKDIS
* (rw) PVPSYN
* (rw) FXS
* (rw) VXS
* (rw) HXS
* (rw) VCTL2S
* (rw) VCTL1S
* (rw) VCTL0S
* (rw) VDEN
* (rw) DPK
* (rw) RGBX
* (rw) RSYNC
* (rw) DVEN
* (rw) RESMPL
* (rw) SCALE
* (rw) CON
* (rw) FRAME
* (rw) DF2
* (rw) DF1
* (rw) DMODE
*
\******************************************************************************/
  #define _VP_VDCTL_OFFSET           129

  #define _VP_VDCTL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDCTL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDCTL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDCTL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDCTL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDCTL_OFFSET)
 #endif


  #define _VP_VDCTL_RSTCH_MASK        0x80000000u
  #define _VP_VDCTL_RSTCH_SHIFT       0x0000001Fu
  #define  VP_VDCTL_RSTCH_DEFAULT     0x00000000u
  #define  VP_VDCTL_RSTCH_OF(x)       _VALUEOF(x)
  #define  VP_VDCTL_RSTCH_NONE        0x00000000u
  #define  VP_VDCTL_RSTCH_RESET       0x00000001u

  #define _VP_VDCTL_BLKDIS_MASK         0x40000000u
  #define _VP_VDCTL_BLKDIS_SHIFT        0x0000001Eu
  #define  VP_VDCTL_BLKDIS_DEFAULT      0x00000001u
  #define  VP_VDCTL_BLKDIS_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_BLKDIS_CLEAR        0x00000000u
  #define  VP_VDCTL_BLKDIS_BLOCK        0x00000001u

  #define _VP_VDCTL_PVPSYN_MASK         0x10000000u
  #define _VP_VDCTL_PVPSYN_SHIFT        0x0000001Cu
  #define  VP_VDCTL_PVPSYN_DEFAULT      0x00000000u
  #define  VP_VDCTL_PVPSYN_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_PVPSYN_DISABLE      0x00000000u
  #define  VP_VDCTL_PVPSYN_ENABLE       0x00000001u

  #define _VP_VDCTL_FXS_MASK         0x00800000u
  #define _VP_VDCTL_FXS_SHIFT        0x00000017u
  #define  VP_VDCTL_FXS_DEFAULT      0x00000000u
  #define  VP_VDCTL_FXS_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_FXS_OUTPUT       0x00000000u
  #define  VP_VDCTL_FXS_FSINPUT      0x00000001u

  #define _VP_VDCTL_VXS_MASK         0x00400000u
  #define _VP_VDCTL_VXS_SHIFT        0x00000016u
  #define  VP_VDCTL_VXS_DEFAULT      0x00000000u
  #define  VP_VDCTL_VXS_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_VXS_OUTPUT       0x00000000u
  #define  VP_VDCTL_VXS_VSINPUT      0x00000001u

  #define _VP_VDCTL_HXS_MASK         0x00200000u
  #define _VP_VDCTL_HXS_SHIFT        0x00000015u
  #define  VP_VDCTL_HXS_DEFAULT      0x00000000u
  #define  VP_VDCTL_HXS_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_HXS_OUTPUT       0x00000000u
  #define  VP_VDCTL_HXS_HSINPUT      0x00000001u

  #define _VP_VDCTL_VCTL2S_MASK         0x00100000u
  #define _VP_VDCTL_VCTL2S_SHIFT        0x00000014u
  #define  VP_VDCTL_VCTL2S_DEFAULT      0x00000000u
  #define  VP_VDCTL_VCTL2S_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_VCTL2S_CBLNK        0x00000000u
  #define  VP_VDCTL_VCTL2S_FLD          0x00000001u

  #define _VP_VDCTL_VCTL1S_MASK         0x000C0000u
  #define _VP_VDCTL_VCTL1S_SHIFT        0x00000012u
  #define  VP_VDCTL_VCTL1S_DEFAULT      0x00000000u
  #define  VP_VDCTL_VCTL1S_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_VCTL1S_VYSYNC       0x00000000u
  #define  VP_VDCTL_VCTL1S_VBLNK        0x00000001u
  #define  VP_VDCTL_VCTL1S_CSYNC        0x00000002u
  #define  VP_VDCTL_VCTL1S_FLD          0x00000003u

  #define _VP_VDCTL_VCTL0S_MASK         0x00030000u
  #define _VP_VDCTL_VCTL0S_SHIFT        0x00000010u
  #define  VP_VDCTL_VCTL0S_DEFAULT      0x00000000u
  #define  VP_VDCTL_VCTL0S_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_VCTL0S_HYSYNC       0x00000000u
  #define  VP_VDCTL_VCTL0S_HBLNK        0x00000001u
  #define  VP_VDCTL_VCTL0S_AVID         0x00000002u
  #define  VP_VDCTL_VCTL0S_FLD          0x00000003u

  #define _VP_VDCTL_VDEN_MASK         0x00008000u
  #define _VP_VDCTL_VDEN_SHIFT        0x0000000Fu
  #define  VP_VDCTL_VDEN_DEFAULT      0x00000000u
  #define  VP_VDCTL_VDEN_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_VDEN_DISABLE      0x00000000u
  #define  VP_VDCTL_VDEN_ENABLE       0x00000001u

  #define _VP_VDCTL_DPK_MASK         0x00004000u
  #define _VP_VDCTL_DPK_SHIFT        0x0000000Eu
  #define  VP_VDCTL_DPK_DEFAULT      0x00000000u
  #define  VP_VDCTL_DPK_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_DPK_N10UNPK      0x00000000u
  #define  VP_VDCTL_DPK_D10UNPK      0x00000001u

  #define _VP_VDCTL_RGBX_MASK         0x00002000u
  #define _VP_VDCTL_RGBX_SHIFT        0x0000000Du
  #define  VP_VDCTL_RGBX_DEFAULT      0x00000000u
  #define  VP_VDCTL_RGBX_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_RGBX_DISABLE      0x00000000u
  #define  VP_VDCTL_RGBX_ENABLE       0x00000001u

  #define _VP_VDCTL_RSYNC_MASK         0x00001000u
  #define _VP_VDCTL_RSYNC_SHIFT        0x0000000Cu
  #define  VP_VDCTL_RSYNC_DEFAULT      0x00000000u
  #define  VP_VDCTL_RSYNC_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_RSYNC_DISABLE      0x00000000u
  #define  VP_VDCTL_RSYNC_ENABLE       0x00000001u

  #define _VP_VDCTL_DVEN_MASK         0x00000800u
  #define _VP_VDCTL_DVEN_SHIFT        0x0000000Bu
  #define  VP_VDCTL_DVEN_DEFAULT      0x00000000u
  #define  VP_VDCTL_DVEN_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_DVEN_BLANKING     0x00000000u
  #define  VP_VDCTL_DVEN_DV           0x00000001u

  #define _VP_VDCTL_RESMPL_MASK         0x00000400u
  #define _VP_VDCTL_RESMPL_SHIFT        0x0000000Au
  #define  VP_VDCTL_RESMPL_DEFAULT      0x00000000u
  #define  VP_VDCTL_RESMPL_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_RESMPL_DISABLE      0x00000000u
  #define  VP_VDCTL_RESMPL_ENABLE       0x00000001u

/*    ??? */
  #define _VP_VDCTL_SCALE_MASK         0x00000100u
  #define _VP_VDCTL_SCALE_SHIFT        0x00000008u
  #define  VP_VDCTL_SCALE_DEFAULT      0x00000000u
  #define  VP_VDCTL_SCALE_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_SCALE_NONE         0x00000000u
  #define  VP_VDCTL_SCALE_X2           0x00000001u

  #define _VP_VDCTL_CON_MASK         0x00000080u
  #define _VP_VDCTL_CON_SHIFT        0x00000007u
  #define  VP_VDCTL_CON_DEFAULT      0x00000000u
  #define  VP_VDCTL_CON_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_CON_DISABLE      0x00000000u
  #define  VP_VDCTL_CON_ENABLE        0x00000001u

  #define _VP_VDCTL_FRAME_MASK         0x00000040u
  #define _VP_VDCTL_FRAME_SHIFT        0x00000006u
  #define  VP_VDCTL_FRAME_DEFAULT      0x00000000u
  #define  VP_VDCTL_FRAME_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_FRAME_NONE         0x00000000u
  #define  VP_VDCTL_FRAME_FRMDIS       0x00000001u

  #define _VP_VDCTL_DF2_MASK         0x00000020u
  #define _VP_VDCTL_DF2_SHIFT        0x00000005u
  #define  VP_VDCTL_DF2_DEFAULT      0x00000000u
  #define  VP_VDCTL_DF2_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_DF2_NONE         0x00000000u
  #define  VP_VDCTL_DF2_FLDDIS       0x00000001u

  #define _VP_VDCTL_DF1_MASK         0x00000010u
  #define _VP_VDCTL_DF1_SHIFT        0x00000004u
  #define  VP_VDCTL_DF1_DEFAULT      0x00000000u
  #define  VP_VDCTL_DF1_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_DF1_NONE         0x00000000u
  #define  VP_VDCTL_DF1_FLDDIS       0x00000001u

  #define _VP_VDCTL_DMODE_MASK         0x00000007u
  #define _VP_VDCTL_DMODE_SHIFT        0x00000000u
  #define  VP_VDCTL_DMODE_DEFAULT      0x00000000u
  #define  VP_VDCTL_DMODE_OF(x)        _VALUEOF(x)
  #define  VP_VDCTL_DMODE_BT656B       0x00000000u
  #define  VP_VDCTL_DMODE_BT656D       0x00000001u
  #define  VP_VDCTL_DMODE_RAWB         0x00000002u
  #define  VP_VDCTL_DMODE_RAWD         0x00000003u
  #define  VP_VDCTL_DMODE_YC16         0x00000004u
  #define  VP_VDCTL_DMODE_YC20         0x00000005u
  #define  VP_VDCTL_DMODE_RAW16        0x00000006u
  #define  VP_VDCTL_DMODE_RAW20        0x00000007u

  #define  VP_VDCTL_OF(x)            _VALUEOF(x)

  #define VP_VDCTL_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDCTL,RSTCH)\
    |_PER_FDEFAULT(VP,VDCTL,BLKDIS)\
    |_PER_FDEFAULT(VP,VDCTL,PVPSYN)\
    |_PER_FDEFAULT(VP,VDCTL,FXS)\
    |_PER_FDEFAULT(VP,VDCTL,VXS)\
    |_PER_FDEFAULT(VP,VDCTL,HXS)\
    |_PER_FDEFAULT(VP,VDCTL,VCTL2S)\
    |_PER_FDEFAULT(VP,VDCTL,VCTL1S)\
    |_PER_FDEFAULT(VP,VDCTL,VCTL0S)\
    |_PER_FDEFAULT(VP,VDCTL,VDEN)\
    |_PER_FDEFAULT(VP,VDCTL,DPK)\
    |_PER_FDEFAULT(VP,VDCTL,RGBX)\
    |_PER_FDEFAULT(VP,VDCTL,RSYNC)\
    |_PER_FDEFAULT(VP,VDCTL,DVEN)\
    |_PER_FDEFAULT(VP,VDCTL,RESMPL)\
    |_PER_FDEFAULT(VP,VDCTL,SCALE)\
    |_PER_FDEFAULT(VP,VDCTL,CON)\
    |_PER_FDEFAULT(VP,VDCTL,FRAME)\
    |_PER_FDEFAULT(VP,VDCTL,DF2)\
    |_PER_FDEFAULT(VP,VDCTL,DF1)\
    |_PER_FDEFAULT(VP,VDCTL,DMODE)\
  )

  #define VP_VDCTL_RMK(rstch,blkdis,pvpsyn,fxs,vxs,hxs,vctl2s,vctl1s,vctl0s,\
    vden,dpk,rgbx,rsync,dven,resmpl,scale,con,frame,df2,df1,dmode) (Uint32)(\
     _PER_FMK(VP,VDCTL,RSTCH,rstch)\
    |_PER_FMK(VP,VDCTL,BLKDIS,blkdis)\
    |_PER_FMK(VP,VDCTL,PVPSYN,pvpsyn)\
    |_PER_FMK(VP,VDCTL,FXS,fxs)\
    |_PER_FMK(VP,VDCTL,VXS,vxs)\
    |_PER_FMK(VP,VDCTL,HXS,hxs)\
    |_PER_FMK(VP,VDCTL,VCTL2S,vctl2s)\
    |_PER_FMK(VP,VDCTL,VCTL1S,vctl1s)\
    |_PER_FMK(VP,VDCTL,VCTL0S,vctl0s)\
    |_PER_FMK(VP,VDCTL,VDEN,vden)\
    |_PER_FMK(VP,VDCTL,DPK,dpk)\
    |_PER_FMK(VP,VDCTL,RGBX,rgbx)\
    |_PER_FMK(VP,VDCTL,RSYNC,rsync)\
    |_PER_FMK(VP,VDCTL,DVEN,dven)\
    |_PER_FMK(VP,VDCTL,RESMPL,resmpl)\
    |_PER_FMK(VP,VDCTL,SCALE,scale)\
    |_PER_FMK(VP,VDCTL,CON,con)\
    |_PER_FMK(VP,VDCTL,FRAME,frame)\
    |_PER_FMK(VP,VDCTL,DF2,df2)\
    |_PER_FMK(VP,VDCTL,DF1,df1)\
    |_PER_FMK(VP,VDCTL,DMODE,dmode)\
  )

  #define _VP_VDCTL_FGET(N,FIELD)\
    _PER_FGET(_VP_VDCTL##N##_ADDR,VP,VDCTL,##FIELD)

  #define _VP_VDCTL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDCTL##N##_ADDR,VP,VDCTL,##FIELD,field)

  #define _VP_VDCTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDCTL##N##_ADDR,VP,VDCTL,##FIELD,##SYM)

  #define _VP_VDCTL0_FGET(FIELD)   _VP_VDCTL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDCTL1_FGET(FIELD)   _VP_VDCTL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDCTL2_FGET(FIELD)   _VP_VDCTL_FGET(2,##FIELD)
 #endif


  #define _VP_VDCTL0_FSET(FIELD,f)   _VP_VDCTL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDCTL1_FSET(FIELD,f)   _VP_VDCTL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDCTL2_FSET(FIELD,f)   _VP_VDCTL_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDCTL0_FSETS(FIELD,SYM)   _VP_VDCTL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDCTL1_FSETS(FIELD,SYM)   _VP_VDCTL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDCTL2_FSETS(FIELD,SYM)   _VP_VDCTL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D F R M S Z    |
* |___________________|
*
* VDFRMSZ0 -  Video Port 0 Video Display Frame Size
* VDFRMSZ1 -  Video Port 1 Video Display Frame Size
* VDFRMSZ2 -  Video Port 2 Video Display Frame Size
*
* FIELDS (msb -> lsb)
* (rw) FRMHEIGHT
* (rw) FRMWIDTH
*
\******************************************************************************/
  #define _VP_VDFRMSZ_OFFSET           130

  #define _VP_VDFRMSZ0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDFRMSZ_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFRMSZ1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDFRMSZ_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFRMSZ2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDFRMSZ_OFFSET)
 #endif


  #define _VP_VDFRMSZ_FRMHEIGHT_MASK        0x0FFF0000u
  #define _VP_VDFRMSZ_FRMHEIGHT_SHIFT       0x00000010u
  #define  VP_VDFRMSZ_FRMHEIGHT_DEFAULT     0x00000000u
  #define  VP_VDFRMSZ_FRMHEIGHT_OF(x)       _VALUEOF(x)

  #define _VP_VDFRMSZ_FRMWIDTH_MASK        0x00000FFFu
  #define _VP_VDFRMSZ_FRMWIDTH_SHIFT       0x00000000u
  #define  VP_VDFRMSZ_FRMWIDTH_DEFAULT     0x00000000u
  #define  VP_VDFRMSZ_FRMWIDTH_OF(x)       _VALUEOF(x)

  #define  VP_VDFRMSZ_OF(x)            _VALUEOF(x)

  #define VP_VDFRMSZ_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDFRMSZ,FRMHEIGHT)\
    |_PER_FDEFAULT(VP,VDFRMSZ,FRMWIDTH)\
  )

  #define VP_VDFRMSZ_RMK(frmheight,frmwidth) (Uint32)(\
     _PER_FMK(VP,VDFRMSZ,FRMHEIGHT,frmheight)\
    |_PER_FMK(VP,VDFRMSZ,FRMWIDTH,frmwidth)\
  )

  #define _VP_VDFRMSZ_FGET(N,FIELD)\
    _PER_FGET(_VP_VDFRMSZ##N##_ADDR,VP,VDFRMSZ,##FIELD)

  #define _VP_VDFRMSZ_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDFRMSZ##N##_ADDR,VP,VDFRMSZ,##FIELD,field)

  #define _VP_VDFRMSZ_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDFRMSZ##N##_ADDR,VP,VDFRMSZ,##FIELD,##SYM)

  #define _VP_VDFRMSZ0_FGET(FIELD)   _VP_VDFRMSZ_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFRMSZ1_FGET(FIELD)   _VP_VDFRMSZ_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFRMSZ2_FGET(FIELD)   _VP_VDFRMSZ_FGET(2,##FIELD)
 #endif


  #define _VP_VDFRMSZ0_FSET(FIELD,f)   _VP_VDFRMSZ_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFRMSZ1_FSET(FIELD,f)   _VP_VDFRMSZ_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFRMSZ2_FSET(FIELD,f)   _VP_VDFRMSZ_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDFRMSZ0_FSETS(FIELD,SYM)   _VP_VDFRMSZ_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFRMSZ1_FSETS(FIELD,SYM)   _VP_VDFRMSZ_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFRMSZ2_FSETS(FIELD,SYM)   _VP_VDFRMSZ_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D H B L N K    |
* |___________________|
*
* VDHBLNK0 -  Video Port 0 Video Display Horizontal Blanking
* VDHBLNK1 -  Video Port 1 Video Display Horizontal Blanking
* VDHBLNK2 -  Video Port 2 Video Display Horizontal Blanking
*
* FIELDS (msb -> lsb)
* (rw) HBLNKSTOP
* (rw) HBDLA
* (rw) HBLNKSTART
*
\******************************************************************************/
  #define _VP_VDHBLNK_OFFSET           131

  #define _VP_VDHBLNKA_ADDR            (_VP_BASE_PORT0 + 4*_VP_VDHBLNK_OFFSET)
  #define _VP_VDHBLNKB_ADDR            (_VP_BASE_PORT1 + 4*_VP_VDHBLNK_OFFSET)
  #define _VP_VDHBLNKC_ADDR            (_VP_BASE_PORT2 + 4*_VP_VDHBLNK_OFFSET)

  #define _VP_VDHBLNK_HBLNKSTOP_MASK        0x0FFF0000u
  #define _VP_VDHBLNK_HBLNKSTOP_SHIFT       0x00000010u
  #define  VP_VDHBLNK_HBLNKSTOP_DEFAULT     0x00000000u
  #define  VP_VDHBLNK_HBLNKSTOP_OF(x)       _VALUEOF(x)

  #define _VP_VDHBLNK_HBDLA_MASK        0x00008000u
  #define _VP_VDHBLNK_HBDLA_SHIFT       0x0000000Fu
  #define  VP_VDHBLNK_HBDLA_DEFAULT     0x00000000u
  #define  VP_VDHBLNK_HBDLA_OF(x)       _VALUEOF(x)
  #define  VP_VDHBLNK_HBDLA_NONE        0x00000000u
  #define  VP_VDHBLNK_HBDLA_DELAY       0x00000001u

  #define _VP_VDHBLNK_HBLNKSTART_MASK        0x00000FFFu
  #define _VP_VDHBLNK_HBLNKSTART_SHIFT       0x00000000u
  #define  VP_VDHBLNK_HBLNKSTART_DEFAULT     0x00000000u
  #define  VP_VDHBLNK_HBLNKSTART_OF(x)       _VALUEOF(x)

  #define  VP_VDHBLNK_OF(x)            _VALUEOF(x)

  #define VP_VDHBLNK_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDHBLNK,HBLNKSTOP)\
    |_PER_FDEFAULT(VP,VDHBLNK,HBDLA)\
    |_PER_FDEFAULT(VP,VDHBLNK,HBLNKSTART)\
  )

  #define VP_VDHBLNK_RMK(hblnkstop,hbdla,hblnkstart) (Uint32)(\
     _PER_FMK(VP,VDHBLNK,HBLNKSTOP,hblnkstop)\
    |_PER_FMK(VP,VDHBLNK,HBDLA,hbdla)\
    |_PER_FMK(VP,VDHBLNK,HBLNKSTART,hblnkstart)\
  )

  #define _VP_VDHBLNK_FGET(N,FIELD)\
    _PER_FGET(_VP_VDHBLNK##N##_ADDR,VP,VDHBLNK,##FIELD)

  #define _VP_VDHBLNK_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDHBLNK##N##_ADDR,VP,VDHBLNK,##FIELD,field)

  #define _VP_VDHBLNK_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDHBLNK##N##_ADDR,VP,VDHBLNK,##FIELD,##SYM)

  #define _VP_VDHBLNK0_FGET(FIELD)   _VP_VDHBLNK_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDHBLNK1_FGET(FIELD)   _VP_VDHBLNK_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDHBLNK2_FGET(FIELD)   _VP_VDHBLNK_FGET(2,##FIELD)
 #endif


  #define _VP_VDHBLNK0_FSET(FIELD,f)   _VP_VDHBLNK_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDHBLNK1_FSET(FIELD,f)   _VP_VDHBLNK_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDHBLNK2_FSET(FIELD,f)   _VP_VDHBLNK_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDHBLNK0_FSETS(FIELD,SYM)   _VP_VDHBLNK_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDHBLNK1_FSETS(FIELD,SYM)   _VP_VDHBLNK_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDHBLNK2_FSETS(FIELD,SYM)   _VP_VDHBLNK_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D V B L K S 1  |
* |___________________|
*
* VDVBLKS10 -  Video Port 0 Video Display Vertical Blanking Start - Field 1
* VDVBLKS11 -  Video Port 1 Video Display Vertical Blanking Start - Field 1
* VDVBLKS12 -  Video Port 2 Video Display Vertical Blanking Start - Field 1
*
* FIELDS (msb -> lsb)
* (rw) VBLNKYSTART1
* (rw) VBLNKXSTART1
*
\******************************************************************************/
  #define _VP_VDVBLKS1_OFFSET           132

  #define _VP_VDVBLKS10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVBLKS1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKS11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVBLKS1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKS12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVBLKS1_OFFSET)
 #endif


  #define _VP_VDVBLKS1_VBLNKYSTART1_MASK        0x0FFF0000u
  #define _VP_VDVBLKS1_VBLNKYSTART1_SHIFT       0x00000010u
  #define  VP_VDVBLKS1_VBLNKYSTART1_DEFAULT     0x00000000u
  #define  VP_VDVBLKS1_VBLNKYSTART1_OF(x)       _VALUEOF(x)

  #define _VP_VDVBLKS1_VBLNKXSTART1_MASK        0x00000FFFu
  #define _VP_VDVBLKS1_VBLNKXSTART1_SHIFT       0x00000000u
  #define  VP_VDVBLKS1_VBLNKXSTART1_DEFAULT     0x00000000u
  #define  VP_VDVBLKS1_VBLNKXSTART1_OF(x)       _VALUEOF(x)

  #define  VP_VDVBLKS1_OF(x)            _VALUEOF(x)

  #define VP_VDVBLKS1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVBLKS1,VBLNKYSTART1)\
    |_PER_FDEFAULT(VP,VDVBLKS1,VBLNKXSTART1)\
  )

  #define VP_VDVBLKS1_RMK(vblnkystart1,vblnkxstart1) (Uint32)(\
     _PER_FMK(VP,VDVBLKS1,VBLNKYSTART1,vblnkystart1)\
    |_PER_FMK(VP,VDVBLKS1,VBLNKXSTART1,vblnkxstart1)\
  )

  #define _VP_VDVBLKS1_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVBLKS1##N##_ADDR,VP,VDVBLKS1,##FIELD)

  #define _VP_VDVBLKS1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVBLKS1##N##_ADDR,VP,VDVBLKS1,##FIELD,field)

  #define _VP_VDVBLKS1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVBLKS1##N##_ADDR,VP,VDVBLKS1,##FIELD,##SYM)

  #define _VP_VDVBLKS10_FGET(FIELD)   _VP_VDVBLKS1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKS11_FGET(FIELD)   _VP_VDVBLKS1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKS12_FGET(FIELD)   _VP_VDVBLKS1_FGET(2,##FIELD)
 #endif


  #define _VP_VDVBLKS10_FSET(FIELD,f)   _VP_VDVBLKS1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKS11_FSET(FIELD,f)   _VP_VDVBLKS1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKS12_FSET(FIELD,f)   _VP_VDVBLKS1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVBLKS10_FSETS(FIELD,SYM)   _VP_VDVBLKS1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKS11_FSETS(FIELD,SYM)   _VP_VDVBLKS1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKS12_FSETS(FIELD,SYM)   _VP_VDVBLKS1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D V B L K E 1  |
* |___________________|
*
* VDVBLKE10 -  Video Port 0 Video Display Vertical Blanking End - Field 1
* VDVBLKE11 -  Video Port 1 Video Display Vertical Blanking End - Field 1
* VDVBLKE12 -  Video Port 2 Video Display Vertical Blanking End - Field 1
*
* FIELDS (msb -> lsb)
* (rw) VBLNKYSTOP1
* (rw) VBLNKXSTOP1
*
\******************************************************************************/
  #define _VP_VDVBLKE1_OFFSET           133

  #define _VP_VDVBLKE10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVBLKE1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKE11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVBLKE1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKE12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVBLKE1_OFFSET)
 #endif


  #define _VP_VDVBLKE1_VBLNKYSTOP1_MASK        0x0FFF0000u
  #define _VP_VDVBLKE1_VBLNKYSTOP1_SHIFT       0x00000010u
  #define  VP_VDVBLKE1_VBLNKYSTOP1_DEFAULT     0x00000000u
  #define  VP_VDVBLKE1_VBLNKYSTOP1_OF(x)       _VALUEOF(x)

  #define _VP_VDVBLKE1_VBLNKXSTOP1_MASK        0x00000FFFu
  #define _VP_VDVBLKE1_VBLNKXSTOP1_SHIFT       0x00000000u
  #define  VP_VDVBLKE1_VBLNKXSTOP1_DEFAULT     0x00000000u
  #define  VP_VDVBLKE1_VBLNKXSTOP1_OF(x)       _VALUEOF(x)

  #define  VP_VDVBLKE1_OF(x)            _VALUEOF(x)

  #define VP_VDVBLKE1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVBLKE1,VBLNKYSTOP1)\
    |_PER_FDEFAULT(VP,VDVBLKE1,VBLNKXSTOP1)\
  )

  #define VP_VDVBLKE1_RMK(vblnkystop1,vblnkxstop1) (Uint32)(\
     _PER_FMK(VP,VDVBLKE1,VBLNKYSTOP1,vblnkystop1)\
    |_PER_FMK(VP,VDVBLKE1,VBLNKXSTOP1,vblnkxstop1)\
  )

  #define _VP_VDVBLKE1_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVBLKE1##N##_ADDR,VP,VDVBLKE1,##FIELD)

  #define _VP_VDVBLKE1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVBLKE1##N##_ADDR,VP,VDVBLKE1,##FIELD,field)

  #define _VP_VDVBLKE1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVBLKE1##N##_ADDR,VP,VDVBLKE1,##FIELD,##SYM)

  #define _VP_VDVBLKE10_FGET(FIELD)   _VP_VDVBLKE1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKE11_FGET(FIELD)   _VP_VDVBLKE1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKE12_FGET(FIELD)   _VP_VDVBLKE1_FGET(2,##FIELD)
 #endif


  #define _VP_VDVBLKE10_FSET(FIELD,f)   _VP_VDVBLKE1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKE11_FSET(FIELD,f)   _VP_VDVBLKE1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKE12_FSET(FIELD,f)   _VP_VDVBLKE1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVBLKE10_FSETS(FIELD,SYM)   _VP_VDVBLKE1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKE11_FSETS(FIELD,SYM)   _VP_VDVBLKE1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKE12_FSETS(FIELD,SYM)   _VP_VDVBLKE1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D V B L K S 2  |
* |___________________|
*
* VDVBLKS20 -  Video Port 0 Video Display Vertical Blanking Start - Field 2
* VDVBLKS21 -  Video Port 1 Video Display Vertical Blanking Start - Field 2
* VDVBLKS22 -  Video Port 2 Video Display Vertical Blanking Start - Field 2
*
* FIELDS (msb -> lsb)
* (rw) VBLNKYSTART2
* (rw) VBLNKXSTART2
*
\******************************************************************************/
  #define _VP_VDVBLKS2_OFFSET           134

  #define _VP_VDVBLKS20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVBLKS2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKS21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVBLKS2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKS22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVBLKS2_OFFSET)
 #endif


  #define _VP_VDVBLKS2_VBLNKYSTART2_MASK        0x0FFF0000u
  #define _VP_VDVBLKS2_VBLNKYSTART2_SHIFT       0x00000010u
  #define  VP_VDVBLKS2_VBLNKYSTART2_DEFAULT     0x00000000u
  #define  VP_VDVBLKS2_VBLNKYSTART2_OF(x)       _VALUEOF(x)

  #define _VP_VDVBLKS2_VBLNKXSTART2_MASK        0x00000FFFu
  #define _VP_VDVBLKS2_VBLNKXSTART2_SHIFT       0x00000000u
  #define  VP_VDVBLKS2_VBLNKXSTART2_DEFAULT     0x00000000u
  #define  VP_VDVBLKS2_VBLNKXSTART2_OF(x)       _VALUEOF(x)

  #define  VP_VDVBLKS2_OF(x)            _VALUEOF(x)

  #define VP_VDVBLKS2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVBLKS2,VBLNKYSTART2)\
    |_PER_FDEFAULT(VP,VDVBLKS2,VBLNKXSTART2)\
  )

  #define VP_VDVBLKS2_RMK(vblnkystart2,vblnkxstart2) (Uint32)(\
     _PER_FMK(VP,VDVBLKS2,VBLNKYSTART2,vblnkystart2)\
    |_PER_FMK(VP,VDVBLKS2,VBLNKXSTART2,vblnkxstart2)\
  )

  #define _VP_VDVBLKS2_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVBLKS2##N##_ADDR,VP,VDVBLKS2,##FIELD)

  #define _VP_VDVBLKS2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVBLKS2##N##_ADDR,VP,VDVBLKS2,##FIELD,field)

  #define _VP_VDVBLKS2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVBLKS2##N##_ADDR,VP,VDVBLKS2,##FIELD,##SYM)

  #define _VP_VDVBLKS20_FGET(FIELD)   _VP_VDVBLKS2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKS21_FGET(FIELD)   _VP_VDVBLKS2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKS22_FGET(FIELD)   _VP_VDVBLKS2_FGET(2,##FIELD)
 #endif


  #define _VP_VDVBLKS20_FSET(FIELD,f)   _VP_VDVBLKS2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKS21_FSET(FIELD,f)   _VP_VDVBLKS2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKS22_FSET(FIELD,f)   _VP_VDVBLKS2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVBLKS20_FSETS(FIELD,SYM)   _VP_VDVBLKS2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKS21_FSETS(FIELD,SYM)   _VP_VDVBLKS2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKS22_FSETS(FIELD,SYM)   _VP_VDVBLKS2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D V B L K E 2  |
* |___________________|
*
* VDVBLKE20 -  Video Port 0 Video Display Vertical Blanking End - Field 2
* VDVBLKE21 -  Video Port 1 Video Display Vertical Blanking End - Field 2
* VDVBLKE22 -  Video Port 2 Video Display Vertical Blanking End - Field 2
*
* FIELDS (msb -> lsb)
* (rw) VBLNKYSTOP2
* (rw) VBLNKXSTOP2
*
\******************************************************************************/
  #define _VP_VDVBLKE2_OFFSET           135

  #define _VP_VDVBLKE20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVBLKE2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKE21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVBLKE2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKE22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVBLKE2_OFFSET)
 #endif


  #define _VP_VDVBLKE2_VBLNKYSTOP2_MASK        0x0FFF0000u
  #define _VP_VDVBLKE2_VBLNKYSTOP2_SHIFT       0x00000010u
  #define  VP_VDVBLKE2_VBLNKYSTOP2_DEFAULT     0x00000000u
  #define  VP_VDVBLKE2_VBLNKYSTOP2_OF(x)       _VALUEOF(x)

  #define _VP_VDVBLKE2_VBLNKXSTOP2_MASK        0x00000FFFu
  #define _VP_VDVBLKE2_VBLNKXSTOP2_SHIFT       0x00000000u
  #define  VP_VDVBLKE2_VBLNKXSTOP2_DEFAULT     0x00000000u
  #define  VP_VDVBLKE2_VBLNKXSTOP2_OF(x)       _VALUEOF(x)

  #define  VP_VDVBLKE2_OF(x)            _VALUEOF(x)

  #define VP_VDVBLKE2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVBLKE2,VBLNKYSTOP2)\
    |_PER_FDEFAULT(VP,VDVBLKE2,VBLNKXSTOP2)\
  )

  #define VP_VDVBLKE2_RMK(vblnkystop2,vblnkxstop2) (Uint32)(\
     _PER_FMK(VP,VDVBLKE2,VBLNKYSTOP2,vblnkystop2)\
    |_PER_FMK(VP,VDVBLKE2,VBLNKXSTOP2,vblnkxstop2)\
  )

  #define _VP_VDVBLKE2_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVBLKE2##N##_ADDR,VP,VDVBLKE2,##FIELD)

  #define _VP_VDVBLKE2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVBLKE2##N##_ADDR,VP,VDVBLKE2,##FIELD,field)

  #define _VP_VDVBLKE2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVBLKE2##N##_ADDR,VP,VDVBLKE2,##FIELD,##SYM)

  #define _VP_VDVBLKE20_FGET(FIELD)   _VP_VDVBLKE2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKE21_FGET(FIELD)   _VP_VDVBLKE2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKE22_FGET(FIELD)   _VP_VDVBLKE2_FGET(2,##FIELD)
 #endif


  #define _VP_VDVBLKE20_FSET(FIELD,f)   _VP_VDVBLKE2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKE21_FSET(FIELD,f)   _VP_VDVBLKE2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKE22_FSET(FIELD,f)   _VP_VDVBLKE2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVBLKE20_FSETS(FIELD,SYM)   _VP_VDVBLKE2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBLKE21_FSETS(FIELD,SYM)   _VP_VDVBLKE2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBLKE22_FSETS(FIELD,SYM)   _VP_VDVBLKE2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* ______________________
* |                    |
* |  V D I M G O F F 1 |
* |____________________|
*
* VDIMGOFF10 -  Video Port 0 Video Display Image Offset - Field 1
* VDIMGOFF11 -  Video Port 1 Video Display Image Offset - Field 1
* VDIMGOFF12 -  Video Port 2 Video Display Image Offset - Field 1
*
* FIELDS (msb -> lsb)
* (rw) NV
* (rw) IMGVOFF1
* (rw) NH
* (rw) IMGHOFF1
*
\******************************************************************************/
  #define _VP_VDIMGOFF1_OFFSET             136

  #define _VP_VDIMGOFF10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDIMGOFF1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGOFF11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDIMGOFF1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGOFF12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDIMGOFF1_OFFSET)
 #endif


  #define _VP_VDIMGOFF1_NV_MASK            0x80000000u
  #define _VP_VDIMGOFF1_NV_SHIFT           0x0000001Fu
  #define  VP_VDIMGOFF1_NV_DEFAULT         0x00000000u
  #define  VP_VDIMGOFF1_NV_OF(x)           _VALUEOF(x)
  #define  VP_VDIMGOFF1_NV_NONE            0x00000000u
  #define  VP_VDIMGOFF1_NV_NEGOFF          0x00000001u

  #define _VP_VDIMGOFF1_IMGVOFF1_MASK      0x0FFF0000u
  #define _VP_VDIMGOFF1_IMGVOFF1_SHIFT     0x00000010u
  #define  VP_VDIMGOFF1_IMGVOFF1_DEFAULT   0x00000000u
  #define  VP_VDIMGOFF1_IMGVOFF1_OF(x)     _VALUEOF(x)

  #define _VP_VDIMGOFF1_NH_MASK            0x00008000u
  #define _VP_VDIMGOFF1_NH_SHIFT           0x0000000Fu
  #define  VP_VDIMGOFF1_NH_DEFAULT         0x00000000u
  #define  VP_VDIMGOFF1_NH_OF(x)           _VALUEOF(x)
  #define  VP_VDIMGOFF1_NH_NONE            0x00000000u
  #define  VP_VDIMGOFF1_NH_NEGOFF          0x00000001u

  #define _VP_VDIMGOFF1_IMGHOFF1_MASK      0x00000FFFu
  #define _VP_VDIMGOFF1_IMGHOFF1_SHIFT     0x00000000u
  #define  VP_VDIMGOFF1_IMGHOFF1_DEFAULT   0x00000000u
  #define  VP_VDIMGOFF1_IMGHOFF1_OF(x)     _VALUEOF(x)

  #define  VP_VDIMGOFF1_OF(x)            _VALUEOF(x)

  #define VP_VDIMGOFF1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDIMGOFF1,NV)\
    |_PER_FDEFAULT(VP,VDIMGOFF1,IMGVOFF1)\
    |_PER_FDEFAULT(VP,VDIMGOFF1,NH)\
    |_PER_FDEFAULT(VP,VDIMGOFF1,IMGHOFF1)\
  )

  #define VP_VDIMGOFF1_RMK(nv,imgvoff1,nh,imghoff1) (Uint32)(\
     _PER_FMK(VP,VDIMGOFF1,NV,nv)\
    |_PER_FMK(VP,VDIMGOFF1,IMGVOFF1,imgvoff1)\
    |_PER_FMK(VP,VDIMGOFF1,NH,nh)\
    |_PER_FMK(VP,VDIMGOFF1,IMGHOFF1,imghoff1)\
  )

  #define _VP_VDIMGOFF1_FGET(N,FIELD)\
    _PER_FGET(_VP_VDIMGOFF1##N##_ADDR,VP,VDIMGOFF1,##FIELD)

  #define _VP_VDIMGOFF1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDIMGOFF1##N##_ADDR,VP,VDIMGOFF1,##FIELD,field)

  #define _VP_VDIMGOFF1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDIMGOFF1##N##_ADDR,VP,VDIMGOFF1,##FIELD,##SYM)

  #define _VP_VDIMGOFF10_FGET(FIELD)   _VP_VDIMGOFF1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGOFF11_FGET(FIELD)   _VP_VDIMGOFF1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGOFF12_FGET(FIELD)   _VP_VDIMGOFF1_FGET(2,##FIELD)
 #endif


  #define _VP_VDIMGOFF10_FSET(FIELD,f)   _VP_VDIMGOFF1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGOFF11_FSET(FIELD,f)   _VP_VDIMGOFF1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGOFF12_FSET(FIELD,f)   _VP_VDIMGOFF1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDIMGOFF10_FSETS(FIELD,SYM)   _VP_VDIMGOFF1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGOFF11_FSETS(FIELD,SYM)   _VP_VDIMGOFF1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGOFF12_FSETS(FIELD,SYM)   _VP_VDIMGOFF1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D I M G S Z 1  |
* |___________________|
*
* VDIMGSZ10 -  Video Port 0 Video Display Image Size - Field 1
* VDIMGSZ11 -  Video Port 1 Video Display Image Size - Field 1
* VDIMGSZ12 -  Video Port 2 Video Display Image Size - Field 1
*
* FIELDS (msb -> lsb)
* (rw) IMGVSIZE1
* (rw) IMGHSIZE1
*
\******************************************************************************/
  #define _VP_VDIMGSZ1_OFFSET           137

  #define _VP_VDIMGSZ10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDIMGSZ1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGSZ11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDIMGSZ1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGSZ12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDIMGSZ1_OFFSET)
 #endif


  #define _VP_VDIMGSZ1_IMGVSIZE1_MASK        0x0FFF0000u
  #define _VP_VDIMGSZ1_IMGVSIZE1_SHIFT       0x00000010u
  #define  VP_VDIMGSZ1_IMGVSIZE1_DEFAULT     0x00000000u
  #define  VP_VDIMGSZ1_IMGVSIZE1_OF(x)       _VALUEOF(x)

  #define _VP_VDIMGSZ1_IMGHSIZE1_MASK        0x00000FFFu
  #define _VP_VDIMGSZ1_IMGHSIZE1_SHIFT       0x00000000u
  #define  VP_VDIMGSZ1_IMGHSIZE1_DEFAULT     0x00000000u
  #define  VP_VDIMGSZ1_IMGHSIZE1_OF(x)       _VALUEOF(x)

  #define  VP_VDIMGSZ1_OF(x)            _VALUEOF(x)

  #define VP_VDIMGSZ1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDIMGSZ1,IMGVSIZE1)\
    |_PER_FDEFAULT(VP,VDIMGSZ1,IMGHSIZE1)\
  )

  #define VP_VDIMGSZ1_RMK(imgvsize1,imghsize1) (Uint32)(\
     _PER_FMK(VP,VDIMGSZ1,IMGVSIZE1,imgvsize1)\
    |_PER_FMK(VP,VDIMGSZ1,IMGHSIZE1,imghsize1)\
  )

  #define _VP_VDIMGSZ1_FGET(N,FIELD)\
    _PER_FGET(_VP_VDIMGSZ1##N##_ADDR,VP,VDIMGSZ1,##FIELD)

  #define _VP_VDIMGSZ1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDIMGSZ1##N##_ADDR,VP,VDIMGSZ1,##FIELD,field)

  #define _VP_VDIMGSZ1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDIMGSZ1##N##_ADDR,VP,VDIMGSZ1,##FIELD,##SYM)

  #define _VP_VDIMGSZ10_FGET(FIELD)   _VP_VDIMGSZ1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGSZ11_FGET(FIELD)   _VP_VDIMGSZ1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGSZ12_FGET(FIELD)   _VP_VDIMGSZ1_FGET(2,##FIELD)
 #endif


  #define _VP_VDIMGSZ10_FSET(FIELD,f)   _VP_VDIMGSZ1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGSZ11_FSET(FIELD,f)   _VP_VDIMGSZ1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGSZ12_FSET(FIELD,f)   _VP_VDIMGSZ1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDIMGSZ10_FSETS(FIELD,SYM)   _VP_VDIMGSZ1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGSZ11_FSETS(FIELD,SYM)   _VP_VDIMGSZ1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGSZ12_FSETS(FIELD,SYM)   _VP_VDIMGSZ1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* ______________________
* |                    |
* |  V D I M G O F F 2 |
* |____________________|
*
* VDIMGOFF20    -  Video Port 0 Video Display Image Offset - Field 2
* VDIMGOFF21    -  Video Port 1 Video Display Image Offset - Field 2
* VDIMGOFF22    -  Video Port 2 Video Display Image Offset - Field 2
*
* FIELDS (msb -> lsb)
* (rw) NV
* (rw) IMGVOFF2
* (rw) NH
* (rw) IMGHOFF2
*
\******************************************************************************/
  #define _VP_VDIMGOFF2_OFFSET           138

  #define _VP_VDIMGOFF20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDIMGOFF2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGOFF21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDIMGOFF2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGOFF22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDIMGOFF2_OFFSET)
 #endif


  #define _VP_VDIMGOFF2_NV_MASK            0x80000000u
  #define _VP_VDIMGOFF2_NV_SHIFT           0x0000001Fu
  #define  VP_VDIMGOFF2_NV_DEFAULT         0x00000000u
  #define  VP_VDIMGOFF2_NV_OF(x)           _VALUEOF(x)
  #define  VP_VDIMGOFF2_NV_NONE            0x00000000u
  #define  VP_VDIMGOFF2_NV_NEGOFF          0x00000001u

  #define _VP_VDIMGOFF2_IMGVOFF2_MASK        0x0FFF0000u
  #define _VP_VDIMGOFF2_IMGVOFF2_SHIFT       0x00000010u
  #define  VP_VDIMGOFF2_IMGVOFF2_DEFAULT     0x00000000u
  #define  VP_VDIMGOFF2_IMGVOFF2_OF(x)       _VALUEOF(x)

  #define _VP_VDIMGOFF2_NH_MASK            0x00008000u
  #define _VP_VDIMGOFF2_NH_SHIFT           0x0000000Fu
  #define  VP_VDIMGOFF2_NH_DEFAULT         0x00000000u
  #define  VP_VDIMGOFF2_NH_OF(x)           _VALUEOF(x)
  #define  VP_VDIMGOFF2_NH_NONE            0x00000000u
  #define  VP_VDIMGOFF2_NH_NEGOFF          0x00000001u

  #define _VP_VDIMGOFF2_IMGHOFF2_MASK        0x00000FFFu
  #define _VP_VDIMGOFF2_IMGHOFF2_SHIFT       0x00000000u
  #define  VP_VDIMGOFF2_IMGHOFF2_DEFAULT     0x00000000u
  #define  VP_VDIMGOFF2_IMGHOFF2_OF(x)       _VALUEOF(x)

  #define  VP_VDIMGOFF2_OF(x)            _VALUEOF(x)

  #define VP_VDIMGOFF2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDIMGOFF2,NV)\
    |_PER_FDEFAULT(VP,VDIMGOFF2,IMGVOFF2)\
    |_PER_FDEFAULT(VP,VDIMGOFF2,NH)\
    |_PER_FDEFAULT(VP,VDIMGOFF2,IMGHOFF2)\
  )

  #define VP_VDIMGOFF2_RMK(nv,imgvoff2,nh,imghoff2) (Uint32)(\
     _PER_FMK(VP,VDIMGOFF2,NV,nv)\
    |_PER_FMK(VP,VDIMGOFF2,IMGVOFF2,imgvoff2)\
    |_PER_FMK(VP,VDIMGOFF2,NH,nh)\
    |_PER_FMK(VP,VDIMGOFF2,IMGHOFF2,imghoff2)\
  )

  #define _VP_VDIMGOFF2_FGET(N,FIELD)\
    _PER_FGET(_VP_VDIMGOFF2##N##_ADDR,VP,VDIMGOFF2,##FIELD)

  #define _VP_VDIMGOFF2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDIMGOFF2##N##_ADDR,VP,VDIMGOFF2,##FIELD,field)

  #define _VP_VDIMGOFF2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDIMGOFF2##N##_ADDR,VP,VDIMGOFF2,##FIELD,##SYM)

  #define _VP_VDIMGOFF20_FGET(FIELD)   _VP_VDIMGOFF2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGOFF21_FGET(FIELD)   _VP_VDIMGOFF2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGOFF22_FGET(FIELD)   _VP_VDIMGOFF2_FGET(2,##FIELD)
 #endif


  #define _VP_VDIMGOFF20_FSET(FIELD,f)   _VP_VDIMGOFF2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGOFF21_FSET(FIELD,f)   _VP_VDIMGOFF2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGOFF22_FSET(FIELD,f)   _VP_VDIMGOFF2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDIMGOFF20_FSETS(FIELD,SYM)   _VP_VDIMGOFF2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGOFF21_FSETS(FIELD,SYM)   _VP_VDIMGOFF2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGOFF22_FSETS(FIELD,SYM)   _VP_VDIMGOFF2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D I M G S Z 2  |
* |___________________|
*
* VDIMGSZ20 -  Video Port 0 Video Display Image Size - Field 2
* VDIMGSZ21 -  Video Port 1 Video Display Image Size - Field 2
* VDIMGSZ22 -  Video Port 2 Video Display Image Size - Field 2
*
* FIELDS (msb -> lsb)
* (rw) IMGVSIZE2
* (rw) IMGHSIZE2
*
\******************************************************************************/
  #define _VP_VDIMGSZ2_OFFSET           139

  #define _VP_VDIMGSZ20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDIMGSZ2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGSZ21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDIMGSZ2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGSZ22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDIMGSZ2_OFFSET)
 #endif


  #define _VP_VDIMGSZ2_IMGVSIZE2_MASK        0x0FFF0000u
  #define _VP_VDIMGSZ2_IMGVSIZE2_SHIFT       0x00000010u
  #define  VP_VDIMGSZ2_IMGVSIZE2_DEFAULT     0x00000000u
  #define  VP_VDIMGSZ2_IMGVSIZE2_OF(x)       _VALUEOF(x)

  #define _VP_VDIMGSZ2_IMGHSIZE2_MASK        0x00000FFFu
  #define _VP_VDIMGSZ2_IMGHSIZE2_SHIFT       0x00000000u
  #define  VP_VDIMGSZ2_IMGHSIZE2_DEFAULT     0x00000000u
  #define  VP_VDIMGSZ2_IMGHSIZE2_OF(x)       _VALUEOF(x)

  #define  VP_VDIMGSZ2_OF(x)            _VALUEOF(x)

  #define VP_VDIMGSZ2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDIMGSZ2,IMGVSIZE2)\
    |_PER_FDEFAULT(VP,VDIMGSZ2,IMGHSIZE2)\
  )

  #define VP_VDIMGSZ2_RMK(imgvsize2,imghsize2) (Uint32)(\
     _PER_FMK(VP,VDIMGSZ2,IMGVSIZE2,imgvsize2)\
    |_PER_FMK(VP,VDIMGSZ2,IMGHSIZE2,imghsize2)\
  )

  #define _VP_VDIMGSZ2_FGET(N,FIELD)\
    _PER_FGET(_VP_VDIMGSZ2##N##_ADDR,VP,VDIMGSZ2,##FIELD)

  #define _VP_VDIMGSZ2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDIMGSZ2##N##_ADDR,VP,VDIMGSZ2,##FIELD,field)

  #define _VP_VDIMGSZ2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDIMGSZ2##N##_ADDR,VP,VDIMGSZ2,##FIELD,##SYM)

  #define _VP_VDIMGSZ20_FGET(FIELD)   _VP_VDIMGSZ2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGSZ21_FGET(FIELD)   _VP_VDIMGSZ2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGSZ22_FGET(FIELD)   _VP_VDIMGSZ2_FGET(2,##FIELD)
 #endif


  #define _VP_VDIMGSZ20_FSET(FIELD,f)   _VP_VDIMGSZ2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGSZ21_FSET(FIELD,f)   _VP_VDIMGSZ2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGSZ22_FSET(FIELD,f)   _VP_VDIMGSZ2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDIMGSZ20_FSETS(FIELD,SYM)   _VP_VDIMGSZ2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDIMGSZ21_FSETS(FIELD,SYM)   _VP_VDIMGSZ2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDIMGSZ22_FSETS(FIELD,SYM)   _VP_VDIMGSZ2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D F L D T 1    |
* |___________________|
*
* VDFLDT10 -  Video Port 0 Video Display Field1 Timing
* VDFLDT11 -  Video Port 1 Video Display Field1 Timing
* VDFLDT12 -  Video Port 2 Video Display Field1 Timing
*
* FIELDS (msb -> lsb)
* (rw) FLD1YSTART
* (rw) FLD1XSTART
*
\******************************************************************************/
  #define _VP_VDFLDT1_OFFSET           140

  #define _VP_VDFLDT10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDFLDT1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFLDT11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDFLDT1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFLDT12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDFLDT1_OFFSET)
 #endif


  #define _VP_VDFLDT1_FLD1YSTART_MASK        0x0FFF0000u
  #define _VP_VDFLDT1_FLD1YSTART_SHIFT       0x00000010u
  #define  VP_VDFLDT1_FLD1YSTART_DEFAULT     0x00000000u
  #define  VP_VDFLDT1_FLD1YSTART_OF(x)       _VALUEOF(x)

  #define _VP_VDFLDT1_FLD1XSTART_MASK        0x00000FFFu
  #define _VP_VDFLDT1_FLD1XSTART_SHIFT       0x00000000u
  #define  VP_VDFLDT1_FLD1XSTART_DEFAULT     0x00000000u
  #define  VP_VDFLDT1_FLD1XSTART_OF(x)       _VALUEOF(x)

  #define  VP_VDFLDT1_OF(x)            _VALUEOF(x)

  #define VP_VDFLDT1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDFLDT1,FLD1YSTART)\
    |_PER_FDEFAULT(VP,VDFLDT1,FLD1XSTART)\
  )

  #define VP_VDFLDT1_RMK(fld1ystart,fld1xstart) (Uint32)(\
     _PER_FMK(VP,VDFLDT1,FLD1YSTART,fld1ystart)\
    |_PER_FMK(VP,VDFLDT1,FLD1XSTART,fld1xstart)\
  )

  #define _VP_VDFLDT1_FGET(N,FIELD)\
    _PER_FGET(_VP_VDFLDT1##N##_ADDR,VP,VDFLDT1,##FIELD)

  #define _VP_VDFLDT1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDFLDT1##N##_ADDR,VP,VDFLDT1,##FIELD,field)

  #define _VP_VDFLDT1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDFLDT1##N##_ADDR,VP,VDFLDT1,##FIELD,##SYM)

  #define _VP_VDFLDT10_FGET(FIELD)   _VP_VDFLDT1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFLDT11_FGET(FIELD)   _VP_VDFLDT1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFLDT12_FGET(FIELD)   _VP_VDFLDT1_FGET(2,##FIELD)
 #endif


  #define _VP_VDFLDT10_FSET(FIELD,f)   _VP_VDFLDT1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFLDT11_FSET(FIELD,f)   _VP_VDFLDT1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFLDT12_FSET(FIELD,f)   _VP_VDFLDT1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDFLDT10_FSETS(FIELD,SYM)   _VP_VDFLDT1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFLDT11_FSETS(FIELD,SYM)   _VP_VDFLDT1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFLDT12_FSETS(FIELD,SYM)   _VP_VDFLDT1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D F L D T 2    |
* |___________________|
*
* VDFLDT20 -  Video Port 0 Video Display Field2 Timing
* VDFLDT21 -  Video Port 1 Video Display Field2 Timing
* VDFLDT22 -  Video Port 2 Video Display Field2 Timing
*
* FIELDS (msb -> lsb)
* (rw) FLD2YSTART
* (rw) FLD2XSTART
*
\******************************************************************************/
  #define _VP_VDFLDT2_OFFSET           141

  #define _VP_VDFLDT20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDFLDT2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFLDT21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDFLDT2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFLDT22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDFLDT2_OFFSET)
 #endif


  #define _VP_VDFLDT2_FLD2YSTART_MASK        0x0FFF0000u
  #define _VP_VDFLDT2_FLD2YSTART_SHIFT       0x00000010u
  #define  VP_VDFLDT2_FLD2YSTART_DEFAULT     0x00000000u
  #define  VP_VDFLDT2_FLD2YSTART_OF(x)       _VALUEOF(x)

  #define _VP_VDFLDT2_FLD2XSTART_MASK        0x00000FFFu
  #define _VP_VDFLDT2_FLD2XSTART_SHIFT       0x00000000u
  #define  VP_VDFLDT2_FLD2XSTART_DEFAULT     0x00000000u
  #define  VP_VDFLDT2_FLD2XSTART_OF(x)       _VALUEOF(x)

  #define  VP_VDFLDT2_OF(x)            _VALUEOF(x)

  #define VP_VDFLDT2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDFLDT2,FLD2YSTART)\
    |_PER_FDEFAULT(VP,VDFLDT2,FLD2XSTART)\
  )

  #define VP_VDFLDT2_RMK(fld2ystart,fld2xstart) (Uint32)(\
     _PER_FMK(VP,VDFLDT2,FLD2YSTART,fld2ystart)\
    |_PER_FMK(VP,VDFLDT2,FLD2XSTART,fld2xstart)\
  )

  #define _VP_VDFLDT2_FGET(N,FIELD)\
    _PER_FGET(_VP_VDFLDT2##N##_ADDR,VP,VDFLDT2,##FIELD)

  #define _VP_VDFLDT2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDFLDT2##N##_ADDR,VP,VDFLDT2,##FIELD,field)

  #define _VP_VDFLDT2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDFLDT2##N##_ADDR,VP,VDFLDT2,##FIELD,##SYM)

  #define _VP_VDFLDT20_FGET(FIELD)   _VP_VDFLDT2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFLDT21_FGET(FIELD)   _VP_VDFLDT2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFLDT22_FGET(FIELD)   _VP_VDFLDT2_FGET(2,##FIELD)
 #endif


  #define _VP_VDFLDT20_FSET(FIELD,f)   _VP_VDFLDT2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFLDT21_FSET(FIELD,f)   _VP_VDFLDT2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFLDT22_FSET(FIELD,f)   _VP_VDFLDT2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDFLDT20_FSETS(FIELD,SYM)   _VP_VDFLDT2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFLDT21_FSETS(FIELD,SYM)   _VP_VDFLDT2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFLDT22_FSETS(FIELD,SYM)   _VP_VDFLDT2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D T H R L D    |
* |___________________|
*
* VDTHRLD0 -  Video Port 0 Video Display Threshold
* VDTHRLD1 -  Video Port 1 Video Display Threshold
* VDTHRLD2 -  Video Port 2 Video Display Threshold
*
* FIELDS (msb -> lsb)
* (rw) VDTHRLD2
* (rw) INCPIX
* (rw) VDTHRLD1
*
\******************************************************************************/
  #define _VP_VDTHRLD_OFFSET           142

  #define _VP_VDTHRLD0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDTHRLD_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDTHRLD1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDTHRLD_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDTHRLD2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDTHRLD_OFFSET)
 #endif


  #define _VP_VDTHRLD_VDTHRLD2_MASK        0x03FF0000u
  #define _VP_VDTHRLD_VDTHRLD2_SHIFT       0x00000010u
  #define  VP_VDTHRLD_VDTHRLD2_DEFAULT     0x00000000u
  #define  VP_VDTHRLD_VDTHRLD2_OF(x)       _VALUEOF(x)

  #define _VP_VDTHRLD_INCPIX_MASK        0x0000F000u
  #define _VP_VDTHRLD_INCPIX_SHIFT       0x0000000Cu
  #define  VP_VDTHRLD_INCPIX_DEFAULT     0x00000001u
  #define  VP_VDTHRLD_INCPIX_OF(x)       _VALUEOF(x)

  #define _VP_VDTHRLD_VDTHRLD1_MASK        0x000003FFu
  #define _VP_VDTHRLD_VDTHRLD1_SHIFT       0x00000000u
  #define  VP_VDTHRLD_VDTHRLD1_DEFAULT     0x00000000u
  #define  VP_VDTHRLD_VDTHRLD1_OF(x)       _VALUEOF(x)

  #define  VP_VDTHRLD_OF(x)            _VALUEOF(x)

  #define VP_VDTHRLD_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDTHRLD,VDTHRLD2)\
    |_PER_FDEFAULT(VP,VDTHRLD,INCPIX)\
    |_PER_FDEFAULT(VP,VDTHRLD,VDTHRLD1)\
  )

  #define VP_VDTHRLD_RMK(vdthrld2,incpix,vdthrld1) (Uint32)(\
     _PER_FMK(VP,VDTHRLD,VDTHRLD2,vdthrld2)\
    |_PER_FMK(VP,VDTHRLD,INCPIX,incpix)\
    |_PER_FMK(VP,VDTHRLD,VDTHRLD1,vdthrld1)\
  )

  #define _VP_VDTHRLD_FGET(N,FIELD)\
    _PER_FGET(_VP_VDTHRLD##N##_ADDR,VP,VDTHRLD,##FIELD)

  #define _VP_VDTHRLD_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDTHRLD##N##_ADDR,VP,VDTHRLD,##FIELD,field)

  #define _VP_VDTHRLD_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDTHRLD##N##_ADDR,VP,VDTHRLD,##FIELD,##SYM)

  #define _VP_VDTHRLD0_FGET(FIELD)   _VP_VDTHRLD_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDTHRLD1_FGET(FIELD)   _VP_VDTHRLD_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDTHRLD2_FGET(FIELD)   _VP_VDTHRLD_FGET(2,##FIELD)
 #endif


  #define _VP_VDTHRLD0_FSET(FIELD,f)   _VP_VDTHRLD_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDTHRLD1_FSET(FIELD,f)   _VP_VDTHRLD_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDTHRLD2_FSET(FIELD,f)   _VP_VDTHRLD_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDTHRLD0_FSETS(FIELD,SYM)   _VP_VDTHRLD_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDTHRLD1_FSETS(FIELD,SYM)   _VP_VDTHRLD_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDTHRLD2_FSETS(FIELD,SYM)   _VP_VDTHRLD_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D H S Y N C    |
* |___________________|
*
* VDHSYNC0 -  Video Port 0 Video Display Horizontal Sync
* VDHSYNC1 -  Video Port 1 Video Display Horizontal Sync
* VDHSYNC2 -  Video Port 2 Video Display Horizontal Sync
*
* FIELDS (msb -> lsb)
* (rw) HSYNCSTOP
* (rw) HSYNCSTART
*
\******************************************************************************/
  #define _VP_VDHSYNC_OFFSET           143

  #define _VP_VDHSYNC0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDHSYNC_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDHSYNC1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDHSYNC_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDHSYNC2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDHSYNC_OFFSET)
 #endif


  #define _VP_VDHSYNC_HSYNCSTOP_MASK        0x0FFF0000u
  #define _VP_VDHSYNC_HSYNCSTOP_SHIFT       0x00000010u
  #define  VP_VDHSYNC_HSYNCSTOP_DEFAULT     0x00000000u
  #define  VP_VDHSYNC_HSYNCSTOP_OF(x)       _VALUEOF(x)

  #define _VP_VDHSYNC_HSYNCSTART_MASK        0x00000FFFu
  #define _VP_VDHSYNC_HSYNCSTART_SHIFT       0x00000000u
  #define  VP_VDHSYNC_HSYNCSTART_DEFAULT     0x00000000u
  #define  VP_VDHSYNC_HSYNCSTART_OF(x)       _VALUEOF(x)

  #define  VP_VDHSYNC_OF(x)            _VALUEOF(x)

  #define VP_VDHSYNC_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDHSYNC,HSYNCSTOP)\
    |_PER_FDEFAULT(VP,VDHSYNC,HSYNCSTART)\
  )

  #define VP_VDHSYNC_RMK(hsyncstop,hsyncstart) (Uint32)(\
     _PER_FMK(VP,VDHSYNC,HSYNCSTOP,hsyncstop)\
    |_PER_FMK(VP,VDHSYNC,HSYNCSTART,hsyncstart)\
  )

  #define _VP_VDHSYNC_FGET(N,FIELD)\
    _PER_FGET(_VP_VDHSYNC##N##_ADDR,VP,VDHSYNC,##FIELD)

  #define _VP_VDHSYNC_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDHSYNC##N##_ADDR,VP,VDHSYNC,##FIELD,field)

  #define _VP_VDHSYNC_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDHSYNC##N##_ADDR,VP,VDHSYNC,##FIELD,##SYM)

  #define _VP_VDHSYNC0_FGET(FIELD)   _VP_VDHSYNC_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDHSYNC1_FGET(FIELD)   _VP_VDHSYNC_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDHSYNC2_FGET(FIELD)   _VP_VDHSYNC_FGET(2,##FIELD)
 #endif


  #define _VP_VDHSYNC0_FSET(FIELD,f)   _VP_VDHSYNC_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDHSYNC1_FSET(FIELD,f)   _VP_VDHSYNC_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDHSYNC2_FSET(FIELD,f)   _VP_VDHSYNC_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDHSYNC0_FSETS(FIELD,SYM)   _VP_VDHSYNC_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDHSYNC1_FSETS(FIELD,SYM)   _VP_VDHSYNC_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDHSYNC2_FSETS(FIELD,SYM)   _VP_VDHSYNC_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D V S Y N S 1  |
* |___________________|
*
* VDVSYNS10 -  Video Port 0 Video Display Vertical Sync. Start - Field 1
* VDVSYNS11 -  Video Port 1 Video Display Vertical Sync. Start - Field 1
* VDVSYNS12 -  Video Port 2 Video Display Vertical Sync. Start - Field 1
*
* FIELDS (msb -> lsb)
* (rw) VSYNCYSTART1
* (rw) VSYNCXSTART1
*
\******************************************************************************/
  #define _VP_VDVSYNS1_OFFSET           144

  #define _VP_VDVSYNS10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVSYNS1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNS11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVSYNS1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNS12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVSYNS1_OFFSET)
 #endif


  #define _VP_VDVSYNS1_VSYNCYSTART1_MASK        0x0FFF0000u
  #define _VP_VDVSYNS1_VSYNCYSTART1_SHIFT       0x00000010u
  #define  VP_VDVSYNS1_VSYNCYSTART1_DEFAULT     0x00000000u
  #define  VP_VDVSYNS1_VSYNCYSTART1_OF(x)       _VALUEOF(x)

  #define _VP_VDVSYNS1_VSYNCXSTART1_MASK        0x00000FFFu
  #define _VP_VDVSYNS1_VSYNCXSTART1_SHIFT       0x00000000u
  #define  VP_VDVSYNS1_VSYNCXSTART1_DEFAULT     0x00000000u
  #define  VP_VDVSYNS1_VSYNCXSTART1_OF(x)       _VALUEOF(x)

  #define  VP_VDVSYNS1_OF(x)            _VALUEOF(x)

  #define VP_VDVSYNS1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVSYNS1,VSYNCYSTART1)\
    |_PER_FDEFAULT(VP,VDVSYNS1,VSYNCXSTART1)\
  )

  #define VP_VDVSYNS1_RMK(vsyncystart1,vsyncxstart1) (Uint32)(\
     _PER_FMK(VP,VDVSYNS1,VSYNCYSTART1,vsyncystart1)\
    |_PER_FMK(VP,VDVSYNS1,VSYNCXSTART1,vsyncxstart1)\
  )

  #define _VP_VDVSYNS1_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVSYNS1##N##_ADDR,VP,VDVSYNS1,##FIELD)

  #define _VP_VDVSYNS1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVSYNS1##N##_ADDR,VP,VDVSYNS1,##FIELD,field)

  #define _VP_VDVSYNS1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVSYNS1##N##_ADDR,VP,VDVSYNS1,##FIELD,##SYM)

  #define _VP_VDVSYNS10_FGET(FIELD)   _VP_VDVSYNS1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNS11_FGET(FIELD)   _VP_VDVSYNS1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNS12_FGET(FIELD)   _VP_VDVSYNS1_FGET(2,##FIELD)
 #endif


  #define _VP_VDVSYNS10_FSET(FIELD,f)   _VP_VDVSYNS1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNS11_FSET(FIELD,f)   _VP_VDVSYNS1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNS12_FSET(FIELD,f)   _VP_VDVSYNS1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVSYNS10_FSETS(FIELD,SYM)   _VP_VDVSYNS1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNS11_FSETS(FIELD,SYM)   _VP_VDVSYNS1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNS12_FSETS(FIELD,SYM)   _VP_VDVSYNS1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D V S Y N E 1  |
* |___________________|
*
* VDVSYNE10 -  Video Port 0 Video Display Vertical Sync. End - Field 1
* VDVSYNE11 -  Video Port 1 Video Display Vertical Sync. End - Field 1
* VDVSYNE12 -  Video Port 2 Video Display Vertical Sync. End - Field 1
*
* FIELDS (msb -> lsb)
* (rw) VSYNCYSTOP1
* (rw) VSYNCXSTOP1
*
\******************************************************************************/
  #define _VP_VDVSYNE1_OFFSET           145

  #define _VP_VDVSYNE10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVSYNE1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNE11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVSYNE1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNE12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVSYNE1_OFFSET)
 #endif


  #define _VP_VDVSYNE1_VSYNCYSTOP1_MASK        0x0FFF0000u
  #define _VP_VDVSYNE1_VSYNCYSTOP1_SHIFT       0x00000010u
  #define  VP_VDVSYNE1_VSYNCYSTOP1_DEFAULT     0x00000000u
  #define  VP_VDVSYNE1_VSYNCYSTOP1_OF(x)       _VALUEOF(x)

  #define _VP_VDVSYNE1_VSYNCXSTOP1_MASK        0x00000FFFu
  #define _VP_VDVSYNE1_VSYNCXSTOP1_SHIFT       0x00000000u
  #define  VP_VDVSYNE1_VSYNCXSTOP1_DEFAULT     0x00000000u
  #define  VP_VDVSYNE1_VSYNCXSTOP1_OF(x)       _VALUEOF(x)

  #define  VP_VDVSYNE1_OF(x)            _VALUEOF(x)

  #define VP_VDVSYNE1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVSYNE1,VSYNCYSTOP1)\
    |_PER_FDEFAULT(VP,VDVSYNE1,VSYNCXSTOP1)\
  )

  #define VP_VDVSYNE1_RMK(vsyncystop1,vsyncxstop1) (Uint32)(\
     _PER_FMK(VP,VDVSYNE1,VSYNCYSTOP1,vsyncystop1)\
    |_PER_FMK(VP,VDVSYNE1,VSYNCXSTOP1,vsyncxstop1)\
  )

  #define _VP_VDVSYNE1_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVSYNE1##N##_ADDR,VP,VDVSYNE1,##FIELD)

  #define _VP_VDVSYNE1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVSYNE1##N##_ADDR,VP,VDVSYNE1,##FIELD,field)

  #define _VP_VDVSYNE1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVSYNE1##N##_ADDR,VP,VDVSYNE1,##FIELD,##SYM)

  #define _VP_VDVSYNE10_FGET(FIELD)   _VP_VDVSYNE1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNE11_FGET(FIELD)   _VP_VDVSYNE1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNE12_FGET(FIELD)   _VP_VDVSYNE1_FGET(2,##FIELD)
 #endif


  #define _VP_VDVSYNE10_FSET(FIELD,f)   _VP_VDVSYNE1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNE11_FSET(FIELD,f)   _VP_VDVSYNE1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNE12_FSET(FIELD,f)   _VP_VDVSYNE1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVSYNE10_FSETS(FIELD,SYM)   _VP_VDVSYNE1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNE11_FSETS(FIELD,SYM)   _VP_VDVSYNE1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNE12_FSETS(FIELD,SYM)   _VP_VDVSYNE1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D V S Y N S 2  |
* |___________________|
*
* VDVSYNS20 -  Video Port 0 Video Display Vertical Sync. Start - Field 2
* VDVSYNS21 -  Video Port 1 Video Display Vertical Sync. Start - Field 2
* VDVSYNS22 -  Video Port 2 Video Display Vertical Sync. Start - Field 2
*
* FIELDS (msb -> lsb)
* (rw) VSYNCYSTART2
* (rw) VSYNCXSTART2
*
\******************************************************************************/
  #define _VP_VDVSYNS2_OFFSET           146

  #define _VP_VDVSYNS20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVSYNS2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNS21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVSYNS2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNS22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVSYNS2_OFFSET)
 #endif


  #define _VP_VDVSYNS2_VSYNCYSTART2_MASK        0x0FFF0000u
  #define _VP_VDVSYNS2_VSYNCYSTART2_SHIFT       0x00000010u
  #define  VP_VDVSYNS2_VSYNCYSTART2_DEFAULT     0x00000000u
  #define  VP_VDVSYNS2_VSYNCYSTART2_OF(x)       _VALUEOF(x)

  #define _VP_VDVSYNS2_VSYNCXSTART2_MASK        0x00000FFFu
  #define _VP_VDVSYNS2_VSYNCXSTART2_SHIFT       0x00000000u
  #define  VP_VDVSYNS2_VSYNCXSTART2_DEFAULT     0x00000000u
  #define  VP_VDVSYNS2_VSYNCXSTART2_OF(x)       _VALUEOF(x)

  #define  VP_VDVSYNS2_OF(x)            _VALUEOF(x)

  #define VP_VDVSYNS2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVSYNS2,VSYNCYSTART2)\
    |_PER_FDEFAULT(VP,VDVSYNS2,VSYNCXSTART2)\
  )

  #define VP_VDVSYNS2_RMK(vsyncystart2,vsyncxstart2) (Uint32)(\
     _PER_FMK(VP,VDVSYNS2,VSYNCYSTART2,vsyncystart2)\
    |_PER_FMK(VP,VDVSYNS2,VSYNCXSTART2,vsyncxstart2)\
  )

  #define _VP_VDVSYNS2_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVSYNS2##N##_ADDR,VP,VDVSYNS2,##FIELD)

  #define _VP_VDVSYNS2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVSYNS2##N##_ADDR,VP,VDVSYNS2,##FIELD,field)

  #define _VP_VDVSYNS2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVSYNS2##N##_ADDR,VP,VDVSYNS2,##FIELD,##SYM)

  #define _VP_VDVSYNS20_FGET(FIELD)   _VP_VDVSYNS2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNS21_FGET(FIELD)   _VP_VDVSYNS2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNS22_FGET(FIELD)   _VP_VDVSYNS2_FGET(2,##FIELD)
 #endif


  #define _VP_VDVSYNS20_FSET(FIELD,f)   _VP_VDVSYNS2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNS21_FSET(FIELD,f)   _VP_VDVSYNS2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNS22_FSET(FIELD,f)   _VP_VDVSYNS2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVSYNS20_FSETS(FIELD,SYM)   _VP_VDVSYNS2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNS21_FSETS(FIELD,SYM)   _VP_VDVSYNS2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNS22_FSETS(FIELD,SYM)   _VP_VDVSYNS2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D V S Y N E 2  |
* |___________________|
*
* VDVSYNE20 -  Video Port 0 Video Display Vertical Sync. End - Field 2
* VDVSYNE21 -  Video Port 1 Video Display Vertical Sync. End - Field 2
* VDVSYNE22 -  Video Port 2 Video Display Vertical Sync. End - Field 2
*
* FIELDS (msb -> lsb)
* (rw) VSYNCYSTOP2
* (rw) VSYNCXSTOP2
*
\******************************************************************************/
  #define _VP_VDVSYNE2_OFFSET           147

  #define _VP_VDVSYNE20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVSYNE2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNE21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVSYNE2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNE22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVSYNE2_OFFSET)
 #endif


  #define _VP_VDVSYNE2_VSYNCYSTOP2_MASK        0x0FFF0000u
  #define _VP_VDVSYNE2_VSYNCYSTOP2_SHIFT       0x00000010u
  #define  VP_VDVSYNE2_VSYNCYSTOP2_DEFAULT     0x00000000u
  #define  VP_VDVSYNE2_VSYNCYSTOP2_OF(x)       _VALUEOF(x)

  #define _VP_VDVSYNE2_VSYNCXSTOP2_MASK        0x00000FFFu
  #define _VP_VDVSYNE2_VSYNCXSTOP2_SHIFT       0x00000000u
  #define  VP_VDVSYNE2_VSYNCXSTOP2_DEFAULT     0x00000000u
  #define  VP_VDVSYNE2_VSYNCXSTOP2_OF(x)       _VALUEOF(x)

  #define  VP_VDVSYNE2_OF(x)            _VALUEOF(x)

  #define VP_VDVSYNE2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVSYNE2,VSYNCYSTOP2)\
    |_PER_FDEFAULT(VP,VDVSYNE2,VSYNCXSTOP2)\
  )

  #define VP_VDVSYNE2_RMK(vsyncystop2,vsyncxstop2) (Uint32)(\
     _PER_FMK(VP,VDVSYNE2,VSYNCYSTOP2,vsyncystop2)\
    |_PER_FMK(VP,VDVSYNE2,VSYNCXSTOP2,vsyncxstop2)\
  )

  #define _VP_VDVSYNE2_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVSYNE2##N##_ADDR,VP,VDVSYNE2,##FIELD)

  #define _VP_VDVSYNE2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVSYNE2##N##_ADDR,VP,VDVSYNE2,##FIELD,field)

  #define _VP_VDVSYNE2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVSYNE2##N##_ADDR,VP,VDVSYNE2,##FIELD,##SYM)

  #define _VP_VDVSYNE20_FGET(FIELD)   _VP_VDVSYNE2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNE21_FGET(FIELD)   _VP_VDVSYNE2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNE22_FGET(FIELD)   _VP_VDVSYNE2_FGET(2,##FIELD)
 #endif


  #define _VP_VDVSYNE20_FSET(FIELD,f)   _VP_VDVSYNE2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNE21_FSET(FIELD,f)   _VP_VDVSYNE2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNE22_FSET(FIELD,f)   _VP_VDVSYNE2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVSYNE20_FSETS(FIELD,SYM)   _VP_VDVSYNE2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVSYNE21_FSETS(FIELD,SYM)   _VP_VDVSYNE2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVSYNE22_FSETS(FIELD,SYM)   _VP_VDVSYNE2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D R E L O A D  |
* |___________________|
*
* VDRELOAD0 -  Video Port 0 Video Display Counter Reload
* VDRELOAD1 -  Video Port 1 Video Display Counter Reload
* VDRELOAD2 -  Video Port 2 Video Display Counter Reload
*
* FIELDS (msb -> lsb)
* (rw) VRLD
* (rw) CRLD
* (rw) HRLD
*
\******************************************************************************/
  #define _VP_VDRELOAD_OFFSET           148

  #define _VP_VDRELOAD0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDRELOAD_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDRELOAD1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDRELOAD_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDRELOAD2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDRELOAD_OFFSET)
 #endif


  #define _VP_VDRELOAD_VRLD_MASK        0x0FFF0000u
  #define _VP_VDRELOAD_VRLD_SHIFT       0x00000010u
  #define  VP_VDRELOAD_VRLD_DEFAULT     0x00000000u
  #define  VP_VDRELOAD_VRLD_OF(x)       _VALUEOF(x)

  #define _VP_VDRELOAD_CRLD_MASK        0x0000F000u
  #define _VP_VDRELOAD_CRLD_SHIFT       0x0000000Cu
  #define  VP_VDRELOAD_CRLD_DEFAULT     0x00000000u
  #define  VP_VDRELOAD_CRLD_OF(x)       _VALUEOF(x)

  #define _VP_VDRELOAD_HRLD_MASK        0x00000FFFu
  #define _VP_VDRELOAD_HRLD_SHIFT       0x00000000u
  #define  VP_VDRELOAD_HRLD_DEFAULT     0x00000000u
  #define  VP_VDRELOAD_HRLD_OF(x)       _VALUEOF(x)

  #define  VP_VDRELOAD_OF(x)            _VALUEOF(x)

  #define VP_VDRELOAD_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDRELOAD,VRLD)\
    |_PER_FDEFAULT(VP,VDRELOAD,CRLD)\
    |_PER_FDEFAULT(VP,VDRELOAD,HRLD)\
  )

  #define VP_VDRELOAD_RMK(vrld,crld,hrld) (Uint32)(\
     _PER_FMK(VP,VDRELOAD,VRLD,vrld)\
    |_PER_FMK(VP,VDRELOAD,CRLD,crld)\
    |_PER_FMK(VP,VDRELOAD,HRLD,hrld)\
  )

  #define _VP_VDRELOAD_FGET(N,FIELD)\
    _PER_FGET(_VP_VDRELOAD##N##_ADDR,VP,VDRELOAD,##FIELD)

  #define _VP_VDRELOAD_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDRELOAD##N##_ADDR,VP,VDRELOAD,##FIELD,field)

  #define _VP_VDRELOAD_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDRELOAD##N##_ADDR,VP,VDRELOAD,##FIELD,##SYM)

  #define _VP_VDRELOAD0_FGET(FIELD)   _VP_VDRELOAD_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDRELOAD1_FGET(FIELD)   _VP_VDRELOAD_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDRELOAD2_FGET(FIELD)   _VP_VDRELOAD_FGET(2,##FIELD)
 #endif


  #define _VP_VDRELOAD0_FSET(FIELD,f)   _VP_VDRELOAD_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDRELOAD1_FSET(FIELD,f)   _VP_VDRELOAD_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDRELOAD2_FSET(FIELD,f)   _VP_VDRELOAD_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDRELOAD0_FSETS(FIELD,SYM)   _VP_VDRELOAD_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDRELOAD1_FSETS(FIELD,SYM)   _VP_VDRELOAD_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDRELOAD2_FSETS(FIELD,SYM)   _VP_VDRELOAD_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _______________________
* |                     |
* |  V D D I S P E V T  |
* |_____________________|
*
* VDDISPEVT0 -  Video Port 0 Video Display Display Event Register
* VDDISPEVT1 -  Video Port 1 Video Display Display Event Register
* VDDISPEVT2 -  Video Port 2 Video Display Display Event Register
*
* FIELDS (msb -> lsb)
* (rw) DISPEVT2
* (rw) DISPEVT1
*
\******************************************************************************/
  #define _VP_VDDISPEVT_OFFSET           149

  #define _VP_VDDISPEVT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDDISPEVT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDDISPEVT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDDISPEVT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDDISPEVT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDDISPEVT_OFFSET)
 #endif


  #define _VP_VDDISPEVT_DISPEVT2_MASK        0x0FFF0000u
  #define _VP_VDDISPEVT_DISPEVT2_SHIFT       0x00000010u
  #define  VP_VDDISPEVT_DISPEVT2_DEFAULT     0x00000000u
  #define  VP_VDDISPEVT_DISPEVT2_OF(x)       _VALUEOF(x)

  #define _VP_VDDISPEVT_DISPEVT1_MASK        0x00000FFFu
  #define _VP_VDDISPEVT_DISPEVT1_SHIFT       0x00000000u
  #define  VP_VDDISPEVT_DISPEVT1_DEFAULT     0x00000000u
  #define  VP_VDDISPEVT_DISPEVT1_OF(x)       _VALUEOF(x)

  #define  VP_VDDISPEVT_OF(x)            _VALUEOF(x)

  #define VP_VDDISPEVT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDDISPEVT,DISPEVT2)\
    |_PER_FDEFAULT(VP,VDDISPEVT,DISPEVT1)\
  )

  #define VP_VDDISPEVT_RMK(dispevt2,dispevt1) (Uint32)(\
     _PER_FMK(VP,VDDISPEVT,DISPEVT2,dispevt2)\
    |_PER_FMK(VP,VDDISPEVT,DISPEVT1,dispevt1)\
  )

  #define _VP_VDDISPEVT_FGET(N,FIELD)\
    _PER_FGET(_VP_VDDISPEVT##N##_ADDR,VP,VDDISPEVT,##FIELD)

  #define _VP_VDDISPEVT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDDISPEVT##N##_ADDR,VP,VDDISPEVT,##FIELD,field)

  #define _VP_VDDISPEVT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDDISPEVT##N##_ADDR,VP,VDDISPEVT,##FIELD,##SYM)

  #define _VP_VDDISPEVT0_FGET(FIELD)   _VP_VDDISPEVT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDDISPEVT1_FGET(FIELD)   _VP_VDDISPEVT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDDISPEVT2_FGET(FIELD)   _VP_VDDISPEVT_FGET(2,##FIELD)
 #endif


  #define _VP_VDDISPEVT0_FSET(FIELD,f)   _VP_VDDISPEVT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDDISPEVT1_FSET(FIELD,f)   _VP_VDDISPEVT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDDISPEVT2_FSET(FIELD,f)   _VP_VDDISPEVT_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDDISPEVT0_FSETS(FIELD,SYM)   _VP_VDDISPEVT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDDISPEVT1_FSETS(FIELD,SYM)   _VP_VDDISPEVT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDDISPEVT2_FSETS(FIELD,SYM)   _VP_VDDISPEVT_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _________________
* |               |
* |  V D C L I P  |
* |_______________|
*
* VDCLIP0 -  Video Port 0 Video Display Clipping Register
* VDCLIP1 -  Video Port 1 Video Display Clipping Register
* VDCLIP2 -  Video Port 2 Video Display Clipping Register
*
* FIELDS (msb -> lsb)
* (rw) CLIPCHIGH
* (rw) CLIPCLOW
* (rw) CLIPYHIGH
* (rw) CLIPYLOW
*
\******************************************************************************/
  #define _VP_VDCLIP_OFFSET           150

  #define _VP_VDCLIP0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDCLIP_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDCLIP1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDCLIP_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDCLIP2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDCLIP_OFFSET)
 #endif


  #define _VP_VDCLIP_CLIPCHIGH_MASK        0xFF000000u
  #define _VP_VDCLIP_CLIPCHIGH_SHIFT       0x00000018u
  #define  VP_VDCLIP_CLIPCHIGH_DEFAULT     0x000000F0u
  #define  VP_VDCLIP_CLIPCHIGH_OF(x)       _VALUEOF(x)

  #define _VP_VDCLIP_CLIPCLOW_MASK        0x00FF0000u
  #define _VP_VDCLIP_CLIPCLOW_SHIFT       0x00000010u
  #define  VP_VDCLIP_CLIPCLOW_DEFAULT     0x00000010u
  #define  VP_VDCLIP_CLIPCLOW_OF(x)       _VALUEOF(x)

  #define _VP_VDCLIP_CLIPYHIGH_MASK        0x0000FF00u
  #define _VP_VDCLIP_CLIPYHIGH_SHIFT       0x00000008u
  #define  VP_VDCLIP_CLIPYHIGH_DEFAULT     0x000000EBu
  #define  VP_VDCLIP_CLIPYHIGH_OF(x)       _VALUEOF(x)

  #define _VP_VDCLIP_CLIPYLOW_MASK        0x000000FFu
  #define _VP_VDCLIP_CLIPYLOW_SHIFT       0x00000000u
  #define  VP_VDCLIP_CLIPYLOW_DEFAULT     0x00000010u
  #define  VP_VDCLIP_CLIPYLOW_OF(x)       _VALUEOF(x)

  #define  VP_VDCLIP_OF(x)            _VALUEOF(x)

  #define VP_VDCLIP_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDCLIP,CLIPCHIGH)\
    |_PER_FDEFAULT(VP,VDCLIP,CLIPCLOW)\
    |_PER_FDEFAULT(VP,VDCLIP,CLIPYHIGH)\
    |_PER_FDEFAULT(VP,VDCLIP,CLIPYLOW)\
  )

  #define VP_VDCLIP_RMK(clipchigh,clipclow,clipyhigh,clipylow) (Uint32)(\
     _PER_FMK(VP,VDCLIP,CLIPCHIGH,clipchigh)\
    |_PER_FMK(VP,VDCLIP,CLIPCLOW,clipclow)\
    |_PER_FMK(VP,VDCLIP,CLIPYHIGH,clipyhigh)\
    |_PER_FMK(VP,VDCLIP,CLIPYLOW,clipylow)\
  )

  #define _VP_VDCLIP_FGET(N,FIELD)\
    _PER_FGET(_VP_VDCLIP##N##_ADDR,VP,VDCLIP,##FIELD)

  #define _VP_VDCLIP_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDCLIP##N##_ADDR,VP,VDCLIP,##FIELD,field)

  #define _VP_VDCLIP_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDCLIP##N##_ADDR,VP,VDCLIP,##FIELD,##SYM)

  #define _VP_VDCLIP0_FGET(FIELD)   _VP_VDCLIP_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDCLIP1_FGET(FIELD)   _VP_VDCLIP_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDCLIP2_FGET(FIELD)   _VP_VDCLIP_FGET(2,##FIELD)
 #endif


  #define _VP_VDCLIP0_FSET(FIELD,f)   _VP_VDCLIP_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDCLIP1_FSET(FIELD,f)   _VP_VDCLIP_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDCLIP2_FSET(FIELD,f)   _VP_VDCLIP_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDCLIP0_FSETS(FIELD,SYM)   _VP_VDCLIP_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDCLIP1_FSETS(FIELD,SYM)   _VP_VDCLIP_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDCLIP2_FSETS(FIELD,SYM)   _VP_VDCLIP_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _____________________
* |                   |
* |  V D D E F V A L  |
* |___________________|
*
* VDDEFVAL0 -  Video Port 0 Video Display Default Display Value
* VDDEFVAL1 -  Video Port 1 Video Display Default Display Value
* VDDEFVAL2 -  Video Port 2 Video Display Default Display Value
*
* FIELDS (msb -> lsb)
*
* (rw) CRDEFVAL
* (rw) CBDEFVAL
* (rw) YDEFVAL
* (rw) DEFVAL
*
*
\******************************************************************************/
  #define _VP_VDDEFVAL_OFFSET           151

  #define _VP_VDDEFVAL0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDDEFVAL_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDDEFVAL1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDDEFVAL_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDDEFVAL2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDDEFVAL_OFFSET)
 #endif


  #define _VP_VDDEFVAL_CRDEFVAL_MASK         0xFF000000u
  #define _VP_VDDEFVAL_CRDEFVAL_SHIFT        0x00000018u
  #define  VP_VDDEFVAL_CRDEFVAL_DEFAULT      0x00000000u
  #define  VP_VDDEFVAL_CRDEFVAL_OF(x)        _VALUEOF(x)

  #define _VP_VDDEFVAL_CBDEFVAL_MASK         0x00FF0000u
  #define _VP_VDDEFVAL_CBDEFVAL_SHIFT        0x00000010u
  #define  VP_VDDEFVAL_CBDEFVAL_DEFAULT      0x00000000u
  #define  VP_VDDEFVAL_CBDEFVAL_OF(x)        _VALUEOF(x)

  #define _VP_VDDEFVAL_YDEFVAL_MASK          0x000000FFu
  #define _VP_VDDEFVAL_YDEFVAL_SHIFT         0x00000000u
  #define  VP_VDDEFVAL_YDEFVAL_DEFAULT       0x00000000u
  #define  VP_VDDEFVAL_YDEFVAL_OF(x)         _VALUEOF(x)

  #define _VP_VDDEFVAL_DEFVAL_MASK           0x000FFFFFu
  #define _VP_VDDEFVAL_DEFVAL_SHIFT          0x00000000u
  #define  VP_VDDEFVAL_DEFVAL_DEFAULT        0x00000000u
  #define  VP_VDDEFVAL_DEFVAL_OF(x)          _VALUEOF(x)

  #define  VP_VDDEFVAL_OF(x)            _VALUEOF(x)

/***********************************************************************\
* Note: Since this register location been used for two different
*       mode no VP_VDDEFVAL_DEFAULT and VP_VDDEFVAL_RMK were defined
\***********************************************************************/

  #define _VP_VDDEFVAL_FGET(N,FIELD)\
    _PER_FGET(_VP_VDDEFVAL##N##_ADDR,VP,VDDEFVAL,##FIELD)

  #define _VP_VDDEFVAL_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDDEFVAL##N##_ADDR,VP,VDDEFVAL,##FIELD,field)

  #define _VP_VDDEFVAL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDDEFVAL##N##_ADDR,VP,VDDEFVAL,##FIELD,##SYM)

  #define _VP_VDDEFVAL0_FGET(FIELD)   _VP_VDDEFVAL_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDDEFVAL1_FGET(FIELD)   _VP_VDDEFVAL_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDDEFVAL2_FGET(FIELD)   _VP_VDDEFVAL_FGET(2,##FIELD)
 #endif


  #define _VP_VDDEFVAL0_FSET(FIELD,f)   _VP_VDDEFVAL_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDDEFVAL1_FSET(FIELD,f)   _VP_VDDEFVAL_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDDEFVAL2_FSET(FIELD,f)   _VP_VDDEFVAL_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDDEFVAL0_FSETS(FIELD,SYM)   _VP_VDDEFVAL_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDDEFVAL1_FSETS(FIELD,SYM)   _VP_VDDEFVAL_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDDEFVAL2_FSETS(FIELD,SYM)   _VP_VDDEFVAL_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _________________
* |               |
* |  V D V I N T  |
* |_______________|
*
* VDVINT0 -  Video Port 0 Video Display Vertical Interrupt
* VDVINT1 -  Video Port 1 Video Display Vertical Interrupt
* VDVINT2 -  Video Port 2 Video Display Vertical Interrupt
*
* FIELDS (msb -> lsb)
* (rw) VIF2
* (rw) VINT2
* (rw) VIF1
* (rw) VINT1
*
\******************************************************************************/
  #define _VP_VDVINT_OFFSET           152

  #define _VP_VDVINT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVINT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVINT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVINT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVINT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVINT_OFFSET)
 #endif


  #define _VP_VDVINT_VIF2_MASK        0x80000000u
  #define _VP_VDVINT_VIF2_SHIFT       0x0000001Fu
  #define  VP_VDVINT_VIF2_DEFAULT     0x00000000u
  #define  VP_VDVINT_VIF2_OF(x)       _VALUEOF(x)
  #define  VP_VDVINT_VIF2_DISABLE     0x00000000u
  #define  VP_VDVINT_VIF2_ENABLE      0x00000001u

  #define _VP_VDVINT_VINT2_MASK        0x0FFF0000u
  #define _VP_VDVINT_VINT2_SHIFT       0x00000010u
  #define  VP_VDVINT_VINT2_DEFAULT     0x00000000u
  #define  VP_VDVINT_VINT2_OF(x)       _VALUEOF(x)

  #define _VP_VDVINT_VIF1_MASK        0x00008000u
  #define _VP_VDVINT_VIF1_SHIFT       0x0000000Fu
  #define  VP_VDVINT_VIF1_DEFAULT     0x00000000u
  #define  VP_VDVINT_VIF1_OF(x)       _VALUEOF(x)
  #define  VP_VDVINT_VIF1_DISABLE     0x00000000u
  #define  VP_VDVINT_VIF1_ENABLE      0x00000001u

  #define _VP_VDVINT_VINT1_MASK        0x00000FFFu
  #define _VP_VDVINT_VINT1_SHIFT       0x00000000u
  #define  VP_VDVINT_VINT1_DEFAULT     0x00000000u
  #define  VP_VDVINT_VINT1_OF(x)       _VALUEOF(x)

  #define  VP_VDVINT_OF(x)            _VALUEOF(x)

  #define VP_VDVINT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVINT,VIF2)\
    |_PER_FDEFAULT(VP,VDVINT,VINT2)\
    |_PER_FDEFAULT(VP,VDVINT,VIF1)\
    |_PER_FDEFAULT(VP,VDVINT,VINT1)\
  )

  #define VP_VDVINT_RMK(vif2,vint2,vif1,vint1) (Uint32)(\
     _PER_FMK(VP,VDVINT,VIF2,vif2)\
    |_PER_FMK(VP,VDVINT,VINT2,vint2)\
    |_PER_FMK(VP,VDVINT,VIF1,vif1)\
    |_PER_FMK(VP,VDVINT,VINT1,vint1)\
  )

  #define _VP_VDVINT_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVINT##N##_ADDR,VP,VDVINT,##FIELD)

  #define _VP_VDVINT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVINT##N##_ADDR,VP,VDVINT,##FIELD,field)

  #define _VP_VDVINT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVINT##N##_ADDR,VP,VDVINT,##FIELD,##SYM)

  #define _VP_VDVINT0_FGET(FIELD)   _VP_VDVINT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVINT1_FGET(FIELD)   _VP_VDVINT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVINT2_FGET(FIELD)   _VP_VDVINT_FGET(2,##FIELD)
 #endif


  #define _VP_VDVINT0_FSET(FIELD,f)   _VP_VDVINT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVINT1_FSET(FIELD,f)   _VP_VDVINT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVINT2_FSET(FIELD,f)   _VP_VDVINT_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVINT0_FSETS(FIELD,SYM)   _VP_VDVINT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVINT1_FSETS(FIELD,SYM)   _VP_VDVINT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVINT2_FSETS(FIELD,SYM)   _VP_VDVINT_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _________________
* |               |
* |  V D F B I T  |
* |_______________|
*
* VDFBIT0 -  Video Port 0 Video Display Field Bit Register
* VDFBIT1 -  Video Port 1 Video Display Field Bit Register
* VDFBIT2 -  Video Port 2 Video Display Field Bit Register
*
* FIELDS (msb -> lsb)
* (rw) FBITSET
* (rw) FBITCLR
*
\******************************************************************************/
  #define _VP_VDFBIT_OFFSET           153

  #define _VP_VDFBIT0_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDFBIT_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFBIT1_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDFBIT_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFBIT2_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDFBIT_OFFSET)
 #endif


  #define _VP_VDFBIT_FBITSET_MASK        0x0FFF0000u
  #define _VP_VDFBIT_FBITSET_SHIFT       0x00000010u
  #define  VP_VDFBIT_FBITSET_DEFAULT     0x00000000u
  #define  VP_VDFBIT_FBITSET_OF(x)       _VALUEOF(x)

  #define _VP_VDFBIT_FBITCLR_MASK        0x00000FFFu
  #define _VP_VDFBIT_FBITCLR_SHIFT       0x00000000u
  #define  VP_VDFBIT_FBITCLR_DEFAULT     0x00000000u
  #define  VP_VDFBIT_FBITCLR_OF(x)       _VALUEOF(x)

  #define  VP_VDFBIT_OF(x)            _VALUEOF(x)

  #define VP_VDFBIT_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDFBIT,FBITSET)\
    |_PER_FDEFAULT(VP,VDFBIT,FBITCLR)\
  )

  #define VP_VDFBIT_RMK(fbitset,fbitclr) (Uint32)(\
     _PER_FMK(VP,VDFBIT,FBITSET,fbitset)\
    |_PER_FMK(VP,VDFBIT,FBITCLR,fbitclr)\
  )

  #define _VP_VDFBIT_FGET(N,FIELD)\
    _PER_FGET(_VP_VDFBIT##N##_ADDR,VP,VDFBIT,##FIELD)

  #define _VP_VDFBIT_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDFBIT##N##_ADDR,VP,VDFBIT,##FIELD,field)

  #define _VP_VDFBIT_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDFBIT##N##_ADDR,VP,VDFBIT,##FIELD,##SYM)

  #define _VP_VDFBIT0_FGET(FIELD)   _VP_VDFBIT_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFBIT1_FGET(FIELD)   _VP_VDFBIT_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFBIT2_FGET(FIELD)   _VP_VDFBIT_FGET(2,##FIELD)
 #endif


  #define _VP_VDFBIT0_FSET(FIELD,f)   _VP_VDFBIT_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFBIT1_FSET(FIELD,f)   _VP_VDFBIT_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFBIT2_FSET(FIELD,f)   _VP_VDFBIT_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDFBIT0_FSETS(FIELD,SYM)   _VP_VDFBIT_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDFBIT1_FSETS(FIELD,SYM)   _VP_VDFBIT_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDFBIT2_FSETS(FIELD,SYM)   _VP_VDFBIT_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* __________________
* |                |
* |  V D V B I T 1 |
* |________________|
*
* VDVBIT10 -  Video Port 0 Video Display Vertical Blank Bit-Field 1 Register
* VDVBIT11 -  Video Port 1 Video Display Vertical Blank Bit-Field 1 Register
* VDVBIT12 -  Video Port 2 Video Display Vertical Blank Bit-Field 1 Register
*
* FIELDS (msb -> lsb)
* (rw) VBITCLR1
* (rw) VBITSET1
*
\******************************************************************************/
  #define _VP_VDVBIT1_OFFSET           154

  #define _VP_VDVBIT10_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVBIT1_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBIT11_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVBIT1_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBIT12_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVBIT1_OFFSET)
 #endif


  #define _VP_VDVBIT1_VBITCLR1_MASK        0x0FFF0000u
  #define _VP_VDVBIT1_VBITCLR1_SHIFT       0x00000010u
  #define  VP_VDVBIT1_VBITCLR1_DEFAULT     0x00000000u
  #define  VP_VDVBIT1_VBITCLR1_OF(x)       _VALUEOF(x)

  #define _VP_VDVBIT1_VBITSET1_MASK        0x00000FFFu
  #define _VP_VDVBIT1_VBITSET1_SHIFT       0x00000000u
  #define  VP_VDVBIT1_VBITSET1_DEFAULT     0x00000000u
  #define  VP_VDVBIT1_VBITSET1_OF(x)       _VALUEOF(x)

  #define  VP_VDVBIT1_OF(x)            _VALUEOF(x)

  #define VP_VDVBIT1_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVBIT1,VBITCLR1)\
    |_PER_FDEFAULT(VP,VDVBIT1,VBITSET1)\
  )

  #define VP_VDVBIT1_RMK(vbitclr1,vbitset1) (Uint32)(\
  _PER_FMK(VP,VDVBIT1,VBITCLR1,vbitclr1)\
    |_PER_FMK(VP,VDVBIT1,VBITSET1,vbitset1)\
  )

  #define _VP_VDVBIT1_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVBIT1##N##_ADDR,VP,VDVBIT1,##FIELD)

  #define _VP_VDVBIT1_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVBIT1##N##_ADDR,VP,VDVBIT1,##FIELD,field)

  #define _VP_VDVBIT1_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVBIT1##N##_ADDR,VP,VDVBIT1,##FIELD,##SYM)

  #define _VP_VDVBIT10_FGET(FIELD)   _VP_VDVBIT1_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBIT11_FGET(FIELD)   _VP_VDVBIT1_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBIT12_FGET(FIELD)   _VP_VDVBIT1_FGET(2,##FIELD)
 #endif


  #define _VP_VDVBIT10_FSET(FIELD,f)   _VP_VDVBIT1_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBIT11_FSET(FIELD,f)   _VP_VDVBIT1_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBIT12_FSET(FIELD,f)   _VP_VDVBIT1_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVBIT10_FSETS(FIELD,SYM)   _VP_VDVBIT1_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBIT11_FSETS(FIELD,SYM)   _VP_VDVBIT1_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBIT12_FSETS(FIELD,SYM)   _VP_VDVBIT1_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* __________________
* |                |
* |  V D V B I T 2 |
* |________________|
*
* VDVBIT20 -  Video Port 0 Video Display Vertical Blank Bit-Field 2 Register
* VDVBIT21 -  Video Port 1 Video Display Vertical Blank Bit-Field 2 Register
* VDVBIT22 -  Video Port 2 Video Display Vertical Blank Bit-Field 2 Register
*
* FIELDS (msb -> lsb)
* (rw) VBITCLR2
* (rw) VBITSET2
*
\******************************************************************************/
  #define _VP_VDVBIT2_OFFSET           155

  #define _VP_VDVBIT20_ADDR   (_VP_BASE_PORT0 + 4*_VP_VDVBIT2_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBIT21_ADDR   (_VP_BASE_PORT1 + 4*_VP_VDVBIT2_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBIT22_ADDR   (_VP_BASE_PORT2 + 4*_VP_VDVBIT2_OFFSET)
 #endif


  #define _VP_VDVBIT2_VBITCLR2_MASK        0x0FFF0000u
  #define _VP_VDVBIT2_VBITCLR2_SHIFT       0x00000010u
  #define  VP_VDVBIT2_VBITCLR2_DEFAULT     0x00000000u
  #define  VP_VDVBIT2_VBITCLR2_OF(x)       _VALUEOF(x)

  #define _VP_VDVBIT2_VBITSET2_MASK        0x00000FFFu
  #define _VP_VDVBIT2_VBITSET2_SHIFT       0x00000000u
  #define  VP_VDVBIT2_VBITSET2_DEFAULT     0x00000000u
  #define  VP_VDVBIT2_VBITSET2_OF(x)       _VALUEOF(x)

  #define  VP_VDVBIT2_OF(x)            _VALUEOF(x)

  #define VP_VDVBIT2_DEFAULT (Uint32)(\
     _PER_FDEFAULT(VP,VDVBIT2,VBITCLR2)\
    |_PER_FDEFAULT(VP,VDVBIT2,VBITSET2)\
  )

  #define VP_VDVBIT2_RMK(vbitclr2,vbitset2) (Uint32)(\
     _PER_FMK(VP,VDVBIT2,VBITCLR2,vbitclr2)\
    |_PER_FMK(VP,VDVBIT2,VBITSET2,vbitset2)\
  )

  #define _VP_VDVBIT2_FGET(N,FIELD)\
    _PER_FGET(_VP_VDVBIT2##N##_ADDR,VP,VDVBIT2,##FIELD)

  #define _VP_VDVBIT2_FSET(N,FIELD,field)\
    _PER_FSET(_VP_VDVBIT2##N##_ADDR,VP,VDVBIT2,##FIELD,field)

  #define _VP_VDVBIT2_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_VP_VDVBIT2##N##_ADDR,VP,VDVBIT2,##FIELD,##SYM)

  #define _VP_VDVBIT20_FGET(FIELD)   _VP_VDVBIT2_FGET(0,##FIELD)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBIT21_FGET(FIELD)   _VP_VDVBIT2_FGET(1,##FIELD)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBIT22_FGET(FIELD)   _VP_VDVBIT2_FGET(2,##FIELD)
 #endif


  #define _VP_VDVBIT20_FSET(FIELD,f)   _VP_VDVBIT2_FSET(0,##FIELD,f)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBIT21_FSET(FIELD,f)   _VP_VDVBIT2_FSET(1,##FIELD,f)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBIT22_FSET(FIELD,f)   _VP_VDVBIT2_FSET(2,##FIELD,f)
 #endif


  #define _VP_VDVBIT20_FSETS(FIELD,SYM)   _VP_VDVBIT2_FSETS(0,##FIELD,##SYM)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_VDVBIT21_FSETS(FIELD,SYM)   _VP_VDVBIT2_FSETS(1,##FIELD,##SYM)
 #endif

 #if (CHIP_DM642)
  #define _VP_VDVBIT22_FSETS(FIELD,SYM)   _VP_VDVBIT2_FSETS(2,##FIELD,##SYM)
 #endif


/******************************************************************************\
* _________________
* |               |
* |  Y S R C A    |
* |_______________|
*
* YSRCA0       -  Video Port 0 Y FIFO Source Register A
* YSRCA1       -  Video Port 1 Y FIFO Source Register A
* YSRCA2       -  Video Port 2 Y FIFO Source Register A
* _________________
* |               |
* |  C B S R C A  |
* |_______________|
*
* CBSRCA0      -  Video Port 0 Cb FIFO Source Register A
* CBSRCA1      -  Video Port 1 Cb FIFO Source Register A
* CBSRCA2      -  Video Port 2 Cb FIFO Source Register A
* _________________
* |               |
* |  C R S R C A  |
* |_______________|
*
* CRSRCA0      -  Video Port 0 Cr FIFO Source Register A
* CRSRCA1      -  Video Port 1 Cr FIFO Source Register A
* CRSRCA2      -  Video Port 2 Cr FIFO Source Register A
* _________________
* |               |
* |  Y S R C B    |
* |_______________|
*
* YSRCB0       -  Video Port 0 Y FIFO Source Register B (only for DM642)
* YSRCB1       -  Video Port 1 Y FIFO Source Register B (only for DM642)
* YSRCB2       -  Video Port 2 Y FIFO Source Register B (only for DM642)
* _________________
* |               |
* |  C B S R C B  |
* |_______________|
*
* CBSRCB0      -  Video Port 0 Cb FIFO Source Register B (only for DM642)
* CBSRCB1      -  Video Port 1 Cb FIFO Source Register B (only for DM642)
* CBSRCB2      -  Video Port 2 Cb FIFO Source Register B (only for DM642)
* _________________
* |               |
* |  C R S R C B  |
* |_______________|
*
* CRSRCB0      -  Video Port 0 Cr FIFO Source Register B (only for DM642)
* CRSRCB1      -  Video Port 1 Cr FIFO Source Register B (only for DM642)
* CRSRCB2      -  Video Port 2 Cr FIFO Source Register B (only for DM642)
* _________________
* |               |
* |  Y D S T A    |
* |_______________|
*
* YDSTA0       -  Video Port 0 Y FIFO Destination Register A
* YDSTA1       -  Video Port 1 Y FIFO Destination Register A
* YDSTA2       -  Video Port 2 Y FIFO Destination Register A
* _________________
* |               |
* |  C B D S T    |
* |_______________|
*
* CBDST0       -  Video Port 0 Cb FIFO Destination Register 
* CBDST1       -  Video Port 1 Cb FIFO Destination Register 
* CBDST2       -  Video Port 2 Cb FIFO Destination Register 
* _________________
* |               |
* |  C R D S T    |
* |_______________|
*
* CRDST0       -  Video Port 0 Cr FIFO Destination Register
* CRDST1       -  Video Port 1 Cr FIFO Destination Register
* CRDST2       -  Video Port 2 Cr FIFO Destination Register
* _________________
* |               |
* |  Y D S T B    |
* |_______________|
*
* YDSTB0       -  Video Port 0 Y FIFO Destination Register B (only for DM642)
* YDSTB1       -  Video Port 1 Y FIFO Destination Register B (only for DM642)
* YDSTB2       -  Video Port 2 Y FIFO Destination Register B (only for DM642)
\******************************************************************************/
  #define _VP_YSRCA_OFFSET             0
  #define _VP_CBSRCA_OFFSET            2
  #define _VP_CRSRCA_OFFSET            4
  #define _VP_YDSTA_OFFSET             8
  #define _VP_CBDST_OFFSET             10
  #define _VP_CRDST_OFFSET             12

 #if (CHIP_DM642)
  #define _VP_YSRCB_OFFSET             0
  #define _VP_CBSRCB_OFFSET            2
  #define _VP_CRSRCB_OFFSET            4
  #define _VP_YDSTB_OFFSET             8
 #endif

  #define _VP_YSRCA0_ADDR   (_VP_AFBASE_PORT0 + 4*_VP_YSRCA_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_YSRCA1_ADDR   (_VP_AFBASE_PORT1 + 4*_VP_YSRCA_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_YSRCA2_ADDR   (_VP_AFBASE_PORT2 + 4*_VP_YSRCA_OFFSET)
 #endif


  #define _VP_CBSRCA0_ADDR   (_VP_AFBASE_PORT0 + 4*_VP_CBSRCA_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_CBSRCA1_ADDR   (_VP_AFBASE_PORT1 + 4*_VP_CBSRCA_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_CBSRCA2_ADDR   (_VP_AFBASE_PORT2 + 4*_VP_CBSRCA_OFFSET)
 #endif


  #define _VP_CRSRCA0_ADDR   (_VP_AFBASE_PORT0 + 4*_VP_CRSRCA_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_CRSRCA1_ADDR   (_VP_AFBASE_PORT1 + 4*_VP_CRSRCA_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_CRSRCA2_ADDR   (_VP_AFBASE_PORT2 + 4*_VP_CRSRCA_OFFSET)
 #endif


  #define _VP_YDSTA0_ADDR   (_VP_AFBASE_PORT0 + 4*_VP_YDSTA_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_YDSTA1_ADDR   (_VP_AFBASE_PORT1 + 4*_VP_YDSTA_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_YDSTA2_ADDR   (_VP_AFBASE_PORT2 + 4*_VP_YDSTA_OFFSET)
 #endif


  #define _VP_CBDST0_ADDR   (_VP_AFBASE_PORT0 + 4*_VP_CBDST_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_CBDST1_ADDR   (_VP_AFBASE_PORT1 + 4*_VP_CBDST_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_CBDST2_ADDR   (_VP_AFBASE_PORT2 + 4*_VP_CBDST_OFFSET)
 #endif


  #define _VP_CRDST0_ADDR   (_VP_AFBASE_PORT0 + 4*_VP_CRDST_OFFSET)

 #if (CHIP_DM641 | CHIP_DM642)
  #define _VP_CRDST1_ADDR   (_VP_AFBASE_PORT1 + 4*_VP_CRDST_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_CRDST2_ADDR   (_VP_AFBASE_PORT2 + 4*_VP_CRDST_OFFSET)
 #endif

 #if (CHIP_DM642)
  #define _VP_YSRCB0_ADDR   (_VP_BFBASE_PORT0 + 4*_VP_YSRCB_OFFSET)
  #define _VP_YSRCB1_ADDR   (_VP_BFBASE_PORT1 + 4*_VP_YSRCB_OFFSET)
  #define _VP_YSRCB2_ADDR   (_VP_BFBASE_PORT2 + 4*_VP_YSRCB_OFFSET)

  #define _VP_CBSRCB0_ADDR   (_VP_BFBASE_PORT0 + 4*_VP_CBSRCB_OFFSET)
  #define _VP_CBSRCB1_ADDR   (_VP_BFBASE_PORT1 + 4*_VP_CBSRCB_OFFSET)
  #define _VP_CBSRCB2_ADDR   (_VP_BFBASE_PORT2 + 4*_VP_CBSRCB_OFFSET)

  #define _VP_CRSRCB0_ADDR   (_VP_BFBASE_PORT0 + 4*_VP_CRSRCB_OFFSET)
  #define _VP_CRSRCB1_ADDR   (_VP_BFBASE_PORT1 + 4*_VP_CRSRCB_OFFSET)
  #define _VP_CRSRCB2_ADDR   (_VP_BFBASE_PORT2 + 4*_VP_CRSRCB_OFFSET)

  #define _VP_YDSTB0_ADDR   (_VP_BFBASE_PORT0 + 4*_VP_YDSTB_OFFSET)
  #define _VP_YDSTB1_ADDR   (_VP_BFBASE_PORT1 + 4*_VP_YDSTB_OFFSET)
  #define _VP_YDSTB2_ADDR   (_VP_BFBASE_PORT2 + 4*_VP_YDSTB_OFFSET)
 #endif


/*----------------------------------------------------------------------------*/

#endif /* VP_SUPPORT */
#endif /* _CSL_VPHAL_H_ */
/******************************************************************************\
* End of csl_vphal.h
\******************************************************************************/

csl_xbus.h/     1030611986  0     0     0       5795      `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_xbus.h
* DATE CREATED.. 06/12/2000 
* LAST MODIFIED. 10/03/2000 
\******************************************************************************/
#ifndef _CSL_XBUS_H_
#define _CSL_XBUS_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_xbushal.h>


#if (XBUS_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _XBUS_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/


/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* device configuration structure */
typedef struct {
  Uint32 xbgc;
  Uint32 xcectl0;
  Uint32 xcectl1;
  Uint32 xcectl2;
  Uint32 xcectl3;
  Uint32 xbhc;
  Uint32 xbima;
  Uint32 xbea;
} XBUS_Config;


/******************************************************************************\
* global variable declarations
\******************************************************************************/


/******************************************************************************\
* global function declarations
\******************************************************************************/


/******************************************************************************\
* inline function declarations
\******************************************************************************/

IDECL void XBUS_config(XBUS_Config *config);
IDECL void XBUS_configArgs(Uint32 xbgc, Uint32 xcectl0, Uint32 xcectl1,
  Uint32 xcectl2, Uint32 xcectl3, Uint32 xbhc, Uint32 xbima, Uint32 xbea);
IDECL void XBUS_getConfig(XBUS_Config *config);


/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void XBUS_config(XBUS_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_XBUS_BASE_GLOBAL;
  register int x0,x1,x2,x3,x4,x5,x6,x7;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */
  x0 = config->xbgc;
  x1 = config->xcectl0;
  x2 = config->xcectl1;
  x3 = config->xcectl2;
  x4 = config->xcectl3;
  x5 = config->xbhc;
  x6 = config->xbima;
  x7 = config->xbea;

  base[_XBUS_XBGC_OFFSET]    = x0;
  base[_XBUS_XCECTL0_OFFSET] = x1;
  base[_XBUS_XCECTL1_OFFSET] = x2;
  base[_XBUS_XCECTL2_OFFSET] = x3;
  base[_XBUS_XCECTL3_OFFSET] = x4;
  base[_XBUS_XBHC_OFFSET]    = x5;
  base[_XBUS_XBIMA_OFFSET]   = x6;
  base[_XBUS_XBEA_OFFSET]    = x7;

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
IDEF void XBUS_configArgs(Uint32 xbgc, Uint32 xcectl0, Uint32 xcectl1,
  Uint32 xcectl2, Uint32 xcectl3, Uint32 xbhc, Uint32 xbima, Uint32 xbea) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_XBUS_BASE_GLOBAL;

  gie = IRQ_globalDisable();

  base[_XBUS_XBGC_OFFSET]    = xbgc;
  base[_XBUS_XCECTL0_OFFSET] = xcectl0;
  base[_XBUS_XCECTL1_OFFSET] = xcectl1;
  base[_XBUS_XCECTL2_OFFSET] = xcectl2;
  base[_XBUS_XCECTL3_OFFSET] = xcectl3;
  base[_XBUS_XBHC_OFFSET]    = xbhc;
  base[_XBUS_XBIMA_OFFSET]   = xbima;
  base[_XBUS_XBEA_OFFSET]    = xbea;

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
IDEF void XBUS_getConfig(XBUS_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_XBUS_BASE_GLOBAL;
  volatile XBUS_Config* cfg = (volatile XBUS_Config*)config;
  register int x0,x1,x2,x3,x4,x5,x6,x7;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */

  x0 = base[_XBUS_XBGC_OFFSET];
  x1 = base[_XBUS_XCECTL0_OFFSET];
  x2 = base[_XBUS_XCECTL1_OFFSET];
  x3 = base[_XBUS_XCECTL2_OFFSET];
  x4 = base[_XBUS_XCECTL3_OFFSET];
  x5 = base[_XBUS_XBHC_OFFSET];
  x6 = base[_XBUS_XBIMA_OFFSET];  
  x7 = base[_XBUS_XBEA_OFFSET];

  cfg->xbgc    = x0;
  cfg->xcectl0 = x1;
  cfg->xcectl1 = x2;
  cfg->xcectl2 = x3;
  cfg->xcectl3 = x4;
  cfg->xbhc    = x5;
  cfg->xbima   = x6;
  cfg->xbea    = x7;

  IRQ_globalRestore(gie);
}

/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */


#endif /* XBUS_SUPPORT */
#endif /* _CSL_XBUS_H_ */
/******************************************************************************\
* End of csl_xbus.h
\******************************************************************************/


csl_xbushal.h/  1030611986  0     0     0       15427     `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_xbushal.h
* DATE CREATED.. 06/12/2000 
* LAST MODIFIED. 10/03/2000 
*------------------------------------------------------------------------------
* REGISTERS
*
* XBGC     - global control register
* XCECTL0  - space control register 0
* XCECTL1  - space control register 1
* XCECTL2  - space control register 2
* XCECTL3  - space control register 3
* XBHC     - host port interface control register
* XBIMA    - internal master address register
* XBEA     - external address register
*
\******************************************************************************/
#ifndef _CSL_XBUSHAL_H_
#define _CSL_XBUSHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>


#if (XBUS_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
#define _XBUS_BASE_GLOBAL   0x01880000u


/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define XBUS_FMK(REG,FIELD,x)\
    _PER_FMK(XBUS,##REG,##FIELD,x)

  #define XBUS_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(XBUS,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define XBUS_ADDR(REG)\
    _XBUS_##REG##_ADDR

  #define XBUS_RGET(REG)\
    _PER_RGET(_XBUS_##REG##_ADDR,XBUS,##REG)

  #define XBUS_RSET(REG,x)\
    _PER_RSET(_XBUS_##REG##_ADDR,XBUS,##REG,x)

  #define XBUS_FGET(REG,FIELD)\
    _XBUS_##REG##_FGET(##FIELD)

  #define XBUS_FSET(REG,FIELD,x)\
    _XBUS_##REG##_FSET(##FIELD,##x)

  #define XBUS_FSETS(REG,FIELD,SYM)\
    _XBUS_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define XBUS_RGETA(addr,REG)\
    _PER_RGET(addr,XBUS,##REG)

  #define XBUS_RSETA(addr,REG,x)\
    _PER_RSET(addr,XBUS,##REG,x)

  #define XBUS_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,XBUS,##REG,##FIELD)

  #define XBUS_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,XBUS,##REG,##FIELD,x)

  #define XBUS_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,XBUS,##REG,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  X B G C          |
* |___________________|
*
* XBGC - global control register
*
* FIELDS (msb -> lsb)
* (r)  FMOD
* (rw) XFCEN
* (rw) XFRAT
* (r)  XARB
*
\******************************************************************************/
  #define _XBUS_XBGC_OFFSET                0
  
  #define _XBUS_XBGC_ADDR                  0x01880000u

  #define _XBUS_XBGC_FMOD_MASK             0x00008000u
  #define _XBUS_XBGC_FMOD_SHIFT            0x0000000Fu
  #define  XBUS_XBGC_FMOD_DEFAULT          0x00000000u
  #define  XBUS_XBGC_FMOD_OF(x)            _VALUEOF(x)
  #define  XBUS_XBGC_FMOD_GLUE             0x00000000u
  #define  XBUS_XBGC_FMOD_GLUELESS         0x00000001u

  #define _XBUS_XBGC_XFCEN_MASK            0x00004000u
  #define _XBUS_XBGC_XFCEN_SHIFT           0x0000000Eu
  #define  XBUS_XBGC_XFCEN_DEFAULT         0x00000000u
  #define  XBUS_XBGC_XFCEN_OF(x)           _VALUEOF(x)
  #define  XBUS_XBGC_XFCEN_DISABLE         0x00000000u
  #define  XBUS_XBGC_XFCEN_ENABLE          0x00000001u

  #define _XBUS_XBGC_XFRAT_MASK            0x00003000u
  #define _XBUS_XBGC_XFRAT_SHIFT           0x0000000Cu
  #define  XBUS_XBGC_XFRAT_DEFAULT         0x00000000u
  #define  XBUS_XBGC_XFRAT_OF(x)           _VALUEOF(x)
  #define  XBUS_XBGC_XFRAT_ONEEIGHTH       0x00000000u
  #define  XBUS_XBGC_XFRAT_ONESIXTH        0x00000001u
  #define  XBUS_XBGC_XFRAT_ONEFOURTH       0x00000002u
  #define  XBUS_XBGC_XFRAT_ONEHALF         0x00000003u

  #define _XBUS_XBGC_XARB_MASK             0x00000800u
  #define _XBUS_XBGC_XARB_SHIFT            0x0000000Bu
  #define  XBUS_XBGC_XARB_DEFAULT          0x00000000u
  #define  XBUS_XBGC_XARB_OF(x)            _VALUEOF(x)
  #define  XBUS_XBGC_XARB_DISABLE          0x00000000u
  #define  XBUS_XBGC_XARB_ENABLE           0x00000001u

  #define  XBUS_XBGC_OF(x)                 _VALUEOF(x)

  #define XBUS_XBGC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(XBUS,XBGC,FMOD) \
    |_PER_FDEFAULT(XBUS,XBGC,XFCEN) \
    |_PER_FDEFAULT(XBUS,XBGC,XFRAT) \
    |_PER_FDEFAULT(XBUS,XBGC,XARB) \
  )

  #define XBUS_XBGC_RMK(xfcen,xfrat) (Uint32)( \
     _PER_FMK(XBUS,XBGC,XFCEN,xfcen) \
    |_PER_FMK(XBUS,XBGC,XFRAT,xfrat) \
  )

  #define _XBUS_XBGC_FGET(FIELD)\
    _PER_FGET(_XBUS_XBGC_ADDR,XBUS,XBGC,##FIELD)

  #define _XBUS_XBGC_FSET(FIELD,field)\
    _PER_FSET(_XBUS_XBGC_ADDR,XBUS,XBGC,##FIELD,field)

  #define _XBUS_XBGC_FSETS(FIELD,SYM)\
    _PER_FSETS(_XBUS_XBGC_ADDR,XBUS,XBGC,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  X C E C T L      |
* |___________________|
*
* XCECTL0  - XCE space control register 0
* XCECTL1  - XCE space control register 1
* XCECTL2  - XCE space control register 2
* XCECTL3  - XCE space control register 3
*
* FIELDS (msb -> lsb)
* (rw) WRSETUP
* (rw) WRSTROBE
* (rw) WRHOLD
* (rw) RDSETUP
* (rw) RDSTROBE
* (rw) MTYPE
* (rw) RDHOLD
*
\******************************************************************************/
  #define _XBUS_XCECTL0_OFFSET             2
  #define _XBUS_XCECTL1_OFFSET             1
  #define _XBUS_XCECTL2_OFFSET             4
  #define _XBUS_XCECTL3_OFFSET             5

  #define _XBUS_XCECTL0_ADDR               0x01880008u
  #define _XBUS_XCECTL1_ADDR               0x01880004u
  #define _XBUS_XCECTL2_ADDR               0x01880010u
  #define _XBUS_XCECTL3_ADDR               0x01880014u

  #define _XBUS_XCECTL_WRSETUP_MASK        0xF0000000u
  #define _XBUS_XCECTL_WRSETUP_SHIFT       0x0000001Cu
  #define  XBUS_XCECTL_WRSETUP_DEFAULT     0x0000000Fu
  #define  XBUS_XCECTL_WRSETUP_OF(x)       _VALUEOF(x)

  #define _XBUS_XCECTL_WRSTRB_MASK       0x0FC00000u
  #define _XBUS_XCECTL_WRSTRB_SHIFT      0x00000016u
  #define  XBUS_XCECTL_WRSTRB_DEFAULT    0x0000003Fu
  #define  XBUS_XCECTL_WRSTRB_OF(x)      _VALUEOF(x)

  #define _XBUS_XCECTL_WRHLD_MASK         0x00300000u
  #define _XBUS_XCECTL_WRHLD_SHIFT        0x00000014u
  #define  XBUS_XCECTL_WRHLD_DEFAULT      0x00000003u
  #define  XBUS_XCECTL_WRHLD_OF(x)        _VALUEOF(x)

  #define _XBUS_XCECTL_RDSETUP_MASK        0x000F0000u
  #define _XBUS_XCECTL_RDSETUP_SHIFT       0x00000010u
  #define  XBUS_XCECTL_RDSETUP_DEFAULT     0x0000000Fu
  #define  XBUS_XCECTL_RDSETUP_OF(x)       _VALUEOF(x)

  #define _XBUS_XCECTL_RDSTRB_MASK       0x00003F00u
  #define _XBUS_XCECTL_RDSTRB_SHIFT      0x00000008u
  #define  XBUS_XCECTL_RDSTRB_DEFAULT    0x0000003Fu
  #define  XBUS_XCECTL_RDSTRB_OF(x)      _VALUEOF(x)

  #define _XBUS_XCECTL_MTYPE_MASK          0x00000070u
  #define _XBUS_XCECTL_MTYPE_SHIFT         0x00000004u
  #define  XBUS_XCECTL_MTYPE_DEFAULT       0x00000000u
  #define  XBUS_XCECTL_MTYPE_OF(x)         _VALUEOF(x)
  #define  XBUS_XCECTL_MTYPE_32BITASYN     0x00000020u
  #define  XBUS_XCECTL_MTYPE_32BITFIFO     0x00000050u

  #define _XBUS_XCECTL_RDHLD_MASK         0x00000003u
  #define _XBUS_XCECTL_RDHLD_SHIFT        0x00000000u
  #define  XBUS_XCECTL_RDHLD_DEFAULT      0x00000003u
  #define  XBUS_XCECTL_RDHLD_OF(x)        _VALUEOF(x)

  #define  XBUS_XCECTL_OF(x)               _VALUEOF(x)

  #define XBUS_XCECTL_DEFAULT (Uint32)( \
     _PER_FDEFAULT(XBUS,XCECTL,WRSETUP) \
    |_PER_FDEFAULT(XBUS,XCECTL,WRSTRB) \
    |_PER_FDEFAULT(XBUS,XCECTL,WRHLD) \
    |_PER_FDEFAULT(XBUS,XCECTL,RDSETUP) \
    |_PER_FDEFAULT(XBUS,XCECTL,RDSTRB) \
    |_PER_FDEFAULT(XBUS,XCECTL,MTYPE) \
    |_PER_FDEFAULT(XBUS,XCECTL,RDHLD) \
  )

  #define XBUS_XCECTL_RMK(wrsetup,wrstrb,wrhld,\
    rdsetup,rdstrb,rdhld) (Uint32)( \
     _PER_FMK(XBUS,XCECTL,WRSETUP,wrsetup) \
    |_PER_FMK(XBUS,XCECTL,WRSTRB,wrstrb) \
    |_PER_FMK(XBUS,XCECTL,WRHLD,wrhld) \
    |_PER_FMK(XBUS,XCECTL,RDSETUP,rdsetup) \
    |_PER_FMK(XBUS,XCECTL,RDSTRB,rdstrb) \
    |_PER_FMK(XBUS,XCECTL,RDHLD,rdhld) \
  )

  #define _XBUS_XCECTL_FGET(N,FIELD)\
    _PER_FGET(_XBUS_XCECTL##N##_ADDR,XBUS,XCECTL,##FIELD)

  #define _XBUS_XCECTL_FSET(N,FIELD,field)\
    _PER_FSET(_XBUS_XCECTL##N##_ADDR,XBUS,XCECTL,##FIELD,field)

  #define _XBUS_XCECTL_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_XBUS_XCECTL##N##_ADDR,XBUS,XCECTL,##FIELD,##SYM)

  #define _XBUS_XCECTL0_FGET(FIELD) _XBUS_XCECTL_FGET(0,##FIELD)
  #define _XBUS_XCECTL1_FGET(FIELD) _XBUS_XCECTL_FGET(1,##FIELD)
  #define _XBUS_XCECTL2_FGET(FIELD) _XBUS_XCECTL_FGET(2,##FIELD)
  #define _XBUS_XCECTL3_FGET(FIELD) _XBUS_XCECTL_FGET(3,##FIELD)

  #define _XBUS_XCECTL0_FSET(FIELD,f) _XBUS_XCECTL_FSET(0,##FIELD,f)
  #define _XBUS_XCECTL1_FSET(FIELD,f) _XBUS_XCECTL_FSET(1,##FIELD,f)
  #define _XBUS_XCECTL2_FSET(FIELD,f) _XBUS_XCECTL_FSET(2,##FIELD,f)
  #define _XBUS_XCECTL3_FSET(FIELD,f) _XBUS_XCECTL_FSET(3,##FIELD,f)

  #define _XBUS_XCECTL0_FSETS(FIELD,SYM) _XBUS_XCECTL_FSETS(0,##FIELD,##SYM)
  #define _XBUS_XCECTL1_FSETS(FIELD,SYM) _XBUS_XCECTL_FSETS(1,##FIELD,##SYM)
  #define _XBUS_XCECTL2_FSETS(FIELD,SYM) _XBUS_XCECTL_FSETS(2,##FIELD,##SYM)
  #define _XBUS_XCECTL3_FSETS(FIELD,SYM) _XBUS_XCECTL_FSETS(3,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  X B H C          |
* |___________________|
*
* XBHC  - expansion bus host port interface control register
*
* FIELDS (msb -> lsb)
* (rw) XFRCT
* (rw) INTSRC
* (rw) START
* (rw) DSPINT
*
\******************************************************************************/
  #define _XBUS_XBHC_OFFSET                3

  #define _XBUS_XBHC_ADDR                  0x0188000Cu

  #define _XBUS_XBHC_XFRCT_MASK            0xFFFF0000u
  #define _XBUS_XBHC_XFRCT_SHIFT           0x00000010u
  #define  XBUS_XBHC_XFRCT_DEFAULT         0x00000000u
  #define  XBUS_XBHC_XFRCT_OF(x)           _VALUEOF(x)

  #define _XBUS_XBHC_INTSRC_MASK           0x00000020u
  #define _XBUS_XBHC_INTSRC_SHIFT          0x00000005u
  #define  XBUS_XBHC_INTSRC_DEFAULT        0x00000000u
  #define  XBUS_XBHC_INTSRC_OF(x)          _VALUEOF(x)
  #define  XBUS_XBHC_INTSRC_DSPINT         0x00000000u
  #define  XBUS_XBHC_INTSRC_XFRCT          0x00000001u

  #define _XBUS_XBHC_START_MASK            0x00000018u
  #define _XBUS_XBHC_START_SHIFT           0x00000003u
  #define  XBUS_XBHC_START_DEFAULT         0x00000000u
  #define  XBUS_XBHC_START_OF(x)           _VALUEOF(x)
  #define  XBUS_XBHC_START_ABORT           0x00000000u
  #define  XBUS_XBHC_START_WRITE           0x00000001u
  #define  XBUS_XBHC_START_READ            0x00000002u

  #define _XBUS_XBHC_DSPINT_MASK           0x00000002u
  #define _XBUS_XBHC_DSPINT_SHIFT          0x00000001u
  #define  XBUS_XBHC_DSPINT_DEFAULT        0x00000000u
  #define  XBUS_XBHC_DSPINT_OF(x)          _VALUEOF(x)
  #define  XBUS_XBHC_DSPINT_NONE           0x00000000u
  #define  XBUS_XBHC_DSPINT_CLR            0x00000001u

  #define  XBUS_XBHC_OF(x)                 _VALUEOF(x)

  #define XBUS_XBHC_DEFAULT (Uint32)( \
     _PER_FDEFAULT(XBUS,XBHC,XFRCT) \
    |_PER_FDEFAULT(XBUS,XBHC,INTSRC) \
    |_PER_FDEFAULT(XBUS,XBHC,START) \
    |_PER_FDEFAULT(XBUS,XBHC,DSPINT) \
  )

  #define XBUS_XBHC_RMK(xfrct,intsrc,start,dspint) (Uint32)( \
     _PER_FMK(XBUS,XBHC,XFRCT,xfrct) \
    |_PER_FMK(XBUS,XBHC,INTSRC,intsrc) \
    |_PER_FMK(XBUS,XBHC,START,start) \
    |_PER_FMK(XBUS,XBHC,DSPINT,dspint) \
  )

  #define _XBUS_XBHC_FGET(FIELD)\
    _PER_FGET(_XBUS_XBHC_ADDR,XBUS,XBHC,##FIELD)

  #define _XBUS_XBHC_FSET(FIELD,field)\
    _PER_FSET(_XBUS_XBHC_ADDR,XBUS,XBHC,##FIELD,field)

  #define _XBUS_XBHC_FSETS(FIELD,SYM)\
    _PER_FSETS(_XBUS_XBHC_ADDR,XBUS,XBHC,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  X B I M A        |
* |___________________|
*
* XBIMA  - expansion bus internal master address register
*
* FIELDS (msb -> lsb)
* (rw) XBIMA
*
\******************************************************************************/
  #define _XBUS_XBIMA_OFFSET               8

  #define _XBUS_XBIMA_ADDR                 0x01880020u

  #define _XBUS_XBIMA_XBIMA_MASK           0xFFFFFFFFu
  #define _XBUS_XBIMA_XBIMA_SHIFT          0x00000000u
  #define  XBUS_XBIMA_XBIMA_DEFAULT        0x00000000u
  #define  XBUS_XBIMA_XBIMA_OF(x)          _VALUEOF(x)

  #define  XBUS_XBIMA_OF(x)                _VALUEOF(x)

  #define XBUS_XBIMA_DEFAULT (Uint32)( \
     _PER_FDEFAULT(XBUS,XBIMA,XBIMA) \
  )

  #define XBUS_XBIMA_RMK(xbima) (Uint32)( \
     _PER_FMK(XBUS,XBIMA,XBIMA,xbima) \
  )

  #define _XBUS_XBIMA_FGET(FIELD)\
    _PER_FGET(_XBUS_XBIMA_ADDR,XBUS,XBIMA,##FIELD)

  #define _XBUS_XBIMA_FSET(FIELD,field)\
    _PER_FSET(_XBUS_XBIMA_ADDR,XBUS,XBIMA,##FIELD,field)

  #define _XBUS_XBIMA_FSETS(FIELD,SYM)\
    _PER_FSETS(_XBUS_XBIMA_ADDR,XBUS,XBIMA,##FIELD,##SYM)


/******************************************************************************\
* _____________________
* |                   |
* |  X B E A          |
* |___________________|
*
* XBEA  - expansion bus external address register
*
* FIELDS (msb -> lsb)
* (rw) XBEA
*
\******************************************************************************/
  #define _XBUS_XBEA_OFFSET                9

  #define _XBUS_XBEA_ADDR                  0x01880024u

  #define _XBUS_XBEA_XBEA_MASK             0xFFFFFFFFu
  #define _XBUS_XBEA_XBEA_SHIFT            0x00000000u
  #define  XBUS_XBEA_XBEA_DEFAULT          0x00000000u
  #define  XBUS_XBEA_XBEA_OF(x)            _VALUEOF(x)

  #define  XBUS_XBEA_OF(x)                 _VALUEOF(x)

  #define XBUS_XBEA_DEFAULT (Uint32)( \
     _PER_FDEFAULT(XBUS,XBEA,XBEA) \
  )

  #define XBUS_XBEA_RMK(xbea) (Uint32)( \
     _PER_FMK(XBUS,XBEA,XBEA,xbea) \
  )

  #define _XBUS_XBEA_FGET(FIELD)\
    _PER_FGET(_XBUS_XBEA_ADDR,XBUS,XBEA,##FIELD)

  #define _XBUS_XBEA_FSET(FIELD,field)\
    _PER_FSET(_XBUS_XBEA_ADDR,XBUS,XBEA,##FIELD,field)

  #define _XBUS_XBEA_FSETS(FIELD,SYM)\
    _PER_FSETS(_XBUS_XBEA_ADDR,XBUS,XBEA,##FIELD,##SYM)


/*----------------------------------------------------------------------------*/

#endif /* XBUS_SUPPORT */
#endif /* _CSL_XBUSHAL_H_ */
/******************************************************************************\
* End of csl_xbushal.h
\******************************************************************************/


csl_chiphal.inc/1092218718  0     0     0       8653      `
*******************************************************************************
*           Copyright (C) 1999-2001 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_chiphal.inc
* DATE CREATED.. 03/13/1999 
* LAST MODIFIED. 05/19/2004  Added CHIP_DM641 and CHIP_DM640
*                06/26/2003  Added CHIP_6411
*		 06/17/2003  Added CHIP_6712C
*                06/09/2003  Added EMU_SUPPORT
*                05/28/2003  Added CHIP_6711C
*                11/05/2001  -  CHIP_6411 / CHIP_DM642 
*                10/29/2001  -  MCASP + PLL + I2C SUPPORT Macro for 6713
*                10/01/2001  -  CHIP_6713 device 
********************************************************************************
  .if $isdefed("_CSL_CHIPHAL_INC_")==0
_CSL_CHIPHAL_INC_ .set 1

********************************************************************************
* macro and constant declarations
********************************************************************************

 .if $isdefed("CHIP_ALL")==0
CHIP_ALL .set 0
  .else
CHIP_6201 .set 1
CHIP_6202 .set 1
CHIP_6203 .set 1
CHIP_6204 .set 1
CHIP_6205 .set 1
CHIP_6211 .set 1
CHIP_6701 .set 1
CHIP_6711 .set 1
CHIP_6712 .set 1
CHIP_6713 .set 1
CHIP_DA610 .set 1
CHIP_DM642 .set 1
CHIP_DM641 .set 1
CHIP_DM640 .set 1
CHIP_6412 .set 1
CHIP_6414 .set 1
CHIP_6415 .set 1
CHIP_6416 .set 1
CHIP_6711C .set 1
CHIP_6712C .set 1
CHIP_6411 .set 1
CHIP_6410 .set 1
CHIP_6413 .set 1
CHIP_6418 .set 1
  .endif


 .if $isdefed("CHIP_6201")==0
CHIP_6201 .set 0
 .endif

 .if $isdefed("CHIP_6202")==0
CHIP_6202 .set 0
 .endif

 .if $isdefed("CHIP_6203")==0
CHIP_6203 .set 0
 .endif

 .if $isdefed("CHIP_6204")==0
CHIP_6204 .set 0
 .endif

 .if $isdefed("CHIP_6205")==0
CHIP_6205 .set 0
 .endif

 .if $isdefed("CHIP_6211")==0
CHIP_6211 .set 0
 .endif

 .if $isdefed("CHIP_6701")==0
CHIP_6701 .set 0
 .endif

 .if $isdefed("CHIP_6711")==0
CHIP_6711 .set 0
 .endif
 
 .if $isdefed("CHIP_6712")==0
CHIP_6712 .set 0
 .endif

 .if $isdefed("CHIP_6713")==0
CHIP_6713 .set 0
 .endif

 .if $isdefed("CHIP_DA610")==0
CHIP_DA610 .set 0
 .endif


 .if $isdefed("CHIP_DM642")==0
CHIP_DM642 .set 0
 .endif

 .if $isdefed("CHIP_DM641")==0
CHIP_DM641 .set 0
 .endif

 .if $isdefed("CHIP_DM640")==0
CHIP_DM640 .set 0
 .endif

 .if $isdefed("CHIP_6412")==0
CHIP_6412 .set 0
 .endif

 .if $isdefed("CHIP_6414")==0
CHIP_6414 .set 0
 .endif

 .if $isdefed("CHIP_6415")==0
CHIP_6415 .set 0
 .endif

 .if $isdefed("CHIP_6416")==0
CHIP_6416 .set 0
 .endif

 .if $isdefed("CHIP_6711C")==0
CHIP_6711C .set 0
 .endif
 
 .if $isdefed("CHIP_6712C")==0
CHIP_6712C .set 0
 .endif

 .if $isdefed("CHIP_6411")==0
CHIP_6411 .set 0
 .endif

 .if $isdefed("CHIP_6410")==0
CHIP_6410 .set 0
 .endif

 .if $isdefed("CHIP_6413")==0
CHIP_6413 .set 0
 .endif

 .if $isdefed("CHIP_6418")==0
CHIP_6418 .set 0
 .endif

 .if ((CHIP_6201|CHIP_6202|CHIP_6203|CHIP_6204|CHIP_6205|CHIP_6211|CHIP_6701|CHIP_6711|CHIP_6712|CHIP_6713|CHIP_DA610|CHIP_DM642|CHIP_DM641|CHIP_DM640|CHIP_6412|CHIP_6414|CHIP_6415|CHIP_6416|CHIP_6711C|CHIP_6712C|CHIP_6411|CHIP_6410|CHIP_6413|CHIP_6418)==0)
 .emsg "NO CHIP DEFINED (use -dCHIP_XXXX where XXXX is chip number, i.e. 6201)"
 .endif

CHIP_NONE .set 0

SUPPORT .macro symbol,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,c21,c22,c23

 .var r0,r1,r2,r3,r4,r5,r6
 .asg ( c0*CHIP_6201 )|( c1*CHIP_6202 )|( c2*CHIP_6203 )|( c3*CHIP_6204 ),r0
 .asg ( c4*CHIP_6205 )|( c5*CHIP_6211 )|( c6*CHIP_6701 )|( c7*CHIP_6711 ),r1
 .asg ( c8*CHIP_6712 )|( c9*CHIP_6713 )|(c10*CHIP_DA610),r2 
 .asg (c11*CHIP_DM642)|(c12*CHIP_DM641)|(c13*CHIP_DM640),r3
 .asg (c14*CHIP_6412 )|(c15*CHIP_6414 )|(c16*CHIP_6415 )|(c17*CHIP_6416 ),r4
 .asg (c18*CHIP_6711C)|(c19*CHIP_6712C)|(c20*CHIP_6411 ),r5
 .asg (c21*CHIP_6410)|(c22*CHIP_6413)|(c23*CHIP_6418),r6
symbol .set (r0|r1|r2|r3|r4|r5|r6)
 .endm

;*---------------------------------------------------------------------------*/
;*                            6 6 6 6 6 6 6 6 6 6 D D D D 6 6 6 6 6 6 6 6 6 6*/
;*                            2 2 2 2 2 2 7 7 7 7 A M M M 4 4 4 4 7 7 4 4 4 4*/
;*                            0 0 0 0 0 1 0 1 1 1 6 6 6 6 1 1 1 1 1 1 1 1 1 1*/
;*                            1 2 3 4 5 1 1 1 2 3 1 4 4 4 2 4 5 6 1 2 1 0 3 8*/
;*                                                0 2 1 0         C C        */
;*---------------------------------------------------------------------------*/
  SUPPORT   CACHE_SUPPORT,    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   DMA_SUPPORT,      1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  SUPPORT   EDMA_SUPPORT,     0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   EMIF_SUPPORT,     1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0
  SUPPORT   EMIFA_SUPPORT,    0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1
  SUPPORT   EMIFB_SUPPORT,    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0
  SUPPORT   GPIO_SUPPORT,     0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   HPI_SUPPORT,      1,0,0,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1
  SUPPORT   I2C_SUPPORT,      0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1
  SUPPORT   IRQ_SUPPORT,      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   MCASP_SUPPORT,    0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1
  SUPPORT   MCBSP_SUPPORT,    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   PLL_SUPPORT,      0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0
  SUPPORT   TIMER_SUPPORT,    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   XBUS_SUPPORT,     0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  SUPPORT   PCI_SUPPORT,      0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0,1,0,0,0
  SUPPORT   DAT_SUPPORT,      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   PWR_SUPPORT,      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   UTOP_SUPPORT,     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0
  SUPPORT   TCP_SUPPORT,      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
  SUPPORT   VCP_SUPPORT,      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1
  SUPPORT   L2CACHE_SUPPORT,  0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   TC_SUPPORT,       0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  SUPPORT   FPU_SUPPORT,      0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0
  SUPPORT   C01_SUPPORT,      1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  SUPPORT   C11_SUPPORT,      0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0
  SUPPORT   C64_SUPPORT,      0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1
  SUPPORT   EMU_SUPPORT,      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1
                                                                             
;*---------------------------------------------------------------------------*/
;* added for DM642, DM641 and DM640 support begin                            */
;*---------------------------------------------------------------------------*/
  SUPPORT   VIC_SUPPORT,      0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0
  SUPPORT   VP_SUPPORT,       0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0
  SUPPORT   EMAC_SUPPORT,     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0
  SUPPORT   MDIO_SUPPORT,     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0
;*---------------------------------------------------------------------------*/
;* added for DM642, DM641 and DM640 support end                              */
;*---------------------------------------------------------------------------*/
                                                                             
;*---------------------------------------------------------------------------*/
;* added for DRI300 support begin                                            */
;*---------------------------------------------------------------------------*/
  SUPPORT   ATL_SUPPORT,      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
;*---------------------------------------------------------------------------*/
;* added for DRI300 support end                                              */
;*---------------------------------------------------------------------------*/
                                                                               
                                                                               
;*-----------------------------------------------------------------------------*/


  .endif  ;_CSL_CHIPHAL_INC_
********************************************************************************
* End of csl_chiphal.inc
********************************************************************************


csl_dat_.sa/    1030611955  0     0     0       45852     `
********************************************************************************
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_dat_.sa
* DATE CREATED.. 11/11/1999 
* LAST MODIFIED. 10/03/2000
********************************************************************************
  .include "csl_chiphal.inc"

  .global _DAT_wait
  .global _DAT_busy
  .global _DAT_fill
  .global _DAT_copy
  .global _DAT_copy2d

  .ref    __DAT_serialTable
  .ref    __DAT_stateStruct

  .if DAT_SUPPORT

  .if DMA_SUPPORT
********************************************************************************
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
* DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT DMA_SUPPORT 
********************************************************************************

;DMA register offsets
PRICTL .set 0
SECCTL .set 2
SRC    .set 4
DST    .set 6
XFRCNT .set 8 

;State structure, must match that in the C file
State       .struct
useMask     .word
baseAddr    .word
gblcntAddr  .word
gblidxAddr  .word
initPrictl  .word
            .endstruct

 
*------------------------------------------------------------------------------*
* void DAT_wait(Uint32 id);
*------------------------------------------------------------------------------*
_DAT_wait .cproc id

               .reg gieSave
               .reg X
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber 
               .reg pred
               .reg mask
               .reg irfReg
               .reg stateAddr
               .reg useMask

               ;first let's check to see if this is the magic wait-for-all ID
               CMPEQ id,-1,pred
       [!pred] B     DAT_WAIT_NORMAL

               ;at this point, the ID is the wait-for-all magic id
               ;this means we have to wait for ALL tranfers to complete

               ;Load useMask
               MVKL  __DAT_stateStruct,stateAddr
               MVKH  __DAT_stateStruct,stateAddr
               LDW   *stateAddr(State.useMask),useMask 
                
DAT_WAIT_LOOP0:       
               ;Wait until all mask bits appears in the IFR
               MVC   IFR,irfReg
               AND   useMask,irfReg,X
               CMPEQ useMask,X,pred
       [!pred] B     DAT_WAIT_LOOP0

               B     DAT_WAIT_RETURN

DAT_WAIT_NORMAL:
               ;Extract slot number and serial number from id
               MVKL  0x000000FF,X
               MVKH  0x000000FF,X
               AND   id,X,slotNumber
               SHRU  id,16,serialNumber
               
               ;Load old serial number from table
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber
                                            
               ;If the serial numbers don't match then return
               CMPEQ serialNumber,oldSerialNumber,pred
       [!pred] B     DAT_WAIT_RETURN
               
               ;Generate IFR mask from slot number (mask = 1<<slotNumber)
               MVK   1,mask
               SHL   mask,slotNumber,mask
               
DAT_WAIT_LOOP1:       
               ;Wait until the mask bit appears in the IFR
               MVC   IFR,irfReg
               AND   mask,irfReg,pred
       [!pred] B     DAT_WAIT_LOOP1


DAT_WAIT_RETURN:

               .return
               .endproc


*------------------------------------------------------------------------------*
* int DAT_busy(Uint32 id);
*------------------------------------------------------------------------------*
_DAT_busy .cproc id

               .reg gieSave
               .reg X
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber 
               .reg pred
               .reg mask
               .reg irfReg
               .reg busyFlag

               ;set busy flag to zero
               ZERO  busyFlag
 
               ;Extract slot number and serial number from id
               MVKL  0x000000FF,X
               MVKH  0x000000FF,X
               AND   id,X,slotNumber
               SHRU  id,16,serialNumber
               
               ;Load old serial number from table
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber
                                            
               ;If the serial numbers don't match then return
               CMPEQ serialNumber,oldSerialNumber,pred
       [!pred] B     DAT_BUSY_RETURN
               
               ;Generate IFR mask from slot number (mask = 1<<slotNumber)
               MVK   1,mask
               SHL   mask,slotNumber,mask
               
               ;check to see if the mask bit appears in the IFR
               MVC   IFR,irfReg
               AND   mask,irfReg,pred
        [pred] B     DAT_BUSY_RETURN

               ;the IFR flag was not set, hence the slot IS busy
               ADD   busyFlag,1,busyFlag

DAT_BUSY_RETURN:

               .return busyFlag
               .endproc


*------------------------------------------------------------------------------*
* Uint32 DAT_fill(void *dst , Uint16 byteCnt, Uint32 *value);
*------------------------------------------------------------------------------*
_DAT_fill .cproc dst, byteCnt, value

               .reg gieSave
               .reg X,Y
               .reg const31
               .reg stateAddr
               .reg useMask
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber 
               .reg pred
               .reg mask
               .reg irfReg
               .reg id
               .reg alignment
               .reg dmaBase
               .reg initPrictl

               ;Load useMask and Initial primary control register
               MVKL  __DAT_stateStruct,stateAddr
               MVKH  __DAT_stateStruct,stateAddr
               LDW   *stateAddr(State.useMask),useMask 
               LDW   *stateAddr(State.initPrictl),initPrictl 
               
               ;Constant needed later
               MVK   31,const31

DAT_FILL_LOOP1:         
               ;Wait for a free slot to open up
               MVC   IFR,irfReg
               AND   irfReg,useMask,X
               LMBD  1,X,X
               SUB   const31,X,slotNumber
               CMPEQ slotNumber,-1,pred
       [pred]  B     DAT_FILL_LOOP1

               ;Save and clear GIE
               MVC   CSR,X
               AND   X,1,gieSave
               AND   X,-2,X
               MVC   X,CSR
 
               ;Generate mask from slot number
               MVK   1,mask
               SHL   mask,slotNumber,mask

               ;Clear interrupt pending flag
               MVC   mask,ICR

               ;Load up serial number table address
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber
               
               ;Add one to serial numer and store it back into the table
               ADD   oldSerialNumber,1,serialNumber
               STH   serialNumber,*tableAddr[slotNumber] 
               
               ;Construct transfer id from serial number and slot number
               SHL   serialNumber,16,id
               OR    id,slotNumber,id

               ;Load up base address of DMA registers
               LDW   *stateAddr(State.baseAddr),dmaBase 
               
               ;Store zero into DMA primary control register
               MVKL  0x00000000,X
               MVKH  0x00000000,X
               STW   X,*dmaBase[PRICTL]
               
               ;Store source address
               STW   value,*dmaBase[SRC]
               
               ;Store destination address
               STW   dst,*dmaBase[DST]

               ;Store secondary control register
               MVKL  0x0000A080,Y
               MVKH  0x0000A080,Y
               STW   Y,*dmaBase[SECCTL]

               ;Calculate argument alignment
               OR    dst,byteCnt,alignment 
               OR    value,alignment,alignment
               AND   alignment,3,alignment
               
DAT_FILL_32:
               ;Check to see if 32-bit aligned, branch if not
               CMPEQ alignment,0,pred
       [!pred] B     DAT_FILL_16
       
               ;Store transfer count
               SHRU  byteCnt,2,X
               STW   X,*dmaBase[XFRCNT]
               
               ;Store primary control register
               MVKL  0x00000041,Y
               MVKH  0x00000041,Y
               OR    Y,initPrictl,Y
               STW   Y,*dmaBase[PRICTL]
               
               ;All done so go to procedure exit code
               B     DAT_FILL_RETURN
      
DAT_FILL_16:
               ;Check to see if 16-bit aligned, branch if not
               CMPEQ alignment,2,pred
       [!pred] B     DAT_FILL_8 
       
               ;Store transfer count
               SHRU  byteCnt,1,X
               STW   X,*dmaBase[XFRCNT]

               ;Store primary control register
               MVKL  0x00000141,Y
               MVKH  0x00000141,Y
               OR    Y,initPrictl,Y
               STW   Y,*dmaBase[PRICTL]
               
               ;All done so go to procedure exit code
               B     DAT_FILL_RETURN

DAT_FILL_8:
               ;Must be 8-bit aligned since it wasn't 32 or 16 bit aligned

               ;Store transfer count
               STW   byteCnt,*dmaBase[XFRCNT]

               ;Store primary control register
               MVKL  0x00000241,Y
               MVKH  0x00000241,Y
               OR    Y,initPrictl,Y
               STW   Y,*dmaBase[PRICTL]
               

DAT_FILL_RETURN:
               ;Restore GIE
               MVC   CSR,X
               OR    X,gieSave,X
               MVC   X,CSR

               .return id
               .endproc
               

*------------------------------------------------------------------------------*
* Uint32 DAT_copy(void *src , void *dst , Uint16 byteCnt);
*------------------------------------------------------------------------------*
_DAT_copy .cproc src, dst, byteCnt               

               .reg gieSave
               .reg X,Y
               .reg const31
               .reg stateAddr
               .reg useMask
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber 
               .reg pred
               .reg mask
               .reg irfReg
               .reg id
               .reg alignment
               .reg dmaBase
               .reg initPrictl

               ;Load useMask and Initial primary control register
               MVKL  __DAT_stateStruct,stateAddr
               MVKH  __DAT_stateStruct,stateAddr
               LDW   *stateAddr(State.useMask),useMask 
               LDW   *stateAddr(State.initPrictl),initPrictl 

               ;Constant needed later
               MVK   31,const31

DAT_COPY_LOOP1:         
               ;Wait for a free slot to open up
               MVC   IFR,irfReg
               AND   irfReg,useMask,X
               LMBD  1,X,X
               SUB   const31,X,slotNumber
               CMPEQ slotNumber,-1,pred
       [pred]  B     DAT_COPY_LOOP1

               ;Save and clear GIE
               MVC   CSR,X
               AND   X,1,gieSave
               AND   X,-2,X
               MVC   X,CSR
 
               ;Generate mask from slot number
               MVK   1,mask
               SHL   mask,slotNumber,mask

               ;Clear interrupt pending flag
               MVC   mask,ICR

               ;Load up serial number table address
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber
               
               ;Add one to serial numer and store it back into the table
               ADD   oldSerialNumber,1,serialNumber
               STH   serialNumber,*tableAddr[slotNumber] 
               
               ;Construct transfer id from serial number and slot number
               SHL   serialNumber,16,id
               OR    id,slotNumber,id

               ;Load up base address of DMA registers
               LDW   *stateAddr(State.baseAddr),dmaBase 
               
               ;Store zero into DMA primary control register
               MVKL  0x00000000,X
               MVKH  0x00000000,X
               STW   X,*dmaBase[PRICTL]
               
               ;Store source address
               STW   src,*dmaBase[SRC]
               
               ;Store destination address
               STW   dst,*dmaBase[DST]

               ;Store secondary control register
               MVKL  0x0000A080,Y
               MVKH  0x0000A080,Y
               STW   Y,*dmaBase[SECCTL]

               ;Calculate argument alignment
               OR    src,dst,alignment 
               OR    byteCnt,alignment,alignment
               AND   alignment,3,alignment
               
DAT_COPY_32:
               ;Check to see if 32-bit aligned, branch if not
               CMPEQ alignment,0,pred
       [!pred] B     DAT_COPY_16
       
               ;Store transfer count
               SHRU  byteCnt,2,X
               STW   X,*dmaBase[XFRCNT]
               
               ;Store primary control register
               MVKL  0x00000051,Y
               MVKH  0x00000051,Y
               OR    Y,initPrictl,Y
               STW   Y,*dmaBase[PRICTL]
               
               ;All done so go to procedure exit code
               B     DAT_COPY_RETURN
      
DAT_COPY_16:
               ;Check to see if 16-bit aligned, branch if not
               CMPEQ alignment,2,pred
       [!pred] B     DAT_COPY_8 
       
               ;Store transfer count
               SHRU  byteCnt,1,X
               STW   X,*dmaBase[XFRCNT]

               ;Store primary control register
               MVKL  0x00000151,Y
               MVKH  0x00000151,Y
               OR    Y,initPrictl,Y
               STW   Y,*dmaBase[PRICTL]
               
               ;All done so go to procedure exit code
               B     DAT_COPY_RETURN

DAT_COPY_8:
               ;Must be 8-bit aligned since it wasn't 32 or 16 bit aligned

               ;Store transfer count
               STW   byteCnt,*dmaBase[XFRCNT]

               ;Store primary control register
               MVKL  0x00000251,Y
               MVKH  0x00000251,Y
               OR    Y,initPrictl,Y
               STW   Y,*dmaBase[PRICTL]

DAT_COPY_RETURN:
               ;Restore GIE
               MVC   CSR,X
               OR    X,gieSave,X
               MVC   X,CSR

               .return id
               .endproc


*------------------------------------------------------------------------------*
* Uint32 DAT_copy2d(Uint32 type, void *src, void *dst, Uint16 lineLen, 
*   Uint16 lineCnt, Uint16 linePitch);
*------------------------------------------------------------------------------*
_DAT_copy2d .cproc type, src, dst, lineLen, lineCnt, linePitch

               .reg gieSave
               .reg X,Y
               .reg const31
               .reg stateAddr
               .reg useMask
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber 
               .reg pred
               .reg mask
               .reg irfReg
               .reg id
               .reg alignment
               .reg dmaBase
               .reg initPrictl
               .reg gblcntAddr
               .reg gblidxAddr

               ;Load useMask an Initial primary control 
               ;register from state structure
               MVKL  __DAT_stateStruct,stateAddr
               MVKH  __DAT_stateStruct,stateAddr
               LDW   *stateAddr(State.useMask),useMask 
               LDW   *stateAddr(State.initPrictl),initPrictl 
               LDW   *stateAddr(State.gblcntAddr),gblcntAddr 
               LDW   *stateAddr(State.gblidxAddr),gblidxAddr 

               ;Constant needed later
               MVK   31,const31

DAT_COPY2D_LOOP1:         
               ;Wait for a free slot to open up
               MVC   IFR,irfReg
               AND   irfReg,useMask,X
               LMBD  1,X,X
               SUB   const31,X,slotNumber
               CMPEQ slotNumber,-1,pred
       [pred]  B     DAT_COPY2D_LOOP1

               ;Save and clear GIE
               MVC   CSR,X
               AND   X,1,gieSave
               AND   X,-2,X
               MVC   X,CSR
 
               ;Generate mask from slot number
               MVK   1,mask
               SHL   mask,slotNumber,mask

               ;Clear interrupt pending flag
               MVC   mask,ICR

               ;Load up serial number table address
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber
               
               ;Add one to serial numer and store it back into the table
               ADD   oldSerialNumber,1,serialNumber
               STH   serialNumber,*tableAddr[slotNumber] 
               
               ;Construct transfer id from serial number and slot number
               SHL   serialNumber,16,id
               OR    id,slotNumber,id

               ;Load up base address of DMA registers
               LDW   *stateAddr(State.baseAddr),dmaBase 
               
               ;Store zero into DMA primary control register
               MVKL  0x00000000,X
               MVKH  0x00000000,X
               STW   X,*dmaBase[PRICTL]
               
               ;Store source address
               STW   src,*dmaBase[SRC]
               
               ;Store destination address
               STW   dst,*dmaBase[DST]

               ;Store secondary control register
               MVKL  0x0000A080,Y
               MVKH  0x0000A080,Y
               STW   Y,*dmaBase[SECCTL]

               ;Calculate argument alignment
               OR    src,dst,alignment 
               OR    lineLen,alignment,alignment
               OR    linePitch,alignment,alignment
               AND   alignment,3,alignment
               
DAT_COPY2D_32:
               ;Check to see if 32-bit aligned, branch if not
               CMPEQ alignment,0,pred
       [!pred] B     DAT_COPY2D_16
       
               ;Store global index reload register  
               ;((linePitch-lineLen+4)<<16)|4
               SUB   linePitch,lineLen,X
               ADD   X,4,X 
               SHL   X,16,X 
               OR    X,4,X
               STW   X,*gblidxAddr[0]
               
               ;Store transfer count and reload   (lineCnt<<16)|(lineLen>>2)
               SHL   lineCnt,16,Y
               SHRU  lineLen,2,X
               OR    X,Y,X
               STW   X,*dmaBase[XFRCNT]
               STW   X,*gblcntAddr[0]
               
               ;Store primary control register
               MVKL  0x00000001,Y
               MVKH  0x00000001,Y
               OR    Y,initPrictl,Y
               OR    Y,type,Y
               STW   Y,*dmaBase[PRICTL]
               
               ;All done so go to procedure exit code
               B     DAT_COPY2D_RETURN
      
DAT_COPY2D_16:
               ;Check to see if 16-bit aligned, branch if not
               CMPEQ alignment,2,pred
       [!pred] B     DAT_COPY2D_8 
       
               ;Store global index reload register   
               ;((linePitch-lineLen+2)<<16)|2
               SUB   linePitch,lineLen,X
               ADD   X,2,X 
               SHL   X,16,X 
               OR    X,2,X
               STW   X,*gblidxAddr[0]
               
               ;Store transfer count and reload   (lineCnt<<16)|(lineLen>>1)
               SHL   lineCnt,16,Y
               SHRU  lineLen,1,X
               OR    X,Y,X
               STW   X,*dmaBase[XFRCNT]
               STW   X,*gblcntAddr[0]

               ;Store primary control register
               MVKL  0x00000101,Y
               MVKH  0x00000101,Y
               OR    Y,initPrictl,Y
               OR    Y,type,Y
               STW   Y,*dmaBase[PRICTL]
               
               ;All done so go to procedure exit code
               B     DAT_COPY2D_RETURN

DAT_COPY2D_8:
               ;Must be 8-bit aligned since it wasn't 32 or 16 bit aligned

               ;Store global index reload register   
               ;((linePitch-lineLen+1)<<16)|1
               SUB   linePitch,lineLen,X
               ADD   X,1,X 
               SHL   X,16,X 
               OR    X,1,X
               STW   X,*gblidxAddr[0]
               
               ;Store transfer count and reload   (lineCnt<<16)|(lineLen)
               SHL   lineCnt,16,X
               OR    X,lineLen,X
               STW   X,*dmaBase[XFRCNT]
               STW   X,*gblcntAddr[0]

               ;Store primary control register
               MVKL  0x00000201,Y
               MVKH  0x00000201,Y
               OR    Y,initPrictl,Y
               OR    Y,type,Y
               STW   Y,*dmaBase[PRICTL]

DAT_COPY2D_RETURN:
               ;Restore GIE
               MVC   CSR,X
               OR    X,gieSave,X
               MVC   X,CSR

               .return id
               .endproc

*------------------------------------------------------------------------------*
  .endif ;DMA_SUPPORT




 .if EDMA_SUPPORT
********************************************************************************
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
* EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT EDMA_SUPPORT 
********************************************************************************

;QDMA register offsets
OPT    .set 8
SRC    .set 1
CNT    .set 2
DST    .set 3
IDX    .set 4

;state structure, must match that in the C file
State      .struct
useMask    .word
baseAddr   .word
initOpt    .word
           .endstruct

*------------------------------------------------------------------------------*
* void DAT_wait(Uint32 id);
*------------------------------------------------------------------------------*
_DAT_wait .cproc id

               .reg gieSave
               .reg X
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber
               .reg pred
               .reg mask
               .reg cipr
               .reg ciprAddr
               .reg stateAddr
               .reg useMask

               ;first let's check to see if this is the magic wait-for-all ID
               CMPEQ id,-1,pred
       [!pred] B     DAT_WAIT_NORMAL

               ;at this point, the ID is the wait-for-all magic id
               ;this means we have to wait for ALL tranfers to complete

               ;Load useMask
               MVKL  __DAT_stateStruct,stateAddr
               MVKH  __DAT_stateStruct,stateAddr
               LDW   *stateAddr(State.useMask),useMask 
                
               MVKL  0x01A0FFE4,ciprAddr
               MVKH  0x01A0FFE4,ciprAddr
               ZERO  pred
DAT_WAIT_LOOP0:       
               ;Wait until all mask bits appears in the CIPR
       [!pred] LDW   *ciprAddr,cipr
               AND   useMask,cipr,X
               CMPEQ useMask,X,pred
       [!pred] B     DAT_WAIT_LOOP0
             
               B     DAT_WAIT_RETURN

DAT_WAIT_NORMAL:
               ;Extract slot number and serial number from id
;              MVKL  0x000000FF,X
;              MVKH  0x000000FF,X
;              AND   id,X,slotNumber
               EXTU  id,24,24,slotNumber
               SHRU  id,16,serialNumber

               ;Load old serial number from table
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber

               ;If the serial numbers don't match then return
               CMPEQ serialNumber,oldSerialNumber,pred
       [!pred] B     DAT_WAIT_RETURN

               ;Generate CIPR mask from slot number (mask = 1<<slotNumber)
               MVK   1,mask
               SHL   mask,slotNumber,mask

               MVKL  0x01A0FFE4,ciprAddr
               MVKH  0x01A0FFE4,ciprAddr
               ZERO  pred
DAT_WAIT_LOOP1:
               ;Wait until the mask bit appears in the CIPR
       [!pred] LDW   *ciprAddr,cipr
               AND   mask,cipr,pred
       [!pred] B     DAT_WAIT_LOOP1

DAT_WAIT_RETURN:
               .return
               .endproc

*------------------------------------------------------------------------------*
* int DAT_busy(Uint32 id);
*------------------------------------------------------------------------------*
_DAT_busy .cproc id

               .reg gieSave
               .reg X
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber
               .reg pred
               .reg mask
               .reg cipr
               .reg ciprAddr
               .reg busyFlag

               ;clear the busy flag
               ZERO  busyFlag

               ;Extract slot number and serial number from id
               MVKL  0x000000FF,X
               MVKH  0x000000FF,X
               AND   id,X,slotNumber
               SHRU  id,16,serialNumber

               ;Load old serial number from table
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber

               ;If the serial numbers don't match then return
               CMPEQ serialNumber,oldSerialNumber,pred
       [!pred] B     DAT_BUSY_RETURN

               ;Generate CIPR mask from slot number (mask = 1<<slotNumber)
               MVK   1,mask
               SHL   mask,slotNumber,mask

               MVKL  0x01A0FFE4,ciprAddr
               MVKH  0x01A0FFE4,ciprAddr

               ;check to see if the mask bit appears in the CIPR
               LDW   *ciprAddr,cipr
               AND   mask,cipr,pred
        [pred] B     DAT_BUSY_RETURN

               ;the mask bit didn't appear, hence the slot is busy
               ADD   busyFlag,1,busyFlag

DAT_BUSY_RETURN:

               .return busyFlag
               .endproc

*------------------------------------------------------------------------------*
* Uint32 DAT_fill(void *dst , Uint16 byteCnt, Uint32 *value);
*------------------------------------------------------------------------------*
_DAT_fill .cproc dst, byteCnt, value

               .reg gieSave
               .reg X,Y
               .reg const31
               .reg stateAddr
               .reg useMask
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber
               .reg pred
               .reg mask
               .reg cipr
               .reg id
               .reg alignment
               .reg qdmaBase
               .reg initOpt
               .reg ciprAddr

               ;Load useMask and Initial primary control register
               MVKL  __DAT_stateStruct,stateAddr
               MVKH  __DAT_stateStruct,stateAddr
               LDW   *stateAddr(State.useMask),useMask
               LDW   *stateAddr(State.initOpt),initOpt

               ;Constant needed later
               MVK   31,const31

               MVKL  0x01A0FFE4,ciprAddr
               MVKH  0x01A0FFE4,ciprAddr
               ZERO  pred
DAT_FILL_LOOP1:
               ;Wait for a free slot to open up
       [!pred] LDW   *ciprAddr,cipr
               AND   cipr,useMask,pred
       [!pred] B     DAT_FILL_LOOP1

               LMBD  1,pred,X
               SUB   const31,X,slotNumber

               ;Save and clear GIE
               MVC   CSR,X
               AND   X,1,gieSave
               AND   X,-2,X
               MVC   X,CSR

               ;Generate mask from slot number
               MVK   1,mask
               SHL   mask,slotNumber,mask

               ;Clear interrupt pending flag
               STW   mask,*ciprAddr

               ;Load up serial number table address
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber

               ;Add one to serial numer and store it back into the table
               ADD   oldSerialNumber,1,serialNumber
               STH   serialNumber,*tableAddr[slotNumber]

               ;Construct transfer id from serial number and slot number
               SHL   serialNumber,16,id
               OR    id,slotNumber,id

               ;Load up base address of DMA registers
               LDW   *stateAddr(State.baseAddr),qdmaBase

               ;Store source address
               STW   value,*qdmaBase[SRC]

               ;Store destination address
               STW   dst,*qdmaBase[DST]

               ;store index
;              MVKL  0x00000000,Y
;              MVKH  0x00000000,Y
               ZERO  Y
               STW   Y,*qdmaBase[IDX]

               ;Calculate argument alignment
               OR    dst,byteCnt,alignment
               OR    value,alignment,alignment
               AND   alignment,3,alignment

DAT_FILL_32:
               ;Check to see if 32-bit aligned, branch if not
               CMPEQ alignment,0,pred
       [!pred] B     DAT_FILL_16

               ;Store transfer count
               SHRU  byteCnt,2,X
               STW   X,*qdmaBase[CNT]

               ;Store option register into pseudo space to kick off transfer
               MVKL  0x00200000,Y
               MVKH  0x00200000,Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

               ;All done so go to procedure exit code
               B     DAT_FILL_RETURN

DAT_FILL_16:
               ;Check to see if 16-bit aligned, branch if not
               CMPEQ alignment,2,pred
       [!pred] B     DAT_FILL_8

               ;Store transfer count
               SHRU  byteCnt,1,X
               STW   X,*qdmaBase[CNT]

               ;Store option register into pseudo space to kick off transfer
               MVKL  0x08200000,Y
               MVKH  0x08200000,Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

               ;All done so go to procedure exit code
               B     DAT_FILL_RETURN

DAT_FILL_8:
               ;Must be 8-bit aligned since it wasn't 32 or 16 bit aligned

               ;Store transfer count
               STW   byteCnt,*qdmaBase[CNT]

               ;Store option register into pseudo space to kick off transfer
               MVKL  0x10200000,Y
               MVKH  0x10200000,Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

DAT_FILL_RETURN:
               ;Restore GIE
               MVC   CSR,X
               OR    X,gieSave,X
               MVC   X,CSR

               .return id
               .endproc

*------------------------------------------------------------------------------*
* Uint32 DAT_copy(void *src , void *dst , Uint16 byteCnt);
*------------------------------------------------------------------------------*
_DAT_copy .cproc src, dst, byteCnt

               .reg gieSave
               .reg X,Y
               .reg const31
               .reg stateAddr
               .reg useMask
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber
               .reg pred
               .reg mask
               .reg cipr
               .reg id
               .reg alignment
               .reg qdmaBase
               .reg initOpt
               .reg ciprAddr

               ;Load useMask and Initial primary control register
               MVKL  __DAT_stateStruct,stateAddr
               MVKH  __DAT_stateStruct,stateAddr
               LDW   *stateAddr(State.useMask),useMask
               LDW   *stateAddr(State.initOpt),initOpt

               ;Constant needed later
               MVK   31,const31

               MVKL  0x01A0FFE4,ciprAddr
               MVKH  0x01A0FFE4,ciprAddr
;               MVK   1, pred
;DAT_COPY_LOOP1:
;               ;Wait for a free slot to open up
;       [pred]  LDW   *ciprAddr,cipr
;               AND   cipr,useMask,X
;               LMBD  1,X,X
;               SUB   const31,X,slotNumber
;               CMPEQ slotNumber,-1,pred
;       [pred]  B     DAT_COPY_LOOP1

               ZERO  pred
DAT_COPY_LOOP1:
               ;Wait for a free slot to open up
       [!pred] LDW   *ciprAddr,cipr
               AND   cipr,useMask,pred
       [!pred] B     DAT_COPY_LOOP1

               LMBD  1,pred,X
               SUB   const31,X,slotNumber

               ;Save and clear GIE
               MVC   CSR,X
               AND   X,1,gieSave
               AND   X,-2,X
               MVC   X,CSR

               ;Generate mask from slot number
               MVK   1,mask
               SHL   mask,slotNumber,mask

               ;Clear interrupt pending flag
               STW   mask,*ciprAddr

               ;Load up serial number table address
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber

               ;Add one to serial numer and store it back into the table
               ADD   oldSerialNumber,1,serialNumber
               STH   serialNumber,*tableAddr[slotNumber]

               ;Construct transfer id from serial number and slot number
               SHL   serialNumber,16,id
               OR    id,slotNumber,id

               ;Load up base address of DMA registers
               LDW   *stateAddr(State.baseAddr),qdmaBase

               ;Store source address
               STW   src,*qdmaBase[SRC]

               ;Store destination address
               STW   dst,*qdmaBase[DST]

               ;store index
               MVKL  0x00000000,Y
               MVKH  0x00000000,Y
               STW   Y,*qdmaBase[IDX]

               ;Calculate argument alignment
               OR    dst,byteCnt,alignment
               OR    src,alignment,alignment
               AND   alignment,3,alignment

DAT_COPY_32:
               ;Check to see if 32-bit aligned, branch if not
               CMPEQ alignment,0,pred
       [!pred] B     DAT_COPY_16

               ;Store transfer count
               SHRU  byteCnt,2,X
               STW   X,*qdmaBase[CNT]

               ;Store option register into pseudo space to kick off transfer
               MVKL  0x01200000,Y
               MVKH  0x01200000,Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

               ;All done so go to procedure exit code
               B     DAT_COPY_RETURN

DAT_COPY_16:
               ;Check to see if 16-bit aligned, branch if not
               CMPEQ alignment,2,pred
       [!pred] B     DAT_COPY_8

               ;Store transfer count
               SHRU  byteCnt,1,X
               STW   X,*qdmaBase[CNT]

               ;Store option register into pseudo space to kick off transfer
               MVKL  0x09200000,Y
               MVKH  0x09200000,Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

               ;All done so go to procedure exit code
               B     DAT_COPY_RETURN

DAT_COPY_8:
               ;Must be 8-bit aligned since it wasn't 32 or 16 bit aligned

               ;Store transfer count
               STW   byteCnt,*qdmaBase[CNT]

               ;Store option register into pseudo space to kick off transfer
               MVKL  0x11200000,Y
               MVKH  0x11200000,Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

DAT_COPY_RETURN:
               ;Restore GIE
               MVC   CSR,X
               OR    X,gieSave,X
               MVC   X,CSR

               .return id
               .endproc

*------------------------------------------------------------------------------*
* Uint32 DAT_copy2d(Uint32 type, void *src, void *dst, Uint16 lineLen, 
*   Uint16 lineCnt, Uint16 linePitch);
*------------------------------------------------------------------------------*
_DAT_copy2d .cproc type, src, dst, lineLen, lineCnt, linePitch

               .reg gieSave
               .reg X,Y
               .reg const31
               .reg stateAddr
               .reg useMask
               .reg slotNumber
               .reg serialNumber
               .reg tableAddr
               .reg oldSerialNumber
               .reg pred
               .reg mask
               .reg cipr
               .reg id
               .reg alignment
               .reg qdmaBase
               .reg initOpt
               .reg ciprAddr

               ;Load useMask and Initial primary control register
               MVKL  __DAT_stateStruct,stateAddr
               MVKH  __DAT_stateStruct,stateAddr
               LDW   *stateAddr(State.useMask),useMask
               LDW   *stateAddr(State.initOpt),initOpt

               ;Constant needed later
               MVK   31,const31

               ;address of the channel interrupt pending register
               MVKL  0x01A0FFE4,ciprAddr
               MVKH  0x01A0FFE4,ciprAddr

;               MVK   1,pred
;DAT_COPY2D_LOOP1:
;               ;Wait for a free slot to open up
;        [pred] LDW   *ciprAddr,cipr
;               AND   cipr,useMask,X
;               LMBD  1,X,X
;               SUB   const31,X,slotNumber
;               CMPEQ slotNumber,-1,pred
;        [pred] B     DAT_COPY2D_LOOP1

               ZERO  pred
DAT_COPY2D_LOOP1:
               ;Wait for a free slot to open up
       [!pred] LDW   *ciprAddr,cipr
               AND   cipr,useMask,pred
       [!pred] B     DAT_COPY2D_LOOP1

               LMBD  1,pred,X
               SUB   const31,X,slotNumber

               ;Save and clear GIE
               MVC   CSR,X
               AND   X,1,gieSave
               AND   X,-2,X
               MVC   X,CSR

               ;Generate mask from slot number
               MVK   1,mask
               SHL   mask,slotNumber,mask

               ;Clear interrupt pending flag
               STW   mask,*ciprAddr

               ;Load up serial number table address
               MVKL  __DAT_serialTable,tableAddr
               MVKH  __DAT_serialTable,tableAddr
               LDHU  *tableAddr[slotNumber],oldSerialNumber

               ;Add one to serial numer and store it back into the table
               ADD   oldSerialNumber,1,serialNumber
               STH   serialNumber,*tableAddr[slotNumber]

               ;Construct transfer id from serial number and slot number
               SHL   serialNumber,16,id
               OR    id,slotNumber,id

               ;Load up base address of DMA registers
               LDW   *stateAddr(State.baseAddr),qdmaBase

               ;Store source address
               STW   src,*qdmaBase[SRC]

               ;Store destination address
               STW   dst,*qdmaBase[DST]

               ;Calculate argument alignment
               OR    dst,lineLen,alignment
               OR    src,alignment,alignment
               OR    linePitch,alignment,alignment
               AND   alignment,3,alignment

DAT_COPY2D_32:
               ;Check to see if 32-bit aligned, branch if not
               CMPEQ alignment,0,pred
       [!pred] B     DAT_COPY2D_16

               ;Store transfer count
               SHRU  lineLen,2,X
               SUB   lineCnt,1,Y
               SHL   Y,16,Y
               OR    X,Y,X
               STW   X,*qdmaBase[CNT]

               ;Store index register 
               SUB   linePitch,lineLen,X
               SHL   X,16,X
               STW   X,*qdmaBase[IDX]

               ;Store option register into pseudo space to kick off transfer
;              MVKL  0x00000000,Y
;              MVKH  0x00000000,Y
               ZERO  Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    type,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

               ;All done so go to procedure exit code
               B     DAT_COPY2D_RETURN

DAT_COPY2D_16:
               ;Check to see if 16-bit aligned, branch if not
               CMPEQ alignment,2,pred
       [!pred] B     DAT_COPY2D_8

               ;Store transfer count
               SHRU  lineLen,1,X
               SUB   lineCnt,1,Y
               SHL   Y,16,Y
               OR    X,Y,X
               STW   X,*qdmaBase[CNT]

               ;Store index register 
               SUB   linePitch,lineLen,X
               SHL   X,16,X
               STW   X,*qdmaBase[IDX]

               ;Store option register into pseudo space to kick off transfer
               MVKL  0x08000000,Y
               MVKH  0x08000000,Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    type,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

               ;All done so go to procedure exit code
               B     DAT_COPY2D_RETURN

DAT_COPY2D_8:
               ;Must be 8-bit aligned since it wasn't 32 or 16 bit aligned

               ;Store transfer count
               SHRU  lineLen,0,X
               SUB   lineCnt,1,Y
               SHL   Y,16,Y
               OR    X,Y,X
               STW   X,*qdmaBase[CNT]

               ;Store index register 
               SUB   linePitch,lineLen,X
               SHL   X,16,X
               STW   X,*qdmaBase[IDX]

               ;Store option register into pseudo space to kick off transfer
               MVKL  0x10000000,Y
               MVKH  0x10000000,Y
               SHL   slotNumber,16,X
               OR    X,Y,Y
               OR    type,Y,Y
               OR    Y,initOpt,Y
               STW   Y,*qdmaBase[OPT]

DAT_COPY2D_RETURN:
               ;Restore GIE
               MVC   CSR,X
               OR    X,gieSave,X
               MVC   X,CSR

               .return id
               .endproc

*------------------------------------------------------------------------------*
 .endif ;EDMA_SUPPORT
 
 .endif ;DAT_SUPPORT

********************************************************************************
* End of csl_dat_.sa
********************************************************************************

csl_atl.c/      1080217102  0     0     0       2618      `
/******************************************************************************\
*           Copyright (C) 2003-2005 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_atl.c
* DATE CREATED.. 07/01/2003 
\******************************************************************************/
#define _ATL_MOD_

#include "csl_atl.h"


#if (ATL_SUPPORT)
/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/


/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/


/*----------------------------------------------------------------------------*/

#endif /* ATL_SUPPORT */
/******************************************************************************\
* End of csl_atl.c
\******************************************************************************/

csl_atl.h/      1080217102  0     0     0       4480      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_atl.h
* DATE CREATED.. 07/01/2003 
* LAST MODIFIED. 
\******************************************************************************/
#ifndef _CSL_ATL_H_
#define _CSL_ATL_H_

#include <csl_chip.h>
#include <csl_irq.h>
#include <csl_atlhal.h>


#if (ATL_SUPPORT)
/******************************************************************************\
* scope and inline control macros
\******************************************************************************/
#ifdef __cplusplus
#define CSLAPI extern "C" far
#else
#define CSLAPI extern far
#endif

#undef  USEDEFS
#undef  IDECL
#undef  IDEF

#ifdef  _I2C_MOD_
  #define IDECL CSLAPI
  #define USEDEFS
  #define IDEF
#else
  #ifdef  _INLINE
    #define IDECL static inline
    #define USEDEFS
    #define IDEF  static inline
  #else
    #define IDECL CSLAPI
  #endif
#endif


/******************************************************************************\
* global macro declarations
\******************************************************************************/

/******************************************************************************\
* global typedef declarations
\******************************************************************************/

/* device configuration structure */
typedef struct {
	Uint32 atlppmr;
	Uint32 atlcr;
} ATL_Config;

/******************************************************************************\
* global variable declarations
\******************************************************************************/

/******************************************************************************\
* global function declarations
\******************************************************************************/

/******************************************************************************\
* inline function declarations
\******************************************************************************/
IDECL void ATL_config(ATL_Config *config);
IDECL void ATL_configArgs(Uint32 atlppmr, Uint32 atlcr);
IDECL void ATL_getConfig(ATL_Config *config);

/******************************************************************************\
* inline function definitions
\******************************************************************************/
#ifdef USEDEFS
/*----------------------------------------------------------------------------*/
IDEF void ATL_config(ATL_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_ATL_BASE_PORT;
  register int x0,x1;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */
  x0  = config->atlppmr;
  x1  = config->atlcr;

  base[_ATL_ATLPPMR_OFFSET]  = x0;
  base[_ATL_ATLCR_OFFSET]  = x1;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void ATL_configArgs(Uint32 atlppmr, Uint32 atlcr) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_ATL_BASE_PORT;

  gie = IRQ_globalDisable();

  base[_ATL_ATLPPMR_OFFSET]  = atlppmr;
  base[_ATL_ATLCR_OFFSET]  = atlcr;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
IDEF void ATL_getConfig(ATL_Config *config) {

  Uint32 gie;
  volatile Uint32 *base = (volatile Uint32 *)_ATL_BASE_PORT;
  volatile ATL_Config* cfg = (volatile ATL_Config*)config;
  register int x0,x1;

  gie = IRQ_globalDisable();

  /* the compiler generates more efficient code if the loads */
  /* and stores are grouped together raher than intermixed   */

  x0  = base[_ATL_ATLPPMR_OFFSET];
  x1  = base[_ATL_ATLCR_OFFSET];

  cfg->atlppmr  = x0;
  cfg->atlcr  = x1;

  IRQ_globalRestore(gie);
}
/*----------------------------------------------------------------------------*/
#endif /* USEDEFS */

#endif /* ATL_SUPPORT */

#endif /* _CSL_ATL_H_ */
/******************************************************************************\
* End of csl_atl.h
\******************************************************************************/

csl_atlhal.h/   1080217102  0     0     0       7699      `
/******************************************************************************\
*           Copyright (C) 1999-2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_atlhal.h
* DATE CREATED.. 07/01/2003 
* .............. 07/02/2003    first draft completed
* LAST MODIFIED.
*               
*------------------------------------------------------------------------------
* REGISTERS
*
* ATLPPMR    - ATL Parts Per Million Register 
* ATLSCNTR   - ATL Sample Count Register
* ATLCR      - ATL Control Register
*
\******************************************************************************/
#ifndef _CSL_ATLHAL_H_
#define _CSL_ATLHAL_H_

#include <csl_stdinc.h>
#include <csl_chip.h>
#if (ATL_SUPPORT)
/******************************************************************************\
* MISC section
\******************************************************************************/
  #define _ATL_BASE_PORT       0x01B7F000u
 

/******************************************************************************\
* module level register/field access macros
\******************************************************************************/

  /* ----------------- */
  /* FIELD MAKE MACROS */
  /* ----------------- */

  #define ATL_FMK(REG,FIELD,x)\
    _PER_FMK(ATL,##REG,##FIELD,x)

  #define ATL_FMKS(REG,FIELD,SYM)\
    _PER_FMKS(ATL,##REG,##FIELD,##SYM)


  /* -------------------------------- */
  /* RAW REGISTER/FIELD ACCESS MACROS */
  /* -------------------------------- */

  #define ATL_ADDR(REG)\
    _ATL_##REG##_ADDR

  #define ATL_RGET(REG)\
    _PER_RGET(_ATL_##REG##_ADDR,ATL,##REG)

  #define ATL_RSET(REG,x)\
    _PER_RSET(_ATL_##REG##_ADDR,ATL,##REG,x)

  #define ATL_FGET(REG,FIELD)\
    _ATL_##REG##_FGET(##FIELD)

  #define ATL_FSET(REG,FIELD,x)\
    _ATL_##REG##_FSET(##FIELD,##x)

  #define ATL_FSETS(REG,FIELD,SYM)\
    _ATL_##REG##_FSETS(##FIELD,##SYM)


  /* ------------------------------------------ */
  /* ADDRESS BASED REGISTER/FIELD ACCESS MACROS */
  /* ------------------------------------------ */

  #define ATL_RGETA(addr,REG)\
    _PER_RGET(addr,ATL,##REG)

  #define ATL_RSETA(addr,REG,x)\
    _PER_RSET(addr,ATL,##REG,x)

  #define ATL_FGETA(addr,REG,FIELD)\
    _PER_FGET(addr,ATL,##REG,##FIELD)

  #define ATL_FSETA(addr,REG,FIELD,x)\
    _PER_FSET(addr,ATL,##REG,##FIELD,x)

  #define ATL_FSETSA(addr,REG,FIELD,SYM)\
    _PER_FSETS(addr,ATL,##REG,##FIELD,##SYM)

/******************************************************************************\
*  ___________________
* |                   |
* |  A T L P P M R    |
* |___________________|
*
* ATLPPMR    - ATL Parts Per Million register
*
* FIELDS (msb -> lsb)
* (rw) PPMSD
* (rw) PPMSET
*
\******************************************************************************/
  #define _ATL_ATLPPMR_OFFSET           0

  #define _ATL_ATLPPMR_ADDR            0x01B7F000

  #define _ATL_ATLPPMR_PPMSD_MASK          0x00008000u
  #define _ATL_ATLPPMR_PPMSD_SHIFT         0x0000000Fu
  #define  ATL_ATLPPMR_PPMSD_DEFAULT       0x00000000u
  #define  ATL_ATLPPMR_PPMSD_OF(x)         _VALUEOF(x)
  #define  ATL_ATLPPMR_PPMSD_SLOWDOWN      0x00000000u
  #define  ATL_ATLPPMR_PPMSD_SPEEDUP       0x00000001u

  #define _ATL_ATLPPMR_PPMSET_MASK          0x000001FFu
  #define _ATL_ATLPPMR_PPMSET_SHIFT         0x00000000u
  #define  ATL_ATLPPMR_PPMSET_DEFAULT       0x00000000u
  #define  ATL_ATLPPMR_PPMSET_OF(x)         _VALUEOF(x)

  #define  ATL_ATLPPMR_OF(x)             _VALUEOF(x)

  #define ATL_ATLPPMR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(ATL,ATLPPMR,PPMSD)\
    |_PER_FDEFAULT(ATL,ATLPPMR,PPMSET)\
  )

  #define ATL_ATLPPMR_RMK(ppmsd,ppmset) (Uint32)(\
     _PER_FMK(ATL,ATLPPMR,PPMSD,ppmsd)\
    |_PER_FMK(ATL,ATLPPMR,PPMSET,ppmset)\
  )
   
  #define _ATL_ATLPPMR_FGET(N,FIELD)\
    _PER_FGET(_ATL_ATLPPMR##N##_ADDR,ATL,ATLPPMR,##FIELD)

  #define _ATL_ATLPPMR_FSET(N,FIELD,field)\
    _PER_FSET(_ATL_ATLPPMR##N##_ADDR,ATL,ATLPPMR,##FIELD,field)

  #define _ATL_ATLPPMR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_ATL_ATLPPMR##N##_ADDR,ATL,ATLPPMR,##FIELD,##SYM)

/******************************************************************************\
*  ___________________
* |                   |
* |  A T L S C N T R  |
* |___________________|
*
* ATLSCNTR    - ATL Sample Count register
*
* FIELDS (msb -> lsb)
* (r) SCNT
*
\******************************************************************************/
  #define _ATL_ATLSCNTR_OFFSET           1

  #define _ATL_ATLSCNTR_ADDR            0x01B7F004

  #define _ATL_ATLSCNTR_SCNT_MASK          0x0000FFFFu
  #define _ATL_ATLSCNTR_SCNT_SHIFT         0x00000000u
  #define  ATL_ATLSCNTR_SCNT_DEFAULT       0x00000000u
  #define  ATL_ATLSCNTR_SCNT_OF(x)         _VALUEOF(x)

  #define  ATL_ATLSCNTR_OF(x)             _VALUEOF(x)

  #define ATL_ATLSCNTR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(ATL,ATLSCNTR,SCNT)\
  )

  #define ATL_ATLSCNTR_RMK(scnt) (Uint32)(\
     _PER_FMK(ATL,ATLSCNTR,SCNT,scnt)\
  )
   
  #define _ATL_ATLSCNTR_FGET(N,FIELD)\
    _PER_FGET(_ATL_ATLSCNTR##N##_ADDR,ATL,ATLSCNTR,##FIELD)

/******************************************************************************\
*  _______________
* |               |
* |  A T L C R    |
* |_______________|
*
* ATLCR    - ATL Control register
*
* FIELDS (msb -> lsb)
* (rw) MUXCLKSEL
* (rw) MCDSEL
* (rw) ATLIDIV
*
\******************************************************************************/
  #define _ATL_ATLCR_OFFSET           2

  #define _ATL_ATLCR_ADDR            0x01B7F008

  #define _ATL_ATLCR_MUXCLKSEL_MASK          0x00000040u
  #define _ATL_ATLCR_MUXCLKSEL_SHIFT         0x00000006u
  #define  ATL_ATLCR_MUXCLKSEL_DEFAULT       0x00000000u
  #define  ATL_ATLCR_MUXCLKSEL_OF(x)         _VALUEOF(x)
  #define  ATL_ATLCR_MUXCLKSEL_ATLPCLK       0x00000000u
  #define  ATL_ATLCR_MUXCLKSEL_EATCLK        0x00000001u

  #define _ATL_ATLCR_MCDSEL_MASK             0x00000020u
  #define _ATL_ATLCR_MCDSEL_SHIFT            0x00000005u
  #define  ATL_ATLCR_MCDSEL_DEFAULT          0x00000000u
  #define  ATL_ATLCR_MCDSEL_OF(x)            _VALUEOF(x)
  #define  ATL_ATLCR_MCDSEL_BY2P16           0x00000000u
  #define  ATL_ATLCR_MCDSEL_BY2P14           0x00000001u

  #define _ATL_ATLCR_ATLIDIV_MASK            0x0000001Fu
  #define _ATL_ATLCR_ATLIDIV_SHIFT           0x00000000u
  #define  ATL_ATLCR_ATLIDIV_DEFAULT         0x00000018u
  #define  ATL_ATLCR_ATLIDIV_OF(x)           _VALUEOF(x)

  #define  ATL_ATLCR_OF(x)             _VALUEOF(x)

  #define ATL_ATLCR_DEFAULT (Uint32)(\
     _PER_FDEFAULT(ATL,ATLCR,MUXCLKSEL)\
    |_PER_FDEFAULT(ATL,ATLCR,MCDSEL)\
    |_PER_FDEFAULT(ATL,ATLCR,ATLIDIV)\
  )

  #define ATL_ATLCR_RMK(muxclksel,mcdsel,atlidiv) (Uint32)(\
     _PER_FMK(ATL,ATLCR,MUXCLKSEL,muxclksel)\
    |_PER_FMK(ATL,ATLCR,MCDCLK,mcdsel)\
    |_PER_FMK(ATL,ATLCR,ATLIDIV,atlidiv)\
  )
   
  #define _ATL_ATLCR_FGET(N,FIELD)\
    _PER_FGET(_ATL_ATLCR##N##_ADDR,ATL,ATLCR,##FIELD)

  #define _ATL_ATLCR_FSET(N,FIELD,field)\
    _PER_FSET(_ATL_ATLCR##N##_ADDR,ATL,ATLCR,##FIELD,field)

  #define _ATL_ATLCR_FSETS(N,FIELD,SYM)\
    _PER_FSETS(_ATL_ATLCR##N##_ADDR,ATL,ATLCR,##FIELD,##SYM)

#endif /* ATL_SUPPORT */
#endif /* _CSL_ATLHAL_H_ */
/******************************************************************************\
* End of csl_atlhal.h
\******************************************************************************/

csl_test.c/     1074500420  0     0     0       286628    `
/******************************************************************************\
*           Copyright (C) 2000 Texas Instruments Incorporated.
*                           All Rights Reserved
*------------------------------------------------------------------------------
* FILENAME...... csl_test.c
* DATE CREATED.. 08/15/2000 
* LAST MODIFIED. 10/30/2000
\******************************************************************************/
#define _TEST_MOD_
#include "csl_test.h"
#include <csl_legacy.h>

/******************************************************************************\
*                         L O C A L   S E C T I O N
\******************************************************************************/
#define CACHE_BUILD  1
#define CHIP_BUILD   1
#define DAT_BUILD    1
#define DMA_BUILD    1
#define EDMA_BUILD   1
#define EMIF_BUILD   1
#define HPI_BUILD    1
#define IRQ_BUILD    1
#define MCBSP_BUILD  1
#define PCI_BUILD    1
#define PWR_BUILD    1
#define TIMER_BUILD  1
#define UTOP_BUILD   1
#define XBUS_BUILD   1


/******************************************************************************\
* static macro declarations
\******************************************************************************/


/******************************************************************************\
* static typedef declarations
\******************************************************************************/


/******************************************************************************\
* static function declarations
\******************************************************************************/


/******************************************************************************\
* static variable definitions
\******************************************************************************/
static volatile Uint32 x,z;

/******************************************************************************\
* static function definitions
\******************************************************************************/


/******************************************************************************\
*                        G L O B A L   S E C T I O N
\******************************************************************************/


/******************************************************************************\
* global variable definitions
\******************************************************************************/


/******************************************************************************\
* global function definitions
\******************************************************************************/
/*----------------------------------------------------------------------------*/
int TEST_all(int arg) {

  int x = 0;

  x |= TEST_csl(arg);
  x |= TEST_cache(arg);
  x |= TEST_chip(arg);
  x |= TEST_dat(arg);
  x |= TEST_dma(arg);
  x |= TEST_edma(arg);
  x |= TEST_emif(arg);
  x |= TEST_hpi(arg);
  x |= TEST_irq(arg);
  x |= TEST_mcbsp(arg);
  x |= TEST_pci(arg);
  x |= TEST_pwr(arg);
  x |= TEST_stdinc(arg);
  x |= TEST_timer(arg);
  x |= TEST_utop(arg);
  x |= TEST_xbus(arg);

  return x;
}

/*----------------------------------------------------------------------------*/
int TEST_csl(int arg) {


  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_cache(int arg) {

  #if (CACHE_SUPPORT&&CACHE_BUILD)


#if (L2CACHE_SUPPORT)    
    CACHE_L2Mode m;

    m = CACHE_getL2Mode();
    CACHE_enableCaching(CACHE_CE00);
    CACHE_enableCaching(_CACHE_MAR0_ADDR);
#endif

#if (L2CACHE_SUPPORT)    

/*  Test FMK Macro start */
    x = CACHE_FMK(   CCFG,      P,0xFFFFFFFF);
    x = CACHE_FMK(   CCFG,     IP,0xFFFFFFFF);
    x = CACHE_FMK(   CCFG,     ID,0xFFFFFFFF);
    x = CACHE_FMK(   CCFG, L2MODE,0xFFFFFFFF);
    x = CACHE_FMK( L2FBAR, L2FBAR,0xFFFFFFFF);
    x = CACHE_FMK(  L2FWC,  L2FWC,0xFFFFFFFF);
    x = CACHE_FMK( L2CBAR, L2CBAR,0xFFFFFFFF);
    x = CACHE_FMK(  L2CWC,  L2CWC,0xFFFFFFFF);
    x = CACHE_FMK(L1PFBAR,L1PFBAR,0xFFFFFFFF);
    x = CACHE_FMK( L1PFWC, L1PFWC,0xFFFFFFFF);
    x = CACHE_FMK(L1DFBAR,L1DFBAR,0xFFFFFFFF);
    x = CACHE_FMK( L1DFWC, L1DFWC,0xFFFFFFFF);
    x = CACHE_FMK(L2FLUSH,      F,0xFFFFFFFF);
    x = CACHE_FMK(L2CLEAN,      C,0xFFFFFFFF);
    x = CACHE_FMK(    MAR,     CE,0xFFFFFFFF);
/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = CACHE_FMKS(   CCFG,      P,DEFAULT);
    x = CACHE_FMKS(   CCFG,     IP,DEFAULT);
    x = CACHE_FMKS(   CCFG,     ID,DEFAULT);
    x = CACHE_FMKS(   CCFG, L2MODE,DEFAULT);
    x = CACHE_FMKS( L2FBAR, L2FBAR,DEFAULT);
    x = CACHE_FMKS(  L2FWC,  L2FWC,DEFAULT);
    x = CACHE_FMKS( L2CBAR, L2CBAR,DEFAULT);
    x = CACHE_FMKS(  L2CWC,  L2CWC,DEFAULT);
    x = CACHE_FMKS(L1PFBAR,L1PFBAR,DEFAULT);
    x = CACHE_FMKS( L1PFWC, L1PFWC,DEFAULT);
    x = CACHE_FMKS(L1DFBAR,L1DFBAR,DEFAULT);
    x = CACHE_FMKS( L1DFWC, L1DFWC,DEFAULT);
    x = CACHE_FMKS(L2FLUSH,      F,DEFAULT);
    x = CACHE_FMKS(L2CLEAN,      C,DEFAULT);
    x = CACHE_FMKS(    MAR,     CE,DEFAULT);
/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = CACHE_ADDR(   CCFG);
    x = CACHE_ADDR( L2FBAR);
    x = CACHE_ADDR(  L2FWC);
    x = CACHE_ADDR( L2CBAR);
    x = CACHE_ADDR(  L2CWC);
    x = CACHE_ADDR(L1PFBAR);
    x = CACHE_ADDR( L1PFWC);
    x = CACHE_ADDR(L1DFBAR);
    x = CACHE_ADDR( L1DFWC);
    x = CACHE_ADDR(L2FLUSH);
    x = CACHE_ADDR(L2CLEAN);
    x = CACHE_ADDR(   MAR0);
    x = CACHE_ADDR(   MAR1);
    x = CACHE_ADDR(   MAR2);
    x = CACHE_ADDR(   MAR3);
    x = CACHE_ADDR(   MAR4);
    x = CACHE_ADDR(   MAR5);
    x = CACHE_ADDR(   MAR6);
    x = CACHE_ADDR(   MAR7);
    x = CACHE_ADDR(   MAR8);
    x = CACHE_ADDR(   MAR9);
    x = CACHE_ADDR(  MAR10);
    x = CACHE_ADDR(  MAR11);
    x = CACHE_ADDR(  MAR12);
    x = CACHE_ADDR(  MAR13);
    x = CACHE_ADDR(  MAR14);
    x = CACHE_ADDR(  MAR15);
/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = CACHE_RGET(   CCFG);
    x = CACHE_RGET( L2FBAR);
    x = CACHE_RGET(  L2FWC);
    x = CACHE_RGET( L2CBAR);
    x = CACHE_RGET(  L2CWC);
    x = CACHE_RGET(L1PFBAR);
    x = CACHE_RGET( L1PFWC);
    x = CACHE_RGET(L1DFBAR);
    x = CACHE_RGET( L1DFWC);
    x = CACHE_RGET(L2FLUSH);
    x = CACHE_RGET(L2CLEAN);
    x = CACHE_RGET(   MAR0);
    x = CACHE_RGET(   MAR1);
    x = CACHE_RGET(   MAR2);
    x = CACHE_RGET(   MAR3);
    x = CACHE_RGET(   MAR4);
    x = CACHE_RGET(   MAR5);
    x = CACHE_RGET(   MAR6);
    x = CACHE_RGET(   MAR7);
    x = CACHE_RGET(   MAR8);
    x = CACHE_RGET(   MAR9);
    x = CACHE_RGET(  MAR10);
    x = CACHE_RGET(  MAR11);
    x = CACHE_RGET(  MAR12);
    x = CACHE_RGET(  MAR13);
    x = CACHE_RGET(  MAR14);
    x = CACHE_RGET(  MAR15);
/*  Test RGET Macro end */
/*  Test RSET Macro start */
    CACHE_RSET(   CCFG,   CACHE_CCFG_DEFAULT);
    CACHE_RSET( L2FBAR, CACHE_L2FBAR_DEFAULT);
    CACHE_RSET(  L2FWC,  CACHE_L2FWC_DEFAULT);
    CACHE_RSET( L2CBAR, CACHE_L2CBAR_DEFAULT);
    CACHE_RSET(  L2CWC,  CACHE_L2CWC_DEFAULT);
    CACHE_RSET(L1PFBAR,CACHE_L1PFBAR_DEFAULT);
    CACHE_RSET( L1PFWC, CACHE_L1PFWC_DEFAULT);
    CACHE_RSET(L1DFBAR,CACHE_L1DFBAR_DEFAULT);
    CACHE_RSET( L1DFWC, CACHE_L1DFWC_DEFAULT);
    CACHE_RSET(L2FLUSH,CACHE_L2FLUSH_DEFAULT);
    CACHE_RSET(L2CLEAN,CACHE_L2CLEAN_DEFAULT);
    CACHE_RSET(   MAR0,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR1,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR2,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR3,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR4,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR5,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR6,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR7,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR8,    CACHE_MAR_DEFAULT);
    CACHE_RSET(   MAR9,    CACHE_MAR_DEFAULT);
    CACHE_RSET(  MAR10,    CACHE_MAR_DEFAULT);
    CACHE_RSET(  MAR11,    CACHE_MAR_DEFAULT);
    CACHE_RSET(  MAR12,    CACHE_MAR_DEFAULT);
    CACHE_RSET(  MAR13,    CACHE_MAR_DEFAULT);
    CACHE_RSET(  MAR14,    CACHE_MAR_DEFAULT);
    CACHE_RSET(  MAR15,    CACHE_MAR_DEFAULT);

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = CACHE_FGET(   CCFG,      P);
    x = CACHE_FGET(   CCFG,     IP);
    x = CACHE_FGET(   CCFG,     ID);
    x = CACHE_FGET(   CCFG, L2MODE);
    x = CACHE_FGET( L2FBAR, L2FBAR);
    x = CACHE_FGET(  L2FWC,  L2FWC);
    x = CACHE_FGET( L2CBAR, L2CBAR);
    x = CACHE_FGET(  L2CWC,  L2CWC);
    x = CACHE_FGET(L1PFBAR,L1PFBAR);
    x = CACHE_FGET( L1PFWC, L1PFWC);
    x = CACHE_FGET(L1DFBAR,L1DFBAR);        
    x = CACHE_FGET( L1DFWC, L1DFWC);        
    x = CACHE_FGET(L2FLUSH,      F);        
    x = CACHE_FGET(L2CLEAN,      C);        
    x = CACHE_FGET(   MAR0,     CE);        
    x = CACHE_FGET(   MAR1,     CE);        
    x = CACHE_FGET(   MAR2,     CE);        
    x = CACHE_FGET(   MAR3,     CE);        
    x = CACHE_FGET(   MAR4,     CE);
    x = CACHE_FGET(   MAR5,     CE);        
    x = CACHE_FGET(   MAR6,     CE);        
    x = CACHE_FGET(   MAR7,     CE);        
    x = CACHE_FGET(   MAR8,     CE);        
    x = CACHE_FGET(   MAR9,     CE);        
    x = CACHE_FGET(  MAR10,     CE);        
    x = CACHE_FGET(  MAR11,     CE);        
    x = CACHE_FGET(  MAR12,     CE);        
    x = CACHE_FGET(  MAR13,     CE);
    x = CACHE_FGET(  MAR14,     CE);
    x = CACHE_FGET(  MAR15,     CE);
/*  Test FGET Macro end */
/*  Test FSET Macro start */
    CACHE_FSET(   CCFG,      P,         CACHE_CCFG_P_DEFAULT);
    CACHE_FSET(   CCFG,     IP,        CACHE_CCFG_IP_DEFAULT);
    CACHE_FSET(   CCFG,     ID,        CACHE_CCFG_ID_DEFAULT);
    CACHE_FSET(   CCFG, L2MODE,    CACHE_CCFG_L2MODE_DEFAULT);
    CACHE_FSET( L2FBAR, L2FBAR,  CACHE_L2FBAR_L2FBAR_DEFAULT);
    CACHE_FSET(  L2FWC,  L2FWC,    CACHE_L2FWC_L2FWC_DEFAULT);
    CACHE_FSET( L2CBAR, L2CBAR,  CACHE_L2CBAR_L2CBAR_DEFAULT);
    CACHE_FSET(  L2CWC,  L2CWC,    CACHE_L2CWC_L2CWC_DEFAULT);
    CACHE_FSET(L1PFBAR,L1PFBAR,CACHE_L1PFBAR_L1PFBAR_DEFAULT);
    CACHE_FSET( L1PFWC, L1PFWC,  CACHE_L1PFWC_L1PFWC_DEFAULT);
    CACHE_FSET(L1DFBAR,L1DFBAR,CACHE_L1DFBAR_L1DFBAR_DEFAULT);        
    CACHE_FSET( L1DFWC, L1DFWC,  CACHE_L1DFWC_L1DFWC_DEFAULT);        
    CACHE_FSET(L2FLUSH,      F,      CACHE_L2FLUSH_F_DEFAULT);        
    CACHE_FSET(L2CLEAN,      C,      CACHE_L2CLEAN_C_DEFAULT);        
    CACHE_FSET(   MAR0,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(   MAR1,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(   MAR2,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(   MAR3,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(   MAR4,     CE,         CACHE_MAR_CE_DEFAULT);
    CACHE_FSET(   MAR5,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(   MAR6,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(   MAR7,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(   MAR8,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(   MAR9,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(  MAR10,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(  MAR11,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(  MAR12,     CE,         CACHE_MAR_CE_DEFAULT);        
    CACHE_FSET(  MAR13,     CE,         CACHE_MAR_CE_DEFAULT);
    CACHE_FSET(  MAR14,     CE,         CACHE_MAR_CE_DEFAULT);
    CACHE_FSET(  MAR15,     CE,         CACHE_MAR_CE_DEFAULT);
/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    CACHE_FSETS(   CCFG,      P,DEFAULT);
    CACHE_FSETS(   CCFG,     IP,DEFAULT);
    CACHE_FSETS(   CCFG,     ID,DEFAULT);
    CACHE_FSETS(   CCFG, L2MODE,DEFAULT);
    CACHE_FSETS( L2FBAR, L2FBAR,DEFAULT);
    CACHE_FSETS(  L2FWC,  L2FWC,DEFAULT);
    CACHE_FSETS( L2CBAR, L2CBAR,DEFAULT);
    CACHE_FSETS(  L2CWC,  L2CWC,DEFAULT);
    CACHE_FSETS(L1PFBAR,L1PFBAR,DEFAULT);
    CACHE_FSETS( L1PFWC, L1PFWC,DEFAULT);
    CACHE_FSETS(L1DFBAR,L1DFBAR,DEFAULT);        
    CACHE_FSETS( L1DFWC, L1DFWC,DEFAULT);        
    CACHE_FSETS(L2FLUSH,      F,DEFAULT);        
    CACHE_FSETS(L2CLEAN,      C,DEFAULT);        
    CACHE_FSETS(   MAR0,     CE,DEFAULT);        
    CACHE_FSETS(   MAR1,     CE,DEFAULT);        
    CACHE_FSETS(   MAR2,     CE,DEFAULT);        
    CACHE_FSETS(   MAR3,     CE,DEFAULT);        
    CACHE_FSETS(   MAR4,     CE,DEFAULT);
    CACHE_FSETS(   MAR5,     CE,DEFAULT);        
    CACHE_FSETS(   MAR6,     CE,DEFAULT);        
    CACHE_FSETS(   MAR7,     CE,DEFAULT);        
    CACHE_FSETS(   MAR8,     CE,DEFAULT);        
    CACHE_FSETS(   MAR9,     CE,DEFAULT);        
    CACHE_FSETS(  MAR10,     CE,DEFAULT);        
    CACHE_FSETS(  MAR11,     CE,DEFAULT);        
    CACHE_FSETS(  MAR12,     CE,DEFAULT);        
    CACHE_FSETS(  MAR13,     CE,DEFAULT);
    CACHE_FSETS(  MAR14,     CE,DEFAULT);
    CACHE_FSETS(  MAR15,     CE,DEFAULT);
/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = CACHE_RGETA(0,   CCFG);
    x = CACHE_RGETA(0, L2FBAR);
    x = CACHE_RGETA(0,  L2FWC);
    x = CACHE_RGETA(0, L2CBAR);
    x = CACHE_RGETA(0,  L2CWC);
    x = CACHE_RGETA(0,L1PFBAR);
    x = CACHE_RGETA(0, L1PFWC);
    x = CACHE_RGETA(0,L1DFBAR);
    x = CACHE_RGETA(0, L1DFWC);
    x = CACHE_RGETA(0,L2FLUSH);          
    x = CACHE_RGETA(0,L2CLEAN);          
    x = CACHE_RGETA(0,   MAR0);          
    x = CACHE_RGETA(0,   MAR1);          
    x = CACHE_RGETA(0,   MAR2);          
    x = CACHE_RGETA(0,   MAR3);          
    x = CACHE_RGETA(0,   MAR4);          
    x = CACHE_RGETA(0,   MAR5);
    x = CACHE_RGETA(0,   MAR6);          
    x = CACHE_RGETA(0,   MAR7);          
    x = CACHE_RGETA(0,   MAR8);          
    x = CACHE_RGETA(0,   MAR9);          
    x = CACHE_RGETA(0,  MAR10);          
    x = CACHE_RGETA(0,  MAR11);          
    x = CACHE_RGETA(0,  MAR12);          
    x = CACHE_RGETA(0,  MAR13);
    x = CACHE_RGETA(0,  MAR14);          
    x = CACHE_RGETA(0,  MAR15);          
/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    CACHE_RSETA(0,   CCFG,0);
    CACHE_RSETA(0, L2FBAR,0); 
    CACHE_RSETA(0,  L2FWC,0); 
    CACHE_RSETA(0, L2CBAR,0); 
    CACHE_RSETA(0,  L2CWC,0); 
    CACHE_RSETA(0,L1PFBAR,0); 
    CACHE_RSETA(0, L1PFWC,0); 
    CACHE_RSETA(0,L1DFBAR,0); 
    CACHE_RSETA(0, L1DFWC,0); 
    CACHE_RSETA(0,L2FLUSH,0);           
    CACHE_RSETA(0,L2CLEAN,0);           
    CACHE_RSETA(0,   MAR0,0);           
    CACHE_RSETA(0,   MAR1,0);           
    CACHE_RSETA(0,   MAR2,0);           
    CACHE_RSETA(0,   MAR3,0);           
    CACHE_RSETA(0,   MAR4,0);           
    CACHE_RSETA(0,   MAR5,0); 
    CACHE_RSETA(0,   MAR6,0);           
    CACHE_RSETA(0,   MAR7,0);           
    CACHE_RSETA(0,   MAR8,0);           
    CACHE_RSETA(0,   MAR9,0);           
    CACHE_RSETA(0,  MAR10,0);           
    CACHE_RSETA(0,  MAR11,0);           
    CACHE_RSETA(0,  MAR12,0);           
    CACHE_RSETA(0,  MAR13,0); 
    CACHE_RSETA(0,  MAR14,0);           
    CACHE_RSETA(0,  MAR15,0);           
/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = CACHE_FGETA(0,   CCFG,      P);
    x = CACHE_FGETA(0,   CCFG,     IP);
    x = CACHE_FGETA(0,   CCFG,     ID);
    x = CACHE_FGETA(0,   CCFG, L2MODE);
    x = CACHE_FGETA(0, L2FBAR, L2FBAR); 
    x = CACHE_FGETA(0,  L2FWC,  L2FWC); 
    x = CACHE_FGETA(0, L2CBAR, L2CBAR); 
    x = CACHE_FGETA(0,  L2CWC,  L2CWC); 
    x = CACHE_FGETA(0,L1PFBAR,L1PFBAR); 
    x = CACHE_FGETA(0, L1PFWC, L1PFWC); 
    x = CACHE_FGETA(0,L1DFBAR,L1DFBAR); 
    x = CACHE_FGETA(0, L1DFWC, L1DFWC); 
    x = CACHE_FGETA(0,L2FLUSH,      F);           
    x = CACHE_FGETA(0,L2CLEAN,      C);           
    x = CACHE_FGETA(0,    MAR,     CE);           
/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    CACHE_FSETA(0,   CCFG,      P,         CACHE_CCFG_P_DEFAULT);
    CACHE_FSETA(0,   CCFG,     IP,        CACHE_CCFG_IP_DEFAULT);
    CACHE_FSETA(0,   CCFG,     ID,        CACHE_CCFG_ID_DEFAULT);
    CACHE_FSETA(0,   CCFG, L2MODE,    CACHE_CCFG_L2MODE_DEFAULT);
    CACHE_FSETA(0, L2FBAR, L2FBAR,  CACHE_L2FBAR_L2FBAR_DEFAULT); 
    CACHE_FSETA(0,  L2FWC,  L2FWC,    CACHE_L2FWC_L2FWC_DEFAULT); 
    CACHE_FSETA(0, L2CBAR, L2CBAR,  CACHE_L2CBAR_L2CBAR_DEFAULT); 
    CACHE_FSETA(0,  L2CWC,  L2CWC,    CACHE_L2CWC_L2CWC_DEFAULT); 
    CACHE_FSETA(0,L1PFBAR,L1PFBAR,CACHE_L1PFBAR_L1PFBAR_DEFAULT); 
    CACHE_FSETA(0, L1PFWC, L1PFWC,  CACHE_L1PFWC_L1PFWC_DEFAULT); 
    CACHE_FSETA(0,L1DFBAR,L1DFBAR,CACHE_L1DFBAR_L1DFBAR_DEFAULT); 
    CACHE_FSETA(0, L1DFWC, L1DFWC,  CACHE_L1DFWC_L1DFWC_DEFAULT); 
    CACHE_FSETA(0,L2FLUSH,      F,      CACHE_L2FLUSH_F_DEFAULT);           
    CACHE_FSETA(0,L2CLEAN,      C,      CACHE_L2CLEAN_C_DEFAULT);           
    CACHE_FSETA(0,    MAR,     CE,         CACHE_MAR_CE_DEFAULT);           
/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    CACHE_FSETSA(0,   CCFG,      P,DEFAULT);
    CACHE_FSETSA(0,   CCFG,     IP,DEFAULT);
    CACHE_FSETSA(0,   CCFG,     ID,DEFAULT);
    CACHE_FSETSA(0,   CCFG, L2MODE,DEFAULT);
    CACHE_FSETSA(0, L2FBAR, L2FBAR,DEFAULT); 
    CACHE_FSETSA(0,  L2FWC,  L2FWC,DEFAULT); 
    CACHE_FSETSA(0, L2CBAR, L2CBAR,DEFAULT); 
    CACHE_FSETSA(0,  L2CWC,  L2CWC,DEFAULT); 
    CACHE_FSETSA(0,L1PFBAR,L1PFBAR,DEFAULT); 
    CACHE_FSETSA(0, L1PFWC, L1PFWC,DEFAULT); 
    CACHE_FSETSA(0,L1DFBAR,L1DFBAR,DEFAULT); 
    CACHE_FSETSA(0, L1DFWC, L1DFWC,DEFAULT); 
    CACHE_FSETSA(0,L2FLUSH,      F,DEFAULT);           
    CACHE_FSETSA(0,L2CLEAN,      C,DEFAULT);           
    CACHE_FSETSA(0,    MAR,     CE,DEFAULT);           
/*  Test FSETSA Macro end */

    
#endif    

  #endif
  
  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_chip(int arg) {

  #if (CHIP_BUILD)

    x = CHIP_getMapMode();

    x = CHIP_RGET(CSR);
    x = CHIP_FGET(CSR,CPUID);
    x = CHIP_FGET(CSR,REVID);
    x = CHIP_FGET(CSR,PWRD);
    x = CHIP_FGET(CSR,SAT);
    x = CHIP_FGET(CSR,EN);
    x = CHIP_FGET(CSR,PCC);
    x = CHIP_FGET(CSR,DCC);
    x = CHIP_FGET(CSR,PGIE);
    x = CHIP_FGET(CSR,GIE);
    CHIP_RSET(CSR,CHIP_CSR_DEFAULT);

    CHIP_FSET(CSR,CPUID,CHIP_CSR_CPUID_DEFAULT);
    CHIP_FSET(CSR,REVID,CHIP_CSR_REVID_DEFAULT);
    CHIP_FSET(CSR,PWRD, CHIP_CSR_PWRD_DEFAULT);
    CHIP_FSET(CSR,SAT,  CHIP_CSR_SAT_DEFAULT);
    CHIP_FSET(CSR,EN,   CHIP_CSR_EN_DEFAULT);
    CHIP_FSET(CSR,PCC,  CHIP_CSR_PCC_DEFAULT);
    CHIP_FSET(CSR,DCC,  CHIP_CSR_DCC_DEFAULT);
    CHIP_FSET(CSR,PGIE, CHIP_CSR_PGIE_DEFAULT);
    CHIP_FSET(CSR,GIE,  CHIP_CSR_GIE_DEFAULT);

    CHIP_FSETS(CSR,CPUID,DEFAULT);
    CHIP_FSETS(CSR,REVID,DEFAULT);
    CHIP_FSETS(CSR,PWRD, DEFAULT);
    CHIP_FSETS(CSR,SAT,  DEFAULT);
    CHIP_FSETS(CSR,EN,   DEFAULT);
    CHIP_FSETS(CSR,PCC,  DEFAULT);
    CHIP_FSETS(CSR,DCC,  DEFAULT);
    CHIP_FSETS(CSR,PGIE, DEFAULT);
    CHIP_FSETS(CSR,GIE,  DEFAULT);

    x = CHIP_CSR_RMK(
      CHIP_CSR_PWRD_DEFAULT,
      CHIP_CSR_PCC_DEFAULT,
      CHIP_CSR_DCC_DEFAULT,
      CHIP_CSR_PGIE_DEFAULT,
      CHIP_CSR_GIE_DEFAULT
    );

    x = CHIP_RGET(IFR);
    x = CHIP_FGET(IFR,IF);

    CHIP_RSET(ISR,CHIP_ISR_DEFAULT);
    CHIP_FSET(ISR,IS,CHIP_ISR_IS_DEFAULT);

    CHIP_RSET(ICR,CHIP_ICR_DEFAULT);

    x = CHIP_RGET(IER);
    CHIP_RSET(IER,CHIP_IER_DEFAULT);

    x = CHIP_RGET(ISTP);
    CHIP_RSET(ISTP,CHIP_ISTP_DEFAULT);

    x = CHIP_RGET(IRP);
    CHIP_RSET(IRP,CHIP_IRP_DEFAULT);

    x = CHIP_RGET(NRP);
    CHIP_RSET(NRP,CHIP_NRP_DEFAULT);

    x = CHIP_RGET(AMR);
    CHIP_RSET(AMR,CHIP_AMR_DEFAULT);

    #if (FPU_SUPPORT)
      x = CHIP_RGET(IN);

      x = CHIP_RGET(OUT);
      CHIP_RSET(OUT,CHIP_OUT_DEFAULT);

      x = CHIP_RGET(FADCR);
      CHIP_RSET(FADCR,CHIP_FADCR_DEFAULT);

      x = CHIP_RGET(FAUCR);
      CHIP_RSET(FAUCR,CHIP_FAUCR_DEFAULT);

      x = CHIP_RGET(FMCR);
      CHIP_RSET(FMCR,CHIP_FMCR_DEFAULT);
    #endif


/*  Test FMK Macro start */
    x = CHIP_FMK(  CSR,  CPUID,0XFFFFFFFF);
    x = CHIP_FMK(  CSR,  REVID,0XFFFFFFFF);
    x = CHIP_FMK(  CSR,   PWRD,0XFFFFFFFF);
    x = CHIP_FMK(  CSR,    SAT,0XFFFFFFFF);
    x = CHIP_FMK(  CSR,     EN,0XFFFFFFFF);
    x = CHIP_FMK(  CSR,    PCC,0XFFFFFFFF);
    x = CHIP_FMK(  CSR,    DCC,0XFFFFFFFF);
    x = CHIP_FMK(  CSR,   PGIE,0XFFFFFFFF);
    x = CHIP_FMK(  CSR,    GIE,0XFFFFFFFF);

    x = CHIP_FMK(  IFR,     IF,0XFFFFFFFF);
    x = CHIP_FMK(  ISR,     IS,0XFFFFFFFF);
    x = CHIP_FMK(  ICR,     IC,0XFFFFFFFF);
    x = CHIP_FMK(  IER,     IE,0XFFFFFFFF);
    x = CHIP_FMK( ISTP, HPEINT,0XFFFFFFFF);
    x = CHIP_FMK( ISTP,   ISTB,0XFFFFFFFF);
    x = CHIP_FMK(  IRP,    IRP,0XFFFFFFFF);
    x = CHIP_FMK(  NRP,    NRP,0XFFFFFFFF);
    x = CHIP_FMK(  AMR,    BK1,0XFFFFFFFF);
    x = CHIP_FMK(  AMR,    BK0,0XFFFFFFFF);
    x = CHIP_FMK(  AMR, B7MODE,0XFFFFFFFF);
    x = CHIP_FMK(  AMR, B6MODE,0XFFFFFFFF);
    x = CHIP_FMK(  AMR, B5MODE,0XFFFFFFFF);
    x = CHIP_FMK(  AMR, B4MODE,0XFFFFFFFF);
    x = CHIP_FMK(  AMR, A7MODE,0XFFFFFFFF);
    x = CHIP_FMK(  AMR, A6MODE,0XFFFFFFFF);
    x = CHIP_FMK(  AMR, A5MODE,0XFFFFFFFF);
    x = CHIP_FMK(  AMR, A4MODE,0XFFFFFFFF);
#if (FPU_SUPPORT)
    x = CHIP_FMK(   IN,     IN,0XFFFFFFFF);
    x = CHIP_FMK(  OUT,    OUT,0XFFFFFFFF);
    x = CHIP_FMK(FADCR,L2RMODE,0XFFFFFFFF);
    x = CHIP_FMK(FADCR,L2UNDER,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L2INEX,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L2OVER,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L2INFO,0XFFFFFFFF);
    x = CHIP_FMK(FADCR,L2INVAL,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L2DEN2,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L2DEN1,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L2NAN2,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L2NAN1,0XFFFFFFFF);
    x = CHIP_FMK(FADCR,L1RMODE,0XFFFFFFFF);
    x = CHIP_FMK(FADCR,L1UNDER,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L1INEX,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L1OVER,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L1INFO,0XFFFFFFFF);
    x = CHIP_FMK(FADCR,L1INVAL,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L1DEN2,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L1DEN1,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L1NAN2,0XFFFFFFFF);
    x = CHIP_FMK(FADCR, L1NAN1,0XFFFFFFFF);

    x = CHIP_FMK(FAUCR, S2DIV0,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR,S2UNORD,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR,  S2UND,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S2INEX,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S2OVER,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S2INFO,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR,S2INVAL,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S2DEN2,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S2DEN1,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S2NAN2,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S2NAN1,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S1DIV0,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR,S1UNORD,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR,  S1UND,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S1INEX,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S1OVER,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S1INFO,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR,S1INVAL,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S1DEN2,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S1DEN1,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S1NAN2,0XFFFFFFFF);
    x = CHIP_FMK(FAUCR, S1NAN1,0XFFFFFFFF);
 
    x = CHIP_FMK( FMCR,M2RMODE,0XFFFFFFFF);
    x = CHIP_FMK( FMCR,M2UNDER,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M2INEX,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M2OVER,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M2INFO,0XFFFFFFFF);
    x = CHIP_FMK( FMCR,M2INVAL,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M2DEN2,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M2DEN1,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M2NAN2,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M2NAN1,0XFFFFFFFF);
    x = CHIP_FMK( FMCR,M1RMODE,0XFFFFFFFF);
    x = CHIP_FMK( FMCR,M1UNDER,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M1INEX,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M1OVER,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M1INFO,0XFFFFFFFF);
    x = CHIP_FMK( FMCR,M1INVAL,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M1DEN2,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M1DEN1,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M1NAN2,0XFFFFFFFF);
    x = CHIP_FMK( FMCR, M1NAN1,0XFFFFFFFF);
#endif
#if (C64_SUPPORT)
    x = CHIP_FMK( DIER,   ,0XFFFFFFFF);
    x = CHIP_FMK(   EM,   ,0XFFFFFFFF);
    x = CHIP_FMK(   ER,   ,0XFFFFFFFF);
#endif

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = CHIP_FMKS(  CSR,  CPUID,DEFAULT);
    x = CHIP_FMKS(  CSR,  REVID,DEFAULT);
    x = CHIP_FMKS(  CSR,   PWRD,DEFAULT);
    x = CHIP_FMKS(  CSR,    SAT,DEFAULT);
    x = CHIP_FMKS(  CSR,     EN,DEFAULT);
    x = CHIP_FMKS(  CSR,    PCC,DEFAULT);
    x = CHIP_FMKS(  CSR,    DCC,DEFAULT);
    x = CHIP_FMKS(  CSR,   PGIE,DEFAULT);
    x = CHIP_FMKS(  CSR,    GIE,DEFAULT);
    x = CHIP_FMKS(  IFR,     IF,DEFAULT);
    x = CHIP_FMKS(  ISR,     IS,DEFAULT);
    x = CHIP_FMKS(  ICR,     IC,DEFAULT);
    x = CHIP_FMKS(  IER,     IE,DEFAULT);
    x = CHIP_FMKS( ISTP, HPEINT,DEFAULT);
    x = CHIP_FMKS( ISTP,   ISTB,DEFAULT);
    x = CHIP_FMKS(  IRP,    IRP,DEFAULT);
    x = CHIP_FMKS(  NRP,    NRP,DEFAULT);
    x = CHIP_FMKS(  AMR,    BK1,DEFAULT);
    x = CHIP_FMKS(  AMR,    BK0,DEFAULT);
    x = CHIP_FMKS(  AMR, B7MODE,DEFAULT);
    x = CHIP_FMKS(  AMR, B6MODE,DEFAULT);
    x = CHIP_FMKS(  AMR, B5MODE,DEFAULT);
    x = CHIP_FMKS(  AMR, B4MODE,DEFAULT);
    x = CHIP_FMKS(  AMR, A7MODE,DEFAULT);
    x = CHIP_FMKS(  AMR, A6MODE,DEFAULT);
    x = CHIP_FMKS(  AMR, A5MODE,DEFAULT);
    x = CHIP_FMKS(  AMR, A4MODE,DEFAULT);
#if (FPU_SUPPORT)
    x = CHIP_FMKS(   IN,     IN,DEFAULT);
    x = CHIP_FMKS(  OUT,    OUT,DEFAULT);
    x = CHIP_FMKS(FADCR,L2RMODE,DEFAULT);
    x = CHIP_FMKS(FADCR,L2UNDER,DEFAULT);
    x = CHIP_FMKS(FADCR, L2INEX,DEFAULT);
    x = CHIP_FMKS(FADCR, L2OVER,DEFAULT);
    x = CHIP_FMKS(FADCR, L2INFO,DEFAULT);
    x = CHIP_FMKS(FADCR,L2INVAL,DEFAULT);
    x = CHIP_FMKS(FADCR, L2DEN2,DEFAULT);
    x = CHIP_FMKS(FADCR, L2DEN1,DEFAULT);
    x = CHIP_FMKS(FADCR, L2NAN2,DEFAULT);
    x = CHIP_FMKS(FADCR, L2NAN1,DEFAULT);
    x = CHIP_FMKS(FADCR,L1RMODE,DEFAULT);
    x = CHIP_FMKS(FADCR,L1UNDER,DEFAULT);
    x = CHIP_FMKS(FADCR, L1INEX,DEFAULT);
    x = CHIP_FMKS(FADCR, L1OVER,DEFAULT);
    x = CHIP_FMKS(FADCR, L1INFO,DEFAULT);
    x = CHIP_FMKS(FADCR,L1INVAL,DEFAULT);
    x = CHIP_FMKS(FADCR, L1DEN2,DEFAULT);
    x = CHIP_FMKS(FADCR, L1DEN1,DEFAULT);
    x = CHIP_FMKS(FADCR, L1NAN2,DEFAULT);
    x = CHIP_FMKS(FADCR, L1NAN1,DEFAULT);

    x = CHIP_FMKS(FAUCR, S2DIV0,DEFAULT);
    x = CHIP_FMKS(FAUCR,S2UNORD,DEFAULT);
    x = CHIP_FMKS(FAUCR,  S2UND,DEFAULT);
    x = CHIP_FMKS(FAUCR, S2INEX,DEFAULT);
    x = CHIP_FMKS(FAUCR, S2OVER,DEFAULT);
    x = CHIP_FMKS(FAUCR, S2INFO,DEFAULT);
    x = CHIP_FMKS(FAUCR,S2INVAL,DEFAULT);
    x = CHIP_FMKS(FAUCR, S2DEN2,DEFAULT);
    x = CHIP_FMKS(FAUCR, S2DEN1,DEFAULT);
    x = CHIP_FMKS(FAUCR, S2NAN2,DEFAULT);
    x = CHIP_FMKS(FAUCR, S2NAN1,DEFAULT);
    x = CHIP_FMKS(FAUCR, S1DIV0,DEFAULT);
    x = CHIP_FMKS(FAUCR,S1UNORD,DEFAULT);
    x = CHIP_FMKS(FAUCR,  S1UND,DEFAULT);
    x = CHIP_FMKS(FAUCR, S1INEX,DEFAULT);
    x = CHIP_FMKS(FAUCR, S1OVER,DEFAULT);
    x = CHIP_FMKS(FAUCR, S1INFO,DEFAULT);
    x = CHIP_FMKS(FAUCR,S1INVAL,DEFAULT);
    x = CHIP_FMKS(FAUCR, S1DEN2,DEFAULT);
    x = CHIP_FMKS(FAUCR, S1DEN1,DEFAULT);
    x = CHIP_FMKS(FAUCR, S1NAN2,DEFAULT);
    x = CHIP_FMKS(FAUCR, S1NAN1,DEFAULT);
 
    x = CHIP_FMKS( FMCR,M2RMODE,DEFAULT);
    x = CHIP_FMKS( FMCR,M2UNDER,DEFAULT);
    x = CHIP_FMKS( FMCR, M2INEX,DEFAULT);
    x = CHIP_FMKS( FMCR, M2OVER,DEFAULT);
    x = CHIP_FMKS( FMCR, M2INFO,DEFAULT);
    x = CHIP_FMKS( FMCR,M2INVAL,DEFAULT);
    x = CHIP_FMKS( FMCR, M2DEN2,DEFAULT);
    x = CHIP_FMKS( FMCR, M2DEN1,DEFAULT);
    x = CHIP_FMKS( FMCR, M2NAN2,DEFAULT);
    x = CHIP_FMKS( FMCR, M2NAN1,DEFAULT);
    x = CHIP_FMKS( FMCR,M1RMODE,DEFAULT);
    x = CHIP_FMKS( FMCR,M1UNDER,DEFAULT);
    x = CHIP_FMKS( FMCR, M1INEX,DEFAULT);
    x = CHIP_FMKS( FMCR, M1OVER,DEFAULT);
    x = CHIP_FMKS( FMCR, M1INFO,DEFAULT);
    x = CHIP_FMKS( FMCR,M1INVAL,DEFAULT);
    x = CHIP_FMKS( FMCR, M1DEN2,DEFAULT);
    x = CHIP_FMKS( FMCR, M1DEN1,DEFAULT);
    x = CHIP_FMKS( FMCR, M1NAN2,DEFAULT);
    x = CHIP_FMKS( FMCR, M1NAN1,DEFAULT);
#endif
#if (C64_SUPPORT)
    x = CHIP_FMKS( DIER,   ,DEFAULT);
    x = CHIP_FMKS(   EM,   ,DEFAULT);
    x = CHIP_FMKS(   ER,   ,DEFAULT);
#endif

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = CHIP_ADDR(  CSR);
    x = CHIP_ADDR(  IFR);
    x = CHIP_ADDR(  ISR);
    x = CHIP_ADDR(  ICR);
    x = CHIP_ADDR(  IER);
    x = CHIP_ADDR( ISTP);
    x = CHIP_ADDR(  IRP);
    x = CHIP_ADDR(  NRP);
    x = CHIP_ADDR(  AMR);
#if (FPU_SUPPORT)
    x = CHIP_ADDR(   IN);
    x = CHIP_ADDR(  OUT);
    x = CHIP_ADDR(FADCR);
    x = CHIP_ADDR(FAUCR);
    x = CHIP_ADDR( FMCR);
#endif
#if (C64_SUPPORT)
    x = CHIP_ADDR( DIER);
    x = CHIP_ADDR(   EM);
    x = CHIP_ADDR(   ER);
#endif

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = CHIP_RGET(  CSR);
    x = CHIP_RGET(  IFR);
    x = CHIP_RGET(  ISR);
    x = CHIP_RGET(  ICR);
    x = CHIP_RGET(  IER);
    x = CHIP_RGET( ISTP);
    x = CHIP_RGET(  IRP);
    x = CHIP_RGET(  NRP);
    x = CHIP_RGET(  AMR);
#if (FPU_SUPPORT)
    x = CHIP_RGET(   IN);
    x = CHIP_RGET(  OUT);
    x = CHIP_RGET(FADCR);
    x = CHIP_RGET(FAUCR);
    x = CHIP_RGET( FMCR);
#endif
#if (C64_SUPPORT)
    x = CHIP_RGET( DIER);
    x = CHIP_RGET(   EM);
    x = CHIP_RGET(   ER);
#endif


/*  Test RGET Macro end */
/*  Test RSET Macro start */
    CHIP_RSET(  CSR,  CHIP_CSR_DEFAULT);
//    CHIP_RSET(  IFR,  CHIP_IFR_DEFAULT);
    CHIP_RSET(  ISR,  CHIP_ISR_DEFAULT);
    CHIP_RSET(  ICR,  CHIP_ICR_DEFAULT);
    CHIP_RSET(  IER,  CHIP_IER_DEFAULT);
    CHIP_RSET( ISTP, CHIP_ISTP_DEFAULT);
    CHIP_RSET(  IRP,  CHIP_IRP_DEFAULT);
    CHIP_RSET(  NRP,  CHIP_NRP_DEFAULT);
    CHIP_RSET(  AMR,  CHIP_AMR_DEFAULT);
#if (FPU_SUPPORT)
    CHIP_RSET(   IN,   CHIP_IN_DEFAULT);
    CHIP_RSET(  OUT,  CHIP_OUT_DEFAULT);
    CHIP_RSET(FADCR,CHIP_FADCR_DEFAULT);
    CHIP_RSET(FAUCR,CHIP_FAUCR_DEFAULT);
    CHIP_RSET( FMCR, CHIP_FMCR_DEFAULT);
#endif
#if (C64_SUPPORT)
    CHIP_RSET( DIER, CHIP_DIER_DEFAULT);
    CHIP_RSET(   EM,   CHIP_EM_DEFAULT);
    CHIP_RSET(   ER,   CHIP_ER_DEFAULT);
#endif

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = CHIP_FGET(  CSR,  CPUID);
    x = CHIP_FGET(  CSR,  REVID);
    x = CHIP_FGET(  CSR,   PWRD);
    x = CHIP_FGET(  CSR,    SAT);
    x = CHIP_FGET(  CSR,     EN);
    x = CHIP_FGET(  CSR,    PCC);
    x = CHIP_FGET(  CSR,    DCC);
    x = CHIP_FGET(  CSR,   PGIE);
    x = CHIP_FGET(  CSR,    GIE);
    x = CHIP_FGET(  IFR,     IF);
    x = CHIP_FGET(  ISR,     IS);
    x = CHIP_FGET(  ICR,     IC);
    x = CHIP_FGET(  IER,     IE);
    x = CHIP_FGET( ISTP, HPEINT);
    x = CHIP_FGET( ISTP,   ISTB);
    x = CHIP_FGET(  IRP,    IRP);
    x = CHIP_FGET(  NRP,    NRP);
    x = CHIP_FGET(  AMR,    BK1);
    x = CHIP_FGET(  AMR,    BK0);
    x = CHIP_FGET(  AMR, B7MODE);
    x = CHIP_FGET(  AMR, B6MODE);
    x = CHIP_FGET(  AMR, B5MODE);
    x = CHIP_FGET(  AMR, B4MODE);
    x = CHIP_FGET(  AMR, A7MODE);
    x = CHIP_FGET(  AMR, A6MODE);
    x = CHIP_FGET(  AMR, A5MODE);
    x = CHIP_FGET(  AMR, A4MODE);
#if (FPU_SUPPORT)
    x = CHIP_FGET(   IN,     IN);
    x = CHIP_FGET(  OUT,    OUT);
    x = CHIP_FGET(FADCR,L2RMODE);
    x = CHIP_FGET(FADCR,L2UNDER);
    x = CHIP_FGET(FADCR, L2INEX);
    x = CHIP_FGET(FADCR, L2OVER);
    x = CHIP_FGET(FADCR, L2INFO);
    x = CHIP_FGET(FADCR,L2INVAL);
    x = CHIP_FGET(FADCR, L2DEN2);
    x = CHIP_FGET(FADCR, L2DEN1);
    x = CHIP_FGET(FADCR, L2NAN2);
    x = CHIP_FGET(FADCR, L2NAN1);
    x = CHIP_FGET(FADCR,L1RMODE);
    x = CHIP_FGET(FADCR,L1UNDER);
    x = CHIP_FGET(FADCR, L1INEX);
    x = CHIP_FGET(FADCR, L1OVER);
    x = CHIP_FGET(FADCR, L1INFO);
    x = CHIP_FGET(FADCR,L1INVAL);
    x = CHIP_FGET(FADCR, L1DEN2);
    x = CHIP_FGET(FADCR, L1DEN1);
    x = CHIP_FGET(FADCR, L1NAN2);
    x = CHIP_FGET(FADCR, L1NAN1);

    x = CHIP_FGET(FAUCR, S2DIV0);
    x = CHIP_FGET(FAUCR,S2UNORD);
    x = CHIP_FGET(FAUCR,  S2UND);
    x = CHIP_FGET(FAUCR, S2INEX);
    x = CHIP_FGET(FAUCR, S2OVER);
    x = CHIP_FGET(FAUCR, S2INFO);
    x = CHIP_FGET(FAUCR,S2INVAL);
    x = CHIP_FGET(FAUCR, S2DEN2);
    x = CHIP_FGET(FAUCR, S2DEN1);
    x = CHIP_FGET(FAUCR, S2NAN2);
    x = CHIP_FGET(FAUCR, S2NAN1);
    x = CHIP_FGET(FAUCR, S1DIV0);
    x = CHIP_FGET(FAUCR,S1UNORD);
    x = CHIP_FGET(FAUCR,  S1UND);
    x = CHIP_FGET(FAUCR, S1INEX);
    x = CHIP_FGET(FAUCR, S1OVER);
    x = CHIP_FGET(FAUCR, S1INFO);
    x = CHIP_FGET(FAUCR,S1INVAL);
    x = CHIP_FGET(FAUCR, S1DEN2);
    x = CHIP_FGET(FAUCR, S1DEN1);
    x = CHIP_FGET(FAUCR, S1NAN2);
    x = CHIP_FGET(FAUCR, S1NAN1);
 
    x = CHIP_FGET( FMCR,M2RMODE);
    x = CHIP_FGET( FMCR,M2UNDER);
    x = CHIP_FGET( FMCR, M2INEX);
    x = CHIP_FGET( FMCR, M2OVER);
    x = CHIP_FGET( FMCR, M2INFO);
    x = CHIP_FGET( FMCR,M2INVAL);
    x = CHIP_FGET( FMCR, M2DEN2);
    x = CHIP_FGET( FMCR, M2DEN1);
    x = CHIP_FGET( FMCR, M2NAN2);
    x = CHIP_FGET( FMCR, M2NAN1);
    x = CHIP_FGET( FMCR,M1RMODE);
    x = CHIP_FGET( FMCR,M1UNDER);
    x = CHIP_FGET( FMCR, M1INEX);
    x = CHIP_FGET( FMCR, M1OVER);
    x = CHIP_FGET( FMCR, M1INFO);
    x = CHIP_FGET( FMCR,M1INVAL);
    x = CHIP_FGET( FMCR, M1DEN2);
    x = CHIP_FGET( FMCR, M1DEN1);
    x = CHIP_FGET( FMCR, M1NAN2);
    x = CHIP_FGET( FMCR, M1NAN1);
#endif
#if (C64_SUPPORT)
    x = CHIP_FGET( DIER,   );
    x = CHIP_FGET(   EM,   );
    x = CHIP_FGET(   ER,   );
#endif

/*  Test FGET Macro end */
/*  Test FSET Macro start */
    CHIP_FSET(  CSR,  CPUID,    CHIP_CSR_CPUID_DEFAULT);
    CHIP_FSET(  CSR,  REVID,    CHIP_CSR_REVID_DEFAULT);
    CHIP_FSET(  CSR,   PWRD,     CHIP_CSR_PWRD_DEFAULT);
    CHIP_FSET(  CSR,    SAT,      CHIP_CSR_SAT_DEFAULT);
    CHIP_FSET(  CSR,     EN,       CHIP_CSR_EN_DEFAULT);
    CHIP_FSET(  CSR,    PCC,      CHIP_CSR_PCC_DEFAULT);
    CHIP_FSET(  CSR,    DCC,      CHIP_CSR_DCC_DEFAULT);
    CHIP_FSET(  CSR,   PGIE,     CHIP_CSR_PGIE_DEFAULT);
    CHIP_FSET(  CSR,    GIE,      CHIP_CSR_GIE_DEFAULT);
//    CHIP_FSET(  IFR,     IF,       CHIP_IFR_IF_DEFAULT);
    CHIP_FSET(  ISR,     IS,       CHIP_ISR_IS_DEFAULT);
    CHIP_FSET(  ICR,     IC,       CHIP_ICR_IC_DEFAULT);
    CHIP_FSET(  IER,     IE,       CHIP_IER_IE_DEFAULT);
    CHIP_FSET( ISTP, HPEINT,  CHIP_ISTP_HPEINT_DEFAULT);
    CHIP_FSET( ISTP,   ISTB,    CHIP_ISTP_ISTB_DEFAULT);
    CHIP_FSET(  IRP,    IRP,      CHIP_IRP_IRP_DEFAULT);
    CHIP_FSET(  NRP,    NRP,      CHIP_NRP_NRP_DEFAULT);
    CHIP_FSET(  AMR,    BK1,      CHIP_AMR_BK1_DEFAULT);
    CHIP_FSET(  AMR,    BK0,      CHIP_AMR_BK0_DEFAULT);
    CHIP_FSET(  AMR, B7MODE,   CHIP_AMR_B7MODE_DEFAULT);
    CHIP_FSET(  AMR, B6MODE,   CHIP_AMR_B6MODE_DEFAULT);
    CHIP_FSET(  AMR, B5MODE,   CHIP_AMR_B5MODE_DEFAULT);
    CHIP_FSET(  AMR, B4MODE,   CHIP_AMR_B4MODE_DEFAULT);
    CHIP_FSET(  AMR, A7MODE,   CHIP_AMR_A7MODE_DEFAULT);
    CHIP_FSET(  AMR, A6MODE,   CHIP_AMR_A6MODE_DEFAULT);
    CHIP_FSET(  AMR, A5MODE,   CHIP_AMR_A5MODE_DEFAULT);
    CHIP_FSET(  AMR, A4MODE,   CHIP_AMR_A4MODE_DEFAULT);
#if (FPU_SUPPORT)
    CHIP_FSET(   IN,     IN,        CHIP_IN_IN_DEFAULT);
    CHIP_FSET(  OUT,    OUT,      CHIP_OUT_OUT_DEFAULT);
    CHIP_FSET(FADCR,L2RMODE,CHIP_FADCR_L2RMODE_DEFAULT);
    CHIP_FSET(FADCR,L2UNDER,CHIP_FADCR_L2UNDER_DEFAULT);
    CHIP_FSET(FADCR, L2INEX, CHIP_FADCR_L2INEX_DEFAULT);
    CHIP_FSET(FADCR, L2OVER, CHIP_FADCR_L2OVER_DEFAULT);
    CHIP_FSET(FADCR, L2INFO, CHIP_FADCR_L2INFO_DEFAULT);
    CHIP_FSET(FADCR,L2INVAL,CHIP_FADCR_L2INVAL_DEFAULT);
    CHIP_FSET(FADCR, L2DEN2, CHIP_FADCR_L2DEN2_DEFAULT);
    CHIP_FSET(FADCR, L2DEN1, CHIP_FADCR_L2DEN1_DEFAULT);
    CHIP_FSET(FADCR, L2NAN2, CHIP_FADCR_L2NAN2_DEFAULT);
    CHIP_FSET(FADCR, L2NAN1, CHIP_FADCR_L2NAN1_DEFAULT);
    CHIP_FSET(FADCR,L1RMODE,CHIP_FADCR_L1RMODE_DEFAULT);
    CHIP_FSET(FADCR,L1UNDER,CHIP_FADCR_L1UNDER_DEFAULT);
    CHIP_FSET(FADCR, L1INEX, CHIP_FADCR_L1INEX_DEFAULT);
    CHIP_FSET(FADCR, L1OVER, CHIP_FADCR_L1OVER_DEFAULT);
    CHIP_FSET(FADCR, L1INFO, CHIP_FADCR_L1INFO_DEFAULT);
    CHIP_FSET(FADCR,L1INVAL,CHIP_FADCR_L1INVAL_DEFAULT);
    CHIP_FSET(FADCR, L1DEN2, CHIP_FADCR_L1DEN2_DEFAULT);
    CHIP_FSET(FADCR, L1DEN1, CHIP_FADCR_L1DEN1_DEFAULT);
    CHIP_FSET(FADCR, L1NAN2, CHIP_FADCR_L1NAN2_DEFAULT);
    CHIP_FSET(FADCR, L1NAN1, CHIP_FADCR_L1NAN1_DEFAULT);

    CHIP_FSET(FAUCR, S2DIV0, CHIP_FAUCR_S2DIV0_DEFAULT);
    CHIP_FSET(FAUCR,S2UNORD,CHIP_FAUCR_S2UNORD_DEFAULT);
    CHIP_FSET(FAUCR,  S2UND,  CHIP_FAUCR_S2UND_DEFAULT);
    CHIP_FSET(FAUCR, S2INEX, CHIP_FAUCR_S2INEX_DEFAULT);
    CHIP_FSET(FAUCR, S2OVER, CHIP_FAUCR_S2OVER_DEFAULT);
    CHIP_FSET(FAUCR, S2INFO, CHIP_FAUCR_S2INFO_DEFAULT);
    CHIP_FSET(FAUCR,S2INVAL,CHIP_FAUCR_S2INVAL_DEFAULT);
    CHIP_FSET(FAUCR, S2DEN2, CHIP_FAUCR_S2DEN2_DEFAULT);
    CHIP_FSET(FAUCR, S2DEN1, CHIP_FAUCR_S2DEN1_DEFAULT);
    CHIP_FSET(FAUCR, S2NAN2, CHIP_FAUCR_S2NAN2_DEFAULT);
    CHIP_FSET(FAUCR, S2NAN1, CHIP_FAUCR_S2NAN1_DEFAULT);
    CHIP_FSET(FAUCR, S1DIV0, CHIP_FAUCR_S1DIV0_DEFAULT);
    CHIP_FSET(FAUCR,S1UNORD,CHIP_FAUCR_S1UNORD_DEFAULT);
    CHIP_FSET(FAUCR,  S1UND,  CHIP_FAUCR_S1UND_DEFAULT);
    CHIP_FSET(FAUCR, S1INEX, CHIP_FAUCR_S1INEX_DEFAULT);
    CHIP_FSET(FAUCR, S1OVER, CHIP_FAUCR_S1OVER_DEFAULT);
    CHIP_FSET(FAUCR, S1INFO, CHIP_FAUCR_S1INFO_DEFAULT);
    CHIP_FSET(FAUCR,S1INVAL,CHIP_FAUCR_S1INVAL_DEFAULT);
    CHIP_FSET(FAUCR, S1DEN2, CHIP_FAUCR_S1DEN2_DEFAULT);
    CHIP_FSET(FAUCR, S1DEN1, CHIP_FAUCR_S1DEN1_DEFAULT);
    CHIP_FSET(FAUCR, S1NAN2, CHIP_FAUCR_S1NAN2_DEFAULT);
    CHIP_FSET(FAUCR, S1NAN1, CHIP_FAUCR_S1NAN1_DEFAULT);
 
    CHIP_FSET( FMCR,M2RMODE,CHIP_FMCR_M2RMODE_DEFAULT);
    CHIP_FSET( FMCR,M2UNDER,CHIP_FMCR_M2UNDER_DEFAULT);
    CHIP_FSET( FMCR, M2INEX, CHIP_FMCR_M2INEX_DEFAULT);
    CHIP_FSET( FMCR, M2OVER, CHIP_FMCR_M2OVER_DEFAULT);
    CHIP_FSET( FMCR, M2INFO, CHIP_FMCR_M2INFO_DEFAULT);
    CHIP_FSET( FMCR,M2INVAL,CHIP_FMCR_M2INVAL_DEFAULT);
    CHIP_FSET( FMCR, M2DEN2, CHIP_FMCR_M2DEN2_DEFAULT);
    CHIP_FSET( FMCR, M2DEN1, CHIP_FMCR_M2DEN1_DEFAULT);
    CHIP_FSET( FMCR, M2NAN2, CHIP_FMCR_M2NAN2_DEFAULT);
    CHIP_FSET( FMCR, M2NAN1, CHIP_FMCR_M2NAN1_DEFAULT);
    CHIP_FSET( FMCR,M1RMODE,CHIP_FMCR_M1RMODE_DEFAULT);
    CHIP_FSET( FMCR,M1UNDER,CHIP_FMCR_M1UNDER_DEFAULT);
    CHIP_FSET( FMCR, M1INEX, CHIP_FMCR_M1INEX_DEFAULT);
    CHIP_FSET( FMCR, M1OVER, CHIP_FMCR_M1OVER_DEFAULT);
    CHIP_FSET( FMCR, M1INFO, CHIP_FMCR_M1INFO_DEFAULT);
    CHIP_FSET( FMCR,M1INVAL,CHIP_FMCR_M1INVAL_DEFAULT);
    CHIP_FSET( FMCR, M1DEN2, CHIP_FMCR_M1DEN2_DEFAULT);
    CHIP_FSET( FMCR, M1DEN1, CHIP_FMCR_M1DEN1_DEFAULT);
    CHIP_FSET( FMCR, M1NAN2, CHIP_FMCR_M1NAN2_DEFAULT);
    CHIP_FSET( FMCR, M1NAN1, CHIP_FMCR_M1NAN1_DEFAULT);
#endif
#if (C64_SUPPORT)
    CHIP_FSET( DIER,   ,DEFAULT);
    CHIP_FSET(   EM,   ,DEFAULT);
    CHIP_FSET(   ER,   ,DEFAULT);
#endif

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    CHIP_FSETS(  CSR,  CPUID,DEFAULT);
    CHIP_FSETS(  CSR,  REVID,DEFAULT);
    CHIP_FSETS(  CSR,   PWRD,DEFAULT);
    CHIP_FSETS(  CSR,    SAT,DEFAULT);
    CHIP_FSETS(  CSR,     EN,DEFAULT);
    CHIP_FSETS(  CSR,    PCC,DEFAULT);
    CHIP_FSETS(  CSR,    DCC,DEFAULT);
    CHIP_FSETS(  CSR,   PGIE,DEFAULT);
    CHIP_FSETS(  CSR,    GIE,DEFAULT);
//    CHIP_FSETS(  IFR,     IF,DEFAULT);
    CHIP_FSETS(  ISR,     IS,DEFAULT);
    CHIP_FSETS(  ICR,     IC,DEFAULT);
    CHIP_FSETS(  IER,     IE,DEFAULT);
    CHIP_FSETS( ISTP, HPEINT,DEFAULT);
    CHIP_FSETS( ISTP,   ISTB,DEFAULT);
    CHIP_FSETS(  IRP,    IRP,DEFAULT);
    CHIP_FSETS(  NRP,    NRP,DEFAULT);
    CHIP_FSETS(  AMR,    BK1,DEFAULT);
    CHIP_FSETS(  AMR,    BK0,DEFAULT);
    CHIP_FSETS(  AMR, B7MODE,DEFAULT);
    CHIP_FSETS(  AMR, B6MODE,DEFAULT);
    CHIP_FSETS(  AMR, B5MODE,DEFAULT);
    CHIP_FSETS(  AMR, B4MODE,DEFAULT);
    CHIP_FSETS(  AMR, A7MODE,DEFAULT);
    CHIP_FSETS(  AMR, A6MODE,DEFAULT);
    CHIP_FSETS(  AMR, A5MODE,DEFAULT);
    CHIP_FSETS(  AMR, A4MODE,DEFAULT);
#if (FPU_SUPPORT)
    CHIP_FSETS(   IN,     IN,DEFAULT);
    CHIP_FSETS(  OUT,    OUT,DEFAULT);
    CHIP_FSETS(FADCR,L2RMODE,DEFAULT);
    CHIP_FSETS(FADCR,L2UNDER,DEFAULT);
    CHIP_FSETS(FADCR, L2INEX,DEFAULT);
    CHIP_FSETS(FADCR, L2OVER,DEFAULT);
    CHIP_FSETS(FADCR, L2INFO,DEFAULT);
    CHIP_FSETS(FADCR,L2INVAL,DEFAULT);
    CHIP_FSETS(FADCR, L2DEN2,DEFAULT);
    CHIP_FSETS(FADCR, L2DEN1,DEFAULT);
    CHIP_FSETS(FADCR, L2NAN2,DEFAULT);
    CHIP_FSETS(FADCR, L2NAN1,DEFAULT);
    CHIP_FSETS(FADCR,L1RMODE,DEFAULT);
    CHIP_FSETS(FADCR,L1UNDER,DEFAULT);
    CHIP_FSETS(FADCR, L1INEX,DEFAULT);
    CHIP_FSETS(FADCR, L1OVER,DEFAULT);
    CHIP_FSETS(FADCR, L1INFO,DEFAULT);
    CHIP_FSETS(FADCR,L1INVAL,DEFAULT);
    CHIP_FSETS(FADCR, L1DEN2,DEFAULT);
    CHIP_FSETS(FADCR, L1DEN1,DEFAULT);
    CHIP_FSETS(FADCR, L1NAN2,DEFAULT);
    CHIP_FSETS(FADCR, L1NAN1,DEFAULT);

    CHIP_FSETS(FAUCR, S2DIV0,DEFAULT);
    CHIP_FSETS(FAUCR,S2UNORD,DEFAULT);
    CHIP_FSETS(FAUCR,  S2UND,DEFAULT);
    CHIP_FSETS(FAUCR, S2INEX,DEFAULT);
    CHIP_FSETS(FAUCR, S2OVER,DEFAULT);
    CHIP_FSETS(FAUCR, S2INFO,DEFAULT);
    CHIP_FSETS(FAUCR,S2INVAL,DEFAULT);
    CHIP_FSETS(FAUCR, S2DEN2,DEFAULT);
    CHIP_FSETS(FAUCR, S2DEN1,DEFAULT);
    CHIP_FSETS(FAUCR, S2NAN2,DEFAULT);
    CHIP_FSETS(FAUCR, S2NAN1,DEFAULT);
    CHIP_FSETS(FAUCR, S1DIV0,DEFAULT);
    CHIP_FSETS(FAUCR,S1UNORD,DEFAULT);
    CHIP_FSETS(FAUCR,  S1UND,DEFAULT);
    CHIP_FSETS(FAUCR, S1INEX,DEFAULT);
    CHIP_FSETS(FAUCR, S1OVER,DEFAULT);
    CHIP_FSETS(FAUCR, S1INFO,DEFAULT);
    CHIP_FSETS(FAUCR,S1INVAL,DEFAULT);
    CHIP_FSETS(FAUCR, S1DEN2,DEFAULT);
    CHIP_FSETS(FAUCR, S1DEN1,DEFAULT);
    CHIP_FSETS(FAUCR, S1NAN2,DEFAULT);
    CHIP_FSETS(FAUCR, S1NAN1,DEFAULT);
 
    CHIP_FSETS( FMCR,M2RMODE,DEFAULT);
    CHIP_FSETS( FMCR,M2UNDER,DEFAULT);
    CHIP_FSETS( FMCR, M2INEX,DEFAULT);
    CHIP_FSETS( FMCR, M2OVER,DEFAULT);
    CHIP_FSETS( FMCR, M2INFO,DEFAULT);
    CHIP_FSETS( FMCR,M2INVAL,DEFAULT);
    CHIP_FSETS( FMCR, M2DEN2,DEFAULT);
    CHIP_FSETS( FMCR, M2DEN1,DEFAULT);
    CHIP_FSETS( FMCR, M2NAN2,DEFAULT);
    CHIP_FSETS( FMCR, M2NAN1,DEFAULT);
    CHIP_FSETS( FMCR,M1RMODE,DEFAULT);
    CHIP_FSETS( FMCR,M1UNDER,DEFAULT);
    CHIP_FSETS( FMCR, M1INEX,DEFAULT);
    CHIP_FSETS( FMCR, M1OVER,DEFAULT);
    CHIP_FSETS( FMCR, M1INFO,DEFAULT);
    CHIP_FSETS( FMCR,M1INVAL,DEFAULT);
    CHIP_FSETS( FMCR, M1DEN2,DEFAULT);
    CHIP_FSETS( FMCR, M1DEN1,DEFAULT);
    CHIP_FSETS( FMCR, M1NAN2,DEFAULT);
    CHIP_FSETS( FMCR, M1NAN1,DEFAULT);
#endif
#if (C64_SUPPORT)
    CHIP_FSETS( DIER,   ,DEFAULT);
    CHIP_FSETS(   EM,   ,DEFAULT);
    CHIP_FSETS(   ER,   ,DEFAULT);
#endif


/*  Test FSETS Macro end */
  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_dat(int arg) {

  #if (DAT_SUPPORT)

  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_dma(int arg) {

  #if (DMA_SUPPORT&&DMA_BUILD)
    DMA_Handle hDma;

    hDma = DMA_open(DMA_CHAANY, DMA_OPEN_RESET);

    x = DMA_PRICTL_RMK(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),


    DMA_configArgs(hDma,
    x = DMA_PRICTL_RMK(
      DMA_PRICTL_DSTRLD_OF(x),
      DMA_PRICTL_SRCRLD_NONE,
      DMA_PRICTL_EMOD_HALT,
      DMA_PRICTL_FS_DISABLE,
      DMA_PRICTL_TCINT_ENABLE,
      DMA_PRICTL_PRI_DMA,
      DMA_PRICTL_WSYNC_NONE,
      DMA_PRICTL_RSYNC_REVT0,
      DMA_PRICTL_INDEX_OF(x),
      DMA_PRICTL_CNTRLD_OF(x),
      DMA_PRICTL_SPLIT_DISABLE,
      DMA_PRICTL_ESIZE_16BIT,
      DMA_PRICTL_DSTDIR_IDX,
      DMA_PRICTL_SRCDIR_NONE,
      DMA_PRICTL_START_STOP
    ),
    0,0,0,0);


    x = DMA_GET_CONDITION(hDma,DMA_SECCTL_SXCOND);
    x = DMA_GET_CONDITION(hDma,DMA_SECCTL_FRAMECOND);
    x = DMA_GET_CONDITION(hDma,DMA_SECCTL_LASTCOND);
    x = DMA_GET_CONDITION(hDma,DMA_SECCTL_BLOCKCOND);
    x = DMA_GET_CONDITION(hDma,DMA_SECCTL_RDROPCOND);
    x = DMA_GET_CONDITION(hDma,DMA_SECCTL_WDROPCOND);

    DMA_CLEAR_CONDITION(hDma,DMA_SECCTL_SXCOND);
    DMA_CLEAR_CONDITION(hDma,DMA_SECCTL_FRAMECOND);
    DMA_CLEAR_CONDITION(hDma,DMA_SECCTL_LASTCOND);
    DMA_CLEAR_CONDITION(hDma,DMA_SECCTL_BLOCKCOND);
    DMA_CLEAR_CONDITION(hDma,DMA_SECCTL_RDROPCOND);
    DMA_CLEAR_CONDITION(hDma,DMA_SECCTL_WDROPCOND);

    DMA_FSET(SECCTL0,WSYNCSTAT,0);
    DMA_FSETH(hDma,SECCTL,WSYNCSTAT,0);
    DMA_FSETH(hDma,SECCTL,WSYNCCLR,1);
    DMA_FGETH(hDma,SECCTL,RSYNCSTAT);

/*  Test FMK Macro start */
    x = DMA_FMK( AUXCTL,   AUXPRI,0XFFFFFFFF);
    x = DMA_FMK( AUXCTL,    CHPRI,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,   DSTRLD,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,   SRCRLD,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,     EMOD,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,       FS,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,    TCINT,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,      PRI,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,    WSYNC,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,    RSYNC,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,    INDEX,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,   CNTRLD,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,    SPLIT,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,    ESIZE,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,   DSTDIR,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,   SRCDIR,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,   STATUS,0XFFFFFFFF);
    x = DMA_FMK( PRICTL,    START,0XFFFFFFFF);
#if _DMA_COND1    
	x = DMA_FMK( SECCTL,    WSPOL,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,    RSPOL,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,     FSIG,0xFFFFFFFF);
#endif
	x = DMA_FMK( SECCTL,   DMACEN,0xFFFFFFFF);
	x = DMA_FMK( SECCTL, WSYNCCLR,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,WSYNCSTAT,0xFFFFFFFF);
	x = DMA_FMK( SECCTL, RSYNCCLR,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,RSYNCSTAT,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,  WDROPIE,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,WDROPCOND,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,  RDROPIE,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,RDROPCOND,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,  BLOCKIE,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,BLOCKCOND,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,   LASTIE,0xFFFFFFFF);
	x = DMA_FMK( SECCTL, LASTCOND,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,  FRAMEIE,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,FRAMECOND,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,     SXIE,0xFFFFFFFF);
	x = DMA_FMK( SECCTL,   SXCOND,0xFFFFFFFF);

    x = DMA_FMK(    SRC,      SRC,0xFFFFFFFF);
    x = DMA_FMK(    DST,      DST,0xFFFFFFFF);
    x = DMA_FMK( XFRCNT,   FRMCNT,0xFFFFFFFF);
    x = DMA_FMK( XFRCNT,   ELECNT,0xFFFFFFFF);
    x = DMA_FMK( GBLCNT,   FRMCNT,0xFFFFFFFF);
    x = DMA_FMK( GBLCNT,   ELECNT,0xFFFFFFFF);
    x = DMA_FMK( GBLIDX,   FRMIDX,0xFFFFFFFF);
    x = DMA_FMK( GBLIDX,   ELEIDX,0xFFFFFFFF);
    x = DMA_FMK(GBLADDR,  GBLADDR,0xFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = DMA_FMKS( AUXCTL,   AUXPRI,DEFAULT);
    x = DMA_FMKS( AUXCTL,    CHPRI,DEFAULT);
    x = DMA_FMKS( PRICTL,   DSTRLD,DEFAULT);
    x = DMA_FMKS( PRICTL,   SRCRLD,DEFAULT);
    x = DMA_FMKS( PRICTL,     EMOD,DEFAULT);
    x = DMA_FMKS( PRICTL,       FS,DEFAULT);
    x = DMA_FMKS( PRICTL,    TCINT,DEFAULT);
    x = DMA_FMKS( PRICTL,      PRI,DEFAULT);
    x = DMA_FMKS( PRICTL,    WSYNC,DEFAULT);
    x = DMA_FMKS( PRICTL,    RSYNC,DEFAULT);
    x = DMA_FMKS( PRICTL,    INDEX,DEFAULT);
    x = DMA_FMKS( PRICTL,   CNTRLD,DEFAULT);
    x = DMA_FMKS( PRICTL,    SPLIT,DEFAULT);
    x = DMA_FMKS( PRICTL,    ESIZE,DEFAULT);
    x = DMA_FMKS( PRICTL,   DSTDIR,DEFAULT);
    x = DMA_FMKS( PRICTL,   SRCDIR,DEFAULT);
    x = DMA_FMKS( PRICTL,   STATUS,DEFAULT);
    x = DMA_FMKS( PRICTL,    START,DEFAULT);
#if _DMA_COND1    
	x = DMA_FMKS( SECCTL,    WSPOL,DEFAULT);
	x = DMA_FMKS( SECCTL,    RSPOL,DEFAULT);
	x = DMA_FMKS( SECCTL,     FSIG,DEFAULT);
#endif
	x = DMA_FMKS( SECCTL,   DMACEN,DEFAULT);
	x = DMA_FMKS( SECCTL, WSYNCCLR,DEFAULT);
	x = DMA_FMKS( SECCTL,WSYNCSTAT,DEFAULT);
	x = DMA_FMKS( SECCTL, RSYNCCLR,DEFAULT);
	x = DMA_FMKS( SECCTL,RSYNCSTAT,DEFAULT);
	x = DMA_FMKS( SECCTL,  WDROPIE,DEFAULT);
	x = DMA_FMKS( SECCTL,WDROPCOND,DEFAULT);
	x = DMA_FMKS( SECCTL,  RDROPIE,DEFAULT);
	x = DMA_FMKS( SECCTL,RDROPCOND,DEFAULT);
	x = DMA_FMKS( SECCTL,  BLOCKIE,DEFAULT);
	x = DMA_FMKS( SECCTL,BLOCKCOND,DEFAULT);
	x = DMA_FMKS( SECCTL,   LASTIE,DEFAULT);
	x = DMA_FMKS( SECCTL, LASTCOND,DEFAULT);
	x = DMA_FMKS( SECCTL,  FRAMEIE,DEFAULT);
	x = DMA_FMKS( SECCTL,FRAMECOND,DEFAULT);
	x = DMA_FMKS( SECCTL,     SXIE,DEFAULT);
	x = DMA_FMKS( SECCTL,   SXCOND,DEFAULT);

    x = DMA_FMKS(    SRC,      SRC,DEFAULT);
    x = DMA_FMKS(    DST,      DST,DEFAULT);
    x = DMA_FMKS( XFRCNT,   FRMCNT,DEFAULT);
    x = DMA_FMKS( XFRCNT,   ELECNT,DEFAULT);
    x = DMA_FMKS( GBLCNT,   FRMCNT,DEFAULT);
    x = DMA_FMKS( GBLCNT,   ELECNT,DEFAULT);
    x = DMA_FMKS( GBLIDX,   FRMIDX,DEFAULT);
    x = DMA_FMKS( GBLIDX,   ELEIDX,DEFAULT);
    x = DMA_FMKS(GBLADDR,  GBLADDR,DEFAULT);

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = DMA_ADDR(  AUXCTL);
    x = DMA_ADDR( PRICTL0);
    x = DMA_ADDR( PRICTL1);
    x = DMA_ADDR( PRICTL2);
    x = DMA_ADDR( PRICTL3);
    x = DMA_ADDR( SECCTL0);
    x = DMA_ADDR( SECCTL1);
    x = DMA_ADDR( SECCTL2);
    x = DMA_ADDR( SECCTL3);
    x = DMA_ADDR(    SRC0);
    x = DMA_ADDR(    SRC1);
    x = DMA_ADDR(    SRC2);
    x = DMA_ADDR(    SRC3);
    x = DMA_ADDR(    DST0);
    x = DMA_ADDR(    DST1);
    x = DMA_ADDR(    DST2);
    x = DMA_ADDR(    DST3);
    x = DMA_ADDR( XFRCNT0);
    x = DMA_ADDR( XFRCNT1);
    x = DMA_ADDR( XFRCNT2);
    x = DMA_ADDR( XFRCNT3);
    x = DMA_ADDR( GBLCNTA);
    x = DMA_ADDR( GBLCNTB);
    x = DMA_ADDR( GBLIDXA);
    x = DMA_ADDR( GBLIDXB);
    x = DMA_ADDR(GBLADDRA);
    x = DMA_ADDR(GBLADDRB);
    x = DMA_ADDR(GBLADDRC);
    x = DMA_ADDR(GBLADDRD);
        

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = DMA_RGET(  AUXCTL);
    x = DMA_RGET( PRICTL0);
    x = DMA_RGET( PRICTL1);
    x = DMA_RGET( PRICTL2);
    x = DMA_RGET( PRICTL3);
    x = DMA_RGET( SECCTL0);
    x = DMA_RGET( SECCTL1);
    x = DMA_RGET( SECCTL2);
    x = DMA_RGET( SECCTL3);
    x = DMA_RGET(    SRC0);
    x = DMA_RGET(    SRC1);
    x = DMA_RGET(    SRC2);
    x = DMA_RGET(    SRC3);
    x = DMA_RGET(    DST0);
    x = DMA_RGET(    DST1);
    x = DMA_RGET(    DST2);
    x = DMA_RGET(    DST3);
    x = DMA_RGET( XFRCNT0);
    x = DMA_RGET( XFRCNT1);
    x = DMA_RGET( XFRCNT2);
    x = DMA_RGET( XFRCNT3);
    x = DMA_RGET( GBLCNTA);
    x = DMA_RGET( GBLCNTB);
    x = DMA_RGET( GBLIDXA);
    x = DMA_RGET( GBLIDXB);
    x = DMA_RGET(GBLADDRA);
    x = DMA_RGET(GBLADDRB);
    x = DMA_RGET(GBLADDRC);
    x = DMA_RGET(GBLADDRD);

/*  Test RGET Macro end */
/*  Test RSET Macro start */
    DMA_RSET(  AUXCTL, DMA_AUXCTL_DEFAULT);
    DMA_RSET( PRICTL0, DMA_PRICTL_DEFAULT);
    DMA_RSET( PRICTL1, DMA_PRICTL_DEFAULT);
    DMA_RSET( PRICTL2, DMA_PRICTL_DEFAULT);
    DMA_RSET( PRICTL3, DMA_PRICTL_DEFAULT);
    DMA_RSET( SECCTL0, DMA_SECCTL_DEFAULT);
    DMA_RSET( SECCTL1, DMA_SECCTL_DEFAULT);
    DMA_RSET( SECCTL2, DMA_SECCTL_DEFAULT);
    DMA_RSET( SECCTL3, DMA_SECCTL_DEFAULT);
    DMA_RSET(    SRC0,    DMA_SRC_DEFAULT);
    DMA_RSET(    SRC1,    DMA_SRC_DEFAULT);
    DMA_RSET(    SRC2,    DMA_SRC_DEFAULT);
    DMA_RSET(    SRC3,    DMA_SRC_DEFAULT);
    DMA_RSET(    DST0,    DMA_DST_DEFAULT);
    DMA_RSET(    DST1,    DMA_DST_DEFAULT);
    DMA_RSET(    DST2,    DMA_DST_DEFAULT);
    DMA_RSET(    DST3,    DMA_DST_DEFAULT);
    DMA_RSET( XFRCNT0, DMA_XFRCNT_DEFAULT);
    DMA_RSET( XFRCNT1, DMA_XFRCNT_DEFAULT);
    DMA_RSET( XFRCNT2, DMA_XFRCNT_DEFAULT);
    DMA_RSET( XFRCNT3, DMA_XFRCNT_DEFAULT);
    DMA_RSET( GBLCNTA, DMA_GBLCNT_DEFAULT);
    DMA_RSET( GBLCNTB, DMA_GBLCNT_DEFAULT);
    DMA_RSET( GBLIDXA, DMA_GBLIDX_DEFAULT);
    DMA_RSET( GBLIDXB, DMA_GBLIDX_DEFAULT);
    DMA_RSET(GBLADDRA,DMA_GBLADDR_DEFAULT);
    DMA_RSET(GBLADDRB,DMA_GBLADDR_DEFAULT);
    DMA_RSET(GBLADDRC,DMA_GBLADDR_DEFAULT);
    DMA_RSET(GBLADDRD,DMA_GBLADDR_DEFAULT);


/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = DMA_FGET(  AUXCTL,   AUXPRI);
    x = DMA_FGET(  AUXCTL,    CHPRI);

    x = DMA_FGET( PRICTL0,   DSTRLD);
    x = DMA_FGET( PRICTL0,   SRCRLD);
    x = DMA_FGET( PRICTL0,     EMOD);
    x = DMA_FGET( PRICTL0,       FS);
    x = DMA_FGET( PRICTL0,    TCINT);
    x = DMA_FGET( PRICTL0,      PRI);
    x = DMA_FGET( PRICTL0,    WSYNC);
    x = DMA_FGET( PRICTL0,    RSYNC);
    x = DMA_FGET( PRICTL0,    INDEX);
    x = DMA_FGET( PRICTL0,   CNTRLD);
    x = DMA_FGET( PRICTL0,    SPLIT);
    x = DMA_FGET( PRICTL0,    ESIZE);

    x = DMA_FGET( PRICTL1,   DSTDIR);
    x = DMA_FGET( PRICTL1,   SRCDIR);
    x = DMA_FGET( PRICTL1,   STATUS);
    x = DMA_FGET( PRICTL1,    START);
    x = DMA_FGET( PRICTL1,   DSTRLD);
    x = DMA_FGET( PRICTL1,   SRCRLD);
    x = DMA_FGET( PRICTL1,     EMOD);
    x = DMA_FGET( PRICTL1,       FS);
    x = DMA_FGET( PRICTL1,    TCINT);
    x = DMA_FGET( PRICTL1,      PRI);
    x = DMA_FGET( PRICTL1,    WSYNC);
    x = DMA_FGET( PRICTL1,    RSYNC);
    x = DMA_FGET( PRICTL1,    INDEX);
    x = DMA_FGET( PRICTL1,   CNTRLD);
    x = DMA_FGET( PRICTL1,    SPLIT);
    x = DMA_FGET( PRICTL1,    ESIZE);

    x = DMA_FGET( PRICTL2,   DSTDIR);
    x = DMA_FGET( PRICTL2,   SRCDIR);
    x = DMA_FGET( PRICTL2,   STATUS);
    x = DMA_FGET( PRICTL2,    START);
    x = DMA_FGET( PRICTL2,   DSTRLD);
    x = DMA_FGET( PRICTL2,   SRCRLD);
    x = DMA_FGET( PRICTL2,     EMOD);
    x = DMA_FGET( PRICTL2,       FS);
    x = DMA_FGET( PRICTL2,    TCINT);
    x = DMA_FGET( PRICTL2,      PRI);
    x = DMA_FGET( PRICTL2,    WSYNC);
    x = DMA_FGET( PRICTL2,    RSYNC);
    x = DMA_FGET( PRICTL2,    INDEX);
    x = DMA_FGET( PRICTL2,   CNTRLD);
    x = DMA_FGET( PRICTL2,    SPLIT);
    x = DMA_FGET( PRICTL2,    ESIZE);

    x = DMA_FGET( PRICTL3,   DSTDIR);
    x = DMA_FGET( PRICTL3,   SRCDIR);
    x = DMA_FGET( PRICTL3,   STATUS);
    x = DMA_FGET( PRICTL3,    START);
    x = DMA_FGET( PRICTL3,   DSTRLD);
    x = DMA_FGET( PRICTL3,   SRCRLD);
    x = DMA_FGET( PRICTL3,     EMOD);
    x = DMA_FGET( PRICTL3,       FS);
    x = DMA_FGET( PRICTL3,    TCINT);
    x = DMA_FGET( PRICTL3,      PRI);
    x = DMA_FGET( PRICTL3,    WSYNC);
    x = DMA_FGET( PRICTL3,    RSYNC);
    x = DMA_FGET( PRICTL3,    INDEX);
    x = DMA_FGET( PRICTL3,   CNTRLD);
    x = DMA_FGET( PRICTL3,    SPLIT);
    x = DMA_FGET( PRICTL3,    ESIZE);
    x = DMA_FGET( PRICTL3,   DSTDIR);
    x = DMA_FGET( PRICTL3,   SRCDIR);
    x = DMA_FGET( PRICTL3,   STATUS);
    x = DMA_FGET( PRICTL3,    START);

#if _DMA_COND1
    x = DMA_FGET( SECCTL0,    WSPOL);
    x = DMA_FGET( SECCTL0,    RSPOL);
    x = DMA_FGET( SECCTL0,     FSIG);
#endif
    x = DMA_FGET( SECCTL0,   DMACEN);
    x = DMA_FGET( SECCTL0, WSYNCCLR);
    x = DMA_FGET( SECCTL0,WSYNCSTAT);
    x = DMA_FGET( SECCTL0, RSYNCCLR);
    x = DMA_FGET( SECCTL0,RSYNCSTAT);
    x = DMA_FGET( SECCTL0,  WDROPIE);
    x = DMA_FGET( SECCTL0,WDROPCOND);
    x = DMA_FGET( SECCTL0,  RDROPIE);
    x = DMA_FGET( SECCTL0,RDROPCOND);
    x = DMA_FGET( SECCTL0,  BLOCKIE);
    x = DMA_FGET( SECCTL0,BLOCKCOND);
    x = DMA_FGET( SECCTL0,   LASTIE);
    x = DMA_FGET( SECCTL0, LASTCOND);
    x = DMA_FGET( SECCTL0,  FRAMEIE);
    x = DMA_FGET( SECCTL0,FRAMECOND);
    x = DMA_FGET( SECCTL0,     SXIE);
    x = DMA_FGET( SECCTL0,   SXCOND);

#if _DMA_COND1
    x = DMA_FGET( SECCTL1,    WSPOL);
    x = DMA_FGET( SECCTL1,    RSPOL);
    x = DMA_FGET( SECCTL1,     FSIG);
#endif
    x = DMA_FGET( SECCTL1,   DMACEN);
    x = DMA_FGET( SECCTL1, WSYNCCLR);
    x = DMA_FGET( SECCTL1,WSYNCSTAT);
    x = DMA_FGET( SECCTL1, RSYNCCLR);
    x = DMA_FGET( SECCTL1,RSYNCSTAT);
    x = DMA_FGET( SECCTL1,  WDROPIE);
    x = DMA_FGET( SECCTL1,WDROPCOND);
    x = DMA_FGET( SECCTL1,  RDROPIE);
    x = DMA_FGET( SECCTL1,RDROPCOND);
    x = DMA_FGET( SECCTL1,  BLOCKIE);
    x = DMA_FGET( SECCTL1,BLOCKCOND);
    x = DMA_FGET( SECCTL1,   LASTIE);
    x = DMA_FGET( SECCTL1, LASTCOND);
    x = DMA_FGET( SECCTL1,  FRAMEIE);
    x = DMA_FGET( SECCTL1,FRAMECOND);
    x = DMA_FGET( SECCTL1,     SXIE);
    x = DMA_FGET( SECCTL1,   SXCOND);

#if _DMA_COND1
    x = DMA_FGET( SECCTL2,    WSPOL);
    x = DMA_FGET( SECCTL2,    RSPOL);
    x = DMA_FGET( SECCTL2,     FSIG);
#endif
    x = DMA_FGET( SECCTL2,   DMACEN);
    x = DMA_FGET( SECCTL2, WSYNCCLR);
    x = DMA_FGET( SECCTL2,WSYNCSTAT);
    x = DMA_FGET( SECCTL2, RSYNCCLR);
    x = DMA_FGET( SECCTL2,RSYNCSTAT);
    x = DMA_FGET( SECCTL2,  WDROPIE);
    x = DMA_FGET( SECCTL2,WDROPCOND);
    x = DMA_FGET( SECCTL2,  RDROPIE);
    x = DMA_FGET( SECCTL2,RDROPCOND);
    x = DMA_FGET( SECCTL2,  BLOCKIE);
    x = DMA_FGET( SECCTL2,BLOCKCOND);
    x = DMA_FGET( SECCTL2,   LASTIE);
    x = DMA_FGET( SECCTL2, LASTCOND);
    x = DMA_FGET( SECCTL2,  FRAMEIE);
    x = DMA_FGET( SECCTL2,FRAMECOND);
    x = DMA_FGET( SECCTL2,     SXIE);
    x = DMA_FGET( SECCTL2,   SXCOND);

#if _DMA_COND1
    x = DMA_FGET( SECCTL3,    WSPOL);
    x = DMA_FGET( SECCTL3,    RSPOL);
    x = DMA_FGET( SECCTL3,     FSIG);
#endif
    x = DMA_FGET( SECCTL3,   DMACEN);
    x = DMA_FGET( SECCTL3, WSYNCCLR);
    x = DMA_FGET( SECCTL3,WSYNCSTAT);
    x = DMA_FGET( SECCTL3, RSYNCCLR);
    x = DMA_FGET( SECCTL3,RSYNCSTAT);
    x = DMA_FGET( SECCTL3,  WDROPIE);
    x = DMA_FGET( SECCTL3,WDROPCOND);
    x = DMA_FGET( SECCTL3,  RDROPIE);
    x = DMA_FGET( SECCTL3,RDROPCOND);
    x = DMA_FGET( SECCTL3,  BLOCKIE);
    x = DMA_FGET( SECCTL3,BLOCKCOND);
    x = DMA_FGET( SECCTL3,   LASTIE);
    x = DMA_FGET( SECCTL3, LASTCOND);
    x = DMA_FGET( SECCTL3,  FRAMEIE);
    x = DMA_FGET( SECCTL3,FRAMECOND);
    x = DMA_FGET( SECCTL3,     SXIE);
    x = DMA_FGET( SECCTL3,   SXCOND);

    x = DMA_FGET(    SRC0,      SRC);
    x = DMA_FGET(    SRC1,      SRC);
    x = DMA_FGET(    SRC2,      SRC);
    x = DMA_FGET(    SRC3,      SRC);

    x = DMA_FGET(    DST0,      DST);
    x = DMA_FGET(    DST1,      DST);
    x = DMA_FGET(    DST2,      DST);
    x = DMA_FGET(    DST3,      DST);

    x = DMA_FGET( XFRCNT0,   FRMCNT);
    x = DMA_FGET( XFRCNT0,   ELECNT);
    x = DMA_FGET( XFRCNT1,   FRMCNT);
    x = DMA_FGET( XFRCNT1,   ELECNT);
    x = DMA_FGET( XFRCNT2,   FRMCNT);
    x = DMA_FGET( XFRCNT2,   ELECNT);
    x = DMA_FGET( XFRCNT3,   FRMCNT);
    x = DMA_FGET( XFRCNT3,   ELECNT);

    x = DMA_FGET( GBLCNTA,   FRMCNT);
    x = DMA_FGET( GBLCNTA,   ELECNT);
    x = DMA_FGET( GBLCNTB,   FRMCNT);
    x = DMA_FGET( GBLCNTB,   ELECNT);

    x = DMA_FGET( GBLIDXA,   FRMIDX);
    x = DMA_FGET( GBLIDXA,   ELEIDX);
    x = DMA_FGET( GBLIDXB,   FRMIDX);
    x = DMA_FGET( GBLIDXB,   ELEIDX);

    x = DMA_FGET(GBLADDRA,  GBLADDR);
    x = DMA_FGET(GBLADDRB,  GBLADDR);
    x = DMA_FGET(GBLADDRC,  GBLADDR);
    x = DMA_FGET(GBLADDRD,  GBLADDR);


/*  Test FGET Macro end */
/*  Test FSET Macro start */
    DMA_FSET(  AUXCTL,   AUXPRI,   DMA_AUXCTL_AUXPRI_DEFAULT);
    DMA_FSET(  AUXCTL,    CHPRI,    DMA_AUXCTL_CHPRI_DEFAULT);

    DMA_FSET( PRICTL0,   DSTRLD,   DMA_PRICTL_DSTRLD_DEFAULT);
    DMA_FSET( PRICTL0,   SRCRLD,   DMA_PRICTL_SRCRLD_DEFAULT);
    DMA_FSET( PRICTL0,     EMOD,     DMA_PRICTL_EMOD_DEFAULT);
    DMA_FSET( PRICTL0,       FS,       DMA_PRICTL_FS_DEFAULT);
    DMA_FSET( PRICTL0,    TCINT,    DMA_PRICTL_TCINT_DEFAULT);
    DMA_FSET( PRICTL0,      PRI,      DMA_PRICTL_PRI_DEFAULT);
    DMA_FSET( PRICTL0,    WSYNC,    DMA_PRICTL_WSYNC_DEFAULT);
    DMA_FSET( PRICTL0,    RSYNC,    DMA_PRICTL_RSYNC_DEFAULT);
    DMA_FSET( PRICTL0,    INDEX,    DMA_PRICTL_INDEX_DEFAULT);
    DMA_FSET( PRICTL0,   CNTRLD,   DMA_PRICTL_CNTRLD_DEFAULT);
    DMA_FSET( PRICTL0,    SPLIT,    DMA_PRICTL_SPLIT_DEFAULT);
    DMA_FSET( PRICTL0,    ESIZE,    DMA_PRICTL_ESIZE_DEFAULT);
    DMA_FSET( PRICTL1,   DSTDIR,   DMA_PRICTL_DSTDIR_DEFAULT);
    DMA_FSET( PRICTL1,   SRCDIR,   DMA_PRICTL_SRCDIR_DEFAULT);
    DMA_FSET( PRICTL1,   STATUS,   DMA_PRICTL_STATUS_DEFAULT);
    DMA_FSET( PRICTL1,    START,    DMA_PRICTL_START_DEFAULT);

    DMA_FSET( PRICTL1,   DSTRLD,   DMA_PRICTL_DSTRLD_DEFAULT);
    DMA_FSET( PRICTL1,   SRCRLD,   DMA_PRICTL_SRCRLD_DEFAULT);
    DMA_FSET( PRICTL1,     EMOD,     DMA_PRICTL_EMOD_DEFAULT);
    DMA_FSET( PRICTL1,       FS,       DMA_PRICTL_FS_DEFAULT);
    DMA_FSET( PRICTL1,    TCINT,    DMA_PRICTL_TCINT_DEFAULT);
    DMA_FSET( PRICTL1,      PRI,      DMA_PRICTL_PRI_DEFAULT);
    DMA_FSET( PRICTL1,    WSYNC,    DMA_PRICTL_WSYNC_DEFAULT);
    DMA_FSET( PRICTL1,    RSYNC,    DMA_PRICTL_RSYNC_DEFAULT);
    DMA_FSET( PRICTL1,    INDEX,    DMA_PRICTL_INDEX_DEFAULT);
    DMA_FSET( PRICTL1,   CNTRLD,   DMA_PRICTL_CNTRLD_DEFAULT);
    DMA_FSET( PRICTL1,    SPLIT,    DMA_PRICTL_SPLIT_DEFAULT);
    DMA_FSET( PRICTL1,    ESIZE,    DMA_PRICTL_ESIZE_DEFAULT);
    DMA_FSET( PRICTL2,   DSTDIR,   DMA_PRICTL_DSTDIR_DEFAULT);
    DMA_FSET( PRICTL2,   SRCDIR,   DMA_PRICTL_SRCDIR_DEFAULT);
    DMA_FSET( PRICTL2,   STATUS,   DMA_PRICTL_STATUS_DEFAULT);
    DMA_FSET( PRICTL2,    START,    DMA_PRICTL_START_DEFAULT);

    DMA_FSET( PRICTL2,   DSTRLD,   DMA_PRICTL_DSTRLD_DEFAULT);
    DMA_FSET( PRICTL2,   SRCRLD,   DMA_PRICTL_SRCRLD_DEFAULT);
    DMA_FSET( PRICTL2,     EMOD,     DMA_PRICTL_EMOD_DEFAULT);
    DMA_FSET( PRICTL2,       FS,       DMA_PRICTL_FS_DEFAULT);
    DMA_FSET( PRICTL2,    TCINT,    DMA_PRICTL_TCINT_DEFAULT);
    DMA_FSET( PRICTL2,      PRI,      DMA_PRICTL_PRI_DEFAULT);
    DMA_FSET( PRICTL2,    WSYNC,    DMA_PRICTL_WSYNC_DEFAULT);
    DMA_FSET( PRICTL2,    RSYNC,    DMA_PRICTL_RSYNC_DEFAULT);
    DMA_FSET( PRICTL2,    INDEX,    DMA_PRICTL_INDEX_DEFAULT);
    DMA_FSET( PRICTL2,   CNTRLD,   DMA_PRICTL_CNTRLD_DEFAULT);
    DMA_FSET( PRICTL2,    SPLIT,    DMA_PRICTL_SPLIT_DEFAULT);
    DMA_FSET( PRICTL2,    ESIZE,    DMA_PRICTL_ESIZE_DEFAULT);
    DMA_FSET( PRICTL3,   DSTDIR,   DMA_PRICTL_DSTDIR_DEFAULT);
    DMA_FSET( PRICTL3,   SRCDIR,   DMA_PRICTL_SRCDIR_DEFAULT);
    DMA_FSET( PRICTL3,   STATUS,   DMA_PRICTL_STATUS_DEFAULT);
    DMA_FSET( PRICTL3,    START,    DMA_PRICTL_START_DEFAULT);

    DMA_FSET( PRICTL3,   DSTRLD,   DMA_PRICTL_DSTRLD_DEFAULT);
    DMA_FSET( PRICTL3,   SRCRLD,   DMA_PRICTL_SRCRLD_DEFAULT);
    DMA_FSET( PRICTL3,     EMOD,     DMA_PRICTL_EMOD_DEFAULT);
    DMA_FSET( PRICTL3,       FS,       DMA_PRICTL_FS_DEFAULT);
    DMA_FSET( PRICTL3,    TCINT,    DMA_PRICTL_TCINT_DEFAULT);
    DMA_FSET( PRICTL3,      PRI,      DMA_PRICTL_PRI_DEFAULT);
    DMA_FSET( PRICTL3,    WSYNC,    DMA_PRICTL_WSYNC_DEFAULT);
    DMA_FSET( PRICTL3,    RSYNC,    DMA_PRICTL_RSYNC_DEFAULT);
    DMA_FSET( PRICTL3,    INDEX,    DMA_PRICTL_INDEX_DEFAULT);
    DMA_FSET( PRICTL3,   CNTRLD,   DMA_PRICTL_CNTRLD_DEFAULT);
    DMA_FSET( PRICTL3,    SPLIT,    DMA_PRICTL_SPLIT_DEFAULT);
    DMA_FSET( PRICTL3,    ESIZE,    DMA_PRICTL_ESIZE_DEFAULT);
    DMA_FSET( PRICTL3,   DSTDIR,   DMA_PRICTL_DSTDIR_DEFAULT);
    DMA_FSET( PRICTL3,   SRCDIR,   DMA_PRICTL_SRCDIR_DEFAULT);
    DMA_FSET( PRICTL3,   STATUS,   DMA_PRICTL_STATUS_DEFAULT);
    DMA_FSET( PRICTL3,    START,    DMA_PRICTL_START_DEFAULT);

#if _DMA_COND1
    DMA_FSET( SECCTL0,    WSPOL,    DMA_SECCTL_WSPOL_DEFAULT);
    DMA_FSET( SECCTL0,    RSPOL,    DMA_SECCTL_RSPOL_DEFAULT);
    DMA_FSET( SECCTL0,     FSIG,     DMA_SECCTL_FSIG_DEFAULT);
#endif
    DMA_FSET( SECCTL0,   DMACEN,   DMA_SECCTL_DMACEN_DEFAULT);
    DMA_FSET( SECCTL0, WSYNCCLR, DMA_SECCTL_WSYNCCLR_DEFAULT);
    DMA_FSET( SECCTL0,WSYNCSTAT,DMA_SECCTL_WSYNCSTAT_DEFAULT);
    DMA_FSET( SECCTL0, RSYNCCLR, DMA_SECCTL_RSYNCCLR_DEFAULT);
    DMA_FSET( SECCTL0,RSYNCSTAT,DMA_SECCTL_RSYNCSTAT_DEFAULT);
    DMA_FSET( SECCTL0,  WDROPIE,  DMA_SECCTL_WDROPIE_DEFAULT);
    DMA_FSET( SECCTL0,WDROPCOND,DMA_SECCTL_WDROPCOND_DEFAULT);
    DMA_FSET( SECCTL0,  RDROPIE,  DMA_SECCTL_RDROPIE_DEFAULT);
    DMA_FSET( SECCTL0,RDROPCOND,DMA_SECCTL_RDROPCOND_DEFAULT);
    DMA_FSET( SECCTL0,  BLOCKIE,  DMA_SECCTL_BLOCKIE_DEFAULT);
    DMA_FSET( SECCTL0,BLOCKCOND,DMA_SECCTL_BLOCKCOND_DEFAULT);
    DMA_FSET( SECCTL0,   LASTIE,   DMA_SECCTL_LASTIE_DEFAULT);
    DMA_FSET( SECCTL0, LASTCOND, DMA_SECCTL_LASTCOND_DEFAULT);
    DMA_FSET( SECCTL0,  FRAMEIE,  DMA_SECCTL_FRAMEIE_DEFAULT);
    DMA_FSET( SECCTL0,FRAMECOND,DMA_SECCTL_FRAMECOND_DEFAULT);
    DMA_FSET( SECCTL0,     SXIE,     DMA_SECCTL_SXIE_DEFAULT);
    DMA_FSET( SECCTL0,   SXCOND,   DMA_SECCTL_SXCOND_DEFAULT);

#if _DMA_COND1
    DMA_FSET( SECCTL1,    WSPOL,    DMA_SECCTL_WSPOL_DEFAULT);
    DMA_FSET( SECCTL1,    RSPOL,    DMA_SECCTL_RSPOL_DEFAULT);
    DMA_FSET( SECCTL1,     FSIG,     DMA_SECCTL_FSIG_DEFAULT);
#endif
    DMA_FSET( SECCTL1,   DMACEN,   DMA_SECCTL_DMACEN_DEFAULT);
    DMA_FSET( SECCTL1, WSYNCCLR, DMA_SECCTL_WSYNCCLR_DEFAULT);
    DMA_FSET( SECCTL1,WSYNCSTAT,DMA_SECCTL_WSYNCSTAT_DEFAULT);
    DMA_FSET( SECCTL1, RSYNCCLR, DMA_SECCTL_RSYNCCLR_DEFAULT);
    DMA_FSET( SECCTL1,RSYNCSTAT,DMA_SECCTL_RSYNCSTAT_DEFAULT);
    DMA_FSET( SECCTL1,  WDROPIE,  DMA_SECCTL_WDROPIE_DEFAULT);
    DMA_FSET( SECCTL1,WDROPCOND,DMA_SECCTL_WDROPCOND_DEFAULT);
    DMA_FSET( SECCTL1,  RDROPIE,  DMA_SECCTL_RDROPIE_DEFAULT);
    DMA_FSET( SECCTL1,RDROPCOND,DMA_SECCTL_RDROPCOND_DEFAULT);
    DMA_FSET( SECCTL1,  BLOCKIE,  DMA_SECCTL_BLOCKIE_DEFAULT);
    DMA_FSET( SECCTL1,BLOCKCOND,DMA_SECCTL_BLOCKCOND_DEFAULT);
    DMA_FSET( SECCTL1,   LASTIE,   DMA_SECCTL_LASTIE_DEFAULT);
    DMA_FSET( SECCTL1, LASTCOND, DMA_SECCTL_LASTCOND_DEFAULT);
    DMA_FSET( SECCTL1,  FRAMEIE,  DMA_SECCTL_FRAMEIE_DEFAULT);
    DMA_FSET( SECCTL1,FRAMECOND,DMA_SECCTL_FRAMECOND_DEFAULT);
    DMA_FSET( SECCTL1,     SXIE,     DMA_SECCTL_SXIE_DEFAULT);
    DMA_FSET( SECCTL1,   SXCOND,   DMA_SECCTL_SXCOND_DEFAULT);

#if _DMA_COND1
    DMA_FSET( SECCTL2,    WSPOL,    DMA_SECCTL_WSPOL_DEFAULT);
    DMA_FSET( SECCTL2,    RSPOL,    DMA_SECCTL_RSPOL_DEFAULT);
    DMA_FSET( SECCTL2,     FSIG,     DMA_SECCTL_FSIG_DEFAULT);
#endif
    DMA_FSET( SECCTL2,   DMACEN,   DMA_SECCTL_DMACEN_DEFAULT);
    DMA_FSET( SECCTL2, WSYNCCLR, DMA_SECCTL_WSYNCCLR_DEFAULT);
    DMA_FSET( SECCTL2,WSYNCSTAT,DMA_SECCTL_WSYNCSTAT_DEFAULT);
    DMA_FSET( SECCTL2, RSYNCCLR, DMA_SECCTL_RSYNCCLR_DEFAULT);
    DMA_FSET( SECCTL2,RSYNCSTAT,DMA_SECCTL_RSYNCSTAT_DEFAULT);
    DMA_FSET( SECCTL2,  WDROPIE,  DMA_SECCTL_WDROPIE_DEFAULT);
    DMA_FSET( SECCTL2,WDROPCOND,DMA_SECCTL_WDROPCOND_DEFAULT);
    DMA_FSET( SECCTL2,  RDROPIE,  DMA_SECCTL_RDROPIE_DEFAULT);
    DMA_FSET( SECCTL2,RDROPCOND,DMA_SECCTL_RDROPCOND_DEFAULT);
    DMA_FSET( SECCTL2,  BLOCKIE,  DMA_SECCTL_BLOCKIE_DEFAULT);
    DMA_FSET( SECCTL2,BLOCKCOND,DMA_SECCTL_BLOCKCOND_DEFAULT);
    DMA_FSET( SECCTL2,   LASTIE,   DMA_SECCTL_LASTIE_DEFAULT);
    DMA_FSET( SECCTL2, LASTCOND, DMA_SECCTL_LASTCOND_DEFAULT);
    DMA_FSET( SECCTL2,  FRAMEIE,  DMA_SECCTL_FRAMEIE_DEFAULT);
    DMA_FSET( SECCTL2,FRAMECOND,DMA_SECCTL_FRAMECOND_DEFAULT);
    DMA_FSET( SECCTL2,     SXIE,     DMA_SECCTL_SXIE_DEFAULT);
    DMA_FSET( SECCTL2,   SXCOND,   DMA_SECCTL_SXCOND_DEFAULT);

#if _DMA_COND1
    DMA_FSET( SECCTL3,    WSPOL,    DMA_SECCTL_WSPOL_DEFAULT);
    DMA_FSET( SECCTL3,    RSPOL,    DMA_SECCTL_RSPOL_DEFAULT);
    DMA_FSET( SECCTL3,     FSIG,     DMA_SECCTL_FSIG_DEFAULT);
#endif
    DMA_FSET( SECCTL3,   DMACEN,   DMA_SECCTL_DMACEN_DEFAULT);
    DMA_FSET( SECCTL3, WSYNCCLR, DMA_SECCTL_WSYNCCLR_DEFAULT);
    DMA_FSET( SECCTL3,WSYNCSTAT,DMA_SECCTL_WSYNCSTAT_DEFAULT);
    DMA_FSET( SECCTL3, RSYNCCLR, DMA_SECCTL_RSYNCCLR_DEFAULT);
    DMA_FSET( SECCTL3,RSYNCSTAT,DMA_SECCTL_RSYNCSTAT_DEFAULT);
    DMA_FSET( SECCTL3,  WDROPIE,  DMA_SECCTL_WDROPIE_DEFAULT);
    DMA_FSET( SECCTL3,WDROPCOND,DMA_SECCTL_WDROPCOND_DEFAULT);
    DMA_FSET( SECCTL3,  RDROPIE,  DMA_SECCTL_RDROPIE_DEFAULT);
    DMA_FSET( SECCTL3,RDROPCOND,DMA_SECCTL_RDROPCOND_DEFAULT);
    DMA_FSET( SECCTL3,  BLOCKIE,  DMA_SECCTL_BLOCKIE_DEFAULT);
    DMA_FSET( SECCTL3,BLOCKCOND,DMA_SECCTL_BLOCKCOND_DEFAULT);
    DMA_FSET( SECCTL3,   LASTIE,   DMA_SECCTL_LASTIE_DEFAULT);
    DMA_FSET( SECCTL3, LASTCOND, DMA_SECCTL_LASTCOND_DEFAULT);
    DMA_FSET( SECCTL3,  FRAMEIE,  DMA_SECCTL_FRAMEIE_DEFAULT);
    DMA_FSET( SECCTL3,FRAMECOND,DMA_SECCTL_FRAMECOND_DEFAULT);
    DMA_FSET( SECCTL3,     SXIE,     DMA_SECCTL_SXIE_DEFAULT);
    DMA_FSET( SECCTL3,   SXCOND,   DMA_SECCTL_SXCOND_DEFAULT);

    DMA_FSET(    SRC0,      SRC,         DMA_SRC_SRC_DEFAULT);
    DMA_FSET(    SRC1,      SRC,         DMA_SRC_SRC_DEFAULT);
    DMA_FSET(    SRC2,      SRC,         DMA_SRC_SRC_DEFAULT);
    DMA_FSET(    SRC3,      SRC,         DMA_SRC_SRC_DEFAULT);

    DMA_FSET(    DST0,      DST,         DMA_DST_DST_DEFAULT);
    DMA_FSET(    DST1,      DST,         DMA_DST_DST_DEFAULT);
    DMA_FSET(    DST2,      DST,         DMA_DST_DST_DEFAULT);
    DMA_FSET(    DST3,      DST,         DMA_DST_DST_DEFAULT);

    DMA_FSET( XFRCNT0,   FRMCNT,   DMA_XFRCNT_FRMCNT_DEFAULT);
    DMA_FSET( XFRCNT0,   ELECNT,   DMA_XFRCNT_ELECNT_DEFAULT);
    DMA_FSET( XFRCNT1,   FRMCNT,   DMA_XFRCNT_FRMCNT_DEFAULT);
    DMA_FSET( XFRCNT1,   ELECNT,   DMA_XFRCNT_ELECNT_DEFAULT);
    DMA_FSET( XFRCNT2,   FRMCNT,   DMA_XFRCNT_FRMCNT_DEFAULT);
    DMA_FSET( XFRCNT2,   ELECNT,   DMA_XFRCNT_ELECNT_DEFAULT);
    DMA_FSET( XFRCNT3,   FRMCNT,   DMA_XFRCNT_FRMCNT_DEFAULT);
    DMA_FSET( XFRCNT3,   ELECNT,   DMA_XFRCNT_ELECNT_DEFAULT);

    DMA_FSET( GBLCNTA,   FRMCNT,   DMA_GBLCNT_FRMCNT_DEFAULT);
    DMA_FSET( GBLCNTA,   ELECNT,   DMA_GBLCNT_ELECNT_DEFAULT);
    DMA_FSET( GBLCNTB,   FRMCNT,   DMA_GBLCNT_FRMCNT_DEFAULT);
    DMA_FSET( GBLCNTB,   ELECNT,   DMA_GBLCNT_ELECNT_DEFAULT);

    DMA_FSET( GBLIDXA,   FRMIDX,   DMA_GBLIDX_FRMIDX_DEFAULT);
    DMA_FSET( GBLIDXA,   ELEIDX,   DMA_GBLIDX_ELEIDX_DEFAULT);
    DMA_FSET( GBLIDXB,   FRMIDX,   DMA_GBLIDX_FRMIDX_DEFAULT);
    DMA_FSET( GBLIDXB,   ELEIDX,   DMA_GBLIDX_ELEIDX_DEFAULT);

    DMA_FSET(GBLADDRA,  GBLADDR, DMA_GBLADDR_GBLADDR_DEFAULT);
    DMA_FSET(GBLADDRB,  GBLADDR, DMA_GBLADDR_GBLADDR_DEFAULT);
    DMA_FSET(GBLADDRC,  GBLADDR, DMA_GBLADDR_GBLADDR_DEFAULT);
    DMA_FSET(GBLADDRD,  GBLADDR, DMA_GBLADDR_GBLADDR_DEFAULT);

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    DMA_FSETS(  AUXCTL,   AUXPRI,DEFAULT);
    DMA_FSETS(  AUXCTL,    CHPRI,DEFAULT);

    DMA_FSETS( PRICTL0,   DSTRLD,DEFAULT);
    DMA_FSETS( PRICTL0,   SRCRLD,DEFAULT);
    DMA_FSETS( PRICTL0,     EMOD,DEFAULT);
    DMA_FSETS( PRICTL0,       FS,DEFAULT);
    DMA_FSETS( PRICTL0,    TCINT,DEFAULT);
    DMA_FSETS( PRICTL0,      PRI,DEFAULT);
    DMA_FSETS( PRICTL0,    WSYNC,DEFAULT);
    DMA_FSETS( PRICTL0,    RSYNC,DEFAULT);
    DMA_FSETS( PRICTL0,    INDEX,DEFAULT);
    DMA_FSETS( PRICTL0,   CNTRLD,DEFAULT);
    DMA_FSETS( PRICTL0,    SPLIT,DEFAULT);
    DMA_FSETS( PRICTL0,    ESIZE,DEFAULT);
    DMA_FSETS( PRICTL1,   DSTDIR,DEFAULT);
    DMA_FSETS( PRICTL1,   SRCDIR,DEFAULT);
    DMA_FSETS( PRICTL1,   STATUS,DEFAULT);
    DMA_FSETS( PRICTL1,    START,DEFAULT);

    DMA_FSETS( PRICTL1,   DSTRLD,DEFAULT);
    DMA_FSETS( PRICTL1,   SRCRLD,DEFAULT);
    DMA_FSETS( PRICTL1,     EMOD,DEFAULT);
    DMA_FSETS( PRICTL1,       FS,DEFAULT);
    DMA_FSETS( PRICTL1,    TCINT,DEFAULT);
    DMA_FSETS( PRICTL1,      PRI,DEFAULT);
    DMA_FSETS( PRICTL1,    WSYNC,DEFAULT);
    DMA_FSETS( PRICTL1,    RSYNC,DEFAULT);
    DMA_FSETS( PRICTL1,    INDEX,DEFAULT);
    DMA_FSETS( PRICTL1,   CNTRLD,DEFAULT);
    DMA_FSETS( PRICTL1,    SPLIT,DEFAULT);
    DMA_FSETS( PRICTL1,    ESIZE,DEFAULT);
    DMA_FSETS( PRICTL2,   DSTDIR,DEFAULT);
    DMA_FSETS( PRICTL2,   SRCDIR,DEFAULT);
    DMA_FSETS( PRICTL2,   STATUS,DEFAULT);
    DMA_FSETS( PRICTL2,    START,DEFAULT);

    DMA_FSETS( PRICTL2,   DSTRLD,DEFAULT);
    DMA_FSETS( PRICTL2,   SRCRLD,DEFAULT);
    DMA_FSETS( PRICTL2,     EMOD,DEFAULT);
    DMA_FSETS( PRICTL2,       FS,DEFAULT);
    DMA_FSETS( PRICTL2,    TCINT,DEFAULT);
    DMA_FSETS( PRICTL2,      PRI,DEFAULT);
    DMA_FSETS( PRICTL2,    WSYNC,DEFAULT);
    DMA_FSETS( PRICTL2,    RSYNC,DEFAULT);
    DMA_FSETS( PRICTL2,    INDEX,DEFAULT);
    DMA_FSETS( PRICTL2,   CNTRLD,DEFAULT);
    DMA_FSETS( PRICTL2,    SPLIT,DEFAULT);
    DMA_FSETS( PRICTL2,    ESIZE,DEFAULT);
    DMA_FSETS( PRICTL3,   DSTDIR,DEFAULT);
    DMA_FSETS( PRICTL3,   SRCDIR,DEFAULT);
    DMA_FSETS( PRICTL3,   STATUS,DEFAULT);
    DMA_FSETS( PRICTL3,    START,DEFAULT);

    DMA_FSETS( PRICTL3,   DSTRLD,DEFAULT);
    DMA_FSETS( PRICTL3,   SRCRLD,DEFAULT);
    DMA_FSETS( PRICTL3,     EMOD,DEFAULT);
    DMA_FSETS( PRICTL3,       FS,DEFAULT);
    DMA_FSETS( PRICTL3,    TCINT,DEFAULT);
    DMA_FSETS( PRICTL3,      PRI,DEFAULT);
    DMA_FSETS( PRICTL3,    WSYNC,DEFAULT);
    DMA_FSETS( PRICTL3,    RSYNC,DEFAULT);
    DMA_FSETS( PRICTL3,    INDEX,DEFAULT);
    DMA_FSETS( PRICTL3,   CNTRLD,DEFAULT);
    DMA_FSETS( PRICTL3,    SPLIT,DEFAULT);
    DMA_FSETS( PRICTL3,    ESIZE,DEFAULT);
    DMA_FSETS( PRICTL3,   DSTDIR,DEFAULT);
    DMA_FSETS( PRICTL3,   SRCDIR,DEFAULT);
    DMA_FSETS( PRICTL3,   STATUS,DEFAULT);
    DMA_FSETS( PRICTL3,    START,DEFAULT);

#if _DMA_COND1
    DMA_FSETS( SECCTL0,    WSPOL,DEFAULT);
    DMA_FSETS( SECCTL0,    RSPOL,DEFAULT);
    DMA_FSETS( SECCTL0,     FSIG,DEFAULT);
#endif
    DMA_FSETS( SECCTL0,   DMACEN,DEFAULT);
    DMA_FSETS( SECCTL0, WSYNCCLR,DEFAULT);
    DMA_FSETS( SECCTL0,WSYNCSTAT,DEFAULT);
    DMA_FSETS( SECCTL0, RSYNCCLR,DEFAULT);
    DMA_FSETS( SECCTL0,RSYNCSTAT,DEFAULT);
    DMA_FSETS( SECCTL0,  WDROPIE,DEFAULT);
    DMA_FSETS( SECCTL0,WDROPCOND,DEFAULT);
    DMA_FSETS( SECCTL0,  RDROPIE,DEFAULT);
    DMA_FSETS( SECCTL0,RDROPCOND,DEFAULT);
    DMA_FSETS( SECCTL0,  BLOCKIE,DEFAULT);
    DMA_FSETS( SECCTL0,BLOCKCOND,DEFAULT);
    DMA_FSETS( SECCTL0,   LASTIE,DEFAULT);
    DMA_FSETS( SECCTL0, LASTCOND,DEFAULT);
    DMA_FSETS( SECCTL0,  FRAMEIE,DEFAULT);
    DMA_FSETS( SECCTL0,FRAMECOND,DEFAULT);
    DMA_FSETS( SECCTL0,     SXIE,DEFAULT);
    DMA_FSETS( SECCTL0,   SXCOND,DEFAULT);

#if _DMA_COND1
    DMA_FSETS( SECCTL1,    WSPOL,DEFAULT);
    DMA_FSETS( SECCTL1,    RSPOL,DEFAULT);
    DMA_FSETS( SECCTL1,     FSIG,DEFAULT);
#endif
    DMA_FSETS( SECCTL1,   DMACEN,DEFAULT);
    DMA_FSETS( SECCTL1, WSYNCCLR,DEFAULT);
    DMA_FSETS( SECCTL1,WSYNCSTAT,DEFAULT);
    DMA_FSETS( SECCTL1, RSYNCCLR,DEFAULT);
    DMA_FSETS( SECCTL1,RSYNCSTAT,DEFAULT);
    DMA_FSETS( SECCTL1,  WDROPIE,DEFAULT);
    DMA_FSETS( SECCTL1,WDROPCOND,DEFAULT);
    DMA_FSETS( SECCTL1,  RDROPIE,DEFAULT);
    DMA_FSETS( SECCTL1,RDROPCOND,DEFAULT);
    DMA_FSETS( SECCTL1,  BLOCKIE,DEFAULT);
    DMA_FSETS( SECCTL1,BLOCKCOND,DEFAULT);
    DMA_FSETS( SECCTL1,   LASTIE,DEFAULT);
    DMA_FSETS( SECCTL1, LASTCOND,DEFAULT);
    DMA_FSETS( SECCTL1,  FRAMEIE,DEFAULT);
    DMA_FSETS( SECCTL1,FRAMECOND,DEFAULT);
    DMA_FSETS( SECCTL1,     SXIE,DEFAULT);
    DMA_FSETS( SECCTL1,   SXCOND,DEFAULT);

#if _DMA_COND1
    DMA_FSETS( SECCTL2,    WSPOL,DEFAULT);
    DMA_FSETS( SECCTL2,    RSPOL,DEFAULT);
    DMA_FSETS( SECCTL2,     FSIG,DEFAULT);
#endif
    DMA_FSETS( SECCTL2,   DMACEN,DEFAULT);
    DMA_FSETS( SECCTL2, WSYNCCLR,DEFAULT);
    DMA_FSETS( SECCTL2,WSYNCSTAT,DEFAULT);
    DMA_FSETS( SECCTL2, RSYNCCLR,DEFAULT);
    DMA_FSETS( SECCTL2,RSYNCSTAT,DEFAULT);
    DMA_FSETS( SECCTL2,  WDROPIE,DEFAULT);
    DMA_FSETS( SECCTL2,WDROPCOND,DEFAULT);
    DMA_FSETS( SECCTL2,  RDROPIE,DEFAULT);
    DMA_FSETS( SECCTL2,RDROPCOND,DEFAULT);
    DMA_FSETS( SECCTL2,  BLOCKIE,DEFAULT);
    DMA_FSETS( SECCTL2,BLOCKCOND,DEFAULT);
    DMA_FSETS( SECCTL2,   LASTIE,DEFAULT);
    DMA_FSETS( SECCTL2, LASTCOND,DEFAULT);
    DMA_FSETS( SECCTL2,  FRAMEIE,DEFAULT);
    DMA_FSETS( SECCTL2,FRAMECOND,DEFAULT);
    DMA_FSETS( SECCTL2,     SXIE,DEFAULT);
    DMA_FSETS( SECCTL2,   SXCOND,DEFAULT);

#if _DMA_COND1
    DMA_FSETS( SECCTL3,    WSPOL,DEFAULT);
    DMA_FSETS( SECCTL3,    RSPOL,DEFAULT);
    DMA_FSETS( SECCTL3,     FSIG,DEFAULT);
#endif
    DMA_FSETS( SECCTL3,   DMACEN,DEFAULT);
    DMA_FSETS( SECCTL3, WSYNCCLR,DEFAULT);
    DMA_FSETS( SECCTL3,WSYNCSTAT,DEFAULT);
    DMA_FSETS( SECCTL3, RSYNCCLR,DEFAULT);
    DMA_FSETS( SECCTL3,RSYNCSTAT,DEFAULT);
    DMA_FSETS( SECCTL3,  WDROPIE,DEFAULT);
    DMA_FSETS( SECCTL3,WDROPCOND,DEFAULT);
    DMA_FSETS( SECCTL3,  RDROPIE,DEFAULT);
    DMA_FSETS( SECCTL3,RDROPCOND,DEFAULT);
    DMA_FSETS( SECCTL3,  BLOCKIE,DEFAULT);
    DMA_FSETS( SECCTL3,BLOCKCOND,DEFAULT);
    DMA_FSETS( SECCTL3,   LASTIE,DEFAULT);
    DMA_FSETS( SECCTL3, LASTCOND,DEFAULT);
    DMA_FSETS( SECCTL3,  FRAMEIE,DEFAULT);
    DMA_FSETS( SECCTL3,FRAMECOND,DEFAULT);
    DMA_FSETS( SECCTL3,     SXIE,DEFAULT);
    DMA_FSETS( SECCTL3,   SXCOND,DEFAULT);

    DMA_FSETS(    SRC0,      SRC,DEFAULT);
    DMA_FSETS(    SRC1,      SRC,DEFAULT);
    DMA_FSETS(    SRC2,      SRC,DEFAULT);
    DMA_FSETS(    SRC3,      SRC,DEFAULT);

    DMA_FSETS(    DST0,      DST,DEFAULT);
    DMA_FSETS(    DST1,      DST,DEFAULT);
    DMA_FSETS(    DST2,      DST,DEFAULT);
    DMA_FSETS(    DST3,      DST,DEFAULT);

    DMA_FSETS( XFRCNT0,   FRMCNT,DEFAULT);
    DMA_FSETS( XFRCNT0,   ELECNT,DEFAULT);
    DMA_FSETS( XFRCNT1,   FRMCNT,DEFAULT);
    DMA_FSETS( XFRCNT1,   ELECNT,DEFAULT);
    DMA_FSETS( XFRCNT2,   FRMCNT,DEFAULT);
    DMA_FSETS( XFRCNT2,   ELECNT,DEFAULT);
    DMA_FSETS( XFRCNT3,   FRMCNT,DEFAULT);
    DMA_FSETS( XFRCNT3,   ELECNT,DEFAULT);

    DMA_FSETS( GBLCNTA,   FRMCNT,DEFAULT);
    DMA_FSETS( GBLCNTA,   ELECNT,DEFAULT);
    DMA_FSETS( GBLCNTB,   FRMCNT,DEFAULT);
    DMA_FSETS( GBLCNTB,   ELECNT,DEFAULT);

    DMA_FSETS( GBLIDXA,   FRMIDX,DEFAULT);
    DMA_FSETS( GBLIDXA,   ELEIDX,DEFAULT);
    DMA_FSETS( GBLIDXB,   FRMIDX,DEFAULT);
    DMA_FSETS( GBLIDXB,   ELEIDX,DEFAULT);

    DMA_FSETS(GBLADDRA,  GBLADDR,DEFAULT);
    DMA_FSETS(GBLADDRB,  GBLADDR,DEFAULT);
    DMA_FSETS(GBLADDRC,  GBLADDR,DEFAULT);
    DMA_FSETS(GBLADDRD,  GBLADDR,DEFAULT);

/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = DMA_RGETA(0,  AUXCTL);
    x = DMA_RGETA(0, PRICTL0);
    x = DMA_RGETA(0, PRICTL1);
    x = DMA_RGETA(0, PRICTL2);
    x = DMA_RGETA(0, PRICTL3);
    x = DMA_RGETA(0, SECCTL0);
    x = DMA_RGETA(0, SECCTL1);
    x = DMA_RGETA(0, SECCTL2);
    x = DMA_RGETA(0, SECCTL3);
    x = DMA_RGETA(0,    SRC0);
    x = DMA_RGETA(0,    SRC1);
    x = DMA_RGETA(0,    SRC2);
    x = DMA_RGETA(0,    SRC3);
    x = DMA_RGETA(0,    DST0);
    x = DMA_RGETA(0,    DST1);
    x = DMA_RGETA(0,    DST2);
    x = DMA_RGETA(0,    DST3);
    x = DMA_RGETA(0, XFRCNT0);
    x = DMA_RGETA(0, XFRCNT1);
    x = DMA_RGETA(0, XFRCNT2);
    x = DMA_RGETA(0, XFRCNT3);
    x = DMA_RGETA(0, GBLCNTA);
    x = DMA_RGETA(0, GBLCNTB);
    x = DMA_RGETA(0, GBLIDXA);
    x = DMA_RGETA(0, GBLIDXB);
    x = DMA_RGETA(0,GBLADDRA);
    x = DMA_RGETA(0,GBLADDRB);
    x = DMA_RGETA(0,GBLADDRC);
    x = DMA_RGETA(0,GBLADDRD);


/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    DMA_RSETA(0,  AUXCTL,0);
    DMA_RSETA(0, PRICTL0,0);
    DMA_RSETA(0, PRICTL1,0);
    DMA_RSETA(0, PRICTL2,0);
    DMA_RSETA(0, PRICTL3,0);
    DMA_RSETA(0, SECCTL0,0);
    DMA_RSETA(0, SECCTL1,0);
    DMA_RSETA(0, SECCTL2,0);
    DMA_RSETA(0, SECCTL3,0);
    DMA_RSETA(0,    SRC0,0);
    DMA_RSETA(0,    SRC1,0);
    DMA_RSETA(0,    SRC2,0);
    DMA_RSETA(0,    SRC3,0);
    DMA_RSETA(0,    DST0,0);
    DMA_RSETA(0,    DST1,0);
    DMA_RSETA(0,    DST2,0);
    DMA_RSETA(0,    DST3,0);
    DMA_RSETA(0, XFRCNT0,0);
    DMA_RSETA(0, XFRCNT1,0);
    DMA_RSETA(0, XFRCNT2,0);
    DMA_RSETA(0, XFRCNT3,0);
    DMA_RSETA(0, GBLCNTA,0);
    DMA_RSETA(0, GBLCNTB,0);
    DMA_RSETA(0, GBLIDXA,0);
    DMA_RSETA(0, GBLIDXB,0);
    DMA_RSETA(0,GBLADDRA,0);
    DMA_RSETA(0,GBLADDRB,0);
    DMA_RSETA(0,GBLADDRC,0);
    DMA_RSETA(0,GBLADDRD,0);

/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = DMA_FGETA(0, AUXCTL,   AUXPRI);
    x = DMA_FGETA(0, AUXCTL,    CHPRI);

    x = DMA_FGETA(0, PRICTL,   DSTRLD);
    x = DMA_FGETA(0, PRICTL,   SRCRLD);
    x = DMA_FGETA(0, PRICTL,     EMOD);
    x = DMA_FGETA(0, PRICTL,       FS);
    x = DMA_FGETA(0, PRICTL,    TCINT);
    x = DMA_FGETA(0, PRICTL,      PRI);
    x = DMA_FGETA(0, PRICTL,    WSYNC);
    x = DMA_FGETA(0, PRICTL,    RSYNC);
    x = DMA_FGETA(0, PRICTL,    INDEX);
    x = DMA_FGETA(0, PRICTL,   CNTRLD);
    x = DMA_FGETA(0, PRICTL,    SPLIT);
    x = DMA_FGETA(0, PRICTL,    ESIZE);
    x = DMA_FGETA(0, PRICTL,   DSTDIR);
    x = DMA_FGETA(0, PRICTL,   SRCDIR);
    x = DMA_FGETA(0, PRICTL,   STATUS);
    x = DMA_FGETA(0, PRICTL,    START);

#if _DMA_COND1
    x = DMA_FGETA(0, SECCTL,    WSPOL);
    x = DMA_FGETA(0, SECCTL,    RSPOL);
    x = DMA_FGETA(0, SECCTL,     FSIG);
#endif
    x = DMA_FGETA(0, SECCTL,   DMACEN);
    x = DMA_FGETA(0, SECCTL, WSYNCCLR);
    x = DMA_FGETA(0, SECCTL,WSYNCSTAT);
    x = DMA_FGETA(0, SECCTL, RSYNCCLR);
    x = DMA_FGETA(0, SECCTL,RSYNCSTAT);
    x = DMA_FGETA(0, SECCTL,  WDROPIE);
    x = DMA_FGETA(0, SECCTL,WDROPCOND);
    x = DMA_FGETA(0, SECCTL,  RDROPIE);
    x = DMA_FGETA(0, SECCTL,RDROPCOND);
    x = DMA_FGETA(0, SECCTL,  BLOCKIE);
    x = DMA_FGETA(0, SECCTL,BLOCKCOND);
    x = DMA_FGETA(0, SECCTL,   LASTIE);
    x = DMA_FGETA(0, SECCTL, LASTCOND);
    x = DMA_FGETA(0, SECCTL,  FRAMEIE);
    x = DMA_FGETA(0, SECCTL,FRAMECOND);
    x = DMA_FGETA(0, SECCTL,     SXIE);
    x = DMA_FGETA(0, SECCTL,   SXCOND);

    x = DMA_FGETA(0,    SRC,      SRC);
    x = DMA_FGETA(0,    DST,      DST);
    x = DMA_FGETA(0, XFRCNT,   FRMCNT);
    x = DMA_FGETA(0, XFRCNT,   ELECNT);
    x = DMA_FGETA(0, GBLCNT,   FRMCNT);
    x = DMA_FGETA(0, GBLCNT,   ELECNT);
    x = DMA_FGETA(0, GBLIDX,   FRMIDX);
    x = DMA_FGETA(0, GBLIDX,   ELEIDX);
    x = DMA_FGETA(0,GBLADDR,  GBLADDR);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    DMA_FSETA(0, AUXCTL,   AUXPRI,   DMA_AUXCTL_AUXPRI_DEFAULT);
    DMA_FSETA(0, AUXCTL,    CHPRI,    DMA_AUXCTL_CHPRI_DEFAULT);

    DMA_FSETA(0, PRICTL,   DSTRLD,   DMA_PRICTL_DSTRLD_DEFAULT);
    DMA_FSETA(0, PRICTL,   SRCRLD,   DMA_PRICTL_SRCRLD_DEFAULT);
    DMA_FSETA(0, PRICTL,     EMOD,     DMA_PRICTL_EMOD_DEFAULT);
    DMA_FSETA(0, PRICTL,       FS,       DMA_PRICTL_FS_DEFAULT);
    DMA_FSETA(0, PRICTL,    TCINT,    DMA_PRICTL_TCINT_DEFAULT);
    DMA_FSETA(0, PRICTL,      PRI,      DMA_PRICTL_PRI_DEFAULT);
    DMA_FSETA(0, PRICTL,    WSYNC,    DMA_PRICTL_WSYNC_DEFAULT);
    DMA_FSETA(0, PRICTL,    RSYNC,    DMA_PRICTL_RSYNC_DEFAULT);
    DMA_FSETA(0, PRICTL,    INDEX,    DMA_PRICTL_INDEX_DEFAULT);
    DMA_FSETA(0, PRICTL,   CNTRLD,   DMA_PRICTL_CNTRLD_DEFAULT);
    DMA_FSETA(0, PRICTL,    SPLIT,    DMA_PRICTL_SPLIT_DEFAULT);
    DMA_FSETA(0, PRICTL,    ESIZE,    DMA_PRICTL_ESIZE_DEFAULT);
    DMA_FSETA(0, PRICTL,   DSTDIR,   DMA_PRICTL_DSTDIR_DEFAULT);
    DMA_FSETA(0, PRICTL,   SRCDIR,   DMA_PRICTL_SRCDIR_DEFAULT);
    DMA_FSETA(0, PRICTL,   STATUS,   DMA_PRICTL_STATUS_DEFAULT);
    DMA_FSETA(0, PRICTL,    START,    DMA_PRICTL_START_DEFAULT);

#if _DMA_COND1
    DMA_FSETA(0, SECCTL,    WSPOL,    DMA_SECCTL_WSPOL_DEFAULT);
    DMA_FSETA(0, SECCTL,    RSPOL,    DMA_SECCTL_RSPOL_DEFAULT);
    DMA_FSETA(0, SECCTL,     FSIG,     DMA_SECCTL_FSIG_DEFAULT);
#endif
    DMA_FSETA(0, SECCTL,   DMACEN,   DMA_SECCTL_DMACEN_DEFAULT);
    DMA_FSETA(0, SECCTL, WSYNCCLR, DMA_SECCTL_WSYNCCLR_DEFAULT);
    DMA_FSETA(0, SECCTL,WSYNCSTAT,DMA_SECCTL_WSYNCSTAT_DEFAULT);
    DMA_FSETA(0, SECCTL, RSYNCCLR, DMA_SECCTL_RSYNCCLR_DEFAULT);
    DMA_FSETA(0, SECCTL,RSYNCSTAT,DMA_SECCTL_RSYNCSTAT_DEFAULT);
    DMA_FSETA(0, SECCTL,  WDROPIE,  DMA_SECCTL_WDROPIE_DEFAULT);
    DMA_FSETA(0, SECCTL,WDROPCOND,DMA_SECCTL_WDROPCOND_DEFAULT);
    DMA_FSETA(0, SECCTL,  RDROPIE,  DMA_SECCTL_RDROPIE_DEFAULT);
    DMA_FSETA(0, SECCTL,RDROPCOND,DMA_SECCTL_RDROPCOND_DEFAULT);
    DMA_FSETA(0, SECCTL,  BLOCKIE,  DMA_SECCTL_BLOCKIE_DEFAULT);
    DMA_FSETA(0, SECCTL,BLOCKCOND,DMA_SECCTL_BLOCKCOND_DEFAULT);
    DMA_FSETA(0, SECCTL,   LASTIE,   DMA_SECCTL_LASTIE_DEFAULT);
    DMA_FSETA(0, SECCTL, LASTCOND, DMA_SECCTL_LASTCOND_DEFAULT);
    DMA_FSETA(0, SECCTL,  FRAMEIE,  DMA_SECCTL_FRAMEIE_DEFAULT);
    DMA_FSETA(0, SECCTL,FRAMECOND,DMA_SECCTL_FRAMECOND_DEFAULT);
    DMA_FSETA(0, SECCTL,     SXIE,     DMA_SECCTL_SXIE_DEFAULT);
    DMA_FSETA(0, SECCTL,   SXCOND,   DMA_SECCTL_SXCOND_DEFAULT);
	
	DMA_FSETA(0,    SRC,      SRC,         DMA_SRC_SRC_DEFAULT);
    DMA_FSETA(0,    DST,      DST,         DMA_DST_DST_DEFAULT);
    DMA_FSETA(0, XFRCNT,   FRMCNT,   DMA_XFRCNT_FRMCNT_DEFAULT);
    DMA_FSETA(0, XFRCNT,   ELECNT,   DMA_XFRCNT_ELECNT_DEFAULT);
    DMA_FSETA(0, GBLCNT,   FRMCNT,   DMA_GBLCNT_FRMCNT_DEFAULT);
    DMA_FSETA(0, GBLCNT,   ELECNT,   DMA_GBLCNT_ELECNT_DEFAULT);
    DMA_FSETA(0, GBLIDX,   FRMIDX,   DMA_GBLIDX_FRMIDX_DEFAULT);
    DMA_FSETA(0, GBLIDX,   ELEIDX,   DMA_GBLIDX_ELEIDX_DEFAULT);
    DMA_FSETA(0,GBLADDR,  GBLADDR, DMA_GBLADDR_GBLADDR_DEFAULT);

/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    DMA_FSETSA(0, AUXCTL,   AUXPRI,DEFAULT);
    DMA_FSETSA(0, AUXCTL,    CHPRI,DEFAULT);

    DMA_FSETSA(0, PRICTL,   DSTRLD,DEFAULT);
    DMA_FSETSA(0, PRICTL,   SRCRLD,DEFAULT);
    DMA_FSETSA(0, PRICTL,     EMOD,DEFAULT);
    DMA_FSETSA(0, PRICTL,       FS,DEFAULT);
    DMA_FSETSA(0, PRICTL,    TCINT,DEFAULT);
    DMA_FSETSA(0, PRICTL,      PRI,DEFAULT);
    DMA_FSETSA(0, PRICTL,    WSYNC,DEFAULT);
    DMA_FSETSA(0, PRICTL,    RSYNC,DEFAULT);
    DMA_FSETSA(0, PRICTL,    INDEX,DEFAULT);
    DMA_FSETSA(0, PRICTL,   CNTRLD,DEFAULT);
    DMA_FSETSA(0, PRICTL,    SPLIT,DEFAULT);
    DMA_FSETSA(0, PRICTL,    ESIZE,DEFAULT);
    DMA_FSETSA(0, PRICTL,   DSTDIR,DEFAULT);
    DMA_FSETSA(0, PRICTL,   SRCDIR,DEFAULT);
    DMA_FSETSA(0, PRICTL,   STATUS,DEFAULT);
    DMA_FSETSA(0, PRICTL,    START,DEFAULT);

#if _DMA_COND1
    DMA_FSETSA(0, SECCTL,    WSPOL,DEFAULT);
    DMA_FSETSA(0, SECCTL,    RSPOL,DEFAULT);
    DMA_FSETSA(0, SECCTL,     FSIG,DEFAULT);
#endif
    DMA_FSETSA(0, SECCTL,   DMACEN,DEFAULT);
    DMA_FSETSA(0, SECCTL, WSYNCCLR,DEFAULT);
    DMA_FSETSA(0, SECCTL,WSYNCSTAT,DEFAULT);
    DMA_FSETSA(0, SECCTL, RSYNCCLR,DEFAULT);
    DMA_FSETSA(0, SECCTL,RSYNCSTAT,DEFAULT);
    DMA_FSETSA(0, SECCTL,  WDROPIE,DEFAULT);
    DMA_FSETSA(0, SECCTL,WDROPCOND,DEFAULT);
    DMA_FSETSA(0, SECCTL,  RDROPIE,DEFAULT);
    DMA_FSETSA(0, SECCTL,RDROPCOND,DEFAULT);
    DMA_FSETSA(0, SECCTL,  BLOCKIE,DEFAULT);
    DMA_FSETSA(0, SECCTL,BLOCKCOND,DEFAULT);
    DMA_FSETSA(0, SECCTL,   LASTIE,DEFAULT);
    DMA_FSETSA(0, SECCTL, LASTCOND,DEFAULT);
    DMA_FSETSA(0, SECCTL,  FRAMEIE,DEFAULT);
    DMA_FSETSA(0, SECCTL,FRAMECOND,DEFAULT);
    DMA_FSETSA(0, SECCTL,     SXIE,DEFAULT);
    DMA_FSETSA(0, SECCTL,   SXCOND,DEFAULT);
	
	DMA_FSETSA(0,    SRC,      SRC,DEFAULT);
    DMA_FSETSA(0,    DST,      DST,DEFAULT);
    DMA_FSETSA(0, XFRCNT,   FRMCNT,DEFAULT);
    DMA_FSETSA(0, XFRCNT,   ELECNT,DEFAULT);
    DMA_FSETSA(0, GBLCNT,   FRMCNT,DEFAULT);
    DMA_FSETSA(0, GBLCNT,   ELECNT,DEFAULT);
    DMA_FSETSA(0, GBLIDX,   FRMIDX,DEFAULT);
    DMA_FSETSA(0, GBLIDX,   ELEIDX,DEFAULT);
    DMA_FSETSA(0,GBLADDR,  GBLADDR,DEFAULT);

/*  Test FSETSA Macro end */
/*  Test ADDRH Macro start */

    x = DMA_ADDRH(hDma, PRICTL);
    x = DMA_ADDRH(hDma, SECCTL);
    x = DMA_ADDRH(hDma,    SRC);
    x = DMA_ADDRH(hDma,    DST);
    x = DMA_ADDRH(hDma, XFRCNT);

/*  Test ADDRH Macro end */
/*  Test RGETH Macro start */
    x = DMA_RGETH(hDma, PRICTL);
    x = DMA_RGETH(hDma, SECCTL);
    x = DMA_RGETH(hDma,    SRC);
    x = DMA_RGETH(hDma,    DST);
    x = DMA_RGETH(hDma, XFRCNT);

/*  Test RGETH Macro end */
/*  Test RSETH Macro start */
    DMA_RSETH(hDma, PRICTL,DMA_PRICTL_DEFAULT);
    DMA_RSETH(hDma, SECCTL,DMA_SECCTL_DEFAULT);
    DMA_RSETH(hDma,    SRC,   DMA_SRC_DEFAULT);
    DMA_RSETH(hDma,    DST,   DMA_DST_DEFAULT);
    DMA_RSETH(hDma, XFRCNT,DMA_XFRCNT_DEFAULT);

/*  Test RSETH Macro end */
/*  Test FGETH Macro start */
    x = DMA_FGETH(hDma, PRICTL,   DSTRLD);
    x = DMA_FGETH(hDma, PRICTL,   SRCRLD);
    x = DMA_FGETH(hDma, PRICTL,     EMOD);
    x = DMA_FGETH(hDma, PRICTL,       FS);
    x = DMA_FGETH(hDma, PRICTL,    TCINT);
    x = DMA_FGETH(hDma, PRICTL,      PRI);
    x = DMA_FGETH(hDma, PRICTL,    WSYNC);
    x = DMA_FGETH(hDma, PRICTL,    RSYNC);
    x = DMA_FGETH(hDma, PRICTL,    INDEX);
    x = DMA_FGETH(hDma, PRICTL,   CNTRLD);
    x = DMA_FGETH(hDma, PRICTL,    SPLIT);
    x = DMA_FGETH(hDma, PRICTL,    ESIZE);
    x = DMA_FGETH(hDma, PRICTL,   DSTDIR);
    x = DMA_FGETH(hDma, PRICTL,   SRCDIR);
    x = DMA_FGETH(hDma, PRICTL,   STATUS);
    x = DMA_FGETH(hDma, PRICTL,    START);

#if _DMA_COND1    
	x = DMA_FGETH(hDma, SECCTL,    WSPOL);
    x = DMA_FGETH(hDma, SECCTL,    RSPOL);
	x = DMA_FGETH(hDma, SECCTL,     FSIG);
#endif
    x = DMA_FGETH(hDma, SECCTL,   DMACEN);
	x = DMA_FGETH(hDma, SECCTL, WSYNCCLR);
    x = DMA_FGETH(hDma, SECCTL,WSYNCSTAT);
	x = DMA_FGETH(hDma, SECCTL, RSYNCCLR);
    x = DMA_FGETH(hDma, SECCTL,RSYNCSTAT);
	x = DMA_FGETH(hDma, SECCTL,  WDROPIE);
    x = DMA_FGETH(hDma, SECCTL,WDROPCOND);
	x = DMA_FGETH(hDma, SECCTL,  RDROPIE);
    x = DMA_FGETH(hDma, SECCTL,RDROPCOND);
	x = DMA_FGETH(hDma, SECCTL,  BLOCKIE);
    x = DMA_FGETH(hDma, SECCTL,BLOCKCOND);
	x = DMA_FGETH(hDma, SECCTL,   LASTIE);
    x = DMA_FGETH(hDma, SECCTL, LASTCOND);
	x = DMA_FGETH(hDma, SECCTL,  FRAMEIE);
    x = DMA_FGETH(hDma, SECCTL,FRAMECOND);
	x = DMA_FGETH(hDma, SECCTL,     SXIE);
    x = DMA_FGETH(hDma, SECCTL,   SXCOND);

    x = DMA_FGETH(hDma,    SRC,      SRC);
    x = DMA_FGETH(hDma,    DST,      DST);
    x = DMA_FGETH(hDma, XFRCNT,   FRMCNT);
    x = DMA_FGETH(hDma, XFRCNT,   ELECNT);

/*  Test FGETH Macro end */
/*  Test FSETH Macro start */
    DMA_FSETH(hDma, PRICTL,   DSTRLD,   DMA_PRICTL_DSTRLD_DEFAULT);
    DMA_FSETH(hDma, PRICTL,   SRCRLD,   DMA_PRICTL_SRCRLD_DEFAULT);
    DMA_FSETH(hDma, PRICTL,     EMOD,     DMA_PRICTL_EMOD_DEFAULT);
    DMA_FSETH(hDma, PRICTL,       FS,       DMA_PRICTL_FS_DEFAULT);
    DMA_FSETH(hDma, PRICTL,    TCINT,    DMA_PRICTL_TCINT_DEFAULT);
    DMA_FSETH(hDma, PRICTL,      PRI,      DMA_PRICTL_PRI_DEFAULT);
    DMA_FSETH(hDma, PRICTL,    WSYNC,    DMA_PRICTL_WSYNC_DEFAULT);
    DMA_FSETH(hDma, PRICTL,    RSYNC,    DMA_PRICTL_RSYNC_DEFAULT);
    DMA_FSETH(hDma, PRICTL,    INDEX,    DMA_PRICTL_INDEX_DEFAULT);
    DMA_FSETH(hDma, PRICTL,   CNTRLD,   DMA_PRICTL_CNTRLD_DEFAULT);
    DMA_FSETH(hDma, PRICTL,    SPLIT,    DMA_PRICTL_SPLIT_DEFAULT);
    DMA_FSETH(hDma, PRICTL,    ESIZE,    DMA_PRICTL_ESIZE_DEFAULT);
    DMA_FSETH(hDma, PRICTL,   DSTDIR,   DMA_PRICTL_DSTDIR_DEFAULT);
    DMA_FSETH(hDma, PRICTL,   SRCDIR,   DMA_PRICTL_SRCDIR_DEFAULT);
    DMA_FSETH(hDma, PRICTL,   STATUS,   DMA_PRICTL_STATUS_DEFAULT);
    DMA_FSETH(hDma, PRICTL,    START,    DMA_PRICTL_START_DEFAULT);

#if _DMA_COND1    
	DMA_FSETH(hDma, SECCTL,    WSPOL,    DMA_SECCTL_WSPOL_DEFAULT);
    DMA_FSETH(hDma, SECCTL,    RSPOL,    DMA_SECCTL_RSPOL_DEFAULT);
	DMA_FSETH(hDma, SECCTL,     FSIG,     DMA_SECCTL_FSIG_DEFAULT);
#endif
    DMA_FSETH(hDma, SECCTL,   DMACEN,   DMA_SECCTL_DMACEN_DEFAULT);
	DMA_FSETH(hDma, SECCTL, WSYNCCLR, DMA_SECCTL_WSYNCCLR_DEFAULT);
    DMA_FSETH(hDma, SECCTL,WSYNCSTAT,DMA_SECCTL_WSYNCSTAT_DEFAULT);
	DMA_FSETH(hDma, SECCTL, RSYNCCLR, DMA_SECCTL_RSYNCCLR_DEFAULT);
    DMA_FSETH(hDma, SECCTL,RSYNCSTAT,DMA_SECCTL_RSYNCSTAT_DEFAULT);
	DMA_FSETH(hDma, SECCTL,  WDROPIE,  DMA_SECCTL_WDROPIE_DEFAULT);
    DMA_FSETH(hDma, SECCTL,WDROPCOND,DMA_SECCTL_WDROPCOND_DEFAULT);
	DMA_FSETH(hDma, SECCTL,  RDROPIE,  DMA_SECCTL_RDROPIE_DEFAULT);
    DMA_FSETH(hDma, SECCTL,RDROPCOND,DMA_SECCTL_RDROPCOND_DEFAULT);
	DMA_FSETH(hDma, SECCTL,  BLOCKIE,  DMA_SECCTL_BLOCKIE_DEFAULT);
    DMA_FSETH(hDma, SECCTL,BLOCKCOND,DMA_SECCTL_BLOCKCOND_DEFAULT);
	DMA_FSETH(hDma, SECCTL,   LASTIE,   DMA_SECCTL_LASTIE_DEFAULT);
    DMA_FSETH(hDma, SECCTL, LASTCOND, DMA_SECCTL_LASTCOND_DEFAULT);
	DMA_FSETH(hDma, SECCTL,  FRAMEIE,  DMA_SECCTL_FRAMEIE_DEFAULT);
    DMA_FSETH(hDma, SECCTL,FRAMECOND,DMA_SECCTL_FRAMECOND_DEFAULT);
	DMA_FSETH(hDma, SECCTL,     SXIE,     DMA_SECCTL_SXIE_DEFAULT);
    DMA_FSETH(hDma, SECCTL,   SXCOND,   DMA_SECCTL_SXCOND_DEFAULT);

    DMA_FSETH(hDma,    SRC,      SRC,         DMA_SRC_SRC_DEFAULT);
    DMA_FSETH(hDma,    DST,      DST,         DMA_DST_DST_DEFAULT);
    DMA_FSETH(hDma, XFRCNT,   FRMCNT,   DMA_XFRCNT_FRMCNT_DEFAULT);
    DMA_FSETH(hDma, XFRCNT,   ELECNT,   DMA_XFRCNT_ELECNT_DEFAULT);

/*  Test FSETH Macro end */
/*  Test FSETSH Macro start */
    DMA_FSETSH(hDma, PRICTL,   DSTRLD,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,   SRCRLD,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,     EMOD,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,       FS,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,    TCINT,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,      PRI,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,    WSYNC,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,    RSYNC,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,    INDEX,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,   CNTRLD,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,    SPLIT,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,    ESIZE,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,   DSTDIR,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,   SRCDIR,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,   STATUS,DEFAULT);
    DMA_FSETSH(hDma, PRICTL,    START,DEFAULT);

#if _DMA_COND1    
	DMA_FSETSH(hDma, SECCTL,    WSPOL,DEFAULT);
    DMA_FSETSH(hDma, SECCTL,    RSPOL,DEFAULT);
	DMA_FSETSH(hDma, SECCTL,     FSIG,DEFAULT);
#endif
    DMA_FSETSH(hDma, SECCTL,   DMACEN,DEFAULT);
	DMA_FSETSH(hDma, SECCTL, WSYNCCLR,DEFAULT);
    DMA_FSETSH(hDma, SECCTL,WSYNCSTAT,DEFAULT);
	DMA_FSETSH(hDma, SECCTL, RSYNCCLR,DEFAULT);
    DMA_FSETSH(hDma, SECCTL,RSYNCSTAT,DEFAULT);
	DMA_FSETSH(hDma, SECCTL,  WDROPIE,DEFAULT);
    DMA_FSETSH(hDma, SECCTL,WDROPCOND,DEFAULT);
	DMA_FSETSH(hDma, SECCTL,  RDROPIE,DEFAULT);
    DMA_FSETSH(hDma, SECCTL,RDROPCOND,DEFAULT);
	DMA_FSETSH(hDma, SECCTL,  BLOCKIE,DEFAULT);
    DMA_FSETSH(hDma, SECCTL,BLOCKCOND,DEFAULT);
	DMA_FSETSH(hDma, SECCTL,   LASTIE,DEFAULT);
    DMA_FSETSH(hDma, SECCTL, LASTCOND,DEFAULT);
	DMA_FSETSH(hDma, SECCTL,  FRAMEIE,DEFAULT);
    DMA_FSETSH(hDma, SECCTL,FRAMECOND,DEFAULT);
	DMA_FSETSH(hDma, SECCTL,     SXIE,DEFAULT);
    DMA_FSETSH(hDma, SECCTL,   SXCOND,DEFAULT);

    DMA_FSETSH(hDma,    SRC,      SRC,DEFAULT);
    DMA_FSETSH(hDma,    DST,      DST,DEFAULT);
    DMA_FSETSH(hDma, XFRCNT,   FRMCNT,DEFAULT);
    DMA_FSETSH(hDma, XFRCNT,   ELECNT,DEFAULT);

/*  Test FSETSH Macro end */

  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_edma(int arg) {

  #if (EDMA_SUPPORT&&EDMA_BUILD)
    EDMA_Handle hEdma;
    EDMA_Handle tables[16];

    EDMA_allocTableEx(16,tables);
    EDMA_freeTableEx(16,tables);

    hEdma = EDMA_open(EDMA_CHA_TINT0,0);

    EDMA_FSETS(QSRC,SRC,OF(x));

    x = EDMA_RGET(QSRC);
    x = EDMA_FGET(QSRC,SRC);
    EDMA_RSET(QSRC,EDMA_SRC_DEFAULT);
    EDMA_FSET(QSRC,SRC,0);
    x = EDMA_RGET(QSSRC);
    x = EDMA_FGET(QSSRC,SRC);
    EDMA_RSET(QSSRC,EDMA_SRC_DEFAULT);
    EDMA_FSET(QSSRC,SRC,0);

    x = EDMA_RGETH(hEdma,OPT);
    EDMA_RSETH(hEdma,OPT,0);
    EDMA_FSETH(hEdma,OPT,PRI,0);
    EDMA_FSETSH(hEdma,OPT,PRI,HIGH);

    EDMA_qdmaConfigArgs(0,0,0,0,0);

/*  Test FMK Macro start */
    x = EDMA_FMK(    OPT,   PRI,0XFFFFFFFF);
    x = EDMA_FMK(    OPT, ESIZE,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,   2DS,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,   SUM,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,   2DD,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,   DUM,0xFFFFFFFF);
    x = EDMA_FMK(    OPT, TCINT,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,   TCC,0xFFFFFFFF);
#if (CHIP_6400)
    x = EDMA_FMK(    OPT,ATCINT,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,  ATCC,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,  PDTS,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,  PDTD,0xFFFFFFFF);
#endif
    x = EDMA_FMK(    OPT,  LINK,0xFFFFFFFF);
    x = EDMA_FMK(    OPT,    FS,0xFFFFFFFF);

    x = EDMA_FMK(    SRC,   SRC,0xFFFFFFFF);
    x = EDMA_FMK(    CNT,FRMCNT,0xFFFFFFFF);
    x = EDMA_FMK(    CNT,ELECNT,0xFFFFFFFF);
    x = EDMA_FMK(    DST,   DST,0xFFFFFFFF);
    x = EDMA_FMK(    IDX,FRMIDX,0xFFFFFFFF);
    x = EDMA_FMK(    IDX,ELEIDX,0xFFFFFFFF);
    x = EDMA_FMK(    RLD,ELERLD,0xFFFFFFFF);
    x = EDMA_FMK(    RLD,  LINK,0xFFFFFFFF);
    x = EDMA_FMK(   PQSR,    PQ,0xFFFFFFFF);
    x = EDMA_FMK(   CIPR,   CIP,0xFFFFFFFF);
    x = EDMA_FMK(   CIER,   CIE,0xFFFFFFFF);
    x = EDMA_FMK(   CCER,   CCE,0xFFFFFFFF);
    x = EDMA_FMK(     ER,   EVT,0xFFFFFFFF);
    x = EDMA_FMK(    EER,    EE,0xFFFFFFFF);
    x = EDMA_FMK(    ECR,    EC,0xFFFFFFFF);
    x = EDMA_FMK(    ESR,    ES,0xFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = EDMA_FMKS(    OPT,   PRI,DEFAULT);
    x = EDMA_FMKS(    OPT, ESIZE,DEFAULT);
    x = EDMA_FMKS(    OPT,   2DS,DEFAULT);
    x = EDMA_FMKS(    OPT,   SUM,DEFAULT);
    x = EDMA_FMKS(    OPT,   2DD,DEFAULT);
    x = EDMA_FMKS(    OPT,   DUM,DEFAULT);
    x = EDMA_FMKS(    OPT, TCINT,DEFAULT);
    x = EDMA_FMKS(    OPT,   TCC,DEFAULT);
#if (CHIP_6400)
    x = EDMA_FMKS(    OPT,ATCINT,DEFAULT);
    x = EDMA_FMKS(    OPT,  ATCC,DEFAULT);
    x = EDMA_FMKS(    OPT,  PDTS,DEFAULT);
    x = EDMA_FMKS(    OPT,  PDTD,DEFAULT);
#endif
    x = EDMA_FMKS(    OPT,  LINK,DEFAULT);
    x = EDMA_FMKS(    OPT,    FS,DEFAULT);

    x = EDMA_FMKS(    SRC,   SRC,DEFAULT);
    x = EDMA_FMKS(    CNT,FRMCNT,DEFAULT);
    x = EDMA_FMKS(    CNT,ELECNT,DEFAULT);
    x = EDMA_FMKS(    DST,   DST,DEFAULT);
    x = EDMA_FMKS(    IDX,FRMIDX,DEFAULT);
    x = EDMA_FMKS(    IDX,ELEIDX,DEFAULT);
    x = EDMA_FMKS(    RLD,ELERLD,DEFAULT);
    x = EDMA_FMKS(    RLD,  LINK,DEFAULT);
    x = EDMA_FMKS(   PQSR,    PQ,DEFAULT);
    x = EDMA_FMKS(   CIPR,   CIP,DEFAULT);
    x = EDMA_FMKS(   CIER,   CIE,DEFAULT);
    x = EDMA_FMKS(   CCER,   CCE,DEFAULT);
    x = EDMA_FMKS(     ER,   EVT,DEFAULT);
    x = EDMA_FMKS(    EER,    EE,DEFAULT);
    x = EDMA_FMKS(    ECR,    EC,DEFAULT);
    x = EDMA_FMKS(    ESR,    ES,DEFAULT);

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = EDMA_ADDR(   QOPT);
    x = EDMA_ADDR(   QSRC);
    x = EDMA_ADDR(   QCNT);
    x = EDMA_ADDR(   QDST);
    x = EDMA_ADDR(   QIDX);
    x = EDMA_ADDR(   QRLD);

    x = EDMA_ADDR(  QSOPT);
    x = EDMA_ADDR(  QSSRC);
    x = EDMA_ADDR(  QSCNT);
    x = EDMA_ADDR(  QSDST);
    x = EDMA_ADDR(  QSIDX);
    x = EDMA_ADDR(  QSRLD);

    x = EDMA_ADDR(   PQSR);
    x = EDMA_ADDR(   CIPR);
    x = EDMA_ADDR(   CIER);
    x = EDMA_ADDR(   CCER);
    x = EDMA_ADDR(     ER);
    x = EDMA_ADDR(    EER);
    x = EDMA_ADDR(    ECR);
    x = EDMA_ADDR(    ESR);
        
/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = EDMA_RGET(   QOPT);
    x = EDMA_RGET(   QSRC);
    x = EDMA_RGET(   QCNT);
    x = EDMA_RGET(   QDST);
    x = EDMA_RGET(   QIDX);
    x = EDMA_RGET(   QRLD);

    x = EDMA_RGET(  QSOPT);
    x = EDMA_RGET(  QSSRC);
    x = EDMA_RGET(  QSCNT);
    x = EDMA_RGET(  QSDST);
    x = EDMA_RGET(  QSIDX);
    x = EDMA_RGET(  QSRLD);

    x = EDMA_RGET(   PQSR);
    x = EDMA_RGET(   CIPR);
    x = EDMA_RGET(   CIER);
    x = EDMA_RGET(   CCER);
    x = EDMA_RGET(     ER);
    x = EDMA_RGET(    EER);
    x = EDMA_RGET(    ECR);
    x = EDMA_RGET(    ESR);

/*  Test RGET Macro end */
/*  Test RSET Macro start */
    EDMA_RSET(   QOPT,  EDMA_OPT_DEFAULT);
    EDMA_RSET(   QSRC,  EDMA_SRC_DEFAULT);
    EDMA_RSET(   QCNT,  EDMA_CNT_DEFAULT);
    EDMA_RSET(   QDST,  EDMA_DST_DEFAULT);
    EDMA_RSET(   QIDX,  EDMA_IDX_DEFAULT);
    EDMA_RSET(   QRLD,  EDMA_RLD_DEFAULT);

    EDMA_RSET(  QSOPT,  EDMA_OPT_DEFAULT);
    EDMA_RSET(  QSSRC,  EDMA_SRC_DEFAULT);
    EDMA_RSET(  QSCNT,  EDMA_CNT_DEFAULT);
    EDMA_RSET(  QSDST,  EDMA_DST_DEFAULT);
    EDMA_RSET(  QSIDX,  EDMA_IDX_DEFAULT);
    EDMA_RSET(  QSRLD,  EDMA_RLD_DEFAULT);

    EDMA_RSET(   PQSR, EDMA_PQSR_DEFAULT);
    EDMA_RSET(   CIPR, EDMA_CIPR_DEFAULT);
    EDMA_RSET(   CIER, EDMA_CIER_DEFAULT);
    EDMA_RSET(   CCER, EDMA_CCER_DEFAULT);
    EDMA_RSET(     ER,   EDMA_ER_DEFAULT);
    EDMA_RSET(    EER,  EDMA_EER_DEFAULT);
    EDMA_RSET(    ECR,  EDMA_ECR_DEFAULT);
    EDMA_RSET(    ESR,  EDMA_ESR_DEFAULT);

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = EDMA_FGET(    QOPT,   PRI);
    x = EDMA_FGET(    QOPT, ESIZE);
    x = EDMA_FGET(    QOPT,   2DS);
    x = EDMA_FGET(    QOPT,   SUM);
    x = EDMA_FGET(    QOPT,   2DD);
    x = EDMA_FGET(    QOPT,   DUM);
    x = EDMA_FGET(    QOPT, TCINT);
    x = EDMA_FGET(    QOPT,   TCC);
#if (CHIP_6400)
    x = EDMA_FGET(    QOPT,ATCINT);
    x = EDMA_FGET(    QOPT,  ATCC);
    x = EDMA_FGET(    QOPT,  PDTS);
    x = EDMA_FGET(    QOPT,  PDTD);
#endif
    x = EDMA_FGET(    QOPT,  LINK);
    x = EDMA_FGET(    QOPT,    FS);
    x = EDMA_FGET(    QSRC,   SRC);
    x = EDMA_FGET(    QCNT,FRMCNT);
    x = EDMA_FGET(    QCNT,ELECNT);
    x = EDMA_FGET(    QDST,   DST);
    x = EDMA_FGET(    QIDX,FRMIDX);
    x = EDMA_FGET(    QIDX,ELEIDX);
    x = EDMA_FGET(    QRLD,ELERLD);
    x = EDMA_FGET(    QRLD,  LINK);

    x = EDMA_FGET(   QSOPT,   PRI);
    x = EDMA_FGET(   QSOPT, ESIZE);
    x = EDMA_FGET(   QSOPT,   2DS);
    x = EDMA_FGET(   QSOPT,   SUM);
    x = EDMA_FGET(   QSOPT,   2DD);
    x = EDMA_FGET(   QSOPT,   DUM);
    x = EDMA_FGET(   QSOPT, TCINT);
    x = EDMA_FGET(   QSOPT,   TCC);
#if (CHIP_6400)
    x = EDMA_FGET(   QSOPT,ATCINT);
    x = EDMA_FGET(   QSOPT,  ATCC);
    x = EDMA_FGET(   QSOPT,  PDTS);
    x = EDMA_FGET(   QSOPT,  PDTD);
#endif
    x = EDMA_FGET(   QSOPT,  LINK);
    x = EDMA_FGET(   QSOPT,    FS);
    x = EDMA_FGET(   QSSRC,   SRC);
    x = EDMA_FGET(   QSCNT,FRMCNT);
    x = EDMA_FGET(   QSCNT,ELECNT);
    x = EDMA_FGET(   QSDST,   DST);
    x = EDMA_FGET(   QSIDX,FRMIDX);
    x = EDMA_FGET(   QSIDX,ELEIDX);
    x = EDMA_FGET(   QSRLD,ELERLD);
    x = EDMA_FGET(   QSRLD,  LINK);

    x = EDMA_FGET(   PQSR,    PQ);
    x = EDMA_FGET(   CIPR,   CIP);
    x = EDMA_FGET(   CIER,   CIE);
    x = EDMA_FGET(   CCER,   CCE);
    x = EDMA_FGET(     ER,   EVT);
    x = EDMA_FGET(    EER,    EE);
    x = EDMA_FGET(    ECR,    EC);
    x = EDMA_FGET(    ESR,    ES);

/*  Test FGET Macro end */
/*  Test FSET Macro start */
    EDMA_FSET(    QOPT,   PRI,   EDMA_OPT_PRI_DEFAULT);
    EDMA_FSET(    QOPT, ESIZE, EDMA_OPT_ESIZE_DEFAULT);
    EDMA_FSET(    QOPT,   2DS,   EDMA_OPT_2DS_DEFAULT);
    EDMA_FSET(    QOPT,   SUM,   EDMA_OPT_SUM_DEFAULT);
    EDMA_FSET(    QOPT,   2DD,   EDMA_OPT_2DD_DEFAULT);
    EDMA_FSET(    QOPT,   DUM,   EDMA_OPT_DUM_DEFAULT);
    EDMA_FSET(    QOPT, TCINT, EDMA_OPT_TCINT_DEFAULT);
    EDMA_FSET(    QOPT,   TCC,   EDMA_OPT_TCC_DEFAULT);
#if (CHIP_6400)
    EDMA_FSET(    QOPT,ATCINT,EDMA_OPT_ATCINT_DEFAULT);
    EDMA_FSET(    QOPT,  ATCC,  EDMA_OPT_ATCC_DEFAULT);
    EDMA_FSET(    QOPT,  PDTS,  EDMA_OPT_PDTS_DEFAULT);
    EDMA_FSET(    QOPT,  PDTD,  EDMA_OPT_PDTD_DEFAULT);
#endif
    EDMA_FSET(    QOPT,  LINK,  EDMA_OPT_LINK_DEFAULT);
    EDMA_FSET(    QOPT,    FS,    EDMA_OPT_FS_DEFAULT);
    EDMA_FSET(    QSRC,   SRC,   EDMA_SRC_SRC_DEFAULT);
    EDMA_FSET(    QCNT,FRMCNT,EDMA_CNT_FRMCNT_DEFAULT);
    EDMA_FSET(    QCNT,ELECNT,EDMA_CNT_ELECNT_DEFAULT);
    EDMA_FSET(    QDST,   DST,   EDMA_DST_DST_DEFAULT);
    EDMA_FSET(    QIDX,FRMIDX,EDMA_IDX_FRMIDX_DEFAULT);
    EDMA_FSET(    QIDX,ELEIDX,EDMA_IDX_ELEIDX_DEFAULT);
    EDMA_FSET(    QRLD,ELERLD,EDMA_RLD_ELERLD_DEFAULT);
    EDMA_FSET(    QRLD,  LINK,  EDMA_RLD_LINK_DEFAULT);

    EDMA_FSET(   QSOPT,   PRI,   EDMA_OPT_PRI_DEFAULT);
    EDMA_FSET(   QSOPT, ESIZE, EDMA_OPT_ESIZE_DEFAULT);
    EDMA_FSET(   QSOPT,   2DS,   EDMA_OPT_2DS_DEFAULT);
    EDMA_FSET(   QSOPT,   SUM,   EDMA_OPT_SUM_DEFAULT);
    EDMA_FSET(   QSOPT,   2DD,   EDMA_OPT_2DD_DEFAULT);
    EDMA_FSET(   QSOPT,   DUM,   EDMA_OPT_DUM_DEFAULT);
    EDMA_FSET(   QSOPT, TCINT, EDMA_OPT_TCINT_DEFAULT);
    EDMA_FSET(   QSOPT,   TCC,   EDMA_OPT_TCC_DEFAULT);
#if (CHIP_6400)
    EDMA_FSET(   QSOPT,ATCINT,EDMA_OPT_ATCINT_DEFAULT);
    EDMA_FSET(   QSOPT,  ATCC,  EDMA_OPT_ATCC_DEFAULT);
    EDMA_FSET(   QSOPT,  PDTS,  EDMA_OPT_PDTS_DEFAULT);
    EDMA_FSET(   QSOPT,  PDTD,  EDMA_OPT_PDTD_DEFAULT);
#endif
    EDMA_FSET(   QSOPT,  LINK,  EDMA_OPT_LINK_DEFAULT);
    EDMA_FSET(   QSOPT,    FS,    EDMA_OPT_FS_DEFAULT);
    EDMA_FSET(   QSSRC,   SRC,   EDMA_SRC_SRC_DEFAULT);
    EDMA_FSET(   QSCNT,FRMCNT,EDMA_CNT_FRMCNT_DEFAULT);
    EDMA_FSET(   QSCNT,ELECNT,EDMA_CNT_ELECNT_DEFAULT);
    EDMA_FSET(   QSDST,   DST,   EDMA_DST_DST_DEFAULT);
    EDMA_FSET(   QSIDX,FRMIDX,EDMA_IDX_FRMIDX_DEFAULT);
    EDMA_FSET(   QSIDX,ELEIDX,EDMA_IDX_ELEIDX_DEFAULT);
    EDMA_FSET(   QSRLD,ELERLD,EDMA_RLD_ELERLD_DEFAULT);
    EDMA_FSET(   QSRLD,  LINK,  EDMA_RLD_LINK_DEFAULT);  

    EDMA_FSET(    PQSR,    PQ,   EDMA_PQSR_PQ_DEFAULT);
    EDMA_FSET(    CIPR,   CIP,  EDMA_CIPR_CIP_DEFAULT);
    EDMA_FSET(    CIER,   CIE,  EDMA_CIER_CIE_DEFAULT);
    EDMA_FSET(    CCER,   CCE,  EDMA_CCER_CCE_DEFAULT);
    EDMA_FSET(      ER,   EVT,    EDMA_ER_EVT_DEFAULT);
    EDMA_FSET(     EER,    EE,    EDMA_EER_EE_DEFAULT);
    EDMA_FSET(     ECR,    EC,    EDMA_ECR_EC_DEFAULT);
    EDMA_FSET(     ESR,    ES,    EDMA_ESR_ES_DEFAULT);

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    EDMA_FSETS(    QOPT,   PRI,DEFAULT);
    EDMA_FSETS(    QOPT, ESIZE,DEFAULT);
    EDMA_FSETS(    QOPT,   2DS,DEFAULT);
    EDMA_FSETS(    QOPT,   SUM,DEFAULT);
    EDMA_FSETS(    QOPT,   2DD,DEFAULT);
    EDMA_FSETS(    QOPT,   DUM,DEFAULT);
    EDMA_FSETS(    QOPT, TCINT,DEFAULT);
    EDMA_FSETS(    QOPT,   TCC,DEFAULT);
#if (CHIP_6400)
    EDMA_FSETS(    QOPT,ATCINT,DEFAULT);
    EDMA_FSETS(    QOPT,  ATCC,DEFAULT);
    EDMA_FSETS(    QOPT,  PDTS,DEFAULT);
    EDMA_FSETS(    QOPT,  PDTD,DEFAULT);
#endif
    EDMA_FSETS(    QOPT,  LINK,DEFAULT);
    EDMA_FSETS(    QOPT,    FS,DEFAULT);
    EDMA_FSETS(    QSRC,   SRC,DEFAULT);
    EDMA_FSETS(    QCNT,FRMCNT,DEFAULT);
    EDMA_FSETS(    QCNT,ELECNT,DEFAULT);
    EDMA_FSETS(    QDST,   DST,DEFAULT);
    EDMA_FSETS(    QIDX,FRMIDX,DEFAULT);
    EDMA_FSETS(    QIDX,ELEIDX,DEFAULT);
    EDMA_FSETS(    QRLD,ELERLD,DEFAULT);
    EDMA_FSETS(    QRLD,  LINK,DEFAULT);

    EDMA_FSETS(   QSOPT,   PRI,DEFAULT);
    EDMA_FSETS(   QSOPT, ESIZE,DEFAULT);
    EDMA_FSETS(   QSOPT,   2DS,DEFAULT);
    EDMA_FSETS(   QSOPT,   SUM,DEFAULT);
    EDMA_FSETS(   QSOPT,   2DD,DEFAULT);
    EDMA_FSETS(   QSOPT,   DUM,DEFAULT);
    EDMA_FSETS(   QSOPT, TCINT,DEFAULT);
    EDMA_FSETS(   QSOPT,   TCC,DEFAULT);
#if (CHIP_6400)
    EDMA_FSETS(   QSOPT,ATCINT,DEFAULT);
    EDMA_FSETS(   QSOPT,  ATCC,DEFAULT);
    EDMA_FSETS(   QSOPT,  PDTS,DEFAULT);
    EDMA_FSETS(   QSOPT,  PDTD,DEFAULT);
#endif
    EDMA_FSETS(   QSOPT,  LINK,DEFAULT);
    EDMA_FSETS(   QSOPT,    FS,DEFAULT);
    EDMA_FSETS(   QSSRC,   SRC,DEFAULT);
    EDMA_FSETS(   QSCNT,FRMCNT,DEFAULT);
    EDMA_FSETS(   QSCNT,ELECNT,DEFAULT);
    EDMA_FSETS(   QSDST,   DST,DEFAULT);
    EDMA_FSETS(   QSIDX,FRMIDX,DEFAULT);
    EDMA_FSETS(   QSIDX,ELEIDX,DEFAULT);
    EDMA_FSETS(   QSRLD,ELERLD,DEFAULT);
    EDMA_FSETS(   QSRLD,  LINK,DEFAULT);  

    EDMA_FSETS(    PQSR,    PQ,DEFAULT);
    EDMA_FSETS(    CIPR,   CIP,DEFAULT);
    EDMA_FSETS(    CIER,   CIE,DEFAULT);
    EDMA_FSETS(    CCER,   CCE,DEFAULT);
    EDMA_FSETS(      ER,   EVT,DEFAULT);
    EDMA_FSETS(     EER,    EE,DEFAULT);
    EDMA_FSETS(     ECR,    EC,DEFAULT);
    EDMA_FSETS(     ESR,    ES,DEFAULT);

/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = EDMA_RGETA(0,    QOPT);
    x = EDMA_RGETA(0,    QSRC);
    x = EDMA_RGETA(0,    QCNT);
    x = EDMA_RGETA(0,    QDST);
    x = EDMA_RGETA(0,    QIDX);
    x = EDMA_RGETA(0,    QRLD);

    x = EDMA_RGETA(0,   QSOPT);
    x = EDMA_RGETA(0,   QSSRC);
    x = EDMA_RGETA(0,   QSCNT);
    x = EDMA_RGETA(0,   QSDST);
    x = EDMA_RGETA(0,   QSIDX);
    x = EDMA_RGETA(0,   QSRLD);

    x = EDMA_RGETA(0,    PQSR);
    x = EDMA_RGETA(0,    CIPR);
    x = EDMA_RGETA(0,    CIER);
    x = EDMA_RGETA(0,    CCER);
    x = EDMA_RGETA(0,      ER);
    x = EDMA_RGETA(0,     EER);
    x = EDMA_RGETA(0,     ECR);
    x = EDMA_RGETA(0,     ESR);

/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    EDMA_RSETA(0,    QOPT,0);
    EDMA_RSETA(0,    QSRC,0);
    EDMA_RSETA(0,    QCNT,0);
    EDMA_RSETA(0,    QDST,0);
    EDMA_RSETA(0,    QIDX,0);
    EDMA_RSETA(0,    QRLD,0);

    EDMA_RSETA(0,   QSOPT,0);
    EDMA_RSETA(0,   QSSRC,0);
    EDMA_RSETA(0,   QSCNT,0);
    EDMA_RSETA(0,   QSDST,0);
    EDMA_RSETA(0,   QSIDX,0);
    EDMA_RSETA(0,   QSRLD,0);

    EDMA_RSETA(0,    PQSR,0);
    EDMA_RSETA(0,    CIPR,0);
    EDMA_RSETA(0,    CIER,0);
    EDMA_RSETA(0,    CCER,0);
    EDMA_RSETA(0,      ER,0);
    EDMA_RSETA(0,     EER,0);
    EDMA_RSETA(0,     ECR,0);
    EDMA_RSETA(0,     ESR,0);

/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = EDMA_FGETA(0,     OPT,   PRI);
    x = EDMA_FGETA(0,     OPT, ESIZE);
    x = EDMA_FGETA(0,     OPT,   2DS);
    x = EDMA_FGETA(0,     OPT,   SUM);
    x = EDMA_FGETA(0,     OPT,   2DD);
    x = EDMA_FGETA(0,     OPT,   DUM);
    x = EDMA_FGETA(0,     OPT, TCINT);
    x = EDMA_FGETA(0,     OPT,   TCC);
#if (CHIP_6400)
	x = EDMA_FGETA(0,     OPT,ATCINT);
    x = EDMA_FGETA(0,     OPT,  ATCC);
    x = EDMA_FGETA(0,     OPT,  PDTS);
    x = EDMA_FGETA(0,     OPT,  PDTD);
#endif
    x = EDMA_FGETA(0,     OPT,  LINK);
    x = EDMA_FGETA(0,     OPT,    FS);
    x = EDMA_FGETA(0,     SRC,   SRC);
    x = EDMA_FGETA(0,     CNT,FRMCNT);
    x = EDMA_FGETA(0,     CNT,ELECNT);
    x = EDMA_FGETA(0,     DST,   DST);
    x = EDMA_FGETA(0,     IDX,FRMIDX);
    x = EDMA_FGETA(0,     IDX,ELEIDX);
    x = EDMA_FGETA(0,     RLD,ELERLD);
    x = EDMA_FGETA(0,     RLD,  LINK);

    x = EDMA_FGETA(0,    PQSR,    PQ);
    x = EDMA_FGETA(0,    CIPR,   CIP);
    x = EDMA_FGETA(0,    CIER,   CIE);
    x = EDMA_FGETA(0,    CCER,   CCE);
    x = EDMA_FGETA(0,      ER,   EVT);
    x = EDMA_FGETA(0,     EER,    EE);
    x = EDMA_FGETA(0,     ECR,    EC);
    x = EDMA_FGETA(0,     ESR,    ES);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    EDMA_FSETA(0,     OPT,   PRI,   EDMA_OPT_PRI_DEFAULT);
    EDMA_FSETA(0,     OPT, ESIZE, EDMA_OPT_ESIZE_DEFAULT);
    EDMA_FSETA(0,     OPT,   2DS,   EDMA_OPT_2DS_DEFAULT);
    EDMA_FSETA(0,     OPT,   SUM,   EDMA_OPT_SUM_DEFAULT);
    EDMA_FSETA(0,     OPT,   2DD,   EDMA_OPT_2DD_DEFAULT);
    EDMA_FSETA(0,     OPT,   DUM,   EDMA_OPT_DUM_DEFAULT);
    EDMA_FSETA(0,     OPT, TCINT, EDMA_OPT_TCINT_DEFAULT);
    EDMA_FSETA(0,     OPT,   TCC,   EDMA_OPT_TCC_DEFAULT);
#if (CHIP_6400)
	EDMA_FSETA(0,     OPT,ATCINT,EDMA_OPT_ATCINT_DEFAULT);
    EDMA_FSETA(0,     OPT,  ATCC,  EDMA_OPT_ATCC_DEFAULT);
    EDMA_FSETA(0,     OPT,  PDTS,  EDMA_OPT_PDTS_DEFAULT);
    EDMA_FSETA(0,     OPT,  PDTD,  EDMA_OPT_PDTD_DEFAULT);
#endif
    EDMA_FSETA(0,     OPT,  LINK,  EDMA_OPT_LINK_DEFAULT);
    EDMA_FSETA(0,     OPT,    FS,    EDMA_OPT_FS_DEFAULT);
    EDMA_FSETA(0,     SRC,   SRC,   EDMA_SRC_SRC_DEFAULT);
    EDMA_FSETA(0,     CNT,FRMCNT,EDMA_CNT_FRMCNT_DEFAULT);
    EDMA_FSETA(0,     CNT,ELECNT,EDMA_CNT_ELECNT_DEFAULT);
    EDMA_FSETA(0,     DST,   DST,   EDMA_DST_DST_DEFAULT);
    EDMA_FSETA(0,     IDX,FRMIDX,EDMA_IDX_FRMIDX_DEFAULT);
    EDMA_FSETA(0,     IDX,ELEIDX,EDMA_IDX_ELEIDX_DEFAULT);
    EDMA_FSETA(0,     RLD,ELERLD,EDMA_RLD_ELERLD_DEFAULT);
    EDMA_FSETA(0,     RLD,  LINK,  EDMA_RLD_LINK_DEFAULT);

    EDMA_FSETA(0,    PQSR,    PQ,   EDMA_PQSR_PQ_DEFAULT);
    EDMA_FSETA(0,    CIPR,   CIP,  EDMA_CIPR_CIP_DEFAULT);
    EDMA_FSETA(0,    CIER,   CIE,  EDMA_CIER_CIE_DEFAULT);
    EDMA_FSETA(0,    CCER,   CCE,  EDMA_CCER_CCE_DEFAULT);
    EDMA_FSETA(0,      ER,   EVT,    EDMA_ER_EVT_DEFAULT);
    EDMA_FSETA(0,     EER,    EE,    EDMA_EER_EE_DEFAULT);
    EDMA_FSETA(0,     ECR,    EC,    EDMA_ECR_EC_DEFAULT);
    EDMA_FSETA(0,     ESR,    ES,    EDMA_ESR_ES_DEFAULT);

/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    EDMA_FSETSA(0,     OPT,   PRI,DEFAULT);
    EDMA_FSETSA(0,     OPT, ESIZE,DEFAULT);
    EDMA_FSETSA(0,     OPT,   2DS,DEFAULT);
    EDMA_FSETSA(0,     OPT,   SUM,DEFAULT);
    EDMA_FSETSA(0,     OPT,   2DD,DEFAULT);
    EDMA_FSETSA(0,     OPT,   DUM,DEFAULT);
    EDMA_FSETSA(0,     OPT, TCINT,DEFAULT);
    EDMA_FSETSA(0,     OPT,   TCC,DEFAULT);
#if (CHIP_6400)
	EDMA_FSETSA(0,     OPT,ATCINT,DEFAULT);
    EDMA_FSETSA(0,     OPT,  ATCC,DEFAULT);
    EDMA_FSETSA(0,     OPT,  PDTS,DEFAULT);
    EDMA_FSETSA(0,     OPT,  PDTD,DEFAULT);
#endif
    EDMA_FSETSA(0,     OPT,  LINK,DEFAULT);
    EDMA_FSETSA(0,     OPT,    FS,DEFAULT);
    EDMA_FSETSA(0,     SRC,   SRC,DEFAULT);
    EDMA_FSETSA(0,     CNT,FRMCNT,DEFAULT);
    EDMA_FSETSA(0,     CNT,ELECNT,DEFAULT);
    EDMA_FSETSA(0,     DST,   DST,DEFAULT);
    EDMA_FSETSA(0,     IDX,FRMIDX,DEFAULT);
    EDMA_FSETSA(0,     IDX,ELEIDX,DEFAULT);
    EDMA_FSETSA(0,     RLD,ELERLD,DEFAULT);
    EDMA_FSETSA(0,     RLD,  LINK,DEFAULT);

    EDMA_FSETSA(0,    PQSR,    PQ,DEFAULT);
    EDMA_FSETSA(0,    CIPR,   CIP,DEFAULT);
    EDMA_FSETSA(0,    CIER,   CIE,DEFAULT);
    EDMA_FSETSA(0,    CCER,   CCE,DEFAULT);
    EDMA_FSETSA(0,      ER,   EVT,DEFAULT);
    EDMA_FSETSA(0,     EER,    EE,DEFAULT);
    EDMA_FSETSA(0,     ECR,    EC,DEFAULT);
    EDMA_FSETSA(0,     ESR,    ES,DEFAULT);

/*  Test FSETSA Macro end */
/*  Test ADDRH Macro start */
    x = EDMA_ADDRH(hEdma,   QOPT);
    x = EDMA_ADDRH(hEdma,   QSRC);
    x = EDMA_ADDRH(hEdma,   QCNT);
    x = EDMA_ADDRH(hEdma,   QDST);
    x = EDMA_ADDRH(hEdma,   QIDX);
    x = EDMA_ADDRH(hEdma,   QRLD);

    x = EDMA_ADDRH(hEdma,  QSOPT);
    x = EDMA_ADDRH(hEdma,  QSSRC);
    x = EDMA_ADDRH(hEdma,  QSCNT);
    x = EDMA_ADDRH(hEdma,  QSDST);
    x = EDMA_ADDRH(hEdma,  QSIDX);
    x = EDMA_ADDRH(hEdma,  QSRLD);

/*  Test ADDRH Macro end */
/*  Test RGETH Macro start */
    x = EDMA_RGETH(hEdma,   QOPT);
    x = EDMA_RGETH(hEdma,   QSRC);
    x = EDMA_RGETH(hEdma,   QCNT);
    x = EDMA_RGETH(hEdma,   QDST);
    x = EDMA_RGETH(hEdma,   QIDX);
    x = EDMA_RGETH(hEdma,   QRLD);

    x = EDMA_RGETH(hEdma,  QSOPT);
    x = EDMA_RGETH(hEdma,  QSSRC);
    x = EDMA_RGETH(hEdma,  QSCNT);
    x = EDMA_RGETH(hEdma,  QSDST);
    x = EDMA_RGETH(hEdma,  QSIDX);
    x = EDMA_RGETH(hEdma,  QSRLD);

/*  Test RGETH Macro end */
/*  Test RSETH Macro start */
    EDMA_RSETH(hEdma,   QOPT,  EDMA_OPT_DEFAULT);
    EDMA_RSETH(hEdma,   QSRC,  EDMA_SRC_DEFAULT);
    EDMA_RSETH(hEdma,   QCNT,  EDMA_CNT_DEFAULT);
    EDMA_RSETH(hEdma,   QDST,  EDMA_DST_DEFAULT);
    EDMA_RSETH(hEdma,   QIDX,  EDMA_IDX_DEFAULT);
    EDMA_RSETH(hEdma,   QRLD,  EDMA_RLD_DEFAULT);

    EDMA_RSETH(hEdma,  QSOPT,  EDMA_OPT_DEFAULT);
    EDMA_RSETH(hEdma,  QSSRC,  EDMA_SRC_DEFAULT);
    EDMA_RSETH(hEdma,  QSCNT,  EDMA_CNT_DEFAULT);
    EDMA_RSETH(hEdma,  QSDST,  EDMA_DST_DEFAULT);
    EDMA_RSETH(hEdma,  QSIDX,  EDMA_IDX_DEFAULT);
    EDMA_RSETH(hEdma,  QSRLD,  EDMA_RLD_DEFAULT);

/*  Test RSETH Macro end */
/*  Test FGETH Macro start */
    x = EDMA_FGETH(hEdma,   OPT,   PRI);
    x = EDMA_FGETH(hEdma,   OPT, ESIZE);
    x = EDMA_FGETH(hEdma,   OPT,   2DS);
    x = EDMA_FGETH(hEdma,   OPT,   SUM);
    x = EDMA_FGETH(hEdma,   OPT,   2DD);
    x = EDMA_FGETH(hEdma,   OPT,   DUM);
    x = EDMA_FGETH(hEdma,   OPT, TCINT);
    x = EDMA_FGETH(hEdma,   OPT,   TCC);
#if (CHIP_6400)
    x = EDMA_FGETH(hEdma,   OPT,ATCINT);
    x = EDMA_FGETH(hEdma,   OPT,  ATCC);
    x = EDMA_FGETH(hEdma,   OPT,  PDTS);
    x = EDMA_FGETH(hEdma,   OPT,  PDTD);
#endif
    x = EDMA_FGETH(hEdma,   OPT,  LINK);
    x = EDMA_FGETH(hEdma,   OPT,    FS);
    x = EDMA_FGETH(hEdma,   SRC,   SRC);
    x = EDMA_FGETH(hEdma,   CNT,FRMCNT);
    x = EDMA_FGETH(hEdma,   CNT,ELECNT);
    x = EDMA_FGETH(hEdma,   DST,   DST);
    x = EDMA_FGETH(hEdma,   IDX,FRMIDX);
    x = EDMA_FGETH(hEdma,   IDX,ELEIDX);
    x = EDMA_FGETH(hEdma,   RLD,ELERLD);
    x = EDMA_FGETH(hEdma,   RLD,  LINK);


/*  Test FGETH Macro end */
/*  Test FSETH Macro start */
    EDMA_FSETH(hEdma,   OPT,   PRI,   EDMA_OPT_PRI_DEFAULT);
    EDMA_FSETH(hEdma,   OPT, ESIZE, EDMA_OPT_ESIZE_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,   2DS,   EDMA_OPT_2DS_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,   SUM,   EDMA_OPT_SUM_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,   2DD,   EDMA_OPT_2DD_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,   DUM,   EDMA_OPT_DUM_DEFAULT);
    EDMA_FSETH(hEdma,   OPT, TCINT, EDMA_OPT_TCINT_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,   TCC,   EDMA_OPT_TCC_DEFAULT);
#if (CHIP_6400)
    EDMA_FSETH(hEdma,   OPT,ATCINT,EDMA_OPT_ATCINT_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,  ATCC,  EDMA_OPT_ATCC_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,  PDTS,  EDMA_OPT_PDTS_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,  PDTD,  EDMA_OPT_PDTD_DEFAULT);
#endif
    EDMA_FSETH(hEdma,   OPT,  LINK,  EDMA_OPT_LINK_DEFAULT);
    EDMA_FSETH(hEdma,   OPT,    FS,    EDMA_OPT_FS_DEFAULT);
    EDMA_FSETH(hEdma,   SRC,   SRC,   EDMA_SRC_SRC_DEFAULT);
    EDMA_FSETH(hEdma,   CNT,FRMCNT,EDMA_CNT_FRMCNT_DEFAULT);
    EDMA_FSETH(hEdma,   CNT,ELECNT,EDMA_CNT_ELECNT_DEFAULT);
    EDMA_FSETH(hEdma,   DST,   DST,   EDMA_DST_DST_DEFAULT);
    EDMA_FSETH(hEdma,   IDX,FRMIDX,EDMA_IDX_FRMIDX_DEFAULT);
    EDMA_FSETH(hEdma,   IDX,ELEIDX,EDMA_IDX_ELEIDX_DEFAULT);
    EDMA_FSETH(hEdma,   RLD,ELERLD,EDMA_RLD_ELERLD_DEFAULT);
    EDMA_FSETH(hEdma,   RLD,  LINK,  EDMA_RLD_LINK_DEFAULT);

/*  Test FSETH Macro end */
/*  Test FSETSH Macro start */
    EDMA_FSETSH(hEdma,   OPT,   PRI,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT, ESIZE,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,   2DS,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,   SUM,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,   2DD,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,   DUM,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT, TCINT,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,   TCC,DEFAULT);
#if (CHIP_6400)
    EDMA_FSETSH(hEdma,   OPT,ATCINT,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,  ATCC,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,  PDTS,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,  PDTD,DEFAULT);
#endif
    EDMA_FSETSH(hEdma,   OPT,  LINK,DEFAULT);
    EDMA_FSETSH(hEdma,   OPT,    FS,DEFAULT);
    EDMA_FSETSH(hEdma,   SRC,   SRC,DEFAULT);
    EDMA_FSETSH(hEdma,   CNT,FRMCNT,DEFAULT);
    EDMA_FSETSH(hEdma,   CNT,ELECNT,DEFAULT);
    EDMA_FSETSH(hEdma,   DST,   DST,DEFAULT);
    EDMA_FSETSH(hEdma,   IDX,FRMIDX,DEFAULT);
    EDMA_FSETSH(hEdma,   IDX,ELEIDX,DEFAULT);
    EDMA_FSETSH(hEdma,   RLD,ELERLD,DEFAULT);
    EDMA_FSETSH(hEdma,   RLD,  LINK,DEFAULT);

/*  Test FSETSH Macro end */
    
  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_emif(int arg) {


  #if (EMIF_SUPPORT&&EMIF_BUILD)

    /* test FMK macros */
    #if (C11_SUPPORT)
      x = EMIF_FMK(GBLCTL,BUSREQ,0xFFFFFFFF);
    #endif
    x = EMIF_FMK(GBLCTL,ARDY,0xFFFFFFFF);
    x = EMIF_FMK(GBLCTL,HOLD,0xFFFFFFFF);
    x = EMIF_FMK(GBLCTL,HOLDA,0xFFFFFFFF);
    x = EMIF_FMK(GBLCTL,NOHOLD,0xFFFFFFFF);
#if (!C11_SUPPORT)
    x = EMIF_FMK(GBLCTL,SDCEN,0xFFFFFFFF);
    x = EMIF_FMK(GBLCTL,SSCEN,0xFFFFFFFF);
#endif
    x = EMIF_FMK(GBLCTL,CLK1EN,0xFFFFFFFF);
    x = EMIF_FMK(GBLCTL,CLK2EN,0xFFFFFFFF);
#if (CHIP_6201|CHIP_6701)
    x = EMIF_FMK(GBLCTL,SSCRT,0xFFFFFFFF);
#endif
#if (!C11_SUPPORT)
    x = EMIF_FMK(GBLCTL,RBTR8,0xFFFFFFFF);
#endif
#if (!C11_SUPPORT)
    x = EMIF_FMK(GBLCTL,MAP,0xFFFFFFFF);
#endif
    x = EMIF_FMK(CECTL,WRSETUP,0xFFFFFFFF);
    x = EMIF_FMK(CECTL,WRSTRB,0xFFFFFFFF);
    x = EMIF_FMK(CECTL,WRHLD,0xFFFFFFFF);
    x = EMIF_FMK(CECTL,RDSETUP,0xFFFFFFFF);
#if (C11_SUPPORT)
    x = EMIF_FMK(CECTL,TA,0xFFFFFFFF);
#endif
    x = EMIF_FMK(CECTL,RDSTRB,0xFFFFFFFF);
    x = EMIF_FMK(CECTL,MTYPE,0xFFFFFFFF);
#if (C11_SUPPORT)
    x = EMIF_FMK(CECTL,WRHLDMSB,0xFFFFFFFF);
#endif
    x = EMIF_FMK(CECTL,RDHLD,0xFFFFFFFF);
#if (C11_SUPPORT)
    x = EMIF_FMK(SDCTL,SDBSZ,0xFFFFFFFF);
    x = EMIF_FMK(SDCTL,SDRSZ,0xFFFFFFFF);
    x = EMIF_FMK(SDCTL,SDCSZ,0xFFFFFFFF);
#endif
#if (!C11_SUPPORT)
    x = EMIF_FMK(SDCTL,SDWID,0xFFFFFFFF);
#endif
    x = EMIF_FMK(SDCTL,RFEN,0xFFFFFFFF);
    x = EMIF_FMK(SDCTL,INIT,0xFFFFFFFF);
    x = EMIF_FMK(SDCTL,TRCD,0xFFFFFFFF);
    x = EMIF_FMK(SDCTL,TRP,0xFFFFFFFF);
    x = EMIF_FMK(SDCTL,TRC,0xFFFFFFFF);
#if (C11_SUPPORT)
    x = EMIF_FMK(SDTIM,XRFR,0xFFFFFFFF);
#endif
    x = EMIF_FMK(SDTIM,CNTR,0xFFFFFFFF);
    x = EMIF_FMK(SDTIM,PERIOD,0xFFFFFFFF);

#if (C11_SUPPORT)
    x = EMIF_FMK(SDEXT,WR2RD,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,WR2DEAC,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,WR2WR,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,R2WDQM,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,RD2WR,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,RD2DEAC,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,RD2RD,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,THZP,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,TWR,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,TRRD,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,TRAS,0xFFFFFFFF);
    x = EMIF_FMK(SDEXT,TCL,0xFFFFFFFF);
#endif

    /* test FMKS macros */
#if (C11_SUPPORT)
    x = EMIF_FMKS(GBLCTL,BUSREQ,DEFAULT);
#endif
    x = EMIF_FMKS(GBLCTL,ARDY,DEFAULT);
    x = EMIF_FMKS(GBLCTL,HOLD,DEFAULT);
    x = EMIF_FMKS(GBLCTL,HOLDA,DEFAULT);
    x = EMIF_FMKS(GBLCTL,NOHOLD,DEFAULT);
#if (!C11_SUPPORT)
    x = EMIF_FMKS(GBLCTL,SDCEN,DEFAULT);
    x = EMIF_FMKS(GBLCTL,SSCEN,DEFAULT);
#endif
    x = EMIF_FMKS(GBLCTL,CLK1EN,DEFAULT);
    x = EMIF_FMKS(GBLCTL,CLK2EN,DEFAULT);
#if (CHIP_6201|CHIP_6701)
    x = EMIF_FMKS(GBLCTL,SSCRT,DEFAULT);
#endif    

#if (!C11_SUPPORT)
    x = EMIF_FMKS(GBLCTL,RBTR8,DEFAULT);
    x = EMIF_FMKS(GBLCTL,MAP,DEFAULT);
#endif
    x = EMIF_FMKS(CECTL,WRSETUP,DEFAULT);
    x = EMIF_FMKS(CECTL,WRSTRB,DEFAULT);
    x = EMIF_FMKS(CECTL,WRHLD,DEFAULT);
    x = EMIF_FMKS(CECTL,RDSETUP,DEFAULT);
#if (C11_SUPPORT)
    x = EMIF_FMKS(CECTL,TA,DEFAULT);
#endif    
    x = EMIF_FMKS(CECTL,RDSTRB,DEFAULT);
    x = EMIF_FMKS(CECTL,MTYPE,DEFAULT);
#if (C11_SUPPORT)
    x = EMIF_FMKS(CECTL,WRHLDMSB,DEFAULT);
#endif
    x = EMIF_FMKS(CECTL,RDHLD,DEFAULT);

#if (C11_SUPPORT)
    x = EMIF_FMKS(SDCTL,SDBSZ,DEFAULT);
    x = EMIF_FMKS(SDCTL,SDRSZ,DEFAULT);
    x = EMIF_FMKS(SDCTL,SDCSZ,DEFAULT);
#endif
#if (!C11_SUPPORT)
    x = EMIF_FMKS(SDCTL,SDWID,DEFAULT);
#endif
    x = EMIF_FMKS(SDCTL,RFEN,DEFAULT);
    x = EMIF_FMKS(SDCTL,INIT,DEFAULT);
    x = EMIF_FMKS(SDCTL,TRCD,DEFAULT);
    x = EMIF_FMKS(SDCTL,TRP,DEFAULT);
    x = EMIF_FMKS(SDCTL,TRC,DEFAULT);

#if (C11_SUPPORT)
    x = EMIF_FMKS(SDTIM,XRFR,DEFAULT);
#endif    
    x = EMIF_FMKS(SDTIM,CNTR,DEFAULT);
    x = EMIF_FMKS(SDTIM,PERIOD,DEFAULT);

#if (C11_SUPPORT)
    x = EMIF_FMKS(SDEXT,WR2RD,DEFAULT);
    x = EMIF_FMKS(SDEXT,WR2DEAC,DEFAULT);
    x = EMIF_FMKS(SDEXT,WR2WR,DEFAULT);
    x = EMIF_FMKS(SDEXT,R2WDQM,DEFAULT);
    x = EMIF_FMKS(SDEXT,RD2WR,DEFAULT);
    x = EMIF_FMKS(SDEXT,RD2DEAC,DEFAULT);
    x = EMIF_FMKS(SDEXT,RD2RD,DEFAULT);
    x = EMIF_FMKS(SDEXT,THZP,DEFAULT);
    x = EMIF_FMKS(SDEXT,TWR,DEFAULT);
    x = EMIF_FMKS(SDEXT,TRRD,DEFAULT);
    x = EMIF_FMKS(SDEXT,TRAS,DEFAULT);
    x = EMIF_FMKS(SDEXT,TCL,DEFAULT);
#endif

    /* test ADDR macros */
    x = EMIF_ADDR(GBLCTL);
    x = EMIF_ADDR(CECTL0);
    x = EMIF_ADDR(CECTL1);
    x = EMIF_ADDR(CECTL2);
    x = EMIF_ADDR(CECTL3);
    x = EMIF_ADDR(SDCTL);
    x = EMIF_ADDR(SDTIM);
#if (C11_SUPPORT)    
    x = EMIF_ADDR(SDEXT);
#endif

    /* test RGET macros */
    x = EMIF_RGET(GBLCTL);
    x = EMIF_RGET(CECTL0);
    x = EMIF_RGET(CECTL1);
    x = EMIF_RGET(CECTL2);
    x = EMIF_RGET(CECTL3);
    x = EMIF_RGET(SDCTL);
    x = EMIF_RGET(SDTIM);
#if (C11_SUPPORT)
    x = EMIF_RGET(SDEXT);
#endif

    /* test RSET macros */
    EMIF_RSET(GBLCTL,EMIF_GBLCTL_DEFAULT);
    EMIF_RSET(CECTL0,EMIF_CECTL_DEFAULT);
    EMIF_RSET(CECTL1,EMIF_CECTL_DEFAULT);
    EMIF_RSET(CECTL2,EMIF_CECTL_DEFAULT);
    EMIF_RSET(CECTL3,EMIF_CECTL_DEFAULT);
    EMIF_RSET(SDCTL,EMIF_SDCTL_DEFAULT);
    EMIF_RSET(SDTIM,EMIF_SDTIM_DEFAULT);
#if (C11_SUPPORT)
    EMIF_RSET(SDEXT,EMIF_SDEXT_DEFAULT);
#endif
    /* test FGET macros */
#if (C11_SUPPORT)    
    x = EMIF_FGET(GBLCTL,BUSREQ);
#endif    
    x = EMIF_FGET(GBLCTL,ARDY);
    x = EMIF_FGET(GBLCTL,HOLD);
    x = EMIF_FGET(GBLCTL,HOLDA);
    x = EMIF_FGET(GBLCTL,NOHOLD);
#if (!C11_SUPPORT)
    x = EMIF_FGET(GBLCTL,SDCEN);
    x = EMIF_FGET(GBLCTL,SSCEN);
#endif
    x = EMIF_FGET(GBLCTL,CLK1EN);
    x = EMIF_FGET(GBLCTL,CLK2EN);
#if (CHIP_6201|CHIP_6701)
    x = EMIF_FGET(GBLCTL,SSCRT);
#endif
#if (!C11_SUPPORT)
    x = EMIF_FGET(GBLCTL,RBTR8);
    x = EMIF_FGET(GBLCTL,MAP);
#endif

    x = EMIF_FGET(CECTL0,WRSETUP);
    x = EMIF_FGET(CECTL0,WRSTRB);
    x = EMIF_FGET(CECTL0,WRHLD);
    x = EMIF_FGET(CECTL0,RDSETUP);
#if (C11_SUPPORT)
    x = EMIF_FGET(CECTL0,TA);
#endif
    x = EMIF_FGET(CECTL0,RDSTRB);
    x = EMIF_FGET(CECTL0,MTYPE);
#if (C11_SUPPORT)
    x = EMIF_FGET(CECTL0,WRHLDMSB);
#endif
    x = EMIF_FGET(CECTL0,RDHLD);

    x = EMIF_FGET(CECTL1,WRSETUP);
    x = EMIF_FGET(CECTL1,WRSTRB);
    x = EMIF_FGET(CECTL1,WRHLD);
    x = EMIF_FGET(CECTL1,RDSETUP);
#if (C11_SUPPORT)
    x = EMIF_FGET(CECTL1,TA);
#endif
    x = EMIF_FGET(CECTL1,RDSTRB);
    x = EMIF_FGET(CECTL1,MTYPE);
#if (C11_SUPPORT)
    x = EMIF_FGET(CECTL1,WRHLDMSB);
#endif
    x = EMIF_FGET(CECTL1,RDHLD);

    x = EMIF_FGET(CECTL2,WRSETUP);
    x = EMIF_FGET(CECTL2,WRSTRB);
    x = EMIF_FGET(CECTL2,WRHLD);
    x = EMIF_FGET(CECTL2,RDSETUP);
#if (C11_SUPPORT)
    x = EMIF_FGET(CECTL2,TA);
#endif
    x = EMIF_FGET(CECTL2,RDSTRB);
    x = EMIF_FGET(CECTL2,MTYPE);
#if (C11_SUPPORT)
    x = EMIF_FGET(CECTL2,WRHLDMSB);
#endif
    x = EMIF_FGET(CECTL2,RDHLD);

    x = EMIF_FGET(CECTL3,WRSETUP);
    x = EMIF_FGET(CECTL3,WRSTRB);
    x = EMIF_FGET(CECTL3,WRHLD);
    x = EMIF_FGET(CECTL3,RDSETUP);
#if (C11_SUPPORT)
    x = EMIF_FGET(CECTL3,TA);
#endif
    x = EMIF_FGET(CECTL3,RDSTRB);
    x = EMIF_FGET(CECTL3,MTYPE);
#if (C11_SUPPORT)
    x = EMIF_FGET(CECTL3,WRHLDMSB);
#endif
    x = EMIF_FGET(CECTL3,RDHLD);

#if (C11_SUPPORT)
    x = EMIF_FGET(SDCTL,SDBSZ);
    x = EMIF_FGET(SDCTL,SDRSZ);
    x = EMIF_FGET(SDCTL,SDCSZ);
#endif
#if (!C11_SUPPORT)
    x = EMIF_FGET(SDCTL,SDWID);
#endif
    x = EMIF_FGET(SDCTL,RFEN);
    x = EMIF_FGET(SDCTL,INIT);
    x = EMIF_FGET(SDCTL,TRCD);
    x = EMIF_FGET(SDCTL,TRP);
    x = EMIF_FGET(SDCTL,TRC);

#if (C11_SUPPORT)
    x = EMIF_FGET(SDTIM,XRFR);
#endif
    x = EMIF_FGET(SDTIM,CNTR);
    x = EMIF_FGET(SDTIM,PERIOD);

#if (C11_SUPPORT)
    x = EMIF_FGET(SDEXT,WR2RD);
    x = EMIF_FGET(SDEXT,WR2DEAC);
    x = EMIF_FGET(SDEXT,WR2WR);
    x = EMIF_FGET(SDEXT,R2WDQM);
    x = EMIF_FGET(SDEXT,RD2WR);
    x = EMIF_FGET(SDEXT,RD2DEAC);
    x = EMIF_FGET(SDEXT,RD2RD);
    x = EMIF_FGET(SDEXT,THZP);
    x = EMIF_FGET(SDEXT,TWR);
    x = EMIF_FGET(SDEXT,TRRD);
    x = EMIF_FGET(SDEXT,TRAS);
    x = EMIF_FGET(SDEXT,TCL);

    x = EMIF_FGET(SDEXT,WR2RD);
    x = EMIF_FGET(SDEXT,WR2DEAC);
    x = EMIF_FGET(SDEXT,WR2WR);
    x = EMIF_FGET(SDEXT,R2WDQM);
    x = EMIF_FGET(SDEXT,RD2WR);
    x = EMIF_FGET(SDEXT,RD2DEAC);
    x = EMIF_FGET(SDEXT,RD2RD);
    x = EMIF_FGET(SDEXT,THZP);
    x = EMIF_FGET(SDEXT,TWR);
    x = EMIF_FGET(SDEXT,TRRD);
    x = EMIF_FGET(SDEXT,TRAS);
    x = EMIF_FGET(SDEXT,TCL);
#endif
    /* test FSET macros */
#if (C11_SUPPORT)    
    EMIF_FSET(GBLCTL,BUSREQ,EMIF_GBLCTL_BUSREQ_DEFAULT);
#endif
    EMIF_FSET(GBLCTL,ARDY,EMIF_GBLCTL_ARDY_DEFAULT);
    EMIF_FSET(GBLCTL,HOLD,EMIF_GBLCTL_HOLD_DEFAULT);
    EMIF_FSET(GBLCTL,HOLDA,EMIF_GBLCTL_HOLDA_DEFAULT);
    EMIF_FSET(GBLCTL,NOHOLD,EMIF_GBLCTL_NOHOLD_DEFAULT);
#if (!C11_SUPPORT)    
    EMIF_FSET(GBLCTL,SDCEN,EMIF_GBLCTL_SDCEN_DEFAULT);
    EMIF_FSET(GBLCTL,SSCEN,EMIF_GBLCTL_SSCEN_DEFAULT);
#endif
    EMIF_FSET(GBLCTL,CLK1EN,EMIF_GBLCTL_CLK1EN_DEFAULT);
    EMIF_FSET(GBLCTL,CLK2EN,EMIF_GBLCTL_CLK2EN_DEFAULT);
#if (CHIP_6201|CHIP_6701)
    EMIF_FSET(GBLCTL,SSCRT,EMIF_GBLCTL_SSCRT_DEFAULT);
#endif
#if (!C11_SUPPORT)    
    EMIF_FSET(GBLCTL,RBTR8,EMIF_GBLCTL_RBTR8_DEFAULT);
    EMIF_FSET(GBLCTL,MAP,EMIF_GBLCTL_MAP_DEFAULT);
#endif

    EMIF_FSET(CECTL0,WRSETUP,EMIF_CECTL_WRSETUP_DEFAULT);
    EMIF_FSET(CECTL0,WRSTRB,EMIF_CECTL_WRSTRB_DEFAULT);
    EMIF_FSET(CECTL0,WRHLD,EMIF_CECTL_WRHLD_DEFAULT);
    EMIF_FSET(CECTL0,RDSETUP,EMIF_CECTL_RDSETUP_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSET(CECTL0,TA,EMIF_CECTL_TA_DEFAULT);
#endif
    EMIF_FSET(CECTL0,RDSTRB,EMIF_CECTL_RDSTRB_DEFAULT);
    EMIF_FSET(CECTL0,MTYPE,EMIF_CECTL_MTYPE_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSET(CECTL0,WRHLDMSB,EMIF_CECTL_WRHLDMSB_DEFAULT);
#endif
    EMIF_FSET(CECTL0,RDHLD,EMIF_CECTL_RDHLD_DEFAULT);

    EMIF_FSET(CECTL1,WRSETUP,EMIF_CECTL_WRSETUP_DEFAULT);
    EMIF_FSET(CECTL1,WRSTRB,EMIF_CECTL_WRSTRB_DEFAULT);
    EMIF_FSET(CECTL1,WRHLD,EMIF_CECTL_WRHLD_DEFAULT);
    EMIF_FSET(CECTL1,RDSETUP,EMIF_CECTL_RDSETUP_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSET(CECTL1,TA,EMIF_CECTL_TA_DEFAULT);
#endif
    EMIF_FSET(CECTL1,RDSTRB,EMIF_CECTL_RDSTRB_DEFAULT);
    EMIF_FSET(CECTL1,MTYPE,EMIF_CECTL_MTYPE_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSET(CECTL1,WRHLDMSB,EMIF_CECTL_WRHLDMSB_DEFAULT);
#endif
    EMIF_FSET(CECTL1,RDHLD,EMIF_CECTL_RDHLD_DEFAULT);

    EMIF_FSET(CECTL2,WRSETUP,EMIF_CECTL_WRSETUP_DEFAULT);
    EMIF_FSET(CECTL2,WRSTRB,EMIF_CECTL_WRSTRB_DEFAULT);
    EMIF_FSET(CECTL2,WRHLD,EMIF_CECTL_WRHLD_DEFAULT);
    EMIF_FSET(CECTL2,RDSETUP,EMIF_CECTL_RDSETUP_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSET(CECTL2,TA,EMIF_CECTL_TA_DEFAULT);
#endif
    EMIF_FSET(CECTL2,RDSTRB,EMIF_CECTL_RDSTRB_DEFAULT);
    EMIF_FSET(CECTL2,MTYPE,EMIF_CECTL_MTYPE_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSET(CECTL2,WRHLDMSB,EMIF_CECTL_WRHLDMSB_DEFAULT);
#endif
    EMIF_FSET(CECTL2,RDHLD,EMIF_CECTL_RDHLD_DEFAULT);

    EMIF_FSET(CECTL3,WRSETUP,EMIF_CECTL_WRSETUP_DEFAULT);
    EMIF_FSET(CECTL3,WRSTRB,EMIF_CECTL_WRSTRB_DEFAULT);
    EMIF_FSET(CECTL3,WRHLD,EMIF_CECTL_WRHLD_DEFAULT);
    EMIF_FSET(CECTL3,RDSETUP,EMIF_CECTL_RDSETUP_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSET(CECTL3,TA,EMIF_CECTL_TA_DEFAULT);
#endif
    EMIF_FSET(CECTL3,RDSTRB,EMIF_CECTL_RDSTRB_DEFAULT);
    EMIF_FSET(CECTL3,MTYPE,EMIF_CECTL_MTYPE_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSET(CECTL3,WRHLDMSB,EMIF_CECTL_WRHLDMSB_DEFAULT);
#endif
    EMIF_FSET(CECTL3,RDHLD,EMIF_CECTL_RDHLD_DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSET(SDCTL,SDBSZ,EMIF_SDCTL_SDBSZ_DEFAULT);
    EMIF_FSET(SDCTL,SDRSZ,EMIF_SDCTL_SDRSZ_DEFAULT);
    EMIF_FSET(SDCTL,SDCSZ,EMIF_SDCTL_SDCSZ_DEFAULT);
#endif
#if (!C11_SUPPORT)
    EMIF_FSET(SDCTL,SDWID,EMIF_SDCTL_SDWID_DEFAULT);
#endif
    EMIF_FSET(SDCTL,RFEN,EMIF_SDCTL_RFEN_DEFAULT);
    EMIF_FSET(SDCTL,INIT,EMIF_SDCTL_INIT_DEFAULT);
    EMIF_FSET(SDCTL,TRCD,EMIF_SDCTL_TRCD_DEFAULT);
    EMIF_FSET(SDCTL,TRP,EMIF_SDCTL_TRP_DEFAULT);
    EMIF_FSET(SDCTL,TRC,EMIF_SDCTL_TRC_DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSET(SDTIM,XRFR,EMIF_SDTIM_XRFR_DEFAULT);
#endif
    EMIF_FSET(SDTIM,CNTR,EMIF_SDTIM_CNTR_DEFAULT);
    EMIF_FSET(SDTIM,PERIOD,EMIF_SDTIM_PERIOD_DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSET(SDEXT,WR2RD,EMIF_SDEXT_WR2RD_DEFAULT);
    EMIF_FSET(SDEXT,WR2DEAC,EMIF_SDEXT_WR2DEAC_DEFAULT);
    EMIF_FSET(SDEXT,WR2WR,EMIF_SDEXT_WR2WR_DEFAULT);
    EMIF_FSET(SDEXT,R2WDQM,EMIF_SDEXT_R2WDQM_DEFAULT);
    EMIF_FSET(SDEXT,RD2WR,EMIF_SDEXT_RD2WR_DEFAULT);
    EMIF_FSET(SDEXT,RD2DEAC,EMIF_SDEXT_RD2DEAC_DEFAULT);
    EMIF_FSET(SDEXT,RD2RD,EMIF_SDEXT_RD2RD_DEFAULT);
    EMIF_FSET(SDEXT,THZP,EMIF_SDEXT_THZP_DEFAULT);
    EMIF_FSET(SDEXT,TWR,EMIF_SDEXT_TWR_DEFAULT);
    EMIF_FSET(SDEXT,TRRD,EMIF_SDEXT_TRRD_DEFAULT);
    EMIF_FSET(SDEXT,TRAS,EMIF_SDEXT_TRAS_DEFAULT);
    EMIF_FSET(SDEXT,TCL,EMIF_SDEXT_TCL_DEFAULT);
#endif

    /* test FSETS macros */
#if (C11_SUPPORT)
    EMIF_FSETS(GBLCTL,BUSREQ, DEFAULT);
#endif
    EMIF_FSETS(GBLCTL,ARDY,DEFAULT);
    EMIF_FSETS(GBLCTL,HOLD,DEFAULT);
    EMIF_FSETS(GBLCTL,HOLDA,DEFAULT);
    EMIF_FSETS(GBLCTL,NOHOLD,DEFAULT);
#if (!C11_SUPPORT)
    EMIF_FSETS(GBLCTL,SDCEN,DEFAULT);
    EMIF_FSETS(GBLCTL,SSCEN,DEFAULT);
#endif
    EMIF_FSETS(GBLCTL,CLK1EN,DEFAULT);
    EMIF_FSETS(GBLCTL,CLK2EN,DEFAULT);
#if (CHIP_6201|CHIP_6701)
    EMIF_FSETS(GBLCTL,SSCRT,DEFAULT);
#endif
#if (!C11_SUPPORT)
    EMIF_FSETS(GBLCTL,RBTR8,DEFAULT);
    EMIF_FSETS(GBLCTL,MAP,DEFAULT);
#endif

    EMIF_FSETS(CECTL0,WRSETUP,DEFAULT);
    EMIF_FSETS(CECTL0,WRSTRB,DEFAULT);
    EMIF_FSETS(CECTL0,WRHLD,DEFAULT);
    EMIF_FSETS(CECTL0,RDSETUP,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETS(CECTL0,TA,DEFAULT);
#endif
    EMIF_FSETS(CECTL0,RDSTRB,DEFAULT);
    EMIF_FSETS(CECTL0,MTYPE,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETS(CECTL0,WRHLDMSB,DEFAULT);
#endif
    EMIF_FSETS(CECTL0,RDHLD,DEFAULT);

    EMIF_FSETS(CECTL1,WRSETUP,DEFAULT);
    EMIF_FSETS(CECTL1,WRSTRB,DEFAULT);
    EMIF_FSETS(CECTL1,WRHLD,DEFAULT);
    EMIF_FSETS(CECTL1,RDSETUP,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETS(CECTL1,TA,DEFAULT);
#endif
    EMIF_FSETS(CECTL1,RDSTRB,DEFAULT);
    EMIF_FSETS(CECTL1,MTYPE,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETS(CECTL1,WRHLDMSB,DEFAULT);
#endif
    EMIF_FSETS(CECTL1,RDHLD,DEFAULT);

    EMIF_FSETS(CECTL2,WRSETUP,DEFAULT);
    EMIF_FSETS(CECTL2,WRSTRB,DEFAULT);
    EMIF_FSETS(CECTL2,WRHLD,DEFAULT);
    EMIF_FSETS(CECTL2,RDSETUP,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETS(CECTL2,TA,DEFAULT);
#endif
    EMIF_FSETS(CECTL2,RDSTRB,DEFAULT);
    EMIF_FSETS(CECTL2,MTYPE,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETS(CECTL2,WRHLDMSB,DEFAULT);
#endif
    EMIF_FSETS(CECTL2,RDHLD,DEFAULT);

    EMIF_FSETS(CECTL3,WRSETUP,DEFAULT);
    EMIF_FSETS(CECTL3,WRSTRB,DEFAULT);
    EMIF_FSETS(CECTL3,WRHLD,DEFAULT);
    EMIF_FSETS(CECTL3,RDSETUP,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETS(CECTL3,TA,DEFAULT);
#endif
    EMIF_FSETS(CECTL3,RDSTRB,DEFAULT);
    EMIF_FSETS(CECTL3,MTYPE,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETS(CECTL3,WRHLDMSB,DEFAULT);
#endif
    EMIF_FSETS(CECTL3,RDHLD,DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSETS(SDCTL,SDBSZ,DEFAULT);
    EMIF_FSETS(SDCTL,SDRSZ,DEFAULT);
    EMIF_FSETS(SDCTL,SDCSZ,DEFAULT);
#endif
#if (!C11_SUPPORT)
    EMIF_FSETS(SDCTL,SDWID,DEFAULT);
#endif
    EMIF_FSETS(SDCTL,RFEN,DEFAULT);
    EMIF_FSETS(SDCTL,INIT,DEFAULT);
    EMIF_FSETS(SDCTL,TRCD,DEFAULT);
    EMIF_FSETS(SDCTL,TRP,DEFAULT);
    EMIF_FSETS(SDCTL,TRC,DEFAULT);

#if (C11_SUPPORT)    
    EMIF_FSETS(SDTIM,XRFR,DEFAULT);
#endif
    EMIF_FSETS(SDTIM,CNTR,DEFAULT);
    EMIF_FSETS(SDTIM,PERIOD,DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSETS(SDEXT,WR2RD,DEFAULT);
    EMIF_FSETS(SDEXT,WR2DEAC,DEFAULT);
    EMIF_FSETS(SDEXT,WR2WR,DEFAULT);
    EMIF_FSETS(SDEXT,R2WDQM,DEFAULT);
    EMIF_FSETS(SDEXT,RD2WR,DEFAULT);
    EMIF_FSETS(SDEXT,RD2DEAC,DEFAULT);
    EMIF_FSETS(SDEXT,RD2RD,DEFAULT);
    EMIF_FSETS(SDEXT,THZP,DEFAULT);
    EMIF_FSETS(SDEXT,TWR,DEFAULT);
    EMIF_FSETS(SDEXT,TRRD,DEFAULT);
    EMIF_FSETS(SDEXT,TRAS,DEFAULT);
    EMIF_FSETS(SDEXT,TCL,DEFAULT);
#endif

    /* test RGET_A macros */
    x = EMIF_RGETA(0,GBLCTL);

    /* test RSET_A macros */
    EMIF_RSETA(0,GBLCTL,0);

    /* test FGET_A macros */
#if (C11_SUPPORT)
    x = EMIF_FGETA(0,GBLCTL,BUSREQ);
#endif
    x = EMIF_FGETA(0,GBLCTL,ARDY);
    x = EMIF_FGETA(0,GBLCTL,HOLD);
    x = EMIF_FGETA(0,GBLCTL,HOLDA);
    x = EMIF_FGETA(0,GBLCTL,NOHOLD);
#if (!C11_SUPPORT)
    x = EMIF_FGETA(0,GBLCTL,SDCEN);
    x = EMIF_FGETA(0,GBLCTL,SSCEN);
#endif
    x = EMIF_FGETA(0,GBLCTL,CLK1EN);
    x = EMIF_FGETA(0,GBLCTL,CLK2EN);
#if (CHIP_6201|CHIP_6701)
    x = EMIF_FGETA(0,GBLCTL,SSCRT);
#endif
#if (!C11_SUPPORT)
    x = EMIF_FGETA(0,GBLCTL,RBTR8);
    x = EMIF_FGETA(0,GBLCTL,MAP);
#endif

    x = EMIF_FGETA(0,CECTL,WRSETUP);
    x = EMIF_FGETA(0,CECTL,WRSTRB);
    x = EMIF_FGETA(0,CECTL,WRHLD);
    x = EMIF_FGETA(0,CECTL,RDSETUP);
#if (C11_SUPPORT)
    x = EMIF_FGETA(0,CECTL,TA);
#endif
    x = EMIF_FGETA(0,CECTL,RDSTRB);
    x = EMIF_FGETA(0,CECTL,MTYPE);
#if (C11_SUPPORT)
    x = EMIF_FGETA(0,CECTL,WRHLDMSB);
#endif
    x = EMIF_FGETA(0,CECTL,RDHLD);

#if (C11_SUPPORT)
    x = EMIF_FGETA(0,SDCTL,SDBSZ);
    x = EMIF_FGETA(0,SDCTL,SDRSZ);
    x = EMIF_FGETA(0,SDCTL,SDCSZ);
#endif
#if (!C11_SUPPORT)
    x = EMIF_FGETA(0,SDCTL,SDWID);
#endif
    x = EMIF_FGETA(0,SDCTL,RFEN);
    x = EMIF_FGETA(0,SDCTL,INIT);
    x = EMIF_FGETA(0,SDCTL,TRCD);
    x = EMIF_FGETA(0,SDCTL,TRP);
    x = EMIF_FGETA(0,SDCTL,TRC);

#if (C11_SUPPORT)
    x = EMIF_FGETA(0,SDTIM,XRFR);
#endif
    x = EMIF_FGETA(0,SDTIM,CNTR);
    x = EMIF_FGETA(0,SDTIM,PERIOD);

#if (C11_SUPPORT)
    x = EMIF_FGETA(0,SDEXT,WR2RD);
    x = EMIF_FGETA(0,SDEXT,WR2DEAC);
    x = EMIF_FGETA(0,SDEXT,WR2WR);
    x = EMIF_FGETA(0,SDEXT,R2WDQM);
    x = EMIF_FGETA(0,SDEXT,RD2WR);
    x = EMIF_FGETA(0,SDEXT,RD2DEAC);
    x = EMIF_FGETA(0,SDEXT,RD2RD);
    x = EMIF_FGETA(0,SDEXT,THZP);
    x = EMIF_FGETA(0,SDEXT,TWR);
    x = EMIF_FGETA(0,SDEXT,TRRD);
    x = EMIF_FGETA(0,SDEXT,TRAS);
    x = EMIF_FGETA(0,SDEXT,TCL);
#endif

    /* test FSET_A macros */
#if (C11_SUPPORT)
    EMIF_FSETA(0,GBLCTL,BUSREQ,EMIF_GBLCTL_BUSREQ_DEFAULT);
#endif
    EMIF_FSETA(0,GBLCTL,ARDY,EMIF_GBLCTL_ARDY_DEFAULT);
    EMIF_FSETA(0,GBLCTL,HOLD,EMIF_GBLCTL_HOLD_DEFAULT);
    EMIF_FSETA(0,GBLCTL,HOLDA,EMIF_GBLCTL_HOLDA_DEFAULT);
    EMIF_FSETA(0,GBLCTL,NOHOLD,EMIF_GBLCTL_NOHOLD_DEFAULT);
#if (!C11_SUPPORT)
    EMIF_FSETA(0,GBLCTL,SDCEN,EMIF_GBLCTL_SDCEN_DEFAULT);
    EMIF_FSETA(0,GBLCTL,SSCEN,EMIF_GBLCTL_SSCEN_DEFAULT);
#endif
    EMIF_FSETA(0,GBLCTL,CLK1EN,EMIF_GBLCTL_CLK1EN_DEFAULT);
    EMIF_FSETA(0,GBLCTL,CLK2EN,EMIF_GBLCTL_CLK2EN_DEFAULT);
#if (CHIP_6201|CHIP_6701)
    EMIF_FSETA(0,GBLCTL,SSCRT,EMIF_GBLCTL_SSCRT_DEFAULT);
#endif
#if (!C11_SUPPORT)
    EMIF_FSETA(0,GBLCTL,RBTR8,EMIF_GBLCTL_RBTR8_DEFAULT);
    EMIF_FSETA(0,GBLCTL,MAP,EMIF_GBLCTL_MAP_DEFAULT);
#endif

    EMIF_FSETA(0,CECTL,WRSETUP,EMIF_CECTL_WRSETUP_DEFAULT);
    EMIF_FSETA(0,CECTL,WRSTRB,EMIF_CECTL_WRSTRB_DEFAULT);
    EMIF_FSETA(0,CECTL,WRHLD,EMIF_CECTL_WRHLD_DEFAULT);
    EMIF_FSETA(0,CECTL,RDSETUP,EMIF_CECTL_RDSETUP_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETA(0,CECTL,TA,EMIF_CECTL_TA_DEFAULT);
#endif
    EMIF_FSETA(0,CECTL,RDSTRB,EMIF_CECTL_RDSTRB_DEFAULT);
    EMIF_FSETA(0,CECTL,MTYPE,EMIF_CECTL_MTYPE_DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETA(0,CECTL,WRHLDMSB,EMIF_CECTL_WRHLDMSB_DEFAULT);
#endif
    EMIF_FSETA(0,CECTL,RDHLD,EMIF_CECTL_RDHLD_DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSETA(0,SDCTL,SDBSZ,EMIF_SDCTL_SDBSZ_DEFAULT);
    EMIF_FSETA(0,SDCTL,SDRSZ,EMIF_SDCTL_SDRSZ_DEFAULT);
    EMIF_FSETA(0,SDCTL,SDCSZ,EMIF_SDCTL_SDCSZ_DEFAULT);
#endif
#if (!C11_SUPPORT)
    EMIF_FSETA(0,SDCTL,SDWID,EMIF_SDCTL_SDWID_DEFAULT);
#endif
    EMIF_FSETA(0,SDCTL,RFEN,EMIF_SDCTL_RFEN_DEFAULT);
    EMIF_FSETA(0,SDCTL,INIT,EMIF_SDCTL_INIT_DEFAULT);
    EMIF_FSETA(0,SDCTL,TRCD,EMIF_SDCTL_TRCD_DEFAULT);
    EMIF_FSETA(0,SDCTL,TRP,EMIF_SDCTL_TRP_DEFAULT);
    EMIF_FSETA(0,SDCTL,TRC,EMIF_SDCTL_TRC_DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSETA(0,SDTIM,XRFR,EMIF_SDTIM_XRFR_DEFAULT);
#endif
    EMIF_FSETA(0,SDTIM,CNTR,EMIF_SDTIM_CNTR_DEFAULT);
    EMIF_FSETA(0,SDTIM,PERIOD,EMIF_SDTIM_PERIOD_DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSETA(0,SDEXT,WR2RD,EMIF_SDEXT_WR2RD_DEFAULT);
    EMIF_FSETA(0,SDEXT,WR2DEAC,EMIF_SDEXT_WR2DEAC_DEFAULT);
    EMIF_FSETA(0,SDEXT,WR2WR,EMIF_SDEXT_WR2WR_DEFAULT);
    EMIF_FSETA(0,SDEXT,R2WDQM,EMIF_SDEXT_R2WDQM_DEFAULT);
    EMIF_FSETA(0,SDEXT,RD2WR,EMIF_SDEXT_RD2WR_DEFAULT);
    EMIF_FSETA(0,SDEXT,RD2DEAC,EMIF_SDEXT_RD2DEAC_DEFAULT);
    EMIF_FSETA(0,SDEXT,RD2RD,EMIF_SDEXT_RD2RD_DEFAULT);
    EMIF_FSETA(0,SDEXT,THZP,EMIF_SDEXT_THZP_DEFAULT);
    EMIF_FSETA(0,SDEXT,TWR,EMIF_SDEXT_TWR_DEFAULT);
    EMIF_FSETA(0,SDEXT,TRRD,EMIF_SDEXT_TRRD_DEFAULT);
    EMIF_FSETA(0,SDEXT,TRAS,EMIF_SDEXT_TRAS_DEFAULT);
    EMIF_FSETA(0,SDEXT,TCL,EMIF_SDEXT_TCL_DEFAULT);
#endif

    /* test FSETS_A macros */
#if (C11_SUPPORT)
    EMIF_FSETSA(0,GBLCTL,BUSREQ, DEFAULT);
#endif
    EMIF_FSETSA(0,GBLCTL,ARDY,DEFAULT);
    EMIF_FSETSA(0,GBLCTL,HOLD,DEFAULT);
    EMIF_FSETSA(0,GBLCTL,HOLDA,DEFAULT);
    EMIF_FSETSA(0,GBLCTL,NOHOLD,DEFAULT);
#if (!C11_SUPPORT)
    EMIF_FSETSA(0,GBLCTL,SDCEN,DEFAULT);
    EMIF_FSETSA(0,GBLCTL,SSCEN,DEFAULT);
#endif
    EMIF_FSETSA(0,GBLCTL,CLK1EN,DEFAULT);
    EMIF_FSETSA(0,GBLCTL,CLK2EN,DEFAULT);
#if (CHIP_6201|CHIP_6701)
    EMIF_FSETSA(0,GBLCTL,SSCRT,DEFAULT);
#endif
#if (!C11_SUPPORT)
    EMIF_FSETSA(0,GBLCTL,RBTR8,DEFAULT);
    EMIF_FSETSA(0,GBLCTL,MAP,DEFAULT);
#endif

    EMIF_FSETSA(0,CECTL,WRSETUP,DEFAULT);
    EMIF_FSETSA(0,CECTL,WRSTRB,DEFAULT);
    EMIF_FSETSA(0,CECTL,WRHLD,DEFAULT);
    EMIF_FSETSA(0,CECTL,RDSETUP,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETSA(0,CECTL,TA,DEFAULT);
#endif
    EMIF_FSETSA(0,CECTL,RDSTRB,DEFAULT);
    EMIF_FSETSA(0,CECTL,MTYPE,DEFAULT);
#if (C11_SUPPORT)
    EMIF_FSETSA(0,CECTL,WRHLDMSB,DEFAULT);
#endif
    EMIF_FSETSA(0,CECTL,RDHLD,DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSETSA(0,SDCTL,SDBSZ,DEFAULT);
    EMIF_FSETSA(0,SDCTL,SDRSZ,DEFAULT);
    EMIF_FSETSA(0,SDCTL,SDCSZ,DEFAULT);
#endif
#if (!C11_SUPPORT)
    EMIF_FSETSA(0,SDCTL,SDWID,DEFAULT);
#endif
    EMIF_FSETSA(0,SDCTL,RFEN,DEFAULT);
    EMIF_FSETSA(0,SDCTL,INIT,DEFAULT);
    EMIF_FSETSA(0,SDCTL,TRCD,DEFAULT);
    EMIF_FSETSA(0,SDCTL,TRP,DEFAULT);
    EMIF_FSETSA(0,SDCTL,TRC,DEFAULT);

#if (C11_SUPPORT)
    EMIF_FSETSA(0,SDTIM,XRFR,DEFAULT);
#endif
    EMIF_FSETSA(0,SDTIM,CNTR,DEFAULT);
    EMIF_FSETSA(0,SDTIM,PERIOD,DEFAULT);

    #if (C11_SUPPORT)
      EMIF_FSETSA(0,SDEXT,WR2RD,DEFAULT);
      EMIF_FSETSA(0,SDEXT,WR2DEAC,DEFAULT);
      EMIF_FSETSA(0,SDEXT,WR2WR,DEFAULT);
      EMIF_FSETSA(0,SDEXT,R2WDQM,DEFAULT);
      EMIF_FSETSA(0,SDEXT,RD2WR,DEFAULT);
      EMIF_FSETSA(0,SDEXT,RD2DEAC,DEFAULT);
      EMIF_FSETSA(0,SDEXT,RD2RD,DEFAULT);
      EMIF_FSETSA(0,SDEXT,THZP,DEFAULT);
      EMIF_FSETSA(0,SDEXT,TWR,DEFAULT);
      EMIF_FSETSA(0,SDEXT,TRRD,DEFAULT);
      EMIF_FSETSA(0,SDEXT,TRAS,DEFAULT);
      EMIF_FSETSA(0,SDEXT,TCL,DEFAULT);
    #endif

  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_hpi(int arg) {

  #if (HPI_SUPPORT&&HPI_BUILD)

    x = HPI_HPIC_GET();
/*
    x = HPI_HPIC_FGET(FETCH);
    x = HPI_HPIC_FGET(HRDY);
    x = HPI_HPIC_FGET(HINT);
    x = HPI_HPIC_FGET(DSPINT);
    x = HPI_HPIC_FGET(HWOB);

    HPI_HPIC_SET(HPI_HPIC_DEFAULT);
    HPI_HPIC_FSET(FETCH,HPI_HPIC_FETCH_DEFAULT);
    HPI_HPIC_FSET(HRDY,HPI_HPIC_HRDY_DEFAULT);
    HPI_HPIC_FSET(HINT,HPI_HPIC_HINT_DEFAULT);
    HPI_HPIC_FSET(DSPINT,HPI_HPIC_DSPINT_DEFAULT);
    HPI_HPIC_FSET(HWOB,HPI_HPIC_HWOB_DEFAULT);
*/
  x = HPI_HPIC_ADDR();
    x = HPI_HPIC_MK(
      HPI_HPIC_HINT_DEFAULT,
      HPI_HPIC_DSPINT_DEFAULT
    );
    x = HPI_HPIC_ADDR();
    HPI_HPIC_RESET();

/*  Test FMK Macro start */
    x = HPI_FMK(    HPIC, FETCH,0XFFFFFFFF);
    x = HPI_FMK(    HPIC,  HRDY,0XFFFFFFFF);
    x = HPI_FMK(    HPIC,  HINT,0XFFFFFFFF);
    x = HPI_FMK(    HPIC,DSPINT,0XFFFFFFFF);
    x = HPI_FMK(    HPIC,  HWOB,0XFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = HPI_FMKS(    HPIC, FETCH,DEFAULT);
    x = HPI_FMKS(    HPIC,  HRDY,DEFAULT);
    x = HPI_FMKS(    HPIC,  HINT,DEFAULT);
    x = HPI_FMKS(    HPIC,DSPINT,DEFAULT);
    x = HPI_FMKS(    HPIC,  HWOB,DEFAULT);

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = HPI_ADDR(   HPIC);

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = HPI_RGET(   HPIC);

/*  Test RGET Macro end */
/*  Test RSET Macro start */
    HPI_RSET(   HPIC, HPI_HPIC_DEFAULT);

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = HPI_FGET(   HPIC, FETCH);
    x = HPI_FGET(   HPIC,  HRDY);
    x = HPI_FGET(   HPIC,  HINT);
    x = HPI_FGET(   HPIC,DSPINT);
    x = HPI_FGET(   HPIC,  HWOB);

/*  Test FGET Macro end */
/*  Test FSET Macro start */
    HPI_FSET(   HPIC, FETCH, HPI_HPIC_FETCH_DEFAULT);
    HPI_FSET(   HPIC,  HRDY,  HPI_HPIC_HRDY_DEFAULT);
    HPI_FSET(   HPIC,  HINT,  HPI_HPIC_HINT_DEFAULT);
    HPI_FSET(   HPIC,DSPINT,HPI_HPIC_DSPINT_DEFAULT);
    HPI_FSET(   HPIC,  HWOB,  HPI_HPIC_HWOB_DEFAULT);

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    HPI_FSETS(   HPIC, FETCH,DEFAULT);
    HPI_FSETS(   HPIC,  HRDY,DEFAULT);
    HPI_FSETS(   HPIC,  HINT,DEFAULT);
    HPI_FSETS(   HPIC,DSPINT,DEFAULT);
    HPI_FSETS(   HPIC,  HWOB,DEFAULT);

/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = HPI_RGETA(0,   HPIC);

/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    HPI_RSETA(0,   HPIC, 0);

/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = HPI_FGETA(0,   HPIC, FETCH);
    x = HPI_FGETA(0,   HPIC,  HRDY);
    x = HPI_FGETA(0,   HPIC,  HINT);
    x = HPI_FGETA(0,   HPIC,DSPINT);
    x = HPI_FGETA(0,   HPIC,  HWOB);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    HPI_FSETA(0,   HPIC, FETCH, HPI_HPIC_FETCH_DEFAULT);
    HPI_FSETA(0,   HPIC,  HRDY,  HPI_HPIC_HRDY_DEFAULT);
    HPI_FSETA(0,   HPIC,  HINT,  HPI_HPIC_HINT_DEFAULT);
    HPI_FSETA(0,   HPIC,DSPINT,HPI_HPIC_DSPINT_DEFAULT);
    HPI_FSETA(0,   HPIC,  HWOB,  HPI_HPIC_HWOB_DEFAULT);

/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    HPI_FSETSA(0,   HPIC, FETCH,DEFAULT);
    HPI_FSETSA(0,   HPIC,  HRDY,DEFAULT);
    HPI_FSETSA(0,   HPIC,  HINT,DEFAULT);
    HPI_FSETSA(0,   HPIC,DSPINT,DEFAULT);
    HPI_FSETSA(0,   HPIC,  HWOB,DEFAULT);

/*  Test FSETSA Macro end */

  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_irq(int arg) {

  #if (IRQ_SUPPORT&&IRQ_BUILD)

/*  Test FMK Macro start */
    x = IRQ_FMK(    MUXH, INTSEL15,0XFFFFFFFF);
    x = IRQ_FMK(    MUXH, INTSEL14,0XFFFFFFFF);
    x = IRQ_FMK(    MUXH, INTSEL13,0XFFFFFFFF);
    x = IRQ_FMK(    MUXH, INTSEL12,0XFFFFFFFF);
    x = IRQ_FMK(    MUXH, INTSEL11,0XFFFFFFFF);
    x = IRQ_FMK(    MUXH, INTSEL10,0XFFFFFFFF);
    x = IRQ_FMK(    MUXL,  INTSEL9,0XFFFFFFFF);
    x = IRQ_FMK(    MUXL,  INTSEL8,0XFFFFFFFF);
    x = IRQ_FMK(    MUXL,  INTSEL7,0XFFFFFFFF);
    x = IRQ_FMK(    MUXL,  INTSEL6,0XFFFFFFFF);
    x = IRQ_FMK(    MUXL,  INTSEL5,0XFFFFFFFF);
    x = IRQ_FMK(    MUXL,  INTSEL4,0XFFFFFFFF);
    x = IRQ_FMK(  EXTPOL,      XIP,0XFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = IRQ_FMKS(    MUXH, INTSEL15,DEFAULT);
    x = IRQ_FMKS(    MUXH, INTSEL14,DEFAULT);
    x = IRQ_FMKS(    MUXH, INTSEL13,DEFAULT);
    x = IRQ_FMKS(    MUXH, INTSEL12,DEFAULT);
    x = IRQ_FMKS(    MUXH, INTSEL11,DEFAULT);
    x = IRQ_FMKS(    MUXH, INTSEL10,DEFAULT);
    x = IRQ_FMKS(    MUXL,  INTSEL9,DEFAULT);
    x = IRQ_FMKS(    MUXL,  INTSEL8,DEFAULT);
    x = IRQ_FMKS(    MUXL,  INTSEL7,DEFAULT);
    x = IRQ_FMKS(    MUXL,  INTSEL6,DEFAULT);
    x = IRQ_FMKS(    MUXL,  INTSEL5,DEFAULT);
    x = IRQ_FMKS(    MUXL,  INTSEL4,DEFAULT);
    x = IRQ_FMKS(  EXTPOL,      XIP,DEFAULT);

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = IRQ_ADDR(   MUXH);
    x = IRQ_ADDR(   MUXL);
    x = IRQ_ADDR( EXTPOL);

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = IRQ_RGET(   MUXH);
    x = IRQ_RGET(   MUXL);
    x = IRQ_RGET( EXTPOL);

/*  Test RGET Macro end */
/*  Test RSET Macro start */
    IRQ_RSET(   MUXH,   IRQ_MUXH_DEFAULT);
    IRQ_RSET(   MUXL,   IRQ_MUXL_DEFAULT);
    IRQ_RSET( EXTPOL, IRQ_EXTPOL_DEFAULT);

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = IRQ_FGET(    MUXH, INTSEL15);
    x = IRQ_FGET(    MUXH, INTSEL14);
    x = IRQ_FGET(    MUXH, INTSEL13);
    x = IRQ_FGET(    MUXH, INTSEL12);
    x = IRQ_FGET(    MUXH, INTSEL11);
    x = IRQ_FGET(    MUXH, INTSEL10);
    x = IRQ_FGET(    MUXL,  INTSEL9);
    x = IRQ_FGET(    MUXL,  INTSEL8);
    x = IRQ_FGET(    MUXL,  INTSEL7);
    x = IRQ_FGET(    MUXL,  INTSEL6);
    x = IRQ_FGET(    MUXL,  INTSEL5);
    x = IRQ_FGET(    MUXL,  INTSEL4);
    x = IRQ_FGET(  EXTPOL,      XIP);

/*  Test FGET Macro end */
/*  Test FSET Macro start */
    IRQ_FSET(    MUXH, INTSEL15,IRQ_MUXH_INTSEL15_DEFAULT);
    IRQ_FSET(    MUXH, INTSEL14,IRQ_MUXH_INTSEL14_DEFAULT);
    IRQ_FSET(    MUXH, INTSEL13,IRQ_MUXH_INTSEL13_DEFAULT);
    IRQ_FSET(    MUXH, INTSEL12,IRQ_MUXH_INTSEL12_DEFAULT);
    IRQ_FSET(    MUXH, INTSEL11,IRQ_MUXH_INTSEL11_DEFAULT);
    IRQ_FSET(    MUXH, INTSEL10,IRQ_MUXH_INTSEL10_DEFAULT);
    IRQ_FSET(    MUXL,  INTSEL9, IRQ_MUXL_INTSEL9_DEFAULT);
    IRQ_FSET(    MUXL,  INTSEL8, IRQ_MUXL_INTSEL8_DEFAULT);
    IRQ_FSET(    MUXL,  INTSEL7, IRQ_MUXL_INTSEL7_DEFAULT);
    IRQ_FSET(    MUXL,  INTSEL6, IRQ_MUXL_INTSEL6_DEFAULT);
    IRQ_FSET(    MUXL,  INTSEL5, IRQ_MUXL_INTSEL5_DEFAULT);
    IRQ_FSET(    MUXL,  INTSEL4, IRQ_MUXL_INTSEL4_DEFAULT);
    IRQ_FSET(  EXTPOL,      XIP,   IRQ_EXTPOL_XIP_DEFAULT);

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    IRQ_FSETS(    MUXH, INTSEL15,DEFAULT);
    IRQ_FSETS(    MUXH, INTSEL14,DEFAULT);
    IRQ_FSETS(    MUXH, INTSEL13,DEFAULT);
    IRQ_FSETS(    MUXH, INTSEL12,DEFAULT);
    IRQ_FSETS(    MUXH, INTSEL11,DEFAULT);
    IRQ_FSETS(    MUXH, INTSEL10,DEFAULT);
    IRQ_FSETS(    MUXL,  INTSEL9,DEFAULT);
    IRQ_FSETS(    MUXL,  INTSEL8,DEFAULT);
    IRQ_FSETS(    MUXL,  INTSEL7,DEFAULT);
    IRQ_FSETS(    MUXL,  INTSEL6,DEFAULT);
    IRQ_FSETS(    MUXL,  INTSEL5,DEFAULT);
    IRQ_FSETS(    MUXL,  INTSEL4,DEFAULT);
    IRQ_FSETS(  EXTPOL,      XIP,DEFAULT);

/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = IRQ_RGETA(0,   MUXH);
    x = IRQ_RGETA(0,   MUXL);
    x = IRQ_RGETA(0, EXTPOL);

/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    IRQ_RSETA(0,   MUXH,   IRQ_MUXH_DEFAULT);
    IRQ_RSETA(0,   MUXL,   IRQ_MUXL_DEFAULT);
    IRQ_RSETA(0, EXTPOL, IRQ_EXTPOL_DEFAULT);

/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = IRQ_FGETA(0,    MUXH, INTSEL15);
    x = IRQ_FGETA(0,    MUXH, INTSEL14);
    x = IRQ_FGETA(0,    MUXH, INTSEL13);
    x = IRQ_FGETA(0,    MUXH, INTSEL12);
    x = IRQ_FGETA(0,    MUXH, INTSEL11);
    x = IRQ_FGETA(0,    MUXH, INTSEL10);
    x = IRQ_FGETA(0,    MUXL,  INTSEL9);
    x = IRQ_FGETA(0,    MUXL,  INTSEL8);
    x = IRQ_FGETA(0,    MUXL,  INTSEL7);
    x = IRQ_FGETA(0,    MUXL,  INTSEL6);
    x = IRQ_FGETA(0,    MUXL,  INTSEL5);
    x = IRQ_FGETA(0,    MUXL,  INTSEL4);
    x = IRQ_FGETA(0,  EXTPOL,      XIP);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    IRQ_FSETA(0,    MUXH, INTSEL15,IRQ_MUXH_INTSEL15_DEFAULT);
    IRQ_FSETA(0,    MUXH, INTSEL14,IRQ_MUXH_INTSEL14_DEFAULT);
    IRQ_FSETA(0,    MUXH, INTSEL13,IRQ_MUXH_INTSEL13_DEFAULT);
    IRQ_FSETA(0,    MUXH, INTSEL12,IRQ_MUXH_INTSEL12_DEFAULT);
    IRQ_FSETA(0,    MUXH, INTSEL11,IRQ_MUXH_INTSEL11_DEFAULT);
    IRQ_FSETA(0,    MUXH, INTSEL10,IRQ_MUXH_INTSEL10_DEFAULT);
    IRQ_FSETA(0,    MUXL,  INTSEL9, IRQ_MUXL_INTSEL9_DEFAULT);
    IRQ_FSETA(0,    MUXL,  INTSEL8, IRQ_MUXL_INTSEL8_DEFAULT);
    IRQ_FSETA(0,    MUXL,  INTSEL7, IRQ_MUXL_INTSEL7_DEFAULT);
    IRQ_FSETA(0,    MUXL,  INTSEL6, IRQ_MUXL_INTSEL6_DEFAULT);
    IRQ_FSETA(0,    MUXL,  INTSEL5, IRQ_MUXL_INTSEL5_DEFAULT);
    IRQ_FSETA(0,    MUXL,  INTSEL4, IRQ_MUXL_INTSEL4_DEFAULT);
    IRQ_FSETA(0,  EXTPOL,      XIP,   IRQ_EXTPOL_XIP_DEFAULT);

/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    IRQ_FSETSA(0,    MUXH, INTSEL15,DEFAULT);
    IRQ_FSETSA(0,    MUXH, INTSEL14,DEFAULT);
    IRQ_FSETSA(0,    MUXH, INTSEL13,DEFAULT);
    IRQ_FSETSA(0,    MUXH, INTSEL12,DEFAULT);
    IRQ_FSETSA(0,    MUXH, INTSEL11,DEFAULT);
    IRQ_FSETSA(0,    MUXH, INTSEL10,DEFAULT);
    IRQ_FSETSA(0,    MUXL,  INTSEL9,DEFAULT);
    IRQ_FSETSA(0,    MUXL,  INTSEL8,DEFAULT);
    IRQ_FSETSA(0,    MUXL,  INTSEL7,DEFAULT);
    IRQ_FSETSA(0,    MUXL,  INTSEL6,DEFAULT);
    IRQ_FSETSA(0,    MUXL,  INTSEL5,DEFAULT);
    IRQ_FSETSA(0,    MUXL,  INTSEL4,DEFAULT);
    IRQ_FSETSA(0,  EXTPOL,      XIP,DEFAULT);

/*  Test FSETSA Macro end */
  
  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_mcbsp(int arg) {

  #if (MCBSP_SUPPORT&&MCBSP_BUILD)

    MCBSP_Handle hMcbsp;

    hMcbsp = MCBSP_open(MCBSP_DEV1, MCBSP_OPEN_RESET);


/*  Test FMK Macro start */
    x = MCBSP_FMK( DRR,      DR,0XFFFFFFFF);
    x = MCBSP_FMK( DXR,      DX,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,    FRST,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,    GRST,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,   XINTM,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,XSYNCERR,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,  XEMPTY,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,    XRDY,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,    XRST,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,     DLB,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,   RJUST,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,  CLKSTP,0XFFFFFFFF);
#if (C11_SUPPORT)
    x = MCBSP_FMK(SPCR,   DXENA,0XFFFFFFFF);
#endif
    x = MCBSP_FMK(SPCR,   RINTM,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,RSYNCERR,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,   RFULL,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,    RRDY,0XFFFFFFFF);
    x = MCBSP_FMK(SPCR,    RRST,0XFFFFFFFF);

    x = MCBSP_FMK( RCR,  RPHASE,0XFFFFFFFF);
    x = MCBSP_FMK( RCR, RFRLEN2,0XFFFFFFFF);
    x = MCBSP_FMK( RCR, RWDLEN2,0XFFFFFFFF);
    x = MCBSP_FMK( RCR,RCOMPAND,0XFFFFFFFF);
    x = MCBSP_FMK( RCR,    RFIG,0XFFFFFFFF);
    x = MCBSP_FMK( RCR, RDATDLY,0XFFFFFFFF);
#if (C11_SUPPORT)
    x = MCBSP_FMK( RCR, RPHASE2,0XFFFFFFFF);
#endif
    x = MCBSP_FMK( RCR, RFRLEN1,0XFFFFFFFF);
    x = MCBSP_FMK( RCR, RWDLEN1,0XFFFFFFFF);
#if (C11_SUPPORT)
    x = MCBSP_FMK( RCR,RWDREVRS,0XFFFFFFFF);
#endif

    x = MCBSP_FMK( XCR,  XPHASE,0XFFFFFFFF);
    x = MCBSP_FMK( XCR, XFRLEN2,0XFFFFFFFF);
    x = MCBSP_FMK( XCR, XWDLEN2,0XFFFFFFFF);
    x = MCBSP_FMK( XCR,XCOMPAND,0XFFFFFFFF);
    x = MCBSP_FMK( XCR,    XFIG,0XFFFFFFFF);
    x = MCBSP_FMK( XCR, XDATDLY,0XFFFFFFFF);
#if (C11_SUPPORT)
    x = MCBSP_FMK( XCR, XPHASE2,0XFFFFFFFF);
#endif
    x = MCBSP_FMK( XCR, XFRLEN1,0XFFFFFFFF);
    x = MCBSP_FMK( XCR, XWDLEN1,0XFFFFFFFF);
#if (C11_SUPPORT)
    x = MCBSP_FMK( XCR,XWDREVRS,0XFFFFFFFF);
#endif

    x = MCBSP_FMK(SRGR,   GSYNC,0XFFFFFFFF);
    x = MCBSP_FMK(SRGR,   CLKSP,0XFFFFFFFF);
    x = MCBSP_FMK(SRGR,   CLKSM,0XFFFFFFFF);
    x = MCBSP_FMK(SRGR,    FSGM,0XFFFFFFFF);
    x = MCBSP_FMK(SRGR,    FPER,0XFFFFFFFF);
    x = MCBSP_FMK(SRGR,    FWID,0XFFFFFFFF);
    x = MCBSP_FMK(SRGR,  CLKGDV,0XFFFFFFFF);

    x = MCBSP_FMK( MCR,  XPBBLK,0XFFFFFFFF);
    x = MCBSP_FMK( MCR,  XPABLK,0XFFFFFFFF);
    x = MCBSP_FMK( MCR,   XCBLK,0XFFFFFFFF);
    x = MCBSP_FMK( MCR,    XMCM,0XFFFFFFFF);
    x = MCBSP_FMK( MCR,  RPBBLK,0XFFFFFFFF);
    x = MCBSP_FMK( MCR,  RPABLK,0XFFFFFFFF);
    x = MCBSP_FMK( MCR,   RCBLK,0XFFFFFFFF);
    x = MCBSP_FMK( MCR,    RMCM,0XFFFFFFFF);

    x = MCBSP_FMK(RCER,    RCEB,0XFFFFFFFF);
    x = MCBSP_FMK(RCER,    RCEA,0XFFFFFFFF);

    x = MCBSP_FMK(XCER,    XCEB,0XFFFFFFFF);
    x = MCBSP_FMK(XCER,    XCEA,0XFFFFFFFF);

    x = MCBSP_FMK( PCR,   XIOEN,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,   RIOEN,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,    FSXM,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,    FSRM,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,   CLKXM,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,   CLKRM,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,CLKSSTAT,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,  DXSTAT,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,  DRSTAT,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,    FSXP,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,    FSRP,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,   CLKXP,0XFFFFFFFF);
    x = MCBSP_FMK( PCR,   CLKRP,0XFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = MCBSP_FMKS( DRR,      DR,DEFAULT);
    x = MCBSP_FMKS( DXR,      DX,DEFAULT);
    x = MCBSP_FMKS(SPCR,    FRST,DEFAULT);
    x = MCBSP_FMKS(SPCR,    GRST,DEFAULT);
    x = MCBSP_FMKS(SPCR,   XINTM,DEFAULT);
    x = MCBSP_FMKS(SPCR,XSYNCERR,DEFAULT);
    x = MCBSP_FMKS(SPCR,  XEMPTY,DEFAULT);
    x = MCBSP_FMKS(SPCR,    XRDY,DEFAULT);
    x = MCBSP_FMKS(SPCR,    XRST,DEFAULT);
    x = MCBSP_FMKS(SPCR,     DLB,DEFAULT);
    x = MCBSP_FMKS(SPCR,   RJUST,DEFAULT);
    x = MCBSP_FMKS(SPCR,  CLKSTP,DEFAULT);
#if (C11_SUPPORT)
    x = MCBSP_FMKS(SPCR,   DXENA,DEFAULT);
#endif
    x = MCBSP_FMKS(SPCR,   RINTM,DEFAULT);
    x = MCBSP_FMKS(SPCR,RSYNCERR,DEFAULT);
    x = MCBSP_FMKS(SPCR,   RFULL,DEFAULT);
    x = MCBSP_FMKS(SPCR,    RRDY,DEFAULT);
    x = MCBSP_FMKS(SPCR,    RRST,DEFAULT);

    x = MCBSP_FMKS( RCR,  RPHASE,DEFAULT);
    x = MCBSP_FMKS( RCR, RFRLEN2,DEFAULT);
    x = MCBSP_FMKS( RCR, RWDLEN2,DEFAULT);
    x = MCBSP_FMKS( RCR,RCOMPAND,DEFAULT);
    x = MCBSP_FMKS( RCR,    RFIG,DEFAULT);
    x = MCBSP_FMKS( RCR, RDATDLY,DEFAULT);
#if (C11_SUPPORT)
    x = MCBSP_FMKS( RCR, RPHASE2,DEFAULT);
#endif
    x = MCBSP_FMKS( RCR, RFRLEN1,DEFAULT);
    x = MCBSP_FMKS( RCR, RWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    x = MCBSP_FMKS( RCR,RWDREVRS,DEFAULT);
#endif

    x = MCBSP_FMKS( XCR,  XPHASE,DEFAULT);
    x = MCBSP_FMKS( XCR, XFRLEN2,DEFAULT);
    x = MCBSP_FMKS( XCR, XWDLEN2,DEFAULT);
    x = MCBSP_FMKS( XCR,XCOMPAND,DEFAULT);
    x = MCBSP_FMKS( XCR,    XFIG,DEFAULT);
    x = MCBSP_FMKS( XCR, XDATDLY,DEFAULT);
#if (C11_SUPPORT)
    x = MCBSP_FMKS( XCR, XPHASE2,DEFAULT);
#endif
    x = MCBSP_FMKS( XCR, XFRLEN1,DEFAULT);
    x = MCBSP_FMKS( XCR, XWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    x = MCBSP_FMKS( XCR,XWDREVRS,DEFAULT);
#endif

    x = MCBSP_FMKS(SRGR,   GSYNC,DEFAULT);
    x = MCBSP_FMKS(SRGR,   CLKSP,DEFAULT);
    x = MCBSP_FMKS(SRGR,   CLKSM,DEFAULT);
    x = MCBSP_FMKS(SRGR,    FSGM,DEFAULT);
    x = MCBSP_FMKS(SRGR,    FPER,DEFAULT);
    x = MCBSP_FMKS(SRGR,    FWID,DEFAULT);
    x = MCBSP_FMKS(SRGR,  CLKGDV,DEFAULT);

    x = MCBSP_FMKS( MCR,  XPBBLK,DEFAULT);
    x = MCBSP_FMKS( MCR,  XPABLK,DEFAULT);
    x = MCBSP_FMKS( MCR,   XCBLK,DEFAULT);
    x = MCBSP_FMKS( MCR,    XMCM,DEFAULT);
    x = MCBSP_FMKS( MCR,  RPBBLK,DEFAULT);
    x = MCBSP_FMKS( MCR,  RPABLK,DEFAULT);
    x = MCBSP_FMKS( MCR,   RCBLK,DEFAULT);
    x = MCBSP_FMKS( MCR,    RMCM,DEFAULT);

    x = MCBSP_FMKS(RCER,    RCEB,DEFAULT);
    x = MCBSP_FMKS(RCER,    RCEA,DEFAULT);

    x = MCBSP_FMKS(XCER,    XCEB,DEFAULT);
    x = MCBSP_FMKS(XCER,    XCEA,DEFAULT);

    x = MCBSP_FMKS( PCR,   XIOEN,DEFAULT);
    x = MCBSP_FMKS( PCR,   RIOEN,DEFAULT);
    x = MCBSP_FMKS( PCR,    FSXM,DEFAULT);
    x = MCBSP_FMKS( PCR,    FSRM,DEFAULT);
    x = MCBSP_FMKS( PCR,   CLKXM,DEFAULT);
    x = MCBSP_FMKS( PCR,   CLKRM,DEFAULT);
    x = MCBSP_FMKS( PCR,CLKSSTAT,DEFAULT);
    x = MCBSP_FMKS( PCR,  DXSTAT,DEFAULT);
    x = MCBSP_FMKS( PCR,  DRSTAT,DEFAULT);
    x = MCBSP_FMKS( PCR,    FSXP,DEFAULT);
    x = MCBSP_FMKS( PCR,    FSRP,DEFAULT);
    x = MCBSP_FMKS( PCR,   CLKXP,DEFAULT);
    x = MCBSP_FMKS( PCR,   CLKRP,DEFAULT);

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = MCBSP_ADDR( DRR0);
    x = MCBSP_ADDR( RCR0);
    x = MCBSP_ADDR( XCR0);
    x = MCBSP_ADDR(SRGR0);
    x = MCBSP_ADDR( MCR0);
    x = MCBSP_ADDR(RCER0);
    x = MCBSP_ADDR(XCER0);
    x = MCBSP_ADDR( PCR0);

    x = MCBSP_ADDR( DRR1);
    x = MCBSP_ADDR( RCR1);
    x = MCBSP_ADDR( XCR1);
    x = MCBSP_ADDR(SRGR1);
    x = MCBSP_ADDR( MCR1);
    x = MCBSP_ADDR(RCER1);
    x = MCBSP_ADDR(XCER1);
    x = MCBSP_ADDR( PCR1);

#if (CHIP_6202|CHIP_6203)
    x = MCBSP_ADDR( DRR2);
    x = MCBSP_ADDR( RCR2);
    x = MCBSP_ADDR( XCR2);
    x = MCBSP_ADDR(SRGR2);
    x = MCBSP_ADDR( MCR2);
    x = MCBSP_ADDR(RCER2);
    x = MCBSP_ADDR(XCER2);
    x = MCBSP_ADDR( PCR2);
#endif

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = MCBSP_RGET( DRR0);
    x = MCBSP_RGET( RCR0);
    x = MCBSP_RGET( XCR0);
    x = MCBSP_RGET(SRGR0);
    x = MCBSP_RGET( MCR0);
    x = MCBSP_RGET(RCER0);
    x = MCBSP_RGET(XCER0);
    x = MCBSP_RGET( PCR0);

    x = MCBSP_RGET( DRR1);
    x = MCBSP_RGET( RCR1);
    x = MCBSP_RGET( XCR1);
    x = MCBSP_RGET(SRGR1);
    x = MCBSP_RGET( MCR1);
    x = MCBSP_RGET(RCER1);
    x = MCBSP_RGET(XCER1);
    x = MCBSP_RGET( PCR1);

#if (CHIP_6202|CHIP_6203)
    x = MCBSP_RGET( DRR2);
    x = MCBSP_RGET( RCR2);
    x = MCBSP_RGET( XCR2);
    x = MCBSP_RGET(SRGR2);
    x = MCBSP_RGET( MCR2);
    x = MCBSP_RGET(RCER2);
    x = MCBSP_RGET(XCER2);
    x = MCBSP_RGET( PCR2);
#endif

/*  Test RGET Macro end */
/*  Test RSET Macro start */
    MCBSP_RSET( DRR0,  MCBSP_DRR_DEFAULT);
    MCBSP_RSET( RCR0,  MCBSP_RCR_DEFAULT);
    MCBSP_RSET( XCR0,  MCBSP_XCR_DEFAULT);
    MCBSP_RSET(SRGR0, MCBSP_SRGR_DEFAULT);
    MCBSP_RSET( MCR0,  MCBSP_MCR_DEFAULT);
    MCBSP_RSET(RCER0, MCBSP_RCER_DEFAULT);
    MCBSP_RSET(XCER0, MCBSP_XCER_DEFAULT);
    MCBSP_RSET( PCR0,  MCBSP_PCR_DEFAULT);

    MCBSP_RSET( DRR1,  MCBSP_DRR_DEFAULT);
    MCBSP_RSET( RCR1,  MCBSP_RCR_DEFAULT);
    MCBSP_RSET( XCR1,  MCBSP_XCR_DEFAULT);
    MCBSP_RSET(SRGR1, MCBSP_SRGR_DEFAULT);
    MCBSP_RSET( MCR1,  MCBSP_MCR_DEFAULT);
    MCBSP_RSET(RCER1, MCBSP_RCER_DEFAULT);
    MCBSP_RSET(XCER1, MCBSP_XCER_DEFAULT);
    MCBSP_RSET( PCR1,  MCBSP_PCR_DEFAULT);

#if (CHIP_6202|CHIP_6203)
    MCBSP_RSET( DRR2,  MCBSP_DRR_DEFAULT);
    MCBSP_RSET( RCR2,  MCBSP_RCR_DEFAULT);
    MCBSP_RSET( XCR2,  MCBSP_XCR_DEFAULT);
    MCBSP_RSET(SRGR2, MCBSP_SRGR_DEFAULT);
    MCBSP_RSET( MCR2,  MCBSP_MCR_DEFAULT);
    MCBSP_RSET(RCER2, MCBSP_RCER_DEFAULT);
    MCBSP_RSET(XCER2, MCBSP_XCER_DEFAULT);
    MCBSP_RSET( PCR2,  MCBSP_PCR_DEFAULT);
#endif

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = MCBSP_FGET( DRR0,      DR);
    x = MCBSP_FGET( DXR0,      DX);
    x = MCBSP_FGET(SPCR0,    FRST);
    x = MCBSP_FGET(SPCR0,    GRST);
    x = MCBSP_FGET(SPCR0,   XINTM);
    x = MCBSP_FGET(SPCR0,XSYNCERR);
    x = MCBSP_FGET(SPCR0,  XEMPTY);
    x = MCBSP_FGET(SPCR0,    XRDY);
    x = MCBSP_FGET(SPCR0,    XRST);
    x = MCBSP_FGET(SPCR0,     DLB);
    x = MCBSP_FGET(SPCR0,   RJUST);
    x = MCBSP_FGET(SPCR0,  CLKSTP);
#if (C11_SUPPORT)
    x = MCBSP_FGET(SPCR0,   DXENA);
#endif
    x = MCBSP_FGET(SPCR0,   RINTM);
    x = MCBSP_FGET(SPCR0,RSYNCERR);
    x = MCBSP_FGET(SPCR0,   RFULL);
    x = MCBSP_FGET(SPCR0,    RRDY);
    x = MCBSP_FGET(SPCR0,    RRST);

    x = MCBSP_FGET( RCR0,  RPHASE);
    x = MCBSP_FGET( RCR0, RFRLEN2);
    x = MCBSP_FGET( RCR0, RWDLEN2);
    x = MCBSP_FGET( RCR0,RCOMPAND);
    x = MCBSP_FGET( RCR0,    RFIG);
    x = MCBSP_FGET( RCR0, RDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGET( RCR0, RPHASE2);
#endif
    x = MCBSP_FGET( RCR0, RFRLEN1);
    x = MCBSP_FGET( RCR0, RWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGET( RCR0,RWDREVRS);
#endif

    x = MCBSP_FGET( XCR0,  XPHASE);
    x = MCBSP_FGET( XCR0, XFRLEN2);
    x = MCBSP_FGET( XCR0, XWDLEN2);
    x = MCBSP_FGET( XCR0,XCOMPAND);
    x = MCBSP_FGET( XCR0,    XFIG);
    x = MCBSP_FGET( XCR0, XDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGET( XCR0, XPHASE2);
#endif
    x = MCBSP_FGET( XCR0, XFRLEN1);
    x = MCBSP_FGET( XCR0, XWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGET( XCR0,XWDREVRS);
#endif

    x = MCBSP_FGET(SRGR0,   GSYNC);
    x = MCBSP_FGET(SRGR0,   CLKSP);
    x = MCBSP_FGET(SRGR0,   CLKSM);
    x = MCBSP_FGET(SRGR0,    FSGM);
    x = MCBSP_FGET(SRGR0,    FPER);
    x = MCBSP_FGET(SRGR0,    FWID);
    x = MCBSP_FGET(SRGR0,  CLKGDV);

    x = MCBSP_FGET( MCR0,  XPBBLK);
    x = MCBSP_FGET( MCR0,  XPABLK);
    x = MCBSP_FGET( MCR0,   XCBLK);
    x = MCBSP_FGET( MCR0,    XMCM);
    x = MCBSP_FGET( MCR0,  RPBBLK);
    x = MCBSP_FGET( MCR0,  RPABLK);
    x = MCBSP_FGET( MCR0,   RCBLK);
    x = MCBSP_FGET( MCR0,    RMCM);

    x = MCBSP_FGET(RCER0,    RCEB);
    x = MCBSP_FGET(RCER0,    RCEA);

    x = MCBSP_FGET(XCER0,    XCEB);
    x = MCBSP_FGET(XCER0,    XCEA);

    x = MCBSP_FGET( PCR0,   XIOEN);
    x = MCBSP_FGET( PCR0,   RIOEN);
    x = MCBSP_FGET( PCR0,    FSXM);
    x = MCBSP_FGET( PCR0,    FSRM);
    x = MCBSP_FGET( PCR0,   CLKXM);
    x = MCBSP_FGET( PCR0,   CLKRM);
    x = MCBSP_FGET( PCR0,CLKSSTAT);
    x = MCBSP_FGET( PCR0,  DXSTAT);
    x = MCBSP_FGET( PCR0,  DRSTAT);
    x = MCBSP_FGET( PCR0,    FSXP);
    x = MCBSP_FGET( PCR0,    FSRP);
    x = MCBSP_FGET( PCR0,   CLKXP);
    x = MCBSP_FGET( PCR0,   CLKRP);

    x = MCBSP_FGET( DRR1,      DR);
    x = MCBSP_FGET( DXR1,      DX);
    x = MCBSP_FGET(SPCR1,    FRST);
    x = MCBSP_FGET(SPCR1,    GRST);
    x = MCBSP_FGET(SPCR1,   XINTM);
    x = MCBSP_FGET(SPCR1,XSYNCERR);
    x = MCBSP_FGET(SPCR1,  XEMPTY);
    x = MCBSP_FGET(SPCR1,    XRDY);
    x = MCBSP_FGET(SPCR1,    XRST);
    x = MCBSP_FGET(SPCR1,     DLB);
    x = MCBSP_FGET(SPCR1,   RJUST);
    x = MCBSP_FGET(SPCR1,  CLKSTP);
#if (C11_SUPPORT)
    x = MCBSP_FGET(SPCR1,   DXENA);
#endif
    x = MCBSP_FGET(SPCR1,   RINTM);
    x = MCBSP_FGET(SPCR1,RSYNCERR);
    x = MCBSP_FGET(SPCR1,   RFULL);
    x = MCBSP_FGET(SPCR1,    RRDY);
    x = MCBSP_FGET(SPCR1,    RRST);

    x = MCBSP_FGET( RCR1,  RPHASE);
    x = MCBSP_FGET( RCR1, RFRLEN2);
    x = MCBSP_FGET( RCR1, RWDLEN2);
    x = MCBSP_FGET( RCR1,RCOMPAND);
    x = MCBSP_FGET( RCR1,    RFIG);
    x = MCBSP_FGET( RCR1, RDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGET( RCR1, RPHASE2);
#endif
    x = MCBSP_FGET( RCR1, RFRLEN1);
    x = MCBSP_FGET( RCR1, RWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGET( RCR1,RWDREVRS);
#endif

    x = MCBSP_FGET( XCR1,  XPHASE);
    x = MCBSP_FGET( XCR1, XFRLEN2);
    x = MCBSP_FGET( XCR1, XWDLEN2);
    x = MCBSP_FGET( XCR1,XCOMPAND);
    x = MCBSP_FGET( XCR1,    XFIG);
    x = MCBSP_FGET( XCR1, XDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGET( XCR1, XPHASE2);
#endif
    x = MCBSP_FGET( XCR1, XFRLEN1);
    x = MCBSP_FGET( XCR1, XWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGET( XCR1,XWDREVRS);
#endif

    x = MCBSP_FGET(SRGR1,   GSYNC);
    x = MCBSP_FGET(SRGR1,   CLKSP);
    x = MCBSP_FGET(SRGR1,   CLKSM);
    x = MCBSP_FGET(SRGR1,    FSGM);
    x = MCBSP_FGET(SRGR1,    FPER);
    x = MCBSP_FGET(SRGR1,    FWID);
    x = MCBSP_FGET(SRGR1,  CLKGDV);

    x = MCBSP_FGET( MCR1,  XPBBLK);
    x = MCBSP_FGET( MCR1,  XPABLK);
    x = MCBSP_FGET( MCR1,   XCBLK);
    x = MCBSP_FGET( MCR1,    XMCM);
    x = MCBSP_FGET( MCR1,  RPBBLK);
    x = MCBSP_FGET( MCR1,  RPABLK);
    x = MCBSP_FGET( MCR1,   RCBLK);
    x = MCBSP_FGET( MCR1,    RMCM);

    x = MCBSP_FGET(RCER1,    RCEB);
    x = MCBSP_FGET(RCER1,    RCEA);

    x = MCBSP_FGET(XCER1,    XCEB);
    x = MCBSP_FGET(XCER1,    XCEA);

    x = MCBSP_FGET( PCR1,   XIOEN);
    x = MCBSP_FGET( PCR1,   RIOEN);
    x = MCBSP_FGET( PCR1,    FSXM);
    x = MCBSP_FGET( PCR1,    FSRM);
    x = MCBSP_FGET( PCR1,   CLKXM);
    x = MCBSP_FGET( PCR1,   CLKRM);
    x = MCBSP_FGET( PCR1,CLKSSTAT);
    x = MCBSP_FGET( PCR1,  DXSTAT);
    x = MCBSP_FGET( PCR1,  DRSTAT);
    x = MCBSP_FGET( PCR1,    FSXP);
    x = MCBSP_FGET( PCR1,    FSRP);
    x = MCBSP_FGET( PCR1,   CLKXP);
    x = MCBSP_FGET( PCR1,   CLKRP);

#if (CHIP_6202 | CHIP_6203)
    x = MCBSP_FGET( DRR2,      DR);
    x = MCBSP_FGET( DXR2,      DX);
    x = MCBSP_FGET(SPCR2,    FRST);
    x = MCBSP_FGET(SPCR2,    GRST);
    x = MCBSP_FGET(SPCR2,   XINTM);
    x = MCBSP_FGET(SPCR2,XSYNCERR);
    x = MCBSP_FGET(SPCR2,  XEMPTY);
    x = MCBSP_FGET(SPCR2,    XRDY);
    x = MCBSP_FGET(SPCR2,    XRST);
    x = MCBSP_FGET(SPCR2,     DLB);
    x = MCBSP_FGET(SPCR2,   RJUST);
    x = MCBSP_FGET(SPCR2,  CLKSTP);
#if (C11_SUPPORT)
    x = MCBSP_FGET(SPCR2,   DXENA);
#endif
    x = MCBSP_FGET(SPCR2,   RINTM);
    x = MCBSP_FGET(SPCR2,RSYNCERR);
    x = MCBSP_FGET(SPCR2,   RFULL);
    x = MCBSP_FGET(SPCR2,    RRDY);
    x = MCBSP_FGET(SPCR2,    RRST);

    x = MCBSP_FGET( RCR2,  RPHASE);
    x = MCBSP_FGET( RCR2, RFRLEN2);
    x = MCBSP_FGET( RCR2, RWDLEN2);
    x = MCBSP_FGET( RCR2,RCOMPAND);
    x = MCBSP_FGET( RCR2,    RFIG);
    x = MCBSP_FGET( RCR2, RDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGET( RCR2, RPHASE2);
#endif
    x = MCBSP_FGET( RCR2, RFRLEN1);
    x = MCBSP_FGET( RCR2, RWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGET( RCR2,RWDREVRS);
#endif

    x = MCBSP_FGET( XCR2,  XPHASE);
    x = MCBSP_FGET( XCR2, XFRLEN2);
    x = MCBSP_FGET( XCR2, XWDLEN2);
    x = MCBSP_FGET( XCR2,XCOMPAND);
    x = MCBSP_FGET( XCR2,    XFIG);
    x = MCBSP_FGET( XCR2, XDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGET( XCR2, XPHASE2);
#endif
    x = MCBSP_FGET( XCR2, XFRLEN1);
    x = MCBSP_FGET( XCR2, XWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGET( XCR2,XWDREVRS);
#endif

    x = MCBSP_FGET(SRGR2,   GSYNC);
    x = MCBSP_FGET(SRGR2,   CLKSP);
    x = MCBSP_FGET(SRGR2,   CLKSM);
    x = MCBSP_FGET(SRGR2,    FSGM);
    x = MCBSP_FGET(SRGR2,    FPER);
    x = MCBSP_FGET(SRGR2,    FWID);
    x = MCBSP_FGET(SRGR2,  CLKGDV);

    x = MCBSP_FGET( MCR2,  XPBBLK);
    x = MCBSP_FGET( MCR2,  XPABLK);
    x = MCBSP_FGET( MCR2,   XCBLK);
    x = MCBSP_FGET( MCR2,    XMCM);
    x = MCBSP_FGET( MCR2,  RPBBLK);
    x = MCBSP_FGET( MCR2,  RPABLK);
    x = MCBSP_FGET( MCR2,   RCBLK);
    x = MCBSP_FGET( MCR2,    RMCM);

    x = MCBSP_FGET(RCER2,    RCEB);
    x = MCBSP_FGET(RCER2,    RCEA);

    x = MCBSP_FGET(XCER2,    XCEB);
    x = MCBSP_FGET(XCER2,    XCEA);

    x = MCBSP_FGET( PCR2,   XIOEN);
    x = MCBSP_FGET( PCR2,   RIOEN);
    x = MCBSP_FGET( PCR2,    FSXM);
    x = MCBSP_FGET( PCR2,    FSRM);
    x = MCBSP_FGET( PCR2,   CLKXM);
    x = MCBSP_FGET( PCR2,   CLKRM);
    x = MCBSP_FGET( PCR2,CLKSSTAT);
    x = MCBSP_FGET( PCR2,  DXSTAT);
    x = MCBSP_FGET( PCR2,  DRSTAT);
    x = MCBSP_FGET( PCR2,    FSXP);
    x = MCBSP_FGET( PCR2,    FSRP);
    x = MCBSP_FGET( PCR2,   CLKXP);
    x = MCBSP_FGET( PCR2,   CLKRP);
#endif


/*  Test FGET Macro end */
/*  Test FSET Macro start */
    MCBSP_FSET( DRR0,      DR,        MCBSP_DRR_DR_DEFAULT);
    MCBSP_FSET( DXR0,      DX,        MCBSP_DXR_DX_DEFAULT);
    MCBSP_FSET(SPCR0,    FRST,     MCBSP_SPCR_FRST_DEFAULT);
    MCBSP_FSET(SPCR0,    GRST,     MCBSP_SPCR_GRST_DEFAULT);
    MCBSP_FSET(SPCR0,   XINTM,    MCBSP_SPCR_XINTM_DEFAULT);
    MCBSP_FSET(SPCR0,XSYNCERR, MCBSP_SPCR_XSYNCERR_DEFAULT);
    MCBSP_FSET(SPCR0,  XEMPTY,   MCBSP_SPCR_XEMPTY_DEFAULT);
    MCBSP_FSET(SPCR0,    XRDY,     MCBSP_SPCR_XRDY_DEFAULT);
    MCBSP_FSET(SPCR0,    XRST,     MCBSP_SPCR_XRST_DEFAULT);
    MCBSP_FSET(SPCR0,     DLB,      MCBSP_SPCR_DLB_DEFAULT);
    MCBSP_FSET(SPCR0,   RJUST,    MCBSP_SPCR_RJUST_DEFAULT);
    MCBSP_FSET(SPCR0,  CLKSTP,   MCBSP_SPCR_CLKSTP_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET(SPCR0,   DXENA,    MCBSP_SPCR_DXENA_DEFAULT);
#endif
    MCBSP_FSET(SPCR0,   RINTM,    MCBSP_SPCR_RINTM_DEFAULT);
    MCBSP_FSET(SPCR0,RSYNCERR, MCBSP_SPCR_RSYNCERR_DEFAULT);
    MCBSP_FSET(SPCR0,   RFULL,    MCBSP_SPCR_RFULL_DEFAULT);
    MCBSP_FSET(SPCR0,    RRDY,     MCBSP_SPCR_RRDY_DEFAULT);
    MCBSP_FSET(SPCR0,    RRST,     MCBSP_SPCR_RRST_DEFAULT);

    MCBSP_FSET( RCR0,  RPHASE,    MCBSP_RCR_RPHASE_DEFAULT);
    MCBSP_FSET( RCR0, RFRLEN2,   MCBSP_RCR_RFRLEN2_DEFAULT);
    MCBSP_FSET( RCR0, RWDLEN2,   MCBSP_RCR_RWDLEN2_DEFAULT);
    MCBSP_FSET( RCR0,RCOMPAND,  MCBSP_RCR_RCOMPAND_DEFAULT);
    MCBSP_FSET( RCR0,    RFIG,      MCBSP_RCR_RFIG_DEFAULT);
    MCBSP_FSET( RCR0, RDATDLY,   MCBSP_RCR_RDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( RCR0, RPHASE2,   MCBSP_RCR_RPHASE2_DEFAULT);
#endif
    MCBSP_FSET( RCR0, RFRLEN1,   MCBSP_RCR_RFRLEN1_DEFAULT);
    MCBSP_FSET( RCR0, RWDLEN1,   MCBSP_RCR_RWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( RCR0,RWDREVRS,  MCBSP_RCR_RWDREVRS_DEFAULT);
#endif

    MCBSP_FSET( XCR0,  XPHASE,    MCBSP_XCR_XPHASE_DEFAULT);
    MCBSP_FSET( XCR0, XFRLEN2,   MCBSP_XCR_XFRLEN2_DEFAULT);
    MCBSP_FSET( XCR0, XWDLEN2,   MCBSP_XCR_XWDLEN2_DEFAULT);
    MCBSP_FSET( XCR0,XCOMPAND,  MCBSP_XCR_XCOMPAND_DEFAULT);
    MCBSP_FSET( XCR0,    XFIG,      MCBSP_XCR_XFIG_DEFAULT);
    MCBSP_FSET( XCR0, XDATDLY,   MCBSP_XCR_XDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( XCR0, XPHASE2,   MCBSP_XCR_XPHASE2_DEFAULT);
#endif
    MCBSP_FSET( XCR0, XFRLEN1,   MCBSP_XCR_XFRLEN1_DEFAULT);
    MCBSP_FSET( XCR0, XWDLEN1,   MCBSP_XCR_XWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( XCR0,XWDREVRS,  MCBSP_XCR_XWDREVRS_DEFAULT);
#endif

    MCBSP_FSET(SRGR0,   GSYNC,    MCBSP_SRGR_GSYNC_DEFAULT);
    MCBSP_FSET(SRGR0,   CLKSP,    MCBSP_SRGR_CLKSP_DEFAULT);
    MCBSP_FSET(SRGR0,   CLKSM,    MCBSP_SRGR_CLKSM_DEFAULT);
    MCBSP_FSET(SRGR0,    FSGM,     MCBSP_SRGR_FSGM_DEFAULT);
    MCBSP_FSET(SRGR0,    FPER,     MCBSP_SRGR_FPER_DEFAULT);
    MCBSP_FSET(SRGR0,    FWID,     MCBSP_SRGR_FWID_DEFAULT);
    MCBSP_FSET(SRGR0,  CLKGDV,   MCBSP_SRGR_CLKGDV_DEFAULT);

    MCBSP_FSET( MCR0,  XPBBLK,    MCBSP_MCR_XPBBLK_DEFAULT);
    MCBSP_FSET( MCR0,  XPABLK,    MCBSP_MCR_XPABLK_DEFAULT);
    MCBSP_FSET( MCR0,   XCBLK,     MCBSP_MCR_XCBLK_DEFAULT);
    MCBSP_FSET( MCR0,    XMCM,      MCBSP_MCR_XMCM_DEFAULT);
    MCBSP_FSET( MCR0,  RPBBLK,    MCBSP_MCR_RPBBLK_DEFAULT);
    MCBSP_FSET( MCR0,  RPABLK,    MCBSP_MCR_RPABLK_DEFAULT);
    MCBSP_FSET( MCR0,   RCBLK,     MCBSP_MCR_RCBLK_DEFAULT);
    MCBSP_FSET( MCR0,    RMCM,      MCBSP_MCR_RMCM_DEFAULT);

    MCBSP_FSET(RCER0,    RCEB,     MCBSP_RCER_RCEB_DEFAULT);
    MCBSP_FSET(RCER0,    RCEA,     MCBSP_RCER_RCEA_DEFAULT);

    MCBSP_FSET(XCER0,    XCEB,     MCBSP_XCER_XCEB_DEFAULT);
    MCBSP_FSET(XCER0,    XCEA,     MCBSP_XCER_XCEA_DEFAULT);

    MCBSP_FSET( PCR0,   XIOEN,     MCBSP_PCR_XIOEN_DEFAULT);
    MCBSP_FSET( PCR0,   RIOEN,     MCBSP_PCR_RIOEN_DEFAULT);
    MCBSP_FSET( PCR0,    FSXM,      MCBSP_PCR_FSXM_DEFAULT);
    MCBSP_FSET( PCR0,    FSRM,      MCBSP_PCR_FSRM_DEFAULT);
    MCBSP_FSET( PCR0,   CLKXM,     MCBSP_PCR_CLKXM_DEFAULT);
    MCBSP_FSET( PCR0,   CLKRM,     MCBSP_PCR_CLKRM_DEFAULT);
    MCBSP_FSET( PCR0,CLKSSTAT,  MCBSP_PCR_CLKSSTAT_DEFAULT);
    MCBSP_FSET( PCR0,  DXSTAT,    MCBSP_PCR_DXSTAT_DEFAULT);
    MCBSP_FSET( PCR0,  DRSTAT,    MCBSP_PCR_DRSTAT_DEFAULT);
    MCBSP_FSET( PCR0,    FSXP,      MCBSP_PCR_FSXP_DEFAULT);
    MCBSP_FSET( PCR0,    FSRP,      MCBSP_PCR_FSRP_DEFAULT);
    MCBSP_FSET( PCR0,   CLKXP,     MCBSP_PCR_CLKXP_DEFAULT);
    MCBSP_FSET( PCR0,   CLKRP,     MCBSP_PCR_CLKRP_DEFAULT);

    MCBSP_FSET( DRR1,      DR,        MCBSP_DRR_DR_DEFAULT);
    MCBSP_FSET( DXR1,      DX,        MCBSP_DXR_DX_DEFAULT);
    MCBSP_FSET(SPCR1,    FRST,     MCBSP_SPCR_FRST_DEFAULT);
    MCBSP_FSET(SPCR1,    GRST,     MCBSP_SPCR_GRST_DEFAULT);
    MCBSP_FSET(SPCR1,   XINTM,    MCBSP_SPCR_XINTM_DEFAULT);
    MCBSP_FSET(SPCR1,XSYNCERR, MCBSP_SPCR_XSYNCERR_DEFAULT);
    MCBSP_FSET(SPCR1,  XEMPTY,   MCBSP_SPCR_XEMPTY_DEFAULT);
    MCBSP_FSET(SPCR1,    XRDY,     MCBSP_SPCR_XRDY_DEFAULT);
    MCBSP_FSET(SPCR1,    XRST,     MCBSP_SPCR_XRST_DEFAULT);
    MCBSP_FSET(SPCR1,     DLB,      MCBSP_SPCR_DLB_DEFAULT);
    MCBSP_FSET(SPCR1,   RJUST,    MCBSP_SPCR_RJUST_DEFAULT);
    MCBSP_FSET(SPCR1,  CLKSTP,   MCBSP_SPCR_CLKSTP_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET(SPCR1,   DXENA,    MCBSP_SPCR_DXENA_DEFAULT);
#endif
    MCBSP_FSET(SPCR1,   RINTM,    MCBSP_SPCR_RINTM_DEFAULT);
    MCBSP_FSET(SPCR1,RSYNCERR, MCBSP_SPCR_RSYNCERR_DEFAULT);
    MCBSP_FSET(SPCR1,   RFULL,    MCBSP_SPCR_RFULL_DEFAULT);
    MCBSP_FSET(SPCR1,    RRDY,     MCBSP_SPCR_RRDY_DEFAULT);
    MCBSP_FSET(SPCR1,    RRST,     MCBSP_SPCR_RRST_DEFAULT);

    MCBSP_FSET( RCR1,  RPHASE,    MCBSP_RCR_RPHASE_DEFAULT);
    MCBSP_FSET( RCR1, RFRLEN2,   MCBSP_RCR_RFRLEN2_DEFAULT);
    MCBSP_FSET( RCR1, RWDLEN2,   MCBSP_RCR_RWDLEN2_DEFAULT);
    MCBSP_FSET( RCR1,RCOMPAND,  MCBSP_RCR_RCOMPAND_DEFAULT);
    MCBSP_FSET( RCR1,    RFIG,      MCBSP_RCR_RFIG_DEFAULT);
    MCBSP_FSET( RCR1, RDATDLY,   MCBSP_RCR_RDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( RCR1, RPHASE2,   MCBSP_RCR_RPHASE2_DEFAULT);
#endif
    MCBSP_FSET( RCR1, RFRLEN1,   MCBSP_RCR_RFRLEN1_DEFAULT);
    MCBSP_FSET( RCR1, RWDLEN1,   MCBSP_RCR_RWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( RCR1,RWDREVRS,  MCBSP_RCR_RWDREVRS_DEFAULT);
#endif

    MCBSP_FSET( XCR1,  XPHASE,    MCBSP_XCR_XPHASE_DEFAULT);
    MCBSP_FSET( XCR1, XFRLEN2,   MCBSP_XCR_XFRLEN2_DEFAULT);
    MCBSP_FSET( XCR1, XWDLEN2,   MCBSP_XCR_XWDLEN2_DEFAULT);
    MCBSP_FSET( XCR1,XCOMPAND,  MCBSP_XCR_XCOMPAND_DEFAULT);
    MCBSP_FSET( XCR1,    XFIG,      MCBSP_XCR_XFIG_DEFAULT);
    MCBSP_FSET( XCR1, XDATDLY,   MCBSP_XCR_XDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( XCR1, XPHASE2,   MCBSP_XCR_XPHASE2_DEFAULT);
#endif
    MCBSP_FSET( XCR1, XFRLEN1,   MCBSP_XCR_XFRLEN1_DEFAULT);
    MCBSP_FSET( XCR1, XWDLEN1,   MCBSP_XCR_XWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( XCR1,XWDREVRS,  MCBSP_XCR_XWDREVRS_DEFAULT);
#endif

    MCBSP_FSET(SRGR1,   GSYNC,    MCBSP_SRGR_GSYNC_DEFAULT);
    MCBSP_FSET(SRGR1,   CLKSP,    MCBSP_SRGR_CLKSP_DEFAULT);
    MCBSP_FSET(SRGR1,   CLKSM,    MCBSP_SRGR_CLKSM_DEFAULT);
    MCBSP_FSET(SRGR1,    FSGM,     MCBSP_SRGR_FSGM_DEFAULT);
    MCBSP_FSET(SRGR1,    FPER,     MCBSP_SRGR_FPER_DEFAULT);
    MCBSP_FSET(SRGR1,    FWID,     MCBSP_SRGR_FWID_DEFAULT);
    MCBSP_FSET(SRGR1,  CLKGDV,   MCBSP_SRGR_CLKGDV_DEFAULT);

    MCBSP_FSET( MCR1,  XPBBLK,    MCBSP_MCR_XPBBLK_DEFAULT);
    MCBSP_FSET( MCR1,  XPABLK,    MCBSP_MCR_XPABLK_DEFAULT);
    MCBSP_FSET( MCR1,   XCBLK,     MCBSP_MCR_XCBLK_DEFAULT);
    MCBSP_FSET( MCR1,    XMCM,      MCBSP_MCR_XMCM_DEFAULT);
    MCBSP_FSET( MCR1,  RPBBLK,    MCBSP_MCR_RPBBLK_DEFAULT);
    MCBSP_FSET( MCR1,  RPABLK,    MCBSP_MCR_RPABLK_DEFAULT);
    MCBSP_FSET( MCR1,   RCBLK,     MCBSP_MCR_RCBLK_DEFAULT);
    MCBSP_FSET( MCR1,    RMCM,      MCBSP_MCR_RMCM_DEFAULT);

    MCBSP_FSET(RCER1,    RCEB,     MCBSP_RCER_RCEB_DEFAULT);
    MCBSP_FSET(RCER1,    RCEA,     MCBSP_RCER_RCEA_DEFAULT);

    MCBSP_FSET(XCER1,    XCEB,     MCBSP_XCER_XCEB_DEFAULT);
    MCBSP_FSET(XCER1,    XCEA,     MCBSP_XCER_XCEA_DEFAULT);

    MCBSP_FSET( PCR1,   XIOEN,     MCBSP_PCR_XIOEN_DEFAULT);
    MCBSP_FSET( PCR1,   RIOEN,     MCBSP_PCR_RIOEN_DEFAULT);
    MCBSP_FSET( PCR1,    FSXM,      MCBSP_PCR_FSXM_DEFAULT);
    MCBSP_FSET( PCR1,    FSRM,      MCBSP_PCR_FSRM_DEFAULT);
    MCBSP_FSET( PCR1,   CLKXM,     MCBSP_PCR_CLKXM_DEFAULT);
    MCBSP_FSET( PCR1,   CLKRM,     MCBSP_PCR_CLKRM_DEFAULT);
    MCBSP_FSET( PCR1,CLKSSTAT,  MCBSP_PCR_CLKSSTAT_DEFAULT);
    MCBSP_FSET( PCR1,  DXSTAT,    MCBSP_PCR_DXSTAT_DEFAULT);
    MCBSP_FSET( PCR1,  DRSTAT,    MCBSP_PCR_DRSTAT_DEFAULT);
    MCBSP_FSET( PCR1,    FSXP,      MCBSP_PCR_FSXP_DEFAULT);
    MCBSP_FSET( PCR1,    FSRP,      MCBSP_PCR_FSRP_DEFAULT);
    MCBSP_FSET( PCR1,   CLKXP,     MCBSP_PCR_CLKXP_DEFAULT);
    MCBSP_FSET( PCR1,   CLKRP,     MCBSP_PCR_CLKRP_DEFAULT);

#if (CHIP_6202 | CHIP_6203)
    MCBSP_FSET( DRR2,      DR,        MCBSP_DRR_DR_DEFAULT);
    MCBSP_FSET( DXR2,      DX,        MCBSP_DXR_DX_DEFAULT);
    MCBSP_FSET(SPCR2,    FRST,     MCBSP_SPCR_FRST_DEFAULT);
    MCBSP_FSET(SPCR2,    GRST,     MCBSP_SPCR_GRST_DEFAULT);
    MCBSP_FSET(SPCR2,   XINTM,    MCBSP_SPCR_XINTM_DEFAULT);
    MCBSP_FSET(SPCR2,XSYNCERR, MCBSP_SPCR_XSYNCERR_DEFAULT);
    MCBSP_FSET(SPCR2,  XEMPTY,   MCBSP_SPCR_XEMPTY_DEFAULT);
    MCBSP_FSET(SPCR2,    XRDY,     MCBSP_SPCR_XRDY_DEFAULT);
    MCBSP_FSET(SPCR2,    XRST,     MCBSP_SPCR_XRST_DEFAULT);
    MCBSP_FSET(SPCR2,     DLB,      MCBSP_SPCR_DLB_DEFAULT);
    MCBSP_FSET(SPCR2,   RJUST,    MCBSP_SPCR_RJUST_DEFAULT);
    MCBSP_FSET(SPCR2,  CLKSTP,   MCBSP_SPCR_CLKSTP_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET(SPCR2,   DXENA,    MCBSP_SPCR_DXENA_DEFAULT);
#endif
    MCBSP_FSET(SPCR2,   RINTM,    MCBSP_SPCR_RINTM_DEFAULT);
    MCBSP_FSET(SPCR2,RSYNCERR, MCBSP_SPCR_RSYNCERR_DEFAULT);
    MCBSP_FSET(SPCR2,   RFULL,    MCBSP_SPCR_RFULL_DEFAULT);
    MCBSP_FSET(SPCR2,    RRDY,     MCBSP_SPCR_RRDY_DEFAULT);
    MCBSP_FSET(SPCR2,    RRST,     MCBSP_SPCR_RRST_DEFAULT);

    MCBSP_FSET( RCR2,  RPHASE,    MCBSP_RCR_RPHASE_DEFAULT);
    MCBSP_FSET( RCR2, RFRLEN2,   MCBSP_RCR_RFRLEN2_DEFAULT);
    MCBSP_FSET( RCR2, RWDLEN2,   MCBSP_RCR_RWDLEN2_DEFAULT);
    MCBSP_FSET( RCR2,RCOMPAND,  MCBSP_RCR_RCOMPAND_DEFAULT);
    MCBSP_FSET( RCR2,    RFIG,      MCBSP_RCR_RFIG_DEFAULT);
    MCBSP_FSET( RCR2, RDATDLY,   MCBSP_RCR_RDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( RCR2, RPHASE2,   MCBSP_RCR_RPHASE2_DEFAULT);
#endif
    MCBSP_FSET( RCR2, RFRLEN1,   MCBSP_RCR_RFRLEN1_DEFAULT);
    MCBSP_FSET( RCR2, RWDLEN1,   MCBSP_RCR_RWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( RCR2,RWDREVRS,  MCBSP_RCR_RWDREVRS_DEFAULT);
#endif

    MCBSP_FSET( XCR2,  XPHASE,    MCBSP_XCR_XPHASE_DEFAULT);
    MCBSP_FSET( XCR2, XFRLEN2,   MCBSP_XCR_XFRLEN2_DEFAULT);
    MCBSP_FSET( XCR2, XWDLEN2,   MCBSP_XCR_XWDLEN2_DEFAULT);
    MCBSP_FSET( XCR2,XCOMPAND,  MCBSP_XCR_XCOMPAND_DEFAULT);
    MCBSP_FSET( XCR2,    XFIG,      MCBSP_XCR_XFIG_DEFAULT);
    MCBSP_FSET( XCR2, XDATDLY,   MCBSP_XCR_XDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( XCR2, XPHASE2,   MCBSP_XCR_XPHASE2_DEFAULT);
#endif
    MCBSP_FSET( XCR2, XFRLEN1,   MCBSP_XCR_XFRLEN1_DEFAULT);
    MCBSP_FSET( XCR2, XWDLEN1,   MCBSP_XCR_XWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSET( XCR2,XWDREVRS,  MCBSP_XCR_XWDREVRS_DEFAULT);
#endif

    MCBSP_FSET(SRGR2,   GSYNC,    MCBSP_SRGR_GSYNC_DEFAULT);
    MCBSP_FSET(SRGR2,   CLKSP,    MCBSP_SRGR_CLKSP_DEFAULT);
    MCBSP_FSET(SRGR2,   CLKSM,    MCBSP_SRGR_CLKSM_DEFAULT);
    MCBSP_FSET(SRGR2,    FSGM,     MCBSP_SRGR_FSGM_DEFAULT);
    MCBSP_FSET(SRGR2,    FPER,     MCBSP_SRGR_FPER_DEFAULT);
    MCBSP_FSET(SRGR2,    FWID,     MCBSP_SRGR_FWID_DEFAULT);
    MCBSP_FSET(SRGR2,  CLKGDV,   MCBSP_SRGR_CLKGDV_DEFAULT);

    MCBSP_FSET( MCR2,  XPBBLK,    MCBSP_MCR_XPBBLK_DEFAULT);
    MCBSP_FSET( MCR2,  XPABLK,    MCBSP_MCR_XPABLK_DEFAULT);
    MCBSP_FSET( MCR2,   XCBLK,     MCBSP_MCR_XCBLK_DEFAULT);
    MCBSP_FSET( MCR2,    XMCM,      MCBSP_MCR_XMCM_DEFAULT);
    MCBSP_FSET( MCR2,  RPBBLK,    MCBSP_MCR_RPBBLK_DEFAULT);
    MCBSP_FSET( MCR2,  RPABLK,    MCBSP_MCR_RPABLK_DEFAULT);
    MCBSP_FSET( MCR2,   RCBLK,     MCBSP_MCR_RCBLK_DEFAULT);
    MCBSP_FSET( MCR2,    RMCM,      MCBSP_MCR_RMCM_DEFAULT);

    MCBSP_FSET(RCER2,    RCEB,     MCBSP_RCER_RCEB_DEFAULT);
    MCBSP_FSET(RCER2,    RCEA,     MCBSP_RCER_RCEA_DEFAULT);

    MCBSP_FSET(XCER2,    XCEB,     MCBSP_XCER_XCEB_DEFAULT);
    MCBSP_FSET(XCER2,    XCEA,     MCBSP_XCER_XCEA_DEFAULT);

    MCBSP_FSET( PCR2,   XIOEN,     MCBSP_PCR_XIOEN_DEFAULT);
    MCBSP_FSET( PCR2,   RIOEN,     MCBSP_PCR_RIOEN_DEFAULT);
    MCBSP_FSET( PCR2,    FSXM,      MCBSP_PCR_FSXM_DEFAULT);
    MCBSP_FSET( PCR2,    FSRM,      MCBSP_PCR_FSRM_DEFAULT);
    MCBSP_FSET( PCR2,   CLKXM,     MCBSP_PCR_CLKXM_DEFAULT);
    MCBSP_FSET( PCR2,   CLKRM,     MCBSP_PCR_CLKRM_DEFAULT);
    MCBSP_FSET( PCR2,CLKSSTAT,  MCBSP_PCR_CLKSSTAT_DEFAULT);
    MCBSP_FSET( PCR2,  DXSTAT,    MCBSP_PCR_DXSTAT_DEFAULT);
    MCBSP_FSET( PCR2,  DRSTAT,    MCBSP_PCR_DRSTAT_DEFAULT);
    MCBSP_FSET( PCR2,    FSXP,      MCBSP_PCR_FSXP_DEFAULT);
    MCBSP_FSET( PCR2,    FSRP,      MCBSP_PCR_FSRP_DEFAULT);
    MCBSP_FSET( PCR2,   CLKXP,     MCBSP_PCR_CLKXP_DEFAULT);
    MCBSP_FSET( PCR2,   CLKRP,     MCBSP_PCR_CLKRP_DEFAULT);
#endif


/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    MCBSP_FSETS( DRR0,      DR,DEFAULT);
    MCBSP_FSETS( DXR0,      DX,DEFAULT);
    MCBSP_FSETS(SPCR0,    FRST,DEFAULT);
    MCBSP_FSETS(SPCR0,    GRST,DEFAULT);
    MCBSP_FSETS(SPCR0,   XINTM,DEFAULT);
    MCBSP_FSETS(SPCR0,XSYNCERR,DEFAULT);
    MCBSP_FSETS(SPCR0,  XEMPTY,DEFAULT);
    MCBSP_FSETS(SPCR0,    XRDY,DEFAULT);
    MCBSP_FSETS(SPCR0,    XRST,DEFAULT);
    MCBSP_FSETS(SPCR0,     DLB,DEFAULT);
    MCBSP_FSETS(SPCR0,   RJUST,DEFAULT);
    MCBSP_FSETS(SPCR0,  CLKSTP,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS(SPCR0,   DXENA,DEFAULT);
#endif
    MCBSP_FSETS(SPCR0,   RINTM,DEFAULT);
    MCBSP_FSETS(SPCR0,RSYNCERR,DEFAULT);
    MCBSP_FSETS(SPCR0,   RFULL,DEFAULT);
    MCBSP_FSETS(SPCR0,    RRDY,DEFAULT);
    MCBSP_FSETS(SPCR0,    RRST,DEFAULT);

    MCBSP_FSETS( RCR0,  RPHASE,DEFAULT);
    MCBSP_FSETS( RCR0, RFRLEN2,DEFAULT);
    MCBSP_FSETS( RCR0, RWDLEN2,DEFAULT);
    MCBSP_FSETS( RCR0,RCOMPAND,DEFAULT);
    MCBSP_FSETS( RCR0,    RFIG,DEFAULT);
    MCBSP_FSETS( RCR0, RDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( RCR0, RPHASE2,DEFAULT);
#endif
    MCBSP_FSETS( RCR0, RFRLEN1,DEFAULT);
    MCBSP_FSETS( RCR0, RWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( RCR0,RWDREVRS,DEFAULT);
#endif

    MCBSP_FSETS( XCR0,  XPHASE,DEFAULT);
    MCBSP_FSETS( XCR0, XFRLEN2,DEFAULT);
    MCBSP_FSETS( XCR0, XWDLEN2,DEFAULT);
    MCBSP_FSETS( XCR0,XCOMPAND,DEFAULT);
    MCBSP_FSETS( XCR0,    XFIG,DEFAULT);
    MCBSP_FSETS( XCR0, XDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( XCR0, XPHASE2,DEFAULT);
#endif
    MCBSP_FSETS( XCR0, XFRLEN1,DEFAULT);
    MCBSP_FSETS( XCR0, XWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( XCR0,XWDREVRS,DEFAULT);
#endif

    MCBSP_FSETS(SRGR0,   GSYNC,DEFAULT);
    MCBSP_FSETS(SRGR0,   CLKSP,DEFAULT);
    MCBSP_FSETS(SRGR0,   CLKSM,DEFAULT);
    MCBSP_FSETS(SRGR0,    FSGM,DEFAULT);
    MCBSP_FSETS(SRGR0,    FPER,DEFAULT);
    MCBSP_FSETS(SRGR0,    FWID,DEFAULT);
    MCBSP_FSETS(SRGR0,  CLKGDV,DEFAULT);

    MCBSP_FSETS( MCR0,  XPBBLK,DEFAULT);
    MCBSP_FSETS( MCR0,  XPABLK,DEFAULT);
    MCBSP_FSETS( MCR0,   XCBLK,DEFAULT);
    MCBSP_FSETS( MCR0,    XMCM,DEFAULT);
    MCBSP_FSETS( MCR0,  RPBBLK,DEFAULT);
    MCBSP_FSETS( MCR0,  RPABLK,DEFAULT);
    MCBSP_FSETS( MCR0,   RCBLK,DEFAULT);
    MCBSP_FSETS( MCR0,    RMCM,DEFAULT);

    MCBSP_FSETS(RCER0,    RCEB,DEFAULT);
    MCBSP_FSETS(RCER0,    RCEA,DEFAULT);

    MCBSP_FSETS(XCER0,    XCEB,DEFAULT);
    MCBSP_FSETS(XCER0,    XCEA,DEFAULT);

    MCBSP_FSETS( PCR0,   XIOEN,DEFAULT);
    MCBSP_FSETS( PCR0,   RIOEN,DEFAULT);
    MCBSP_FSETS( PCR0,    FSXM,DEFAULT);
    MCBSP_FSETS( PCR0,    FSRM,DEFAULT);
    MCBSP_FSETS( PCR0,   CLKXM,DEFAULT);
    MCBSP_FSETS( PCR0,   CLKRM,DEFAULT);
    MCBSP_FSETS( PCR0,CLKSSTAT,DEFAULT);
    MCBSP_FSETS( PCR0,  DXSTAT,DEFAULT);
    MCBSP_FSETS( PCR0,  DRSTAT,DEFAULT);
    MCBSP_FSETS( PCR0,    FSXP,DEFAULT);
    MCBSP_FSETS( PCR0,    FSRP,DEFAULT);
    MCBSP_FSETS( PCR0,   CLKXP,DEFAULT);
    MCBSP_FSETS( PCR0,   CLKRP,DEFAULT);

    MCBSP_FSETS( DRR1,      DR,DEFAULT);
    MCBSP_FSETS( DXR1,      DX,DEFAULT);
    MCBSP_FSETS(SPCR1,    FRST,DEFAULT);
    MCBSP_FSETS(SPCR1,    GRST,DEFAULT);
    MCBSP_FSETS(SPCR1,   XINTM,DEFAULT);
    MCBSP_FSETS(SPCR1,XSYNCERR,DEFAULT);
    MCBSP_FSETS(SPCR1,  XEMPTY,DEFAULT);
    MCBSP_FSETS(SPCR1,    XRDY,DEFAULT);
    MCBSP_FSETS(SPCR1,    XRST,DEFAULT);
    MCBSP_FSETS(SPCR1,     DLB,DEFAULT);
    MCBSP_FSETS(SPCR1,   RJUST,DEFAULT);
    MCBSP_FSETS(SPCR1,  CLKSTP,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS(SPCR1,   DXENA,DEFAULT);
#endif
    MCBSP_FSETS(SPCR1,   RINTM,DEFAULT);
    MCBSP_FSETS(SPCR1,RSYNCERR,DEFAULT);
    MCBSP_FSETS(SPCR1,   RFULL,DEFAULT);
    MCBSP_FSETS(SPCR1,    RRDY,DEFAULT);
    MCBSP_FSETS(SPCR1,    RRST,DEFAULT);

    MCBSP_FSETS( RCR1,  RPHASE,DEFAULT);
    MCBSP_FSETS( RCR1, RFRLEN2,DEFAULT);
    MCBSP_FSETS( RCR1, RWDLEN2,DEFAULT);
    MCBSP_FSETS( RCR1,RCOMPAND,DEFAULT);
    MCBSP_FSETS( RCR1,    RFIG,DEFAULT);
    MCBSP_FSETS( RCR1, RDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( RCR1, RPHASE2,DEFAULT);
#endif
    MCBSP_FSETS( RCR1, RFRLEN1,DEFAULT);
    MCBSP_FSETS( RCR1, RWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( RCR1,RWDREVRS,DEFAULT);
#endif

    MCBSP_FSETS( XCR1,  XPHASE,DEFAULT);
    MCBSP_FSETS( XCR1, XFRLEN2,DEFAULT);
    MCBSP_FSETS( XCR1, XWDLEN2,DEFAULT);
    MCBSP_FSETS( XCR1,XCOMPAND,DEFAULT);
    MCBSP_FSETS( XCR1,    XFIG,DEFAULT);
    MCBSP_FSETS( XCR1, XDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( XCR1, XPHASE2,DEFAULT);
#endif
    MCBSP_FSETS( XCR1, XFRLEN1,DEFAULT);
    MCBSP_FSETS( XCR1, XWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( XCR1,XWDREVRS,DEFAULT);
#endif

    MCBSP_FSETS(SRGR1,   GSYNC,DEFAULT);
    MCBSP_FSETS(SRGR1,   CLKSP,DEFAULT);
    MCBSP_FSETS(SRGR1,   CLKSM,DEFAULT);
    MCBSP_FSETS(SRGR1,    FSGM,DEFAULT);
    MCBSP_FSETS(SRGR1,    FPER,DEFAULT);
    MCBSP_FSETS(SRGR1,    FWID,DEFAULT);
    MCBSP_FSETS(SRGR1,  CLKGDV,DEFAULT);

    MCBSP_FSETS( MCR1,  XPBBLK,DEFAULT);
    MCBSP_FSETS( MCR1,  XPABLK,DEFAULT);
    MCBSP_FSETS( MCR1,   XCBLK,DEFAULT);
    MCBSP_FSETS( MCR1,    XMCM,DEFAULT);
    MCBSP_FSETS( MCR1,  RPBBLK,DEFAULT);
    MCBSP_FSETS( MCR1,  RPABLK,DEFAULT);
    MCBSP_FSETS( MCR1,   RCBLK,DEFAULT);
    MCBSP_FSETS( MCR1,    RMCM,DEFAULT);

    MCBSP_FSETS(RCER1,    RCEB,DEFAULT);
    MCBSP_FSETS(RCER1,    RCEA,DEFAULT);

    MCBSP_FSETS(XCER1,    XCEB,DEFAULT);
    MCBSP_FSETS(XCER1,    XCEA,DEFAULT);

    MCBSP_FSETS( PCR1,   XIOEN,DEFAULT);
    MCBSP_FSETS( PCR1,   RIOEN,DEFAULT);
    MCBSP_FSETS( PCR1,    FSXM,DEFAULT);
    MCBSP_FSETS( PCR1,    FSRM,DEFAULT);
    MCBSP_FSETS( PCR1,   CLKXM,DEFAULT);
    MCBSP_FSETS( PCR1,   CLKRM,DEFAULT);
    MCBSP_FSETS( PCR1,CLKSSTAT,DEFAULT);
    MCBSP_FSETS( PCR1,  DXSTAT,DEFAULT);
    MCBSP_FSETS( PCR1,  DRSTAT,DEFAULT);
    MCBSP_FSETS( PCR1,    FSXP,DEFAULT);
    MCBSP_FSETS( PCR1,    FSRP,DEFAULT);
    MCBSP_FSETS( PCR1,   CLKXP,DEFAULT);
    MCBSP_FSETS( PCR1,   CLKRP,DEFAULT);

#if (CHIP_6202 | CHIP_6203)
    MCBSP_FSETS( DRR2,      DR,DEFAULT);
    MCBSP_FSETS( DXR2,      DX,DEFAULT);
    MCBSP_FSETS(SPCR2,    FRST,DEFAULT);
    MCBSP_FSETS(SPCR2,    GRST,DEFAULT);
    MCBSP_FSETS(SPCR2,   XINTM,DEFAULT);
    MCBSP_FSETS(SPCR2,XSYNCERR,DEFAULT);
    MCBSP_FSETS(SPCR2,  XEMPTY,DEFAULT);
    MCBSP_FSETS(SPCR2,    XRDY,DEFAULT);
    MCBSP_FSETS(SPCR2,    XRST,DEFAULT);
    MCBSP_FSETS(SPCR2,     DLB,DEFAULT);
    MCBSP_FSETS(SPCR2,   RJUST,DEFAULT);
    MCBSP_FSETS(SPCR2,  CLKSTP,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS(SPCR2,   DXENA,DEFAULT);
#endif
    MCBSP_FSETS(SPCR2,   RINTM,DEFAULT);
    MCBSP_FSETS(SPCR2,RSYNCERR,DEFAULT);
    MCBSP_FSETS(SPCR2,   RFULL,DEFAULT);
    MCBSP_FSETS(SPCR2,    RRDY,DEFAULT);
    MCBSP_FSETS(SPCR2,    RRST,DEFAULT);

    MCBSP_FSETS( RCR2,  RPHASE,DEFAULT);
    MCBSP_FSETS( RCR2, RFRLEN2,DEFAULT);
    MCBSP_FSETS( RCR2, RWDLEN2,DEFAULT);
    MCBSP_FSETS( RCR2,RCOMPAND,DEFAULT);
    MCBSP_FSETS( RCR2,    RFIG,DEFAULT);
    MCBSP_FSETS( RCR2, RDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( RCR2, RPHASE2,DEFAULT);
#endif
    MCBSP_FSETS( RCR2, RFRLEN1,DEFAULT);
    MCBSP_FSETS( RCR2, RWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( RCR2,RWDREVRS,DEFAULT);
#endif

    MCBSP_FSETS( XCR2,  XPHASE,DEFAULT);
    MCBSP_FSETS( XCR2, XFRLEN2,DEFAULT);
    MCBSP_FSETS( XCR2, XWDLEN2,DEFAULT);
    MCBSP_FSETS( XCR2,XCOMPAND,DEFAULT);
    MCBSP_FSETS( XCR2,    XFIG,DEFAULT);
    MCBSP_FSETS( XCR2, XDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( XCR2, XPHASE2,DEFAULT);
#endif
    MCBSP_FSETS( XCR2, XFRLEN1,DEFAULT);
    MCBSP_FSETS( XCR2, XWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETS( XCR2,XWDREVRS,DEFAULT);
#endif

    MCBSP_FSETS(SRGR2,   GSYNC,DEFAULT);
    MCBSP_FSETS(SRGR2,   CLKSP,DEFAULT);
    MCBSP_FSETS(SRGR2,   CLKSM,DEFAULT);
    MCBSP_FSETS(SRGR2,    FSGM,DEFAULT);
    MCBSP_FSETS(SRGR2,    FPER,DEFAULT);
    MCBSP_FSETS(SRGR2,    FWID,DEFAULT);
    MCBSP_FSETS(SRGR2,  CLKGDV,DEFAULT);

    MCBSP_FSETS( MCR2,  XPBBLK,DEFAULT);
    MCBSP_FSETS( MCR2,  XPABLK,DEFAULT);
    MCBSP_FSETS( MCR2,   XCBLK,DEFAULT);
    MCBSP_FSETS( MCR2,    XMCM,DEFAULT);
    MCBSP_FSETS( MCR2,  RPBBLK,DEFAULT);
    MCBSP_FSETS( MCR2,  RPABLK,DEFAULT);
    MCBSP_FSETS( MCR2,   RCBLK,DEFAULT);
    MCBSP_FSETS( MCR2,    RMCM,DEFAULT);

    MCBSP_FSETS(RCER2,    RCEB,DEFAULT);
    MCBSP_FSETS(RCER2,    RCEA,DEFAULT);

    MCBSP_FSETS(XCER2,    XCEB,DEFAULT);
    MCBSP_FSETS(XCER2,    XCEA,DEFAULT);

    MCBSP_FSETS( PCR2,   XIOEN,DEFAULT);
    MCBSP_FSETS( PCR2,   RIOEN,DEFAULT);
    MCBSP_FSETS( PCR2,    FSXM,DEFAULT);
    MCBSP_FSETS( PCR2,    FSRM,DEFAULT);
    MCBSP_FSETS( PCR2,   CLKXM,DEFAULT);
    MCBSP_FSETS( PCR2,   CLKRM,DEFAULT);
    MCBSP_FSETS( PCR2,CLKSSTAT,DEFAULT);
    MCBSP_FSETS( PCR2,  DXSTAT,DEFAULT);
    MCBSP_FSETS( PCR2,  DRSTAT,DEFAULT);
    MCBSP_FSETS( PCR2,    FSXP,DEFAULT);
    MCBSP_FSETS( PCR2,    FSRP,DEFAULT);
    MCBSP_FSETS( PCR2,   CLKXP,DEFAULT);
    MCBSP_FSETS( PCR2,   CLKRP,DEFAULT);
#endif

/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = MCBSP_RGETA(0, DRR0);
    x = MCBSP_RGETA(0, RCR0);
    x = MCBSP_RGETA(0, XCR0);
    x = MCBSP_RGETA(0,SRGR0);
    x = MCBSP_RGETA(0, MCR0);
    x = MCBSP_RGETA(0,RCER0);
    x = MCBSP_RGETA(0,XCER0);
    x = MCBSP_RGETA(0, PCR0);

    x = MCBSP_RGETA(0, DRR1);
    x = MCBSP_RGETA(0, RCR1);
    x = MCBSP_RGETA(0, XCR1);
    x = MCBSP_RGETA(0,SRGR1);
    x = MCBSP_RGETA(0, MCR1);
    x = MCBSP_RGETA(0,RCER1);
    x = MCBSP_RGETA(0,XCER1);
    x = MCBSP_RGETA(0, PCR1);

#if (CHIP_6202|CHIP_6203)
    x = MCBSP_RGETA(0, DRR2);
    x = MCBSP_RGETA(0, RCR2);
    x = MCBSP_RGETA(0, XCR2);
    x = MCBSP_RGETA(0,SRGR2);
    x = MCBSP_RGETA(0, MCR2);
    x = MCBSP_RGETA(0,RCER2);
    x = MCBSP_RGETA(0,XCER2);
    x = MCBSP_RGETA(0, PCR2);
#endif

/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    MCBSP_RSETA(0, DRR0,  MCBSP_DRR_DEFAULT);
    MCBSP_RSETA(0, RCR0,  MCBSP_RCR_DEFAULT);
    MCBSP_RSETA(0, XCR0,  MCBSP_XCR_DEFAULT);
    MCBSP_RSETA(0,SRGR0, MCBSP_SRGR_DEFAULT);
    MCBSP_RSETA(0, MCR0,  MCBSP_MCR_DEFAULT);
    MCBSP_RSETA(0,RCER0, MCBSP_RCER_DEFAULT);
    MCBSP_RSETA(0,XCER0, MCBSP_XCER_DEFAULT);
    MCBSP_RSETA(0, PCR0,  MCBSP_PCR_DEFAULT);

    MCBSP_RSETA(0, DRR1,  MCBSP_DRR_DEFAULT);
    MCBSP_RSETA(0, RCR1,  MCBSP_RCR_DEFAULT);
    MCBSP_RSETA(0, XCR1,  MCBSP_XCR_DEFAULT);
    MCBSP_RSETA(0,SRGR1, MCBSP_SRGR_DEFAULT);
    MCBSP_RSETA(0, MCR1,  MCBSP_MCR_DEFAULT);
    MCBSP_RSETA(0,RCER1, MCBSP_RCER_DEFAULT);
    MCBSP_RSETA(0,XCER1, MCBSP_XCER_DEFAULT);
    MCBSP_RSETA(0, PCR1,  MCBSP_PCR_DEFAULT);

#if (CHIP_6202|CHIP_6203)
    MCBSP_RSETA(0, DRR2,  MCBSP_DRR_DEFAULT);
    MCBSP_RSETA(0, RCR2,  MCBSP_RCR_DEFAULT);
    MCBSP_RSETA(0, XCR2,  MCBSP_XCR_DEFAULT);
    MCBSP_RSETA(0,SRGR2, MCBSP_SRGR_DEFAULT);
    MCBSP_RSETA(0, MCR2,  MCBSP_MCR_DEFAULT);
    MCBSP_RSETA(0,RCER2, MCBSP_RCER_DEFAULT);
    MCBSP_RSETA(0,XCER2, MCBSP_XCER_DEFAULT);
    MCBSP_RSETA(0, PCR2,  MCBSP_PCR_DEFAULT);
#endif


/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = MCBSP_FGETA(0, DRR,      DR);
    x = MCBSP_FGETA(0, DXR,      DX);
    x = MCBSP_FGETA(0,SPCR,    FRST);
    x = MCBSP_FGETA(0,SPCR,    GRST);
    x = MCBSP_FGETA(0,SPCR,   XINTM);
    x = MCBSP_FGETA(0,SPCR,XSYNCERR);
    x = MCBSP_FGETA(0,SPCR,  XEMPTY);
    x = MCBSP_FGETA(0,SPCR,    XRDY);
    x = MCBSP_FGETA(0,SPCR,    XRST);
    x = MCBSP_FGETA(0,SPCR,     DLB);
    x = MCBSP_FGETA(0,SPCR,   RJUST);
    x = MCBSP_FGETA(0,SPCR,  CLKSTP);
#if (C11_SUPPORT)
    x = MCBSP_FGETA(0,SPCR,   DXENA);
#endif
    x = MCBSP_FGETA(0,SPCR,   RINTM);
    x = MCBSP_FGETA(0,SPCR,RSYNCERR);
    x = MCBSP_FGETA(0,SPCR,   RFULL);
    x = MCBSP_FGETA(0,SPCR,    RRDY);
    x = MCBSP_FGETA(0,SPCR,    RRST);

    x = MCBSP_FGETA(0, RCR,  RPHASE);
    x = MCBSP_FGETA(0, RCR, RFRLEN2);
    x = MCBSP_FGETA(0, RCR, RWDLEN2);
    x = MCBSP_FGETA(0, RCR,RCOMPAND);
    x = MCBSP_FGETA(0, RCR,    RFIG);
    x = MCBSP_FGETA(0, RCR, RDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGETA(0, RCR, RPHASE2);
#endif
    x = MCBSP_FGETA(0, RCR, RFRLEN1);
    x = MCBSP_FGETA(0, RCR, RWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGETA(0, RCR,RWDREVRS);
#endif

    x = MCBSP_FGETA(0, XCR,  XPHASE);
    x = MCBSP_FGETA(0, XCR, XFRLEN2);
    x = MCBSP_FGETA(0, XCR, XWDLEN2);
    x = MCBSP_FGETA(0, XCR,XCOMPAND);
    x = MCBSP_FGETA(0, XCR,    XFIG);
    x = MCBSP_FGETA(0, XCR, XDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGETA(0, XCR, XPHASE2);
#endif
    x = MCBSP_FGETA(0, XCR, XFRLEN1);
    x = MCBSP_FGETA(0, XCR, XWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGETA(0, XCR,XWDREVRS);
#endif

    x = MCBSP_FGETA(0,SRGR,   GSYNC);
    x = MCBSP_FGETA(0,SRGR,   CLKSP);
    x = MCBSP_FGETA(0,SRGR,   CLKSM);
    x = MCBSP_FGETA(0,SRGR,    FSGM);
    x = MCBSP_FGETA(0,SRGR,    FPER);
    x = MCBSP_FGETA(0,SRGR,    FWID);
    x = MCBSP_FGETA(0,SRGR,  CLKGDV);

    x = MCBSP_FGETA(0, MCR,  XPBBLK);
    x = MCBSP_FGETA(0, MCR,  XPABLK);
    x = MCBSP_FGETA(0, MCR,   XCBLK);
    x = MCBSP_FGETA(0, MCR,    XMCM);
    x = MCBSP_FGETA(0, MCR,  RPBBLK);
    x = MCBSP_FGETA(0, MCR,  RPABLK);
    x = MCBSP_FGETA(0, MCR,   RCBLK);
    x = MCBSP_FGETA(0, MCR,    RMCM);

    x = MCBSP_FGETA(0,RCER,    RCEB);
    x = MCBSP_FGETA(0,RCER,    RCEA);

    x = MCBSP_FGETA(0,XCER,    XCEB);
    x = MCBSP_FGETA(0,XCER,    XCEA);

    x = MCBSP_FGETA(0, PCR,   XIOEN);
    x = MCBSP_FGETA(0, PCR,   RIOEN);
    x = MCBSP_FGETA(0, PCR,    FSXM);
    x = MCBSP_FGETA(0, PCR,    FSRM);
    x = MCBSP_FGETA(0, PCR,   CLKXM);
    x = MCBSP_FGETA(0, PCR,   CLKRM);
    x = MCBSP_FGETA(0, PCR,CLKSSTAT);
    x = MCBSP_FGETA(0, PCR,  DXSTAT);
    x = MCBSP_FGETA(0, PCR,  DRSTAT);
    x = MCBSP_FGETA(0, PCR,    FSXP);
    x = MCBSP_FGETA(0, PCR,    FSRP);
    x = MCBSP_FGETA(0, PCR,   CLKXP);
    x = MCBSP_FGETA(0, PCR,   CLKRP);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    MCBSP_FSETA(0, DRR,      DR,        MCBSP_DRR_DR_DEFAULT);
    MCBSP_FSETA(0, DXR,      DX,        MCBSP_DXR_DX_DEFAULT);
    MCBSP_FSETA(0,SPCR,    FRST,     MCBSP_SPCR_FRST_DEFAULT);
    MCBSP_FSETA(0,SPCR,    GRST,     MCBSP_SPCR_GRST_DEFAULT);
    MCBSP_FSETA(0,SPCR,   XINTM,    MCBSP_SPCR_XINTM_DEFAULT);
    MCBSP_FSETA(0,SPCR,XSYNCERR, MCBSP_SPCR_XSYNCERR_DEFAULT);
    MCBSP_FSETA(0,SPCR,  XEMPTY,   MCBSP_SPCR_XEMPTY_DEFAULT);
    MCBSP_FSETA(0,SPCR,    XRDY,     MCBSP_SPCR_XRDY_DEFAULT);
    MCBSP_FSETA(0,SPCR,    XRST,     MCBSP_SPCR_XRST_DEFAULT);
    MCBSP_FSETA(0,SPCR,     DLB,      MCBSP_SPCR_DLB_DEFAULT);
    MCBSP_FSETA(0,SPCR,   RJUST,    MCBSP_SPCR_RJUST_DEFAULT);
    MCBSP_FSETA(0,SPCR,  CLKSTP,   MCBSP_SPCR_CLKSTP_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETA(0,SPCR,   DXENA,    MCBSP_SPCR_DXENA_DEFAULT);
#endif
    MCBSP_FSETA(0,SPCR,   RINTM,    MCBSP_SPCR_RINTM_DEFAULT);
    MCBSP_FSETA(0,SPCR,RSYNCERR, MCBSP_SPCR_RSYNCERR_DEFAULT);
    MCBSP_FSETA(0,SPCR,   RFULL,    MCBSP_SPCR_RFULL_DEFAULT);
    MCBSP_FSETA(0,SPCR,    RRDY,     MCBSP_SPCR_RRDY_DEFAULT);
    MCBSP_FSETA(0,SPCR,    RRST,     MCBSP_SPCR_RRST_DEFAULT);

    MCBSP_FSETA(0, RCR,  RPHASE,    MCBSP_RCR_RPHASE_DEFAULT);
    MCBSP_FSETA(0, RCR, RFRLEN2,   MCBSP_RCR_RFRLEN2_DEFAULT);
    MCBSP_FSETA(0, RCR, RWDLEN2,   MCBSP_RCR_RWDLEN2_DEFAULT);
    MCBSP_FSETA(0, RCR,RCOMPAND,  MCBSP_RCR_RCOMPAND_DEFAULT);
    MCBSP_FSETA(0, RCR,    RFIG,      MCBSP_RCR_RFIG_DEFAULT);
    MCBSP_FSETA(0, RCR, RDATDLY,   MCBSP_RCR_RDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETA(0, RCR, RPHASE2,   MCBSP_RCR_RPHASE2_DEFAULT);
#endif
    MCBSP_FSETA(0, RCR, RFRLEN1,   MCBSP_RCR_RFRLEN1_DEFAULT);
    MCBSP_FSETA(0, RCR, RWDLEN1,   MCBSP_RCR_RWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETA(0, RCR,RWDREVRS,  MCBSP_RCR_RWDREVRS_DEFAULT);
#endif

    MCBSP_FSETA(0, XCR,  XPHASE,    MCBSP_XCR_XPHASE_DEFAULT);
    MCBSP_FSETA(0, XCR, XFRLEN2,   MCBSP_XCR_XFRLEN2_DEFAULT);
    MCBSP_FSETA(0, XCR, XWDLEN2,   MCBSP_XCR_XWDLEN2_DEFAULT);
    MCBSP_FSETA(0, XCR,XCOMPAND,  MCBSP_XCR_XCOMPAND_DEFAULT);
    MCBSP_FSETA(0, XCR,    XFIG,      MCBSP_XCR_XFIG_DEFAULT);
    MCBSP_FSETA(0, XCR, XDATDLY,   MCBSP_XCR_XDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETA(0, XCR, XPHASE2,   MCBSP_XCR_XPHASE2_DEFAULT);
#endif
    MCBSP_FSETA(0, XCR, XFRLEN1,   MCBSP_XCR_XFRLEN1_DEFAULT);
    MCBSP_FSETA(0, XCR, XWDLEN1,   MCBSP_XCR_XWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETA(0, XCR,XWDREVRS,  MCBSP_XCR_XWDREVRS_DEFAULT);
#endif

    MCBSP_FSETA(0,SRGR,   GSYNC,    MCBSP_SRGR_GSYNC_DEFAULT);
    MCBSP_FSETA(0,SRGR,   CLKSP,    MCBSP_SRGR_CLKSP_DEFAULT);
    MCBSP_FSETA(0,SRGR,   CLKSM,    MCBSP_SRGR_CLKSM_DEFAULT);
    MCBSP_FSETA(0,SRGR,    FSGM,     MCBSP_SRGR_FSGM_DEFAULT);
    MCBSP_FSETA(0,SRGR,    FPER,     MCBSP_SRGR_FPER_DEFAULT);
    MCBSP_FSETA(0,SRGR,    FWID,     MCBSP_SRGR_FWID_DEFAULT);
    MCBSP_FSETA(0,SRGR,  CLKGDV,   MCBSP_SRGR_CLKGDV_DEFAULT);

    MCBSP_FSETA(0, MCR,  XPBBLK,    MCBSP_MCR_XPBBLK_DEFAULT);
    MCBSP_FSETA(0, MCR,  XPABLK,    MCBSP_MCR_XPABLK_DEFAULT);
    MCBSP_FSETA(0, MCR,   XCBLK,     MCBSP_MCR_XCBLK_DEFAULT);
    MCBSP_FSETA(0, MCR,    XMCM,      MCBSP_MCR_XMCM_DEFAULT);
    MCBSP_FSETA(0, MCR,  RPBBLK,    MCBSP_MCR_RPBBLK_DEFAULT);
    MCBSP_FSETA(0, MCR,  RPABLK,    MCBSP_MCR_RPABLK_DEFAULT);
    MCBSP_FSETA(0, MCR,   RCBLK,     MCBSP_MCR_RCBLK_DEFAULT);
    MCBSP_FSETA(0, MCR,    RMCM,      MCBSP_MCR_RMCM_DEFAULT);

    MCBSP_FSETA(0,RCER,    RCEB,     MCBSP_RCER_RCEB_DEFAULT);
    MCBSP_FSETA(0,RCER,    RCEA,     MCBSP_RCER_RCEA_DEFAULT);

    MCBSP_FSETA(0,XCER,    XCEB,     MCBSP_XCER_XCEB_DEFAULT);
    MCBSP_FSETA(0,XCER,    XCEA,     MCBSP_XCER_XCEA_DEFAULT);

    MCBSP_FSETA(0, PCR,   XIOEN,     MCBSP_PCR_XIOEN_DEFAULT);
    MCBSP_FSETA(0, PCR,   RIOEN,     MCBSP_PCR_RIOEN_DEFAULT);
    MCBSP_FSETA(0, PCR,    FSXM,      MCBSP_PCR_FSXM_DEFAULT);
    MCBSP_FSETA(0, PCR,    FSRM,      MCBSP_PCR_FSRM_DEFAULT);
    MCBSP_FSETA(0, PCR,   CLKXM,     MCBSP_PCR_CLKXM_DEFAULT);
    MCBSP_FSETA(0, PCR,   CLKRM,     MCBSP_PCR_CLKRM_DEFAULT);
    MCBSP_FSETA(0, PCR,CLKSSTAT,  MCBSP_PCR_CLKSSTAT_DEFAULT);
    MCBSP_FSETA(0, PCR,  DXSTAT,    MCBSP_PCR_DXSTAT_DEFAULT);
    MCBSP_FSETA(0, PCR,  DRSTAT,    MCBSP_PCR_DRSTAT_DEFAULT);
    MCBSP_FSETA(0, PCR,    FSXP,      MCBSP_PCR_FSXP_DEFAULT);
    MCBSP_FSETA(0, PCR,    FSRP,      MCBSP_PCR_FSRP_DEFAULT);
    MCBSP_FSETA(0, PCR,   CLKXP,     MCBSP_PCR_CLKXP_DEFAULT);
    MCBSP_FSETA(0, PCR,   CLKRP,     MCBSP_PCR_CLKRP_DEFAULT);


/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    MCBSP_FSETSA(0, DRR,      DR,DEFAULT);
    MCBSP_FSETSA(0, DXR,      DX,DEFAULT);
    MCBSP_FSETSA(0,SPCR,    FRST,DEFAULT);
    MCBSP_FSETSA(0,SPCR,    GRST,DEFAULT);
    MCBSP_FSETSA(0,SPCR,   XINTM,DEFAULT);
    MCBSP_FSETSA(0,SPCR,XSYNCERR,DEFAULT);
    MCBSP_FSETSA(0,SPCR,  XEMPTY,DEFAULT);
    MCBSP_FSETSA(0,SPCR,    XRDY,DEFAULT);
    MCBSP_FSETSA(0,SPCR,    XRST,DEFAULT);
    MCBSP_FSETSA(0,SPCR,     DLB,DEFAULT);
    MCBSP_FSETSA(0,SPCR,   RJUST,DEFAULT);
    MCBSP_FSETSA(0,SPCR,  CLKSTP,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSA(0,SPCR,   DXENA,DEFAULT);
#endif
    MCBSP_FSETSA(0,SPCR,   RINTM,DEFAULT);
    MCBSP_FSETSA(0,SPCR,RSYNCERR,DEFAULT);
    MCBSP_FSETSA(0,SPCR,   RFULL,DEFAULT);
    MCBSP_FSETSA(0,SPCR,    RRDY,DEFAULT);
    MCBSP_FSETSA(0,SPCR,    RRST,DEFAULT);

    MCBSP_FSETSA(0, RCR,  RPHASE,DEFAULT);
    MCBSP_FSETSA(0, RCR, RFRLEN2,DEFAULT);
    MCBSP_FSETSA(0, RCR, RWDLEN2,DEFAULT);
    MCBSP_FSETSA(0, RCR,RCOMPAND,DEFAULT);
    MCBSP_FSETSA(0, RCR,    RFIG,DEFAULT);
    MCBSP_FSETSA(0, RCR, RDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSA(0, RCR, RPHASE2,DEFAULT);
#endif
    MCBSP_FSETSA(0, RCR, RFRLEN1,DEFAULT);
    MCBSP_FSETSA(0, RCR, RWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSA(0, RCR,RWDREVRS,DEFAULT);
#endif

    MCBSP_FSETSA(0, XCR,  XPHASE,DEFAULT);
    MCBSP_FSETSA(0, XCR, XFRLEN2,DEFAULT);
    MCBSP_FSETSA(0, XCR, XWDLEN2,DEFAULT);
    MCBSP_FSETSA(0, XCR,XCOMPAND,DEFAULT);
    MCBSP_FSETSA(0, XCR,    XFIG,DEFAULT);
    MCBSP_FSETSA(0, XCR, XDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSA(0, XCR, XPHASE2,DEFAULT);
#endif
    MCBSP_FSETSA(0, XCR, XFRLEN1,DEFAULT);
    MCBSP_FSETSA(0, XCR, XWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSA(0, XCR,XWDREVRS,DEFAULT);
#endif

    MCBSP_FSETSA(0,SRGR,   GSYNC,DEFAULT);
    MCBSP_FSETSA(0,SRGR,   CLKSP,DEFAULT);
    MCBSP_FSETSA(0,SRGR,   CLKSM,DEFAULT);
    MCBSP_FSETSA(0,SRGR,    FSGM,DEFAULT);
    MCBSP_FSETSA(0,SRGR,    FPER,DEFAULT);
    MCBSP_FSETSA(0,SRGR,    FWID,DEFAULT);
    MCBSP_FSETSA(0,SRGR,  CLKGDV,DEFAULT);

    MCBSP_FSETSA(0, MCR,  XPBBLK,DEFAULT);
    MCBSP_FSETSA(0, MCR,  XPABLK,DEFAULT);
    MCBSP_FSETSA(0, MCR,   XCBLK,DEFAULT);
    MCBSP_FSETSA(0, MCR,    XMCM,DEFAULT);
    MCBSP_FSETSA(0, MCR,  RPBBLK,DEFAULT);
    MCBSP_FSETSA(0, MCR,  RPABLK,DEFAULT);
    MCBSP_FSETSA(0, MCR,   RCBLK,DEFAULT);
    MCBSP_FSETSA(0, MCR,    RMCM,DEFAULT);

    MCBSP_FSETSA(0,RCER,    RCEB,DEFAULT);
    MCBSP_FSETSA(0,RCER,    RCEA,DEFAULT);

    MCBSP_FSETSA(0,XCER,    XCEB,DEFAULT);
    MCBSP_FSETSA(0,XCER,    XCEA,DEFAULT);

    MCBSP_FSETSA(0, PCR,   XIOEN,DEFAULT);
    MCBSP_FSETSA(0, PCR,   RIOEN,DEFAULT);
    MCBSP_FSETSA(0, PCR,    FSXM,DEFAULT);
    MCBSP_FSETSA(0, PCR,    FSRM,DEFAULT);
    MCBSP_FSETSA(0, PCR,   CLKXM,DEFAULT);
    MCBSP_FSETSA(0, PCR,   CLKRM,DEFAULT);
    MCBSP_FSETSA(0, PCR,CLKSSTAT,DEFAULT);
    MCBSP_FSETSA(0, PCR,  DXSTAT,DEFAULT);
    MCBSP_FSETSA(0, PCR,  DRSTAT,DEFAULT);
    MCBSP_FSETSA(0, PCR,    FSXP,DEFAULT);
    MCBSP_FSETSA(0, PCR,    FSRP,DEFAULT);
    MCBSP_FSETSA(0, PCR,   CLKXP,DEFAULT);
    MCBSP_FSETSA(0, PCR,   CLKRP,DEFAULT);

/*  Test FSETSA Macro end */
/*  Test ADDRH Macro start */
    x = MCBSP_ADDRH(hMcbsp, DRR);
    x = MCBSP_ADDRH(hMcbsp, RCR);
    x = MCBSP_ADDRH(hMcbsp, XCR);
    x = MCBSP_ADDRH(hMcbsp,SRGR);
    x = MCBSP_ADDRH(hMcbsp, MCR);
    x = MCBSP_ADDRH(hMcbsp,RCER);
    x = MCBSP_ADDRH(hMcbsp,XCER);
    x = MCBSP_ADDRH(hMcbsp, PCR);

/*  Test ADDR Macro start */
/*  Test RGETH Macro start */
    x = MCBSP_RGETH(hMcbsp, DRR);
    x = MCBSP_RGETH(hMcbsp, RCR);
    x = MCBSP_RGETH(hMcbsp, XCR);
    x = MCBSP_RGETH(hMcbsp,SRGR);
    x = MCBSP_RGETH(hMcbsp, MCR);
    x = MCBSP_RGETH(hMcbsp,RCER);
    x = MCBSP_RGETH(hMcbsp,XCER);
    x = MCBSP_RGETH(hMcbsp, PCR);

/*  Test RGETH Macro end */
/*  Test RSETH Macro start */
    MCBSP_RSETH(hMcbsp, DRR,  MCBSP_DRR_DEFAULT);
    MCBSP_RSETH(hMcbsp, RCR,  MCBSP_RCR_DEFAULT);
    MCBSP_RSETH(hMcbsp, XCR,  MCBSP_XCR_DEFAULT);
    MCBSP_RSETH(hMcbsp,SRGR, MCBSP_SRGR_DEFAULT);
    MCBSP_RSETH(hMcbsp, MCR,  MCBSP_MCR_DEFAULT);
    MCBSP_RSETH(hMcbsp,RCER, MCBSP_RCER_DEFAULT);
    MCBSP_RSETH(hMcbsp,XCER, MCBSP_XCER_DEFAULT);
    MCBSP_RSETH(hMcbsp, PCR,  MCBSP_PCR_DEFAULT);

/*  Test RSETH Macro end */
/*  Test FGETH Macro start */
    x = MCBSP_FGETH(hMcbsp, DRR,      DR);
    x = MCBSP_FGETH(hMcbsp, DXR,      DX);
    x = MCBSP_FGETH(hMcbsp,SPCR,    FRST);
    x = MCBSP_FGETH(hMcbsp,SPCR,    GRST);
    x = MCBSP_FGETH(hMcbsp,SPCR,   XINTM);
    x = MCBSP_FGETH(hMcbsp,SPCR,XSYNCERR);
    x = MCBSP_FGETH(hMcbsp,SPCR,  XEMPTY);
    x = MCBSP_FGETH(hMcbsp,SPCR,    XRDY);
    x = MCBSP_FGETH(hMcbsp,SPCR,    XRST);
    x = MCBSP_FGETH(hMcbsp,SPCR,     DLB);
    x = MCBSP_FGETH(hMcbsp,SPCR,   RJUST);
    x = MCBSP_FGETH(hMcbsp,SPCR,  CLKSTP);
#if (C11_SUPPORT)
    x = MCBSP_FGETH(hMcbsp,SPCR,   DXENA);
#endif
    x = MCBSP_FGETH(hMcbsp,SPCR,   RINTM);
    x = MCBSP_FGETH(hMcbsp,SPCR,RSYNCERR);
    x = MCBSP_FGETH(hMcbsp,SPCR,   RFULL);
    x = MCBSP_FGETH(hMcbsp,SPCR,    RRDY);
    x = MCBSP_FGETH(hMcbsp,SPCR,    RRST);

    x = MCBSP_FGETH(hMcbsp, RCR,  RPHASE);
    x = MCBSP_FGETH(hMcbsp, RCR, RFRLEN2);
    x = MCBSP_FGETH(hMcbsp, RCR, RWDLEN2);
    x = MCBSP_FGETH(hMcbsp, RCR,RCOMPAND);
    x = MCBSP_FGETH(hMcbsp, RCR,    RFIG);
    x = MCBSP_FGETH(hMcbsp, RCR, RDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGETH(hMcbsp, RCR, RPHASE2);
#endif
    x = MCBSP_FGETH(hMcbsp, RCR, RFRLEN1);
    x = MCBSP_FGETH(hMcbsp, RCR, RWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGETH(hMcbsp, RCR,RWDREVRS);
#endif

    x = MCBSP_FGETH(hMcbsp, XCR,  XPHASE);
    x = MCBSP_FGETH(hMcbsp, XCR, XFRLEN2);
    x = MCBSP_FGETH(hMcbsp, XCR, XWDLEN2);
    x = MCBSP_FGETH(hMcbsp, XCR,XCOMPAND);
    x = MCBSP_FGETH(hMcbsp, XCR,    XFIG);
    x = MCBSP_FGETH(hMcbsp, XCR, XDATDLY);
#if (C11_SUPPORT)
    x = MCBSP_FGETH(hMcbsp, XCR, XPHASE2);
#endif
    x = MCBSP_FGETH(hMcbsp, XCR, XFRLEN1);
    x = MCBSP_FGETH(hMcbsp, XCR, XWDLEN1);
#if (C11_SUPPORT)
    x = MCBSP_FGETH(hMcbsp, XCR,XWDREVRS);
#endif

    x = MCBSP_FGETH(hMcbsp,SRGR,   GSYNC);
    x = MCBSP_FGETH(hMcbsp,SRGR,   CLKSP);
    x = MCBSP_FGETH(hMcbsp,SRGR,   CLKSM);
    x = MCBSP_FGETH(hMcbsp,SRGR,    FSGM);
    x = MCBSP_FGETH(hMcbsp,SRGR,    FPER);
    x = MCBSP_FGETH(hMcbsp,SRGR,    FWID);
    x = MCBSP_FGETH(hMcbsp,SRGR,  CLKGDV);

    x = MCBSP_FGETH(hMcbsp, MCR,  XPBBLK);
    x = MCBSP_FGETH(hMcbsp, MCR,  XPABLK);
    x = MCBSP_FGETH(hMcbsp, MCR,   XCBLK);
    x = MCBSP_FGETH(hMcbsp, MCR,    XMCM);
    x = MCBSP_FGETH(hMcbsp, MCR,  RPBBLK);
    x = MCBSP_FGETH(hMcbsp, MCR,  RPABLK);
    x = MCBSP_FGETH(hMcbsp, MCR,   RCBLK);
    x = MCBSP_FGETH(hMcbsp, MCR,    RMCM);

    x = MCBSP_FGETH(hMcbsp,RCER,    RCEB);
    x = MCBSP_FGETH(hMcbsp,RCER,    RCEA);

    x = MCBSP_FGETH(hMcbsp,XCER,    XCEB);
    x = MCBSP_FGETH(hMcbsp,XCER,    XCEA);

    x = MCBSP_FGETH(hMcbsp, PCR,   XIOEN);
    x = MCBSP_FGETH(hMcbsp, PCR,   RIOEN);
    x = MCBSP_FGETH(hMcbsp, PCR,    FSXM);
    x = MCBSP_FGETH(hMcbsp, PCR,    FSRM);
    x = MCBSP_FGETH(hMcbsp, PCR,   CLKXM);
    x = MCBSP_FGETH(hMcbsp, PCR,   CLKRM);
    x = MCBSP_FGETH(hMcbsp, PCR,CLKSSTAT);
    x = MCBSP_FGETH(hMcbsp, PCR,  DXSTAT);
    x = MCBSP_FGETH(hMcbsp, PCR,  DRSTAT);
    x = MCBSP_FGETH(hMcbsp, PCR,    FSXP);
    x = MCBSP_FGETH(hMcbsp, PCR,    FSRP);
    x = MCBSP_FGETH(hMcbsp, PCR,   CLKXP);
    x = MCBSP_FGETH(hMcbsp, PCR,   CLKRP);

/*  Test FGETH Macro end */
/*  Test FSETH Macro start */
    MCBSP_FSETH(hMcbsp, DRR,      DR,        MCBSP_DRR_DR_DEFAULT);
    MCBSP_FSETH(hMcbsp, DXR,      DX,        MCBSP_DXR_DX_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,    FRST,     MCBSP_SPCR_FRST_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,    GRST,     MCBSP_SPCR_GRST_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,   XINTM,    MCBSP_SPCR_XINTM_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,XSYNCERR, MCBSP_SPCR_XSYNCERR_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,  XEMPTY,   MCBSP_SPCR_XEMPTY_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,    XRDY,     MCBSP_SPCR_XRDY_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,    XRST,     MCBSP_SPCR_XRST_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,     DLB,      MCBSP_SPCR_DLB_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,   RJUST,    MCBSP_SPCR_RJUST_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,  CLKSTP,   MCBSP_SPCR_CLKSTP_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETH(hMcbsp,SPCR,   DXENA,    MCBSP_SPCR_DXENA_DEFAULT);
#endif
    MCBSP_FSETH(hMcbsp,SPCR,   RINTM,    MCBSP_SPCR_RINTM_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,RSYNCERR, MCBSP_SPCR_RSYNCERR_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,   RFULL,    MCBSP_SPCR_RFULL_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,    RRDY,     MCBSP_SPCR_RRDY_DEFAULT);
    MCBSP_FSETH(hMcbsp,SPCR,    RRST,     MCBSP_SPCR_RRST_DEFAULT);

    MCBSP_FSETH(hMcbsp, RCR,  RPHASE,    MCBSP_RCR_RPHASE_DEFAULT);
    MCBSP_FSETH(hMcbsp, RCR, RFRLEN2,   MCBSP_RCR_RFRLEN2_DEFAULT);
    MCBSP_FSETH(hMcbsp, RCR, RWDLEN2,   MCBSP_RCR_RWDLEN2_DEFAULT);
    MCBSP_FSETH(hMcbsp, RCR,RCOMPAND,  MCBSP_RCR_RCOMPAND_DEFAULT);
    MCBSP_FSETH(hMcbsp, RCR,    RFIG,      MCBSP_RCR_RFIG_DEFAULT);
    MCBSP_FSETH(hMcbsp, RCR, RDATDLY,   MCBSP_RCR_RDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETH(hMcbsp, RCR, RPHASE2,   MCBSP_RCR_RPHASE2_DEFAULT);
#endif
    MCBSP_FSETH(hMcbsp, RCR, RFRLEN1,   MCBSP_RCR_RFRLEN1_DEFAULT);
    MCBSP_FSETH(hMcbsp, RCR, RWDLEN1,   MCBSP_RCR_RWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETH(hMcbsp, RCR,RWDREVRS,  MCBSP_RCR_RWDREVRS_DEFAULT);
#endif

    MCBSP_FSETH(hMcbsp, XCR,  XPHASE,    MCBSP_XCR_XPHASE_DEFAULT);
    MCBSP_FSETH(hMcbsp, XCR, XFRLEN2,   MCBSP_XCR_XFRLEN2_DEFAULT);
    MCBSP_FSETH(hMcbsp, XCR, XWDLEN2,   MCBSP_XCR_XWDLEN2_DEFAULT);
    MCBSP_FSETH(hMcbsp, XCR,XCOMPAND,  MCBSP_XCR_XCOMPAND_DEFAULT);
    MCBSP_FSETH(hMcbsp, XCR,    XFIG,      MCBSP_XCR_XFIG_DEFAULT);
    MCBSP_FSETH(hMcbsp, XCR, XDATDLY,   MCBSP_XCR_XDATDLY_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETH(hMcbsp, XCR, XPHASE2,   MCBSP_XCR_XPHASE2_DEFAULT);
#endif
    MCBSP_FSETH(hMcbsp, XCR, XFRLEN1,   MCBSP_XCR_XFRLEN1_DEFAULT);
    MCBSP_FSETH(hMcbsp, XCR, XWDLEN1,   MCBSP_XCR_XWDLEN1_DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETH(hMcbsp, XCR,XWDREVRS,  MCBSP_XCR_XWDREVRS_DEFAULT);
#endif

    MCBSP_FSETH(hMcbsp,SRGR,   GSYNC,    MCBSP_SRGR_GSYNC_DEFAULT);
    MCBSP_FSETH(hMcbsp,SRGR,   CLKSP,    MCBSP_SRGR_CLKSP_DEFAULT);
    MCBSP_FSETH(hMcbsp,SRGR,   CLKSM,    MCBSP_SRGR_CLKSM_DEFAULT);
    MCBSP_FSETH(hMcbsp,SRGR,    FSGM,     MCBSP_SRGR_FSGM_DEFAULT);
    MCBSP_FSETH(hMcbsp,SRGR,    FPER,     MCBSP_SRGR_FPER_DEFAULT);
    MCBSP_FSETH(hMcbsp,SRGR,    FWID,     MCBSP_SRGR_FWID_DEFAULT);
    MCBSP_FSETH(hMcbsp,SRGR,  CLKGDV,   MCBSP_SRGR_CLKGDV_DEFAULT);

    MCBSP_FSETH(hMcbsp, MCR,  XPBBLK,    MCBSP_MCR_XPBBLK_DEFAULT);
    MCBSP_FSETH(hMcbsp, MCR,  XPABLK,    MCBSP_MCR_XPABLK_DEFAULT);
    MCBSP_FSETH(hMcbsp, MCR,   XCBLK,     MCBSP_MCR_XCBLK_DEFAULT);
    MCBSP_FSETH(hMcbsp, MCR,    XMCM,      MCBSP_MCR_XMCM_DEFAULT);
    MCBSP_FSETH(hMcbsp, MCR,  RPBBLK,    MCBSP_MCR_RPBBLK_DEFAULT);
    MCBSP_FSETH(hMcbsp, MCR,  RPABLK,    MCBSP_MCR_RPABLK_DEFAULT);
    MCBSP_FSETH(hMcbsp, MCR,   RCBLK,     MCBSP_MCR_RCBLK_DEFAULT);
    MCBSP_FSETH(hMcbsp, MCR,    RMCM,      MCBSP_MCR_RMCM_DEFAULT);

    MCBSP_FSETH(hMcbsp,RCER,    RCEB,     MCBSP_RCER_RCEB_DEFAULT);
    MCBSP_FSETH(hMcbsp,RCER,    RCEA,     MCBSP_RCER_RCEA_DEFAULT);

    MCBSP_FSETH(hMcbsp,XCER,    XCEB,     MCBSP_XCER_XCEB_DEFAULT);
    MCBSP_FSETH(hMcbsp,XCER,    XCEA,     MCBSP_XCER_XCEA_DEFAULT);

    MCBSP_FSETH(hMcbsp, PCR,   XIOEN,     MCBSP_PCR_XIOEN_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,   RIOEN,     MCBSP_PCR_RIOEN_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,    FSXM,      MCBSP_PCR_FSXM_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,    FSRM,      MCBSP_PCR_FSRM_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,   CLKXM,     MCBSP_PCR_CLKXM_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,   CLKRM,     MCBSP_PCR_CLKRM_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,CLKSSTAT,  MCBSP_PCR_CLKSSTAT_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,  DXSTAT,    MCBSP_PCR_DXSTAT_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,  DRSTAT,    MCBSP_PCR_DRSTAT_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,    FSXP,      MCBSP_PCR_FSXP_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,    FSRP,      MCBSP_PCR_FSRP_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,   CLKXP,     MCBSP_PCR_CLKXP_DEFAULT);
    MCBSP_FSETH(hMcbsp, PCR,   CLKRP,     MCBSP_PCR_CLKRP_DEFAULT);


/*  Test FSETH Macro end */
/*  Test FSETSH Macro start */
    MCBSP_FSETSH(hMcbsp, DRR,      DR,DEFAULT);
    MCBSP_FSETSH(hMcbsp, DXR,      DX,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,    FRST,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,    GRST,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,   XINTM,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,XSYNCERR,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,  XEMPTY,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,    XRDY,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,    XRST,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,     DLB,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,   RJUST,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,  CLKSTP,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSH(hMcbsp,SPCR,   DXENA,DEFAULT);
#endif
    MCBSP_FSETSH(hMcbsp,SPCR,   RINTM,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,RSYNCERR,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,   RFULL,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,    RRDY,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SPCR,    RRST,DEFAULT);

    MCBSP_FSETSH(hMcbsp, RCR,  RPHASE,DEFAULT);
    MCBSP_FSETSH(hMcbsp, RCR, RFRLEN2,DEFAULT);
    MCBSP_FSETSH(hMcbsp, RCR, RWDLEN2,DEFAULT);
    MCBSP_FSETSH(hMcbsp, RCR,RCOMPAND,DEFAULT);
    MCBSP_FSETSH(hMcbsp, RCR,    RFIG,DEFAULT);
    MCBSP_FSETSH(hMcbsp, RCR, RDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSH(hMcbsp, RCR, RPHASE2,DEFAULT);
#endif
    MCBSP_FSETSH(hMcbsp, RCR, RFRLEN1,DEFAULT);
    MCBSP_FSETSH(hMcbsp, RCR, RWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSH(hMcbsp, RCR,RWDREVRS,DEFAULT);
#endif

    MCBSP_FSETSH(hMcbsp, XCR,  XPHASE,DEFAULT);
    MCBSP_FSETSH(hMcbsp, XCR, XFRLEN2,DEFAULT);
    MCBSP_FSETSH(hMcbsp, XCR, XWDLEN2,DEFAULT);
    MCBSP_FSETSH(hMcbsp, XCR,XCOMPAND,DEFAULT);
    MCBSP_FSETSH(hMcbsp, XCR,    XFIG,DEFAULT);
    MCBSP_FSETSH(hMcbsp, XCR, XDATDLY,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSH(hMcbsp, XCR, XPHASE2,DEFAULT);
#endif
    MCBSP_FSETSH(hMcbsp, XCR, XFRLEN1,DEFAULT);
    MCBSP_FSETSH(hMcbsp, XCR, XWDLEN1,DEFAULT);
#if (C11_SUPPORT)
    MCBSP_FSETSH(hMcbsp, XCR,XWDREVRS,DEFAULT);
#endif

    MCBSP_FSETSH(hMcbsp,SRGR,   GSYNC,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SRGR,   CLKSP,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SRGR,   CLKSM,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SRGR,    FSGM,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SRGR,    FPER,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SRGR,    FWID,DEFAULT);
    MCBSP_FSETSH(hMcbsp,SRGR,  CLKGDV,DEFAULT);

    MCBSP_FSETSH(hMcbsp, MCR,  XPBBLK,DEFAULT);
    MCBSP_FSETSH(hMcbsp, MCR,  XPABLK,DEFAULT);
    MCBSP_FSETSH(hMcbsp, MCR,   XCBLK,DEFAULT);
    MCBSP_FSETSH(hMcbsp, MCR,    XMCM,DEFAULT);
    MCBSP_FSETSH(hMcbsp, MCR,  RPBBLK,DEFAULT);
    MCBSP_FSETSH(hMcbsp, MCR,  RPABLK,DEFAULT);
    MCBSP_FSETSH(hMcbsp, MCR,   RCBLK,DEFAULT);
    MCBSP_FSETSH(hMcbsp, MCR,    RMCM,DEFAULT);

    MCBSP_FSETSH(hMcbsp,RCER,    RCEB,DEFAULT);
    MCBSP_FSETSH(hMcbsp,RCER,    RCEA,DEFAULT);

    MCBSP_FSETSH(hMcbsp,XCER,    XCEB,DEFAULT);
    MCBSP_FSETSH(hMcbsp,XCER,    XCEA,DEFAULT);

    MCBSP_FSETSH(hMcbsp, PCR,   XIOEN,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,   RIOEN,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,    FSXM,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,    FSRM,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,   CLKXM,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,   CLKRM,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,CLKSSTAT,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,  DXSTAT,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,  DRSTAT,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,    FSXP,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,    FSRP,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,   CLKXP,DEFAULT);
    MCBSP_FSETSH(hMcbsp, PCR,   CLKRP,DEFAULT);

/*  Test FSETSA Macro end */

  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_pci(int arg) {
  
  #if (PCI_SUPPORT&&PCI_BUILD)


/*  Test FMK Macro start */
    x = PCI_FMK(RSTSRC,     CFGERR,0XFFFFFFFF);
    x = PCI_FMK(RSTSRC,    CFGDONE,0XFFFFFFFF);
    x = PCI_FMK(RSTSRC,     INTRST,0XFFFFFFFF);
    x = PCI_FMK(RSTSRC,     INTREQ,0XFFFFFFFF);
    x = PCI_FMK(RSTSRC,    WARMRST,0XFFFFFFFF);
    x = PCI_FMK(RSTSRC,       PRST,0XFFFFFFFF);
    x = PCI_FMK(RSTSRC,        RST,0XFFFFFFFF);
    
	x = PCI_FMK(PMDCSR,   HWPMECTL,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,D3WARMONWKP,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,D2WARMONWKP,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,      PMEEN,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,     PWRWKP,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,    PMESTAT,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,    PMEDRVN,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,  AUXDETECT,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,   CURSTATE,0XFFFFFFFF);
	x = PCI_FMK(PMDCSR,   REQSTATE,0XFFFFFFFF);

	x = PCI_FMK( PCIIS,  DMAHALTED,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,       PRST,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,      EERDY,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,     CFGERR,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,    CFGDONE,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,   MASTEROK,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,      PWRHL,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,      PWRLH,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,     HOSTSW,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,  PCIMASTER,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,  PCITARGET,0XFFFFFFFF);
	x = PCI_FMK( PCIIS,    PWRMGMT,0XFFFFFFFF);

    x = PCI_FMK(PCIIEN,       PRST,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,      EERDY,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,     CFGERR,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,    CFGDONE,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,   MASTEROK,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,      PWRHL,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,      PWRLH,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,     HOSTSW,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,  PCIMASTER,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,  PCITARGET,0XFFFFFFFF);
    x = PCI_FMK(PCIIEN,    PWRMGMT,0XFFFFFFFF);

    x = PCI_FMK( DSPMA,     ADDRMA,0XFFFFFFFF);
    x = PCI_FMK( DSPMA,       AINC,0XFFFFFFFF);
    x = PCI_FMK( PCIMA,     ADDRMA,0XFFFFFFFF);
    x = PCI_FMK( PCIMC,        CNT,0XFFFFFFFF);
    x = PCI_FMK( PCIMC,      START,0XFFFFFFFF);

    x = PCI_FMK( CDSPA,      CDSPA,0XFFFFFFFF);
    x = PCI_FMK( CPCIA,      CPCIA,0XFFFFFFFF);
    x = PCI_FMK(  CCNT,       CCNT,0XFFFFFFFF);
    x = PCI_FMK(  HALT,       HALT,0XFFFFFFFF);
    x = PCI_FMK( EEADD,      EEADD,0XFFFFFFFF);
    x = PCI_FMK( EEDAT,      EEDAT,0XFFFFFFFF);
    x = PCI_FMK( EECTL,    CFGDONE,0XFFFFFFFF);
    x = PCI_FMK( EECTL,     CFGERR,0XFFFFFFFF);
    x = PCI_FMK( EECTL,       EEAI,0XFFFFFFFF);
    x = PCI_FMK( EECTL,       EESZ,0XFFFFFFFF);
    x = PCI_FMK( EECTL,      READY,0XFFFFFFFF);
    x = PCI_FMK( EECTL,      EECNT,0XFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = PCI_FMKS(RSTSRC,     CFGERR,DEFAULT);
    x = PCI_FMKS(RSTSRC,    CFGDONE,DEFAULT);
    x = PCI_FMKS(RSTSRC,     INTRST,DEFAULT);
    x = PCI_FMKS(RSTSRC,     INTREQ,DEFAULT);
    x = PCI_FMKS(RSTSRC,    WARMRST,DEFAULT);
    x = PCI_FMKS(RSTSRC,       PRST,DEFAULT);
    x = PCI_FMKS(RSTSRC,        RST,DEFAULT);
    
	x = PCI_FMKS(PMDCSR,   HWPMECTL,DEFAULT);
	x = PCI_FMKS(PMDCSR,D3WARMONWKP,DEFAULT);
	x = PCI_FMKS(PMDCSR,D2WARMONWKP,DEFAULT);
	x = PCI_FMKS(PMDCSR,      PMEEN,DEFAULT);
	x = PCI_FMKS(PMDCSR,     PWRWKP,DEFAULT);
	x = PCI_FMKS(PMDCSR,    PMESTAT,DEFAULT);
	x = PCI_FMKS(PMDCSR,    PMEDRVN,DEFAULT);
	x = PCI_FMKS(PMDCSR,  AUXDETECT,DEFAULT);
	x = PCI_FMKS(PMDCSR,   CURSTATE,DEFAULT);
	x = PCI_FMKS(PMDCSR,   REQSTATE,DEFAULT);

	x = PCI_FMKS( PCIIS,  DMAHALTED,DEFAULT);
	x = PCI_FMKS( PCIIS,       PRST,DEFAULT);
	x = PCI_FMKS( PCIIS,      EERDY,DEFAULT);
	x = PCI_FMKS( PCIIS,     CFGERR,DEFAULT);
	x = PCI_FMKS( PCIIS,    CFGDONE,DEFAULT);
	x = PCI_FMKS( PCIIS,   MASTEROK,DEFAULT);
	x = PCI_FMKS( PCIIS,      PWRHL,DEFAULT);
	x = PCI_FMKS( PCIIS,      PWRLH,DEFAULT);
	x = PCI_FMKS( PCIIS,     HOSTSW,DEFAULT);
	x = PCI_FMKS( PCIIS,  PCIMASTER,DEFAULT);
	x = PCI_FMKS( PCIIS,  PCITARGET,DEFAULT);
	x = PCI_FMKS( PCIIS,    PWRMGMT,DEFAULT);

    x = PCI_FMKS(PCIIEN,       PRST,DEFAULT);
    x = PCI_FMKS(PCIIEN,      EERDY,DEFAULT);
    x = PCI_FMKS(PCIIEN,     CFGERR,DEFAULT);
    x = PCI_FMKS(PCIIEN,    CFGDONE,DEFAULT);
    x = PCI_FMKS(PCIIEN,   MASTEROK,DEFAULT);
    x = PCI_FMKS(PCIIEN,      PWRHL,DEFAULT);
    x = PCI_FMKS(PCIIEN,      PWRLH,DEFAULT);
    x = PCI_FMKS(PCIIEN,     HOSTSW,DEFAULT);
    x = PCI_FMKS(PCIIEN,  PCIMASTER,DEFAULT);
    x = PCI_FMKS(PCIIEN,  PCITARGET,DEFAULT);
    x = PCI_FMKS(PCIIEN,    PWRMGMT,DEFAULT);

    x = PCI_FMKS( DSPMA,     ADDRMA,DEFAULT);
    x = PCI_FMKS( DSPMA,       AINC,DEFAULT);
    x = PCI_FMKS( PCIMA,     ADDRMA,DEFAULT);
    x = PCI_FMKS( PCIMC,        CNT,DEFAULT);
    x = PCI_FMKS( PCIMC,      START,DEFAULT);

    x = PCI_FMKS( CDSPA,      CDSPA,DEFAULT);
    x = PCI_FMKS( CPCIA,      CPCIA,DEFAULT);
    x = PCI_FMKS(  CCNT,       CCNT,DEFAULT);
    x = PCI_FMKS(  HALT,       HALT,DEFAULT);
    x = PCI_FMKS( EEADD,      EEADD,DEFAULT);
    x = PCI_FMKS( EEDAT,      EEDAT,DEFAULT);
    x = PCI_FMKS( EECTL,    CFGDONE,DEFAULT);
    x = PCI_FMKS( EECTL,     CFGERR,DEFAULT);
    x = PCI_FMKS( EECTL,       EEAI,DEFAULT);
    x = PCI_FMKS( EECTL,       EESZ,DEFAULT);
    x = PCI_FMKS( EECTL,      READY,DEFAULT);
    x = PCI_FMKS( EECTL,      EECNT,DEFAULT);


/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = PCI_ADDR(RSTSRC);
	x = PCI_ADDR(PMDCSR);
	x = PCI_ADDR( PCIIS);
    x = PCI_ADDR(PCIIEN);
    x = PCI_ADDR( DSPMA);
    x = PCI_ADDR( PCIMA);
    x = PCI_ADDR( PCIMC);
    x = PCI_ADDR( CDSPA);
    x = PCI_ADDR( CPCIA);
    x = PCI_ADDR(  CCNT);
    x = PCI_ADDR(  HALT);
    x = PCI_ADDR( EEADD);
    x = PCI_ADDR( EEDAT);
    x = PCI_ADDR( EECTL);

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = PCI_RGET(RSTSRC);
	x = PCI_RGET(PMDCSR);
	x = PCI_RGET( PCIIS);
    x = PCI_RGET(PCIIEN);
    x = PCI_RGET( DSPMA);
    x = PCI_RGET( PCIMA);
    x = PCI_RGET( PCIMC);
    x = PCI_RGET( CDSPA);
    x = PCI_RGET( CPCIA);
    x = PCI_RGET(  CCNT);
    x = PCI_RGET(  HALT);
    x = PCI_RGET( EEADD);
    x = PCI_RGET( EEDAT);
    x = PCI_RGET( EECTL);


/*  Test RGET Macro end */
/*  Test RSET Macro start */
    PCI_RSET(RSTSRC,PCI_RSTSRC_DEFAULT);
	PCI_RSET(PMDCSR,PCI_PMDCSR_DEFAULT);
	PCI_RSET( PCIIS, PCI_PCIIS_DEFAULT);
    PCI_RSET(PCIIEN,PCI_PCIIEN_DEFAULT);
    PCI_RSET( DSPMA, PCI_DSPMA_DEFAULT);
    PCI_RSET( PCIMA, PCI_PCIMA_DEFAULT);
    PCI_RSET( PCIMC, PCI_PCIMC_DEFAULT);
    PCI_RSET( CDSPA, PCI_CDSPA_DEFAULT);
    PCI_RSET( CPCIA, PCI_CPCIA_DEFAULT);
    PCI_RSET(  CCNT,  PCI_CCNT_DEFAULT);
    PCI_RSET(  HALT,  PCI_HALT_DEFAULT);
    PCI_RSET( EEADD, PCI_EEADD_DEFAULT);
    PCI_RSET( EEDAT, PCI_EEDAT_DEFAULT);
    PCI_RSET( EECTL, PCI_EECTL_DEFAULT);

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = PCI_FGET(RSTSRC,     CFGERR);
    x = PCI_FGET(RSTSRC,    CFGDONE);
    x = PCI_FGET(RSTSRC,     INTRST);
    x = PCI_FGET(RSTSRC,     INTREQ);
    x = PCI_FGET(RSTSRC,    WARMRST);
    x = PCI_FGET(RSTSRC,       PRST);
    x = PCI_FGET(RSTSRC,        RST);
    
	x = PCI_FGET(PMDCSR,   HWPMECTL);
	x = PCI_FGET(PMDCSR,D3WARMONWKP);
	x = PCI_FGET(PMDCSR,D2WARMONWKP);
	x = PCI_FGET(PMDCSR,      PMEEN);
	x = PCI_FGET(PMDCSR,     PWRWKP);
	x = PCI_FGET(PMDCSR,    PMESTAT);
	x = PCI_FGET(PMDCSR,    PMEDRVN);
	x = PCI_FGET(PMDCSR,  AUXDETECT);
	x = PCI_FGET(PMDCSR,   CURSTATE);
	x = PCI_FGET(PMDCSR,   REQSTATE);

	x = PCI_FGET( PCIIS,  DMAHALTED);
	x = PCI_FGET( PCIIS,       PRST);
	x = PCI_FGET( PCIIS,      EERDY);
	x = PCI_FGET( PCIIS,     CFGERR);
	x = PCI_FGET( PCIIS,    CFGDONE);
	x = PCI_FGET( PCIIS,   MASTEROK);
	x = PCI_FGET( PCIIS,      PWRHL);
	x = PCI_FGET( PCIIS,      PWRLH);
	x = PCI_FGET( PCIIS,     HOSTSW);
	x = PCI_FGET( PCIIS,  PCIMASTER);
	x = PCI_FGET( PCIIS,  PCITARGET);
	x = PCI_FGET( PCIIS,    PWRMGMT);

    x = PCI_FGET(PCIIEN,       PRST);
    x = PCI_FGET(PCIIEN,      EERDY);
    x = PCI_FGET(PCIIEN,     CFGERR);
    x = PCI_FGET(PCIIEN,    CFGDONE);
    x = PCI_FGET(PCIIEN,   MASTEROK);
    x = PCI_FGET(PCIIEN,      PWRHL);
    x = PCI_FGET(PCIIEN,      PWRLH);
    x = PCI_FGET(PCIIEN,     HOSTSW);
    x = PCI_FGET(PCIIEN,  PCIMASTER);
    x = PCI_FGET(PCIIEN,  PCITARGET);
    x = PCI_FGET(PCIIEN,    PWRMGMT);

    x = PCI_FGET( DSPMA,     ADDRMA);
    x = PCI_FGET( DSPMA,       AINC);
    x = PCI_FGET( PCIMA,     ADDRMA);
    x = PCI_FGET( PCIMC,        CNT);
    x = PCI_FGET( PCIMC,      START);

    x = PCI_FGET( CDSPA,      CDSPA);
    x = PCI_FGET( CPCIA,      CPCIA);
    x = PCI_FGET(  CCNT,       CCNT);
    x = PCI_FGET(  HALT,       HALT);
    x = PCI_FGET( EEADD,      EEADD);
    x = PCI_FGET( EEDAT,      EEDAT);
    x = PCI_FGET( EECTL,    CFGDONE);
    x = PCI_FGET( EECTL,     CFGERR);
    x = PCI_FGET( EECTL,       EEAI);
    x = PCI_FGET( EECTL,       EESZ);
    x = PCI_FGET( EECTL,      READY);
    x = PCI_FGET( EECTL,      EECNT);


/*  Test FGET Macro end */
/*  Test FSET Macro start */
    PCI_FSET(RSTSRC,     CFGERR,     PCI_RSTSRC_CFGERR_DEFAULT);
    PCI_FSET(RSTSRC,    CFGDONE,    PCI_RSTSRC_CFGDONE_DEFAULT);
    PCI_FSET(RSTSRC,     INTRST,     PCI_RSTSRC_INTRST_DEFAULT);
    PCI_FSET(RSTSRC,     INTREQ,     PCI_RSTSRC_INTREQ_DEFAULT);
    PCI_FSET(RSTSRC,    WARMRST,    PCI_RSTSRC_WARMRST_DEFAULT);
    PCI_FSET(RSTSRC,       PRST,       PCI_RSTSRC_PRST_DEFAULT);
    PCI_FSET(RSTSRC,        RST,        PCI_RSTSRC_RST_DEFAULT);
    
	PCI_FSET(PMDCSR,   HWPMECTL,   PCI_PMDCSR_HWPMECTL_DEFAULT);
	PCI_FSET(PMDCSR,D3WARMONWKP,PCI_PMDCSR_D3WARMONWKP_DEFAULT);
	PCI_FSET(PMDCSR,D2WARMONWKP,PCI_PMDCSR_D2WARMONWKP_DEFAULT);
	PCI_FSET(PMDCSR,      PMEEN,      PCI_PMDCSR_PMEEN_DEFAULT);
	PCI_FSET(PMDCSR,     PWRWKP,     PCI_PMDCSR_PWRWKP_DEFAULT);
	PCI_FSET(PMDCSR,    PMESTAT,    PCI_PMDCSR_PMESTAT_DEFAULT);
	PCI_FSET(PMDCSR,    PMEDRVN,    PCI_PMDCSR_PMEDRVN_DEFAULT);
	PCI_FSET(PMDCSR,  AUXDETECT,  PCI_PMDCSR_AUXDETECT_DEFAULT);
	PCI_FSET(PMDCSR,   CURSTATE,   PCI_PMDCSR_CURSTATE_DEFAULT);
	PCI_FSET(PMDCSR,   REQSTATE,   PCI_PMDCSR_REQSTATE_DEFAULT);

	PCI_FSET( PCIIS,  DMAHALTED,   PCI_PCIIS_DMAHALTED_DEFAULT);
	PCI_FSET( PCIIS,       PRST,        PCI_PCIIS_PRST_DEFAULT);
	PCI_FSET( PCIIS,      EERDY,       PCI_PCIIS_EERDY_DEFAULT);
	PCI_FSET( PCIIS,     CFGERR,      PCI_PCIIS_CFGERR_DEFAULT);
	PCI_FSET( PCIIS,    CFGDONE,     PCI_PCIIS_CFGDONE_DEFAULT);
	PCI_FSET( PCIIS,   MASTEROK,    PCI_PCIIS_MASTEROK_DEFAULT);
	PCI_FSET( PCIIS,      PWRHL,       PCI_PCIIS_PWRHL_DEFAULT);
	PCI_FSET( PCIIS,      PWRLH,       PCI_PCIIS_PWRLH_DEFAULT);
	PCI_FSET( PCIIS,     HOSTSW,      PCI_PCIIS_HOSTSW_DEFAULT);
	PCI_FSET( PCIIS,  PCIMASTER,   PCI_PCIIS_PCIMASTER_DEFAULT);
	PCI_FSET( PCIIS,  PCITARGET,   PCI_PCIIS_PCITARGET_DEFAULT);
	PCI_FSET( PCIIS,    PWRMGMT,     PCI_PCIIS_PWRMGMT_DEFAULT);

    PCI_FSET(PCIIEN,       PRST,       PCI_PCIIEN_PRST_DEFAULT);
    PCI_FSET(PCIIEN,      EERDY,      PCI_PCIIEN_EERDY_DEFAULT);
    PCI_FSET(PCIIEN,     CFGERR,     PCI_PCIIEN_CFGERR_DEFAULT);
    PCI_FSET(PCIIEN,    CFGDONE,    PCI_PCIIEN_CFGDONE_DEFAULT);
    PCI_FSET(PCIIEN,   MASTEROK,   PCI_PCIIEN_MASTEROK_DEFAULT);
    PCI_FSET(PCIIEN,      PWRHL,      PCI_PCIIEN_PWRHL_DEFAULT);
    PCI_FSET(PCIIEN,      PWRLH,      PCI_PCIIEN_PWRLH_DEFAULT);
    PCI_FSET(PCIIEN,     HOSTSW,     PCI_PCIIEN_HOSTSW_DEFAULT);
    PCI_FSET(PCIIEN,  PCIMASTER,  PCI_PCIIEN_PCIMASTER_DEFAULT);
    PCI_FSET(PCIIEN,  PCITARGET,  PCI_PCIIEN_PCITARGET_DEFAULT);
    PCI_FSET(PCIIEN,    PWRMGMT,    PCI_PCIIEN_PWRMGMT_DEFAULT);

    PCI_FSET( DSPMA,     ADDRMA,      PCI_DSPMA_ADDRMA_DEFAULT);
    PCI_FSET( DSPMA,       AINC,        PCI_DSPMA_AINC_DEFAULT);
    PCI_FSET( PCIMA,     ADDRMA,      PCI_PCIMA_ADDRMA_DEFAULT);
    PCI_FSET( PCIMC,        CNT,         PCI_PCIMC_CNT_DEFAULT);
    PCI_FSET( PCIMC,      START,       PCI_PCIMC_START_DEFAULT);

    PCI_FSET( CDSPA,      CDSPA,       PCI_CDSPA_CDSPA_DEFAULT);
    PCI_FSET( CPCIA,      CPCIA,       PCI_CPCIA_CPCIA_DEFAULT);
    PCI_FSET(  CCNT,       CCNT,         PCI_CCNT_CCNT_DEFAULT);
    PCI_FSET(  HALT,       HALT,         PCI_HALT_HALT_DEFAULT);
    PCI_FSET( EEADD,      EEADD,       PCI_EEADD_EEADD_DEFAULT);
    PCI_FSET( EEDAT,      EEDAT,       PCI_EEDAT_EEDAT_DEFAULT);
    PCI_FSET( EECTL,    CFGDONE,     PCI_EECTL_CFGDONE_DEFAULT);
    PCI_FSET( EECTL,     CFGERR,      PCI_EECTL_CFGERR_DEFAULT);
    PCI_FSET( EECTL,       EEAI,        PCI_EECTL_EEAI_DEFAULT);
    PCI_FSET( EECTL,       EESZ,        PCI_EECTL_EESZ_DEFAULT);
    PCI_FSET( EECTL,      READY,       PCI_EECTL_READY_DEFAULT);
    PCI_FSET( EECTL,      EECNT,       PCI_EECTL_EECNT_DEFAULT);

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    PCI_FSETS(RSTSRC,     CFGERR,DEFAULT);
    PCI_FSETS(RSTSRC,    CFGDONE,DEFAULT);
    PCI_FSETS(RSTSRC,     INTRST,DEFAULT);
    PCI_FSETS(RSTSRC,     INTREQ,DEFAULT);
    PCI_FSETS(RSTSRC,    WARMRST,DEFAULT);
    PCI_FSETS(RSTSRC,       PRST,DEFAULT);
    PCI_FSETS(RSTSRC,        RST,DEFAULT);
    
	PCI_FSETS(PMDCSR,   HWPMECTL,DEFAULT);
	PCI_FSETS(PMDCSR,D3WARMONWKP,DEFAULT);
	PCI_FSETS(PMDCSR,D2WARMONWKP,DEFAULT);
	PCI_FSETS(PMDCSR,      PMEEN,DEFAULT);
	PCI_FSETS(PMDCSR,     PWRWKP,DEFAULT);
	PCI_FSETS(PMDCSR,    PMESTAT,DEFAULT);
	PCI_FSETS(PMDCSR,    PMEDRVN,DEFAULT);
	PCI_FSETS(PMDCSR,  AUXDETECT,DEFAULT);
	PCI_FSETS(PMDCSR,   CURSTATE,DEFAULT);
	PCI_FSETS(PMDCSR,   REQSTATE,DEFAULT);

	PCI_FSETS( PCIIS,  DMAHALTED,DEFAULT);
	PCI_FSETS( PCIIS,       PRST,DEFAULT);
	PCI_FSETS( PCIIS,      EERDY,DEFAULT);
	PCI_FSETS( PCIIS,     CFGERR,DEFAULT);
	PCI_FSETS( PCIIS,    CFGDONE,DEFAULT);
	PCI_FSETS( PCIIS,   MASTEROK,DEFAULT);
	PCI_FSETS( PCIIS,      PWRHL,DEFAULT);
	PCI_FSETS( PCIIS,      PWRLH,DEFAULT);
	PCI_FSETS( PCIIS,     HOSTSW,DEFAULT);
	PCI_FSETS( PCIIS,  PCIMASTER,DEFAULT);
	PCI_FSETS( PCIIS,  PCITARGET,DEFAULT);
	PCI_FSETS( PCIIS,    PWRMGMT,DEFAULT);

    PCI_FSETS(PCIIEN,       PRST,DEFAULT);
    PCI_FSETS(PCIIEN,      EERDY,DEFAULT);
    PCI_FSETS(PCIIEN,     CFGERR,DEFAULT);
    PCI_FSETS(PCIIEN,    CFGDONE,DEFAULT);
    PCI_FSETS(PCIIEN,   MASTEROK,DEFAULT);
    PCI_FSETS(PCIIEN,      PWRHL,DEFAULT);
    PCI_FSETS(PCIIEN,      PWRLH,DEFAULT);
    PCI_FSETS(PCIIEN,     HOSTSW,DEFAULT);
    PCI_FSETS(PCIIEN,  PCIMASTER,DEFAULT);
    PCI_FSETS(PCIIEN,  PCITARGET,DEFAULT);
    PCI_FSETS(PCIIEN,    PWRMGMT,DEFAULT);

    PCI_FSETS( DSPMA,     ADDRMA,DEFAULT);
    PCI_FSETS( DSPMA,       AINC,DEFAULT);
    PCI_FSETS( PCIMA,     ADDRMA,DEFAULT);
    PCI_FSETS( PCIMC,        CNT,DEFAULT);
    PCI_FSETS( PCIMC,      START,DEFAULT);

    PCI_FSETS( CDSPA,      CDSPA,DEFAULT);
    PCI_FSETS( CPCIA,      CPCIA,DEFAULT);
    PCI_FSETS(  CCNT,       CCNT,DEFAULT);
    PCI_FSETS(  HALT,       HALT,DEFAULT);
    PCI_FSETS( EEADD,      EEADD,DEFAULT);
    PCI_FSETS( EEDAT,      EEDAT,DEFAULT);
    PCI_FSETS( EECTL,    CFGDONE,DEFAULT);
    PCI_FSETS( EECTL,     CFGERR,DEFAULT);
    PCI_FSETS( EECTL,       EEAI,DEFAULT);
    PCI_FSETS( EECTL,       EESZ,DEFAULT);
    PCI_FSETS( EECTL,      READY,DEFAULT);
    PCI_FSETS( EECTL,      EECNT,DEFAULT);

/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = PCI_RGETA(0, RSTSRC);
	x = PCI_RGETA(0, PMDCSR);
	x = PCI_RGETA(0,  PCIIS);
    x = PCI_RGETA(0, PCIIEN);
    x = PCI_RGETA(0,  DSPMA);
    x = PCI_RGETA(0,  PCIMA);
    x = PCI_RGETA(0,  PCIMC);
    x = PCI_RGETA(0,  CDSPA);
    x = PCI_RGETA(0,  CPCIA);
    x = PCI_RGETA(0,   CCNT);
    x = PCI_RGETA(0,   HALT);
    x = PCI_RGETA(0,  EEADD);
    x = PCI_RGETA(0,  EEDAT);
    x = PCI_RGETA(0,  EECTL);


/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    PCI_RSETA(0, RSTSRC,PCI_RSTSRC_DEFAULT);
	PCI_RSETA(0, PMDCSR,PCI_PMDCSR_DEFAULT);
	PCI_RSETA(0,  PCIIS, PCI_PCIIS_DEFAULT);
    PCI_RSETA(0, PCIIEN,PCI_PCIIEN_DEFAULT);
    PCI_RSETA(0,  DSPMA, PCI_DSPMA_DEFAULT);
    PCI_RSETA(0,  PCIMA, PCI_PCIMA_DEFAULT);
    PCI_RSETA(0,  PCIMC, PCI_PCIMC_DEFAULT);
    PCI_RSETA(0,  CDSPA, PCI_CDSPA_DEFAULT);
    PCI_RSETA(0,  CPCIA, PCI_CPCIA_DEFAULT);
    PCI_RSETA(0,   CCNT,  PCI_CCNT_DEFAULT);
    PCI_RSETA(0,   HALT,  PCI_HALT_DEFAULT);
    PCI_RSETA(0,  EEADD, PCI_EEADD_DEFAULT);
    PCI_RSETA(0,  EEDAT, PCI_EEDAT_DEFAULT);
    PCI_RSETA(0,  EECTL, PCI_EECTL_DEFAULT);


/*  Test RSETA Macro end */
    x = PCI_FGETA(0, RSTSRC,     CFGERR);
    x = PCI_FGETA(0, RSTSRC,    CFGDONE);
    x = PCI_FGETA(0, RSTSRC,     INTRST);
    x = PCI_FGETA(0, RSTSRC,     INTREQ);
    x = PCI_FGETA(0, RSTSRC,    WARMRST);
    x = PCI_FGETA(0, RSTSRC,       PRST);
    x = PCI_FGETA(0, RSTSRC,        RST);
    
	x = PCI_FGETA(0, PMDCSR,   HWPMECTL);
	x = PCI_FGETA(0, PMDCSR,D3WARMONWKP);
	x = PCI_FGETA(0, PMDCSR,D2WARMONWKP);
	x = PCI_FGETA(0, PMDCSR,      PMEEN);
	x = PCI_FGETA(0, PMDCSR,     PWRWKP);
	x = PCI_FGETA(0, PMDCSR,    PMESTAT);
	x = PCI_FGETA(0, PMDCSR,    PMEDRVN);
	x = PCI_FGETA(0, PMDCSR,  AUXDETECT);
	x = PCI_FGETA(0, PMDCSR,   CURSTATE);
	x = PCI_FGETA(0, PMDCSR,   REQSTATE);

	x = PCI_FGETA(0,  PCIIS,  DMAHALTED);
	x = PCI_FGETA(0,  PCIIS,       PRST);
	x = PCI_FGETA(0,  PCIIS,      EERDY);
	x = PCI_FGETA(0,  PCIIS,     CFGERR);
	x = PCI_FGETA(0,  PCIIS,    CFGDONE);
	x = PCI_FGETA(0,  PCIIS,   MASTEROK);
	x = PCI_FGETA(0,  PCIIS,      PWRHL);
	x = PCI_FGETA(0,  PCIIS,      PWRLH);
	x = PCI_FGETA(0,  PCIIS,     HOSTSW);
	x = PCI_FGETA(0,  PCIIS,  PCIMASTER);
	x = PCI_FGETA(0,  PCIIS,  PCITARGET);
	x = PCI_FGETA(0,  PCIIS,    PWRMGMT);

    x = PCI_FGETA(0, PCIIEN,       PRST);
    x = PCI_FGETA(0, PCIIEN,      EERDY);
    x = PCI_FGETA(0, PCIIEN,     CFGERR);
    x = PCI_FGETA(0, PCIIEN,    CFGDONE);
    x = PCI_FGETA(0, PCIIEN,   MASTEROK);
    x = PCI_FGETA(0, PCIIEN,      PWRHL);
    x = PCI_FGETA(0, PCIIEN,      PWRLH);
    x = PCI_FGETA(0, PCIIEN,     HOSTSW);
    x = PCI_FGETA(0, PCIIEN,  PCIMASTER);
    x = PCI_FGETA(0, PCIIEN,  PCITARGET);
    x = PCI_FGETA(0, PCIIEN,    PWRMGMT);

    x = PCI_FGETA(0,  DSPMA,     ADDRMA);
    x = PCI_FGETA(0,  DSPMA,       AINC);
    x = PCI_FGETA(0,  PCIMA,     ADDRMA);
    x = PCI_FGETA(0,  PCIMC,        CNT);
    x = PCI_FGETA(0,  PCIMC,      START);

    x = PCI_FGETA(0,  CDSPA,      CDSPA);
    x = PCI_FGETA(0,  CPCIA,      CPCIA);
    x = PCI_FGETA(0,   CCNT,       CCNT);
    x = PCI_FGETA(0,   HALT,       HALT);
    x = PCI_FGETA(0,  EEADD,      EEADD);
    x = PCI_FGETA(0,  EEDAT,      EEDAT);
    x = PCI_FGETA(0,  EECTL,    CFGDONE);
    x = PCI_FGETA(0,  EECTL,     CFGERR);
    x = PCI_FGETA(0,  EECTL,       EEAI);
    x = PCI_FGETA(0,  EECTL,       EESZ);
    x = PCI_FGETA(0,  EECTL,      READY);
    x = PCI_FGETA(0,  EECTL,      EECNT);


/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    PCI_FSETA(0, RSTSRC,     CFGERR,     PCI_RSTSRC_CFGERR_DEFAULT);
    PCI_FSETA(0, RSTSRC,    CFGDONE,    PCI_RSTSRC_CFGDONE_DEFAULT);
    PCI_FSETA(0, RSTSRC,     INTRST,     PCI_RSTSRC_INTRST_DEFAULT);
    PCI_FSETA(0, RSTSRC,     INTREQ,     PCI_RSTSRC_INTREQ_DEFAULT);
    PCI_FSETA(0, RSTSRC,    WARMRST,    PCI_RSTSRC_WARMRST_DEFAULT);
    PCI_FSETA(0, RSTSRC,       PRST,       PCI_RSTSRC_PRST_DEFAULT);
    PCI_FSETA(0, RSTSRC,        RST,        PCI_RSTSRC_RST_DEFAULT);
    
	PCI_FSETA(0, PMDCSR,   HWPMECTL,   PCI_PMDCSR_HWPMECTL_DEFAULT);
	PCI_FSETA(0, PMDCSR,D3WARMONWKP,PCI_PMDCSR_D3WARMONWKP_DEFAULT);
	PCI_FSETA(0, PMDCSR,D2WARMONWKP,PCI_PMDCSR_D2WARMONWKP_DEFAULT);
	PCI_FSETA(0, PMDCSR,      PMEEN,      PCI_PMDCSR_PMEEN_DEFAULT);
	PCI_FSETA(0, PMDCSR,     PWRWKP,     PCI_PMDCSR_PWRWKP_DEFAULT);
	PCI_FSETA(0, PMDCSR,    PMESTAT,    PCI_PMDCSR_PMESTAT_DEFAULT);
	PCI_FSETA(0, PMDCSR,    PMEDRVN,    PCI_PMDCSR_PMEDRVN_DEFAULT);
	PCI_FSETA(0, PMDCSR,  AUXDETECT,  PCI_PMDCSR_AUXDETECT_DEFAULT);
	PCI_FSETA(0, PMDCSR,   CURSTATE,   PCI_PMDCSR_CURSTATE_DEFAULT);
	PCI_FSETA(0, PMDCSR,   REQSTATE,   PCI_PMDCSR_REQSTATE_DEFAULT);

	PCI_FSETA(0,  PCIIS,  DMAHALTED,   PCI_PCIIS_DMAHALTED_DEFAULT);
	PCI_FSETA(0,  PCIIS,       PRST,        PCI_PCIIS_PRST_DEFAULT);
	PCI_FSETA(0,  PCIIS,      EERDY,       PCI_PCIIS_EERDY_DEFAULT);
	PCI_FSETA(0,  PCIIS,     CFGERR,      PCI_PCIIS_CFGERR_DEFAULT);
	PCI_FSETA(0,  PCIIS,    CFGDONE,     PCI_PCIIS_CFGDONE_DEFAULT);
	PCI_FSETA(0,  PCIIS,   MASTEROK,    PCI_PCIIS_MASTEROK_DEFAULT);
	PCI_FSETA(0,  PCIIS,      PWRHL,       PCI_PCIIS_PWRHL_DEFAULT);
	PCI_FSETA(0,  PCIIS,      PWRLH,       PCI_PCIIS_PWRLH_DEFAULT);
	PCI_FSETA(0,  PCIIS,     HOSTSW,      PCI_PCIIS_HOSTSW_DEFAULT);
	PCI_FSETA(0,  PCIIS,  PCIMASTER,   PCI_PCIIS_PCIMASTER_DEFAULT);
	PCI_FSETA(0,  PCIIS,  PCITARGET,   PCI_PCIIS_PCITARGET_DEFAULT);
	PCI_FSETA(0,  PCIIS,    PWRMGMT,     PCI_PCIIS_PWRMGMT_DEFAULT);

    PCI_FSETA(0, PCIIEN,       PRST,       PCI_PCIIEN_PRST_DEFAULT);
    PCI_FSETA(0, PCIIEN,      EERDY,      PCI_PCIIEN_EERDY_DEFAULT);
    PCI_FSETA(0, PCIIEN,     CFGERR,     PCI_PCIIEN_CFGERR_DEFAULT);
    PCI_FSETA(0, PCIIEN,    CFGDONE,    PCI_PCIIEN_CFGDONE_DEFAULT);
    PCI_FSETA(0, PCIIEN,   MASTEROK,   PCI_PCIIEN_MASTEROK_DEFAULT);
    PCI_FSETA(0, PCIIEN,      PWRHL,      PCI_PCIIEN_PWRHL_DEFAULT);
    PCI_FSETA(0, PCIIEN,      PWRLH,      PCI_PCIIEN_PWRLH_DEFAULT);
    PCI_FSETA(0, PCIIEN,     HOSTSW,     PCI_PCIIEN_HOSTSW_DEFAULT);
    PCI_FSETA(0, PCIIEN,  PCIMASTER,  PCI_PCIIEN_PCIMASTER_DEFAULT);
    PCI_FSETA(0, PCIIEN,  PCITARGET,  PCI_PCIIEN_PCITARGET_DEFAULT);
    PCI_FSETA(0, PCIIEN,    PWRMGMT,    PCI_PCIIEN_PWRMGMT_DEFAULT);

    PCI_FSETA(0,  DSPMA,     ADDRMA,      PCI_DSPMA_ADDRMA_DEFAULT);
    PCI_FSETA(0,  DSPMA,       AINC,        PCI_DSPMA_AINC_DEFAULT);
    PCI_FSETA(0,  PCIMA,     ADDRMA,      PCI_PCIMA_ADDRMA_DEFAULT);
    PCI_FSETA(0,  PCIMC,        CNT,         PCI_PCIMC_CNT_DEFAULT);
    PCI_FSETA(0,  PCIMC,      START,       PCI_PCIMC_START_DEFAULT);

    PCI_FSETA(0,  CDSPA,      CDSPA,       PCI_CDSPA_CDSPA_DEFAULT);
    PCI_FSETA(0,  CPCIA,      CPCIA,       PCI_CPCIA_CPCIA_DEFAULT);
    PCI_FSETA(0,   CCNT,       CCNT,         PCI_CCNT_CCNT_DEFAULT);
    PCI_FSETA(0,   HALT,       HALT,         PCI_HALT_HALT_DEFAULT);
    PCI_FSETA(0,  EEADD,      EEADD,       PCI_EEADD_EEADD_DEFAULT);
    PCI_FSETA(0,  EEDAT,      EEDAT,       PCI_EEDAT_EEDAT_DEFAULT);
    PCI_FSETA(0,  EECTL,    CFGDONE,     PCI_EECTL_CFGDONE_DEFAULT);
    PCI_FSETA(0,  EECTL,     CFGERR,      PCI_EECTL_CFGERR_DEFAULT);
    PCI_FSETA(0,  EECTL,       EEAI,        PCI_EECTL_EEAI_DEFAULT);
    PCI_FSETA(0,  EECTL,       EESZ,        PCI_EECTL_EESZ_DEFAULT);
    PCI_FSETA(0,  EECTL,      READY,       PCI_EECTL_READY_DEFAULT);
    PCI_FSETA(0,  EECTL,      EECNT,       PCI_EECTL_EECNT_DEFAULT);

/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    PCI_FSETSA(0, RSTSRC,     CFGERR,DEFAULT);
    PCI_FSETSA(0, RSTSRC,    CFGDONE,DEFAULT);
    PCI_FSETSA(0, RSTSRC,     INTRST,DEFAULT);
    PCI_FSETSA(0, RSTSRC,     INTREQ,DEFAULT);
    PCI_FSETSA(0, RSTSRC,    WARMRST,DEFAULT);
    PCI_FSETSA(0, RSTSRC,       PRST,DEFAULT);
    PCI_FSETSA(0, RSTSRC,        RST,DEFAULT);
    
	PCI_FSETSA(0, PMDCSR,   HWPMECTL,DEFAULT);
	PCI_FSETSA(0, PMDCSR,D3WARMONWKP,DEFAULT);
	PCI_FSETSA(0, PMDCSR,D2WARMONWKP,DEFAULT);
	PCI_FSETSA(0, PMDCSR,      PMEEN,DEFAULT);
	PCI_FSETSA(0, PMDCSR,     PWRWKP,DEFAULT);
	PCI_FSETSA(0, PMDCSR,    PMESTAT,DEFAULT);
	PCI_FSETSA(0, PMDCSR,    PMEDRVN,DEFAULT);
	PCI_FSETSA(0, PMDCSR,  AUXDETECT,DEFAULT);
	PCI_FSETSA(0, PMDCSR,   CURSTATE,DEFAULT);
	PCI_FSETSA(0, PMDCSR,   REQSTATE,DEFAULT);

	PCI_FSETSA(0,  PCIIS,  DMAHALTED,DEFAULT);
	PCI_FSETSA(0,  PCIIS,       PRST,DEFAULT);
	PCI_FSETSA(0,  PCIIS,      EERDY,DEFAULT);
	PCI_FSETSA(0,  PCIIS,     CFGERR,DEFAULT);
	PCI_FSETSA(0,  PCIIS,    CFGDONE,DEFAULT);
	PCI_FSETSA(0,  PCIIS,   MASTEROK,DEFAULT);
	PCI_FSETSA(0,  PCIIS,      PWRHL,DEFAULT);
	PCI_FSETSA(0,  PCIIS,      PWRLH,DEFAULT);
	PCI_FSETSA(0,  PCIIS,     HOSTSW,DEFAULT);
	PCI_FSETSA(0,  PCIIS,  PCIMASTER,DEFAULT);
	PCI_FSETSA(0,  PCIIS,  PCITARGET,DEFAULT);
	PCI_FSETSA(0,  PCIIS,    PWRMGMT,DEFAULT);

    PCI_FSETSA(0, PCIIEN,       PRST,DEFAULT);
    PCI_FSETSA(0, PCIIEN,      EERDY,DEFAULT);
    PCI_FSETSA(0, PCIIEN,     CFGERR,DEFAULT);
    PCI_FSETSA(0, PCIIEN,    CFGDONE,DEFAULT);
    PCI_FSETSA(0, PCIIEN,   MASTEROK,DEFAULT);
    PCI_FSETSA(0, PCIIEN,      PWRHL,DEFAULT);
    PCI_FSETSA(0, PCIIEN,      PWRLH,DEFAULT);
    PCI_FSETSA(0, PCIIEN,     HOSTSW,DEFAULT);
    PCI_FSETSA(0, PCIIEN,  PCIMASTER,DEFAULT);
    PCI_FSETSA(0, PCIIEN,  PCITARGET,DEFAULT);
    PCI_FSETSA(0, PCIIEN,    PWRMGMT,DEFAULT);

    PCI_FSETSA(0,  DSPMA,     ADDRMA,DEFAULT);
    PCI_FSETSA(0,  DSPMA,       AINC,DEFAULT);
    PCI_FSETSA(0,  PCIMA,     ADDRMA,DEFAULT);
    PCI_FSETSA(0,  PCIMC,        CNT,DEFAULT);
    PCI_FSETSA(0,  PCIMC,      START,DEFAULT);

    PCI_FSETSA(0,  CDSPA,      CDSPA,DEFAULT);
    PCI_FSETSA(0,  CPCIA,      CPCIA,DEFAULT);
    PCI_FSETSA(0,   CCNT,       CCNT,DEFAULT);
    PCI_FSETSA(0,   HALT,       HALT,DEFAULT);
    PCI_FSETSA(0,  EEADD,      EEADD,DEFAULT);
    PCI_FSETSA(0,  EEDAT,      EEDAT,DEFAULT);
    PCI_FSETSA(0,  EECTL,    CFGDONE,DEFAULT);
    PCI_FSETSA(0,  EECTL,     CFGERR,DEFAULT);
    PCI_FSETSA(0,  EECTL,       EEAI,DEFAULT);
    PCI_FSETSA(0,  EECTL,       EESZ,DEFAULT);
    PCI_FSETSA(0,  EECTL,      READY,DEFAULT);
    PCI_FSETSA(0,  EECTL,      EECNT,DEFAUALT);

/*  Test FSETS Macro end */
  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_pwr(int arg) {
  
  #if (/*PWR_SUPPORT&&*/PWR_BUILD&&_PWR_COND0)

/*
    x = PWR_PDCTL_GET();
    x = PWR_PDCTL_FGET(MCBSP2);
    x = PWR_PDCTL_FGET(MCBSP1);
    x = PWR_PDCTL_FGET(MCBSP0);
    x = PWR_PDCTL_FGET(EMIF);
    x = PWR_PDCTL_FGET(DMA);

	PWR_PDCTL_SET(PWR_PDCTL_DEFAULT);
    PWR_PDCTL_FSET(MCBSP2,PWR_PDCTL_MCBSP2_DEFAULT);
    PWR_PDCTL_FSET(MCBSP1,PWR_PDCTL_MCBSP1_DEFAULT);
    PWR_PDCTL_FSET(MCBSP0,PWR_PDCTL_MCBSP0_DEFAULT);
    PWR_PDCTL_FSET(EMIF,PWR_PDCTL_EMIF_DEFAULT);
    PWR_PDCTL_FSET(DMA,PWR_PDCTL_DMA_DEFAULT);
*/
  x = PWR_PDCTL_ADDR();
    PWR_PDCTL_RESET();
    x = PWR_PDCTL_MK(
      PWR_PDCTL_MCBSP2_DEFAULT,
      PWR_PDCTL_MCBSP1_DEFAULT,
      PWR_PDCTL_MCBSP0_DEFAULT,
      PWR_PDCTL_EMIF_DEFAULT,
      PWR_PDCTL_DMA_DEFAULT
    );


/*  Test FMK Macro start */
    x = PWR_FMK(   PDCTL, MCBSP2,0XFFFFFFFF);
    x = PWR_FMK(   PDCTL, MCBSP1,0XFFFFFFFF);
    x = PWR_FMK(   PDCTL, MCBSP0,0XFFFFFFFF);
    x = PWR_FMK(   PDCTL,   EMIF,0XFFFFFFFF);
    x = PWR_FMK(   PDCTL,    DMA,0XFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = PWR_FMKS(   PDCTL, MCBSP2,DEFAULT);
    x = PWR_FMKS(   PDCTL, MCBSP1,DEFAULT);
    x = PWR_FMKS(   PDCTL, MCBSP0,DEFAULT);
    x = PWR_FMKS(   PDCTL,   EMIF,DEFAULT);
    x = PWR_FMKS(   PDCTL,    DMA,DEFAULT);

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = PWR_ADDR(  PDCTL);

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = PWR_RGET(  PDCTL);

/*  Test RGET Macro end */
/*  Test RSET Macro start */
    PWR_RSET(  PDCTL, PWR_PDCTL_DEFAULT);

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = PWR_FGET(  PDCTL, MCBSP2);
    x = PWR_FGET(  PDCTL, MCBSP1);
    x = PWR_FGET(  PDCTL, MCBSP0);
    x = PWR_FGET(  PDCTL,   EMIF);
    x = PWR_FGET(  PDCTL,    DMA);

/*  Test FGET Macro end */
/*  Test FSET Macro start */
    PWR_FSET(  PDCTL, MCBSP2,PWR_PDCTL_MCBSP2_DEFAULT);
    PWR_FSET(  PDCTL, MCBSP1,PWR_PDCTL_MCBSP1_DEFAULT);
    PWR_FSET(  PDCTL, MCBSP0,PWR_PDCTL_MCBSP0_DEFAULT);
    PWR_FSET(  PDCTL,   EMIF,  PWR_PDCTL_EMIF_DEFAULT);
    PWR_FSET(  PDCTL,    DMA,   PWR_PDCTL_DMA_DEFAULT);

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    PWR_FSETS(  PDCTL, MCBSP2,DEFAULT);
    PWR_FSETS(  PDCTL, MCBSP1,DEFAULT);
    PWR_FSETS(  PDCTL, MCBSP0,DEFAULT);
    PWR_FSETS(  PDCTL,   EMIF,DEFAULT);
    PWR_FSETS(  PDCTL,    DMA,DEFAULT);

/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = PWR_RGETA(0,   PDCTL);

/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    PWR_RSETA(0,  PDCTL, 0);

/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = PWR_FGETA(0,  PDCTL, MCBSP2);
    x = PWR_FGETA(0,  PDCTL, MCBSP1);
    x = PWR_FGETA(0,  PDCTL, MCBSP0);
    x = PWR_FGETA(0,  PDCTL,   EMIF);
    x = PWR_FGETA(0,  PDCTL,    DMA);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    PWR_FSETA(0,  PDCTL, MCBSP2,PWR_PDCTL_MCBSP2_DEFAULT);
    PWR_FSETA(0,  PDCTL, MCBSP1,PWR_PDCTL_MCBSP1_DEFAULT);
    PWR_FSETA(0,  PDCTL, MCBSP0,PWR_PDCTL_MCBSP0_DEFAULT);
    PWR_FSETA(0,  PDCTL,   EMIF,  PWR_PDCTL_EMIF_DEFAULT);
    PWR_FSETA(0,  PDCTL,    DMA,   PWR_PDCTL_DMA_DEFAULT);

/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    PWR_FSETSA(0,   PDCTL, MCBSP2,DEFAULT);
    PWR_FSETSA(0,   PDCTL, MCBSP1,DEFAULT);
    PWR_FSETSA(0,   PDCTL, MCBSP0,DEFAULT);
    PWR_FSETSA(0,   PDCTL,   EMIF,DEFAULT);
    PWR_FSETSA(0,   PDCTL,    DMA,DEFAULT);

/*  Test FSETSA Macro end */

  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_stdinc(int arg) {
  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_timer(int arg) {

  #if (TIMER_SUPPORT&&TIMER_BUILD)

    TIMER_Handle hTimer;

    hTimer = TIMER_open(TIMER_DEV1, TIMER_OPEN_RESET);
/*
    if (hTimer != INV) {

      x = TIMER_CTL_GET(hTimer);
      x = TIMER_CTL_FGET(hTimer,TSTAT);
      x = TIMER_CTL_FGET(hTimer,INVINP);
      x = TIMER_CTL_FGET(hTimer,CLKSRC);
      x = TIMER_CTL_FGET(hTimer,CP);
      x = TIMER_CTL_FGET(hTimer,HLD);
      x = TIMER_CTL_FGET(hTimer,GO);
      x = TIMER_CTL_FGET(hTimer,PWID);
      x = TIMER_CTL_FGET(hTimer,DATIN);
      x = TIMER_CTL_FGET(hTimer,DATOUT);
      x = TIMER_CTL_FGET(hTimer,INVOUT);
      x = TIMER_CTL_FGET(hTimer,FUNC);
      TIMER_CTL_SET(hTimer,TIMER_CTL_DEFAULT);
      TIMER_CTL_FSET(hTimer,TSTAT, TIMER_CTL_TSTAT_DEFAULT);
      TIMER_CTL_FSET(hTimer,INVINP,TIMER_CTL_INVINP_DEFAULT);
      TIMER_CTL_FSET(hTimer,CLKSRC,TIMER_CTL_CLKSRC_DEFAULT);
      TIMER_CTL_FSET(hTimer,CP,    TIMER_CTL_CP_DEFAULT);
      TIMER_CTL_FSET(hTimer,HLD,   TIMER_CTL_HLD_DEFAULT);
      TIMER_CTL_FSET(hTimer,GO,    TIMER_CTL_GO_DEFAULT);
      TIMER_CTL_FSET(hTimer,PWID,  TIMER_CTL_PWID_DEFAULT);
      TIMER_CTL_FSET(hTimer,DATIN, TIMER_CTL_DATIN_DEFAULT);
      TIMER_CTL_FSET(hTimer,DATOUT,TIMER_CTL_DATOUT_DEFAULT);
      TIMER_CTL_FSET(hTimer,INVOUT,TIMER_CTL_INVOUT_DEFAULT);
      TIMER_CTL_FSET(hTimer,FUNC,  TIMER_CTL_FUNC_DEFAULT);
      x = TIMER_CTL_ADDR(hTimer);
      x = TIMER_CTL_MK(
        TIMER_CTL_INVINP_DEFAULT,
        TIMER_CTL_CLKSRC_DEFAULT,
        TIMER_CTL_CP_DEFAULT,
        TIMER_CTL_HLD_DEFAULT,
        TIMER_CTL_GO_DEFAULT,
        TIMER_CTL_PWID_DEFAULT,
        TIMER_CTL_DATOUT_DEFAULT,
        TIMER_CTL_INVOUT_DEFAULT,
        TIMER_CTL_FUNC_DEFAULT
      );
      TIMER_CTL_RESET(hTimer);


      x = TIMER_PRD_GET(hTimer);
      x = TIMER_PRD_FGET(hTimer,PRD);
      TIMER_PRD_SET(hTimer,TIMER_PRD_DEFAULT);
      TIMER_PRD_FSET(hTimer,PRD,TIMER_PRD_PRD_DEFAULT);
      x = TIMER_PRD_ADDR(hTimer);
      x = TIMER_PRD_MK(
        TIMER_PRD_PRD_DEFAULT
      );
      TIMER_PRD_RESET(hTimer);


      x = TIMER_CNT_GET(hTimer);
      x = TIMER_CNT_FGET(hTimer,CNT);
      TIMER_CNT_SET(hTimer,TIMER_CNT_DEFAULT);
      TIMER_CNT_FSET(hTimer,CNT,TIMER_CNT_CNT_DEFAULT);
      x = TIMER_CNT_ADDR(hTimer);
      x = TIMER_CNT_MK(
        TIMER_CNT_CNT_DEFAULT
      );
      TIMER_CNT_RESET(hTimer);

    }

    TIMER_close(hTimer);
*/
/*  Test FMK Macro start */
    x = TIMER_FMK(   CTL, TSTAT,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,INVINP,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,CLKSRC,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,    CP,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,   HLD,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,    GO,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,  PWID,0XFFFFFFFF);
    x = TIMER_FMK(   CTL, DATIN,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,DATOUT,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,INVOUT,0XFFFFFFFF);
    x = TIMER_FMK(   CTL,  FUNC,0XFFFFFFFF);
    x = TIMER_FMK(   PRD,   PRD,0XFFFFFFFF);
    x = TIMER_FMK(   CNT,   CNT,0XFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = TIMER_FMKS(   CTL, TSTAT,DEFAULT);
    x = TIMER_FMKS(   CTL,INVINP,DEFAULT);
    x = TIMER_FMKS(   CTL,CLKSRC,DEFAULT);
    x = TIMER_FMKS(   CTL,    CP,DEFAULT);
    x = TIMER_FMKS(   CTL,   HLD,DEFAULT);
    x = TIMER_FMKS(   CTL,    GO,DEFAULT);
    x = TIMER_FMKS(   CTL,  PWID,DEFAULT);
    x = TIMER_FMKS(   CTL, DATIN,DEFAULT);
    x = TIMER_FMKS(   CTL,DATOUT,DEFAULT);
    x = TIMER_FMKS(   CTL,INVOUT,DEFAULT);
    x = TIMER_FMKS(   CTL,  FUNC,DEFAULT);
    x = TIMER_FMKS(   PRD,   PRD,DEFAULT);
    x = TIMER_FMKS(   CNT,   CNT,DEFAULT);

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = TIMER_ADDR(  CTL0);
    x = TIMER_ADDR(  CTL1);
#if (C64_SUPPORT)
    x = TIMER_ADDR(  CTL2);
#endif
    x = TIMER_ADDR(  PRD0);
    x = TIMER_ADDR(  PRD1);
#if (C64_SUPPORT)
    x = TIMER_ADDR(  PRD2);
#endif
    x = TIMER_ADDR(  CNT0);
    x = TIMER_ADDR(  CNT1);
#if (C64_SUPPORT)
    x = TIMER_ADDR(  CNT2);
#endif

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = TIMER_RGET(  CTL0);
    x = TIMER_RGET(  CTL1);
#if (C64_SUPPORT)
    x = TIMER_RGET(  CTL2);
#endif
    x = TIMER_RGET(  PRD0);
    x = TIMER_RGET(  PRD1);
#if (C64_SUPPORT)
    x = TIMER_RGET(  PRD2);
#endif
    x = TIMER_RGET(  CNT0);
    x = TIMER_RGET(  CNT1);
#if (C64_SUPPORT)
    x = TIMER_RGET(  CNT2);
#endif

/*  Test RGET Macro end */
/*  Test RSET Macro start */
    TIMER_RSET(  CTL0,TIMER_CTL_DEFAULT);
    TIMER_RSET(  CTL1,TIMER_CTL_DEFAULT);
#if (C64_SUPPORT)
    TIMER_RSET(  CTL2,TIMER_CTL_DEFAULT);
#endif
    TIMER_RSET(  PRD0,TIMER_PRD_DEFAULT);
    TIMER_RSET(  PRD1,TIMER_PRD_DEFAULT);
#if (C64_SUPPORT)
    TIMER_RSET(  PRD2,TIMER_PRD_DEFAULT);
#endif
    TIMER_RSET(  CNT0,TIMER_CNT_DEFAULT);
    TIMER_RSET(  CNT1,TIMER_CNT_DEFAULT);
#if (C64_SUPPORT)
    TIMER_RSET(  CNT2,TIMER_CNT_DEFAULT);
#endif
/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = TIMER_FGET(   CTL0, TSTAT);
    x = TIMER_FGET(   CTL0,INVINP);
    x = TIMER_FGET(   CTL0,CLKSRC);
    x = TIMER_FGET(   CTL0,    CP);
    x = TIMER_FGET(   CTL0,   HLD);
    x = TIMER_FGET(   CTL0,    GO);
    x = TIMER_FGET(   CTL0,  PWID);
    x = TIMER_FGET(   CTL0, DATIN);
    x = TIMER_FGET(   CTL0,DATOUT);
    x = TIMER_FGET(   CTL0,INVOUT);
    x = TIMER_FGET(   CTL0,  FUNC);
    x = TIMER_FGET(   PRD0,   PRD);
    x = TIMER_FGET(   CNT0,   CNT);

    x = TIMER_FGET(   CTL1, TSTAT);
    x = TIMER_FGET(   CTL1,INVINP);
    x = TIMER_FGET(   CTL1,CLKSRC);
    x = TIMER_FGET(   CTL1,    CP);
    x = TIMER_FGET(   CTL1,   HLD);
    x = TIMER_FGET(   CTL1,    GO);
    x = TIMER_FGET(   CTL1,  PWID);
    x = TIMER_FGET(   CTL1, DATIN);
    x = TIMER_FGET(   CTL1,DATOUT);
    x = TIMER_FGET(   CTL1,INVOUT);
    x = TIMER_FGET(   CTL1,  FUNC);
    x = TIMER_FGET(   PRD1,   PRD);
    x = TIMER_FGET(   CNT1,   CNT);

#if (C64_SUPPORT)
    x = TIMER_FGET(   CTL2, TSTAT);
    x = TIMER_FGET(   CTL2,INVINP);
    x = TIMER_FGET(   CTL2,CLKSRC);
    x = TIMER_FGET(   CTL2,    CP);
    x = TIMER_FGET(   CTL2,   HLD);
    x = TIMER_FGET(   CTL2,    GO);
    x = TIMER_FGET(   CTL2,  PWID);
    x = TIMER_FGET(   CTL2, DATIN);
    x = TIMER_FGET(   CTL2,DATOUT);
    x = TIMER_FGET(   CTL2,INVOUT);
    x = TIMER_FGET(   CTL2,  FUNC);
    x = TIMER_FGET(   PRD2,   PRD);
    x = TIMER_FGET(   CNT2,   CNT);
#endif

/*  Test FGET Macro end */
/*  Test FSET Macro start */
    TIMER_FSET(   CTL0, TSTAT,  TIMER_CTL_TSTAT_DEFAULT);
    TIMER_FSET(   CTL0,INVINP, TIMER_CTL_INVINP_DEFAULT);
    TIMER_FSET(   CTL0,CLKSRC, TIMER_CTL_CLKSRC_DEFAULT);
    TIMER_FSET(   CTL0,    CP,     TIMER_CTL_CP_DEFAULT);
    TIMER_FSET(   CTL0,   HLD,    TIMER_CTL_HLD_DEFAULT);
    TIMER_FSET(   CTL0,    GO,     TIMER_CTL_GO_DEFAULT);
    TIMER_FSET(   CTL0,  PWID,   TIMER_CTL_PWID_DEFAULT);
    TIMER_FSET(   CTL0, DATIN,  TIMER_CTL_DATIN_DEFAULT);
    TIMER_FSET(   CTL0,DATOUT, TIMER_CTL_DATOUT_DEFAULT);
    TIMER_FSET(   CTL0,INVOUT, TIMER_CTL_INVOUT_DEFAULT);
    TIMER_FSET(   CTL0,  FUNC,   TIMER_CTL_FUNC_DEFAULT);
    TIMER_FSET(   PRD0,   PRD,    TIMER_PRD_PRD_DEFAULT);
    TIMER_FSET(   CNT0,   CNT,    TIMER_CNT_CNT_DEFAULT);

    TIMER_FSET(   CTL1, TSTAT,  TIMER_CTL_TSTAT_DEFAULT);
    TIMER_FSET(   CTL1,INVINP, TIMER_CTL_INVINP_DEFAULT);
    TIMER_FSET(   CTL1,CLKSRC, TIMER_CTL_CLKSRC_DEFAULT);
    TIMER_FSET(   CTL1,    CP,     TIMER_CTL_CP_DEFAULT);
    TIMER_FSET(   CTL1,   HLD,    TIMER_CTL_HLD_DEFAULT);
    TIMER_FSET(   CTL1,    GO,     TIMER_CTL_GO_DEFAULT);
    TIMER_FSET(   CTL1,  PWID,   TIMER_CTL_PWID_DEFAULT);
    TIMER_FSET(   CTL1, DATIN,  TIMER_CTL_DATIN_DEFAULT);
    TIMER_FSET(   CTL1,DATOUT, TIMER_CTL_DATOUT_DEFAULT);
    TIMER_FSET(   CTL1,INVOUT, TIMER_CTL_INVOUT_DEFAULT);
    TIMER_FSET(   CTL1,  FUNC,   TIMER_CTL_FUNC_DEFAULT);
    TIMER_FSET(   PRD1,   PRD,    TIMER_PRD_PRD_DEFAULT);
    TIMER_FSET(   CNT1,   CNT,    TIMER_CNT_CNT_DEFAULT);

#if (C64_SUPPORT)
    TIMER_FSET(   CTL2, TSTAT,  TIMER_CTL_TSTAT_DEFAULT);
    TIMER_FSET(   CTL2,INVINP, TIMER_CTL_INVINP_DEFAULT);
    TIMER_FSET(   CTL2,CLKSRC, TIMER_CTL_CLKSRC_DEFAULT);
    TIMER_FSET(   CTL2,    CP,     TIMER_CTL_CP_DEFAULT);
    TIMER_FSET(   CTL2,   HLD,    TIMER_CTL_HLD_DEFAULT);
    TIMER_FSET(   CTL2,    GO,     TIMER_CTL_GO_DEFAULT);
    TIMER_FSET(   CTL2,  PWID,   TIMER_CTL_PWID_DEFAULT);
    TIMER_FSET(   CTL2, DATIN,  TIMER_CTL_DATIN_DEFAULT);
    TIMER_FSET(   CTL2,DATOUT, TIMER_CTL_DATOUT_DEFAULT);
    TIMER_FSET(   CTL2,INVOUT, TIMER_CTL_INVOUT_DEFAULT);
    TIMER_FSET(   CTL2,  FUNC,   TIMER_CTL_FUNC_DEFAULT);
    TIMER_FSET(   PRD2,   PRD,    TIMER_PRD_PRD_DEFAULT);
    TIMER_FSET(   CNT2,   CNT,    TIMER_CNT_CNT_DEFAULT);
#endif


/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    TIMER_FSETS(   CTL0, TSTAT,DEFAULT);
    TIMER_FSETS(   CTL0,INVINP,DEFAULT);
    TIMER_FSETS(   CTL0,CLKSRC,DEFAULT);
    TIMER_FSETS(   CTL0,    CP,DEFAULT);
    TIMER_FSETS(   CTL0,   HLD,DEFAULT);
    TIMER_FSETS(   CTL0,    GO,DEFAULT);
    TIMER_FSETS(   CTL0,  PWID,DEFAULT);
    TIMER_FSETS(   CTL0, DATIN,DEFAULT);
    TIMER_FSETS(   CTL0,DATOUT,DEFAULT);
    TIMER_FSETS(   CTL0,INVOUT,DEFAULT);
    TIMER_FSETS(   CTL0,  FUNC,DEFAULT);
    TIMER_FSETS(   PRD0,   PRD,DEFAULT);
    TIMER_FSETS(   CNT0,   CNT,DEFAULT);

    TIMER_FSETS(   CTL1, TSTAT,DEFAULT);
    TIMER_FSETS(   CTL1,INVINP,DEFAULT);
    TIMER_FSETS(   CTL1,CLKSRC,DEFAULT);
    TIMER_FSETS(   CTL1,    CP,DEFAULT);
    TIMER_FSETS(   CTL1,   HLD,DEFAULT);
    TIMER_FSETS(   CTL1,    GO,DEFAULT);
    TIMER_FSETS(   CTL1,  PWID,DEFAULT);
    TIMER_FSETS(   CTL1, DATIN,DEFAULT);
    TIMER_FSETS(   CTL1,DATOUT,DEFAULT);
    TIMER_FSETS(   CTL1,INVOUT,DEFAULT);
    TIMER_FSETS(   CTL1,  FUNC,DEFAULT);
    TIMER_FSETS(   PRD1,   PRD,DEFAULT);
    TIMER_FSETS(   CNT1,   CNT,DEFAULT);

#if (C64_SUPPORT)
    TIMER_FSETS(   CTL2, TSTAT,DEFAULT);
    TIMER_FSETS(   CTL2,INVINP,DEFAULT);
    TIMER_FSETS(   CTL2,CLKSRC,DEFAULT);
    TIMER_FSETS(   CTL2,    CP,DEFAULT);
    TIMER_FSETS(   CTL2,   HLD,DEFAULT);
    TIMER_FSETS(   CTL2,    GO,DEFAULT);
    TIMER_FSETS(   CTL2,  PWID,DEFAULT);
    TIMER_FSETS(   CTL2, DATIN,DEFAULT);
    TIMER_FSETS(   CTL2,DATOUT,DEFAULT);
    TIMER_FSETS(   CTL2,INVOUT,DEFAULT);
    TIMER_FSETS(   CTL2,  FUNC,DEFAULT);
    TIMER_FSETS(   PRD2,   PRD,DEFAULT);
    TIMER_FSETS(   CNT2,   CNT,DEFAULT);
#endif


/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = TIMER_RGETA(0,  CTL0);
    x = TIMER_RGETA(0,  CTL1);
    x = TIMER_RGETA(0,  CTL2);
    x = TIMER_RGETA(0,  PRD0);
    x = TIMER_RGETA(0,  PRD1);
    x = TIMER_RGETA(0,  PRD2);
    x = TIMER_RGETA(0,  CNT0);
    x = TIMER_RGETA(0,  CNT1);
    x = TIMER_RGETA(0,  CNT2);


/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    TIMER_RSETA(0, CTL0,TIMER_CTL_DEFAULT);
    TIMER_RSETA(0, CTL1,TIMER_CTL_DEFAULT);
    TIMER_RSETA(0, CTL2,TIMER_CTL_DEFAULT);
    TIMER_RSETA(0, PRD0,TIMER_PRD_DEFAULT);
    TIMER_RSETA(0, PRD1,TIMER_PRD_DEFAULT);
    TIMER_RSETA(0, PRD2,TIMER_PRD_DEFAULT);
    TIMER_RSETA(0, CNT0,TIMER_CNT_DEFAULT);
    TIMER_RSETA(0, CNT1,TIMER_CNT_DEFAULT);
    TIMER_RSETA(0, CNT2,TIMER_CNT_DEFAULT);


/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = TIMER_FGETA(0,  CTL, TSTAT);
    x = TIMER_FGETA(0,  CTL,INVINP);
    x = TIMER_FGETA(0,  CTL,CLKSRC);
    x = TIMER_FGETA(0,  CTL,    CP);
    x = TIMER_FGETA(0,  CTL,   HLD);
    x = TIMER_FGETA(0,  CTL,    GO);
    x = TIMER_FGETA(0,  CTL,  PWID);
    x = TIMER_FGETA(0,  CTL, DATIN);
    x = TIMER_FGETA(0,  CTL,DATOUT);
    x = TIMER_FGETA(0,  CTL,INVOUT);
    x = TIMER_FGETA(0,  CTL,  FUNC);
    x = TIMER_FGETA(0,  PRD,   PRD);
    x = TIMER_FGETA(0,  CNT,   CNT);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    TIMER_FSETA(0,  CTL, TSTAT,  TIMER_CTL_TSTAT_DEFAULT);
    TIMER_FSETA(0,  CTL,INVINP, TIMER_CTL_INVINP_DEFAULT);
    TIMER_FSETA(0,  CTL,CLKSRC, TIMER_CTL_CLKSRC_DEFAULT);
    TIMER_FSETA(0,  CTL,    CP,     TIMER_CTL_CP_DEFAULT);
    TIMER_FSETA(0,  CTL,   HLD,    TIMER_CTL_HLD_DEFAULT);
    TIMER_FSETA(0,  CTL,    GO,     TIMER_CTL_GO_DEFAULT);
    TIMER_FSETA(0,  CTL,  PWID,   TIMER_CTL_PWID_DEFAULT);
    TIMER_FSETA(0,  CTL, DATIN,  TIMER_CTL_DATIN_DEFAULT);
    TIMER_FSETA(0,  CTL,DATOUT, TIMER_CTL_DATOUT_DEFAULT);
    TIMER_FSETA(0,  CTL,INVOUT, TIMER_CTL_INVOUT_DEFAULT);
    TIMER_FSETA(0,  CTL,  FUNC,   TIMER_CTL_FUNC_DEFAULT);
    TIMER_FSETA(0,  PRD,   PRD,    TIMER_PRD_PRD_DEFAULT);
    TIMER_FSETA(0,  CNT,   CNT,    TIMER_CNT_CNT_DEFAULT);


/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    TIMER_FSETSA(0,  CTL, TSTAT,DEFAULT);
    TIMER_FSETSA(0,  CTL,INVINP,DEFAULT);
    TIMER_FSETSA(0,  CTL,CLKSRC,DEFAULT);
    TIMER_FSETSA(0,  CTL,    CP,DEFAULT);
    TIMER_FSETSA(0,  CTL,   HLD,DEFAULT);
    TIMER_FSETSA(0,  CTL,    GO,DEFAULT);
    TIMER_FSETSA(0,  CTL,  PWID,DEFAULT);
    TIMER_FSETSA(0,  CTL, DATIN,DEFAULT);
    TIMER_FSETSA(0,  CTL,DATOUT,DEFAULT);
    TIMER_FSETSA(0,  CTL,INVOUT,DEFAULT);
    TIMER_FSETSA(0,  CTL,  FUNC,DEFAULT);
    TIMER_FSETSA(0,  PRD,   PRD,DEFAULT);
    TIMER_FSETSA(0,  CNT,   CNT,DEFAULT);


/*  Test FSETSA Macro end */
/*  Test ADDRH Macro start */
    x = TIMER_ADDRH(hTimer,  CTL);
    x = TIMER_ADDRH(hTimer,  PRD);
    x = TIMER_ADDRH(hTimer,  CNT);

/*  Test ADDRH Macro end */
/*  Test RGETH Macro start */
    x = TIMER_RGETH(hTimer,  CTL);
    x = TIMER_RGETH(hTimer,  PRD);
    x = TIMER_RGETH(hTimer,  CNT);

/*  Test RGETH Macro end */
/*  Test RSETH Macro start */
    TIMER_RSETH(hTimer,  CTL,TIMER_CTL_DEFAULT);
    TIMER_RSETH(hTimer,  PRD,TIMER_PRD_DEFAULT);
    TIMER_RSETH(hTimer,  CNT,TIMER_CNT_DEFAULT);

/*  Test RSETH Macro end */
/*  Test FGETH Macro start */
    x = TIMER_FGETH(hTimer,   CTL, TSTAT);
    x = TIMER_FGETH(hTimer,   CTL,INVINP);
    x = TIMER_FGETH(hTimer,   CTL,CLKSRC);
    x = TIMER_FGETH(hTimer,   CTL,    CP);
    x = TIMER_FGETH(hTimer,   CTL,   HLD);
    x = TIMER_FGETH(hTimer,   CTL,    GO);
    x = TIMER_FGETH(hTimer,   CTL,  PWID);
    x = TIMER_FGETH(hTimer,   CTL, DATIN);
    x = TIMER_FGETH(hTimer,   CTL,DATOUT);
    x = TIMER_FGETH(hTimer,   CTL,INVOUT);
    x = TIMER_FGETH(hTimer,   CTL,  FUNC);
    x = TIMER_FGETH(hTimer,   PRD,   PRD);
    x = TIMER_FGETH(hTimer,   CNT,   CNT);

/*  Test FGETH Macro end */
/*  Test FSETH Macro start */
    TIMER_FSETH(hTimer,   CTL, TSTAT,  TIMER_CTL_TSTAT_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,INVINP, TIMER_CTL_INVINP_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,CLKSRC, TIMER_CTL_CLKSRC_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,    CP,     TIMER_CTL_CP_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,   HLD,    TIMER_CTL_HLD_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,    GO,     TIMER_CTL_GO_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,  PWID,   TIMER_CTL_PWID_DEFAULT);
    TIMER_FSETH(hTimer,   CTL, DATIN,  TIMER_CTL_DATIN_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,DATOUT, TIMER_CTL_DATOUT_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,INVOUT, TIMER_CTL_INVOUT_DEFAULT);
    TIMER_FSETH(hTimer,   CTL,  FUNC,   TIMER_CTL_FUNC_DEFAULT);
    TIMER_FSETH(hTimer,   PRD,   PRD,    TIMER_PRD_PRD_DEFAULT);
    TIMER_FSETH(hTimer,   CNT,   CNT,    TIMER_CNT_CNT_DEFAULT);

/*  Test FSETH Macro end */
/*  Test FSETSH Macro start */
    TIMER_FSETSH(hTimer,   CTL, TSTAT,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,INVINP,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,CLKSRC,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,    CP,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,   HLD,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,    GO,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,  PWID,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL, DATIN,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,DATOUT,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,INVOUT,DEFAULT);
    TIMER_FSETSH(hTimer,   CTL,  FUNC,DEFAULT);
    TIMER_FSETSH(hTimer,   PRD,   PRD,DEFAULT);
    TIMER_FSETSH(hTimer,   CNT,   CNT,DEFAULT);

/*  Test FSETSH Macro end */

  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_utop(int arg) {

  #if (UTOP_SUPPORT&&UTOP_BUILD)

/*  Test FMK Macro start */
    x = UTOP_FMK(  UCR,     BEND,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,SLIDSLEND,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,   UXMSTR,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,     UXEN,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,      ULB,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,     MPHY,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,     U16M,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,      UPM,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,   URMSTR,0XFFFFFFFF);
    x = UTOP_FMK(  UCR,     UREN,0XFFFFFFFF);
	x = UTOP_FMK(  PDR,      PHY,0XFFFFFFFF);
    x = UTOP_FMK(XCAPR,      CAP,0XFFFFFFFF);
    x = UTOP_FMK( UIER,     RQIE,0XFFFFFFFF);
    x = UTOP_FMK( UIER,     XQIE,0XFFFFFFFF);
    x = UTOP_FMK( UIPR,     RQIE,0XFFFFFFFF);
    x = UTOP_FMK( UIPR,     XQIE,0XFFFFFFFF);
    x = UTOP_FMK(  CDR,    XCCNT,0XFFFFFFFF);
    x = UTOP_FMK(  CDR,    RCCNT,0XFFFFFFFF);
    x = UTOP_FMK( EIER,     XCPE,0XFFFFFFFF);
    x = UTOP_FMK( EIER,     XCFE,0XFFFFFFFF);
    x = UTOP_FMK( EIER,     XQSE,0XFFFFFFFF);
    x = UTOP_FMK( EIER,     RCPE,0XFFFFFFFF);
    x = UTOP_FMK( EIER,     RCFE,0XFFFFFFFF);
    x = UTOP_FMK( EIER,     RQSE,0XFFFFFFFF);
    x = UTOP_FMK( EIPR,     XCPP,0XFFFFFFFF);
    x = UTOP_FMK( EIPR,     XCFP,0XFFFFFFFF);
    x = UTOP_FMK( EIPR,     XQSP,0XFFFFFFFF);
    x = UTOP_FMK( EIPR,     RCPP,0XFFFFFFFF);
    x = UTOP_FMK( EIPR,     RCFP,0XFFFFFFFF);
    x = UTOP_FMK( EIPR,     RQSP,0XFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = UTOP_FMKS(  UCR,     BEND,DEFAULT);
    x = UTOP_FMKS(  UCR,SLIDSLEND,DEFAULT);
    x = UTOP_FMKS(  UCR,   UXMSTR,DEFAULT);
    x = UTOP_FMKS(  UCR,     UXEN,DEFAULT);
    x = UTOP_FMKS(  UCR,      ULB,DEFAULT);
    x = UTOP_FMKS(  UCR,     MPHY,DEFAULT);
    x = UTOP_FMKS(  UCR,     U16M,DEFAULT);
    x = UTOP_FMKS(  UCR,      UPM,DEFAULT);
    x = UTOP_FMKS(  UCR,   URMSTR,DEFAULT);
    x = UTOP_FMKS(  UCR,     UREN,DEFAULT);
	x = UTOP_FMKS(  PDR,      PHY,DEFAULT);
    x = UTOP_FMKS(XCAPR,      CAP,DEFAULT);
    x = UTOP_FMKS( UIER,     RQIE,DEFAULT);
    x = UTOP_FMKS( UIER,     XQIE,DEFAULT);
    x = UTOP_FMKS( UIPR,     RQIE,DEFAULT);
    x = UTOP_FMKS( UIPR,     XQIE,DEFAULT);
    x = UTOP_FMKS(  CDR,    XCCNT,DEFAULT);
    x = UTOP_FMKS(  CDR,    RCCNT,DEFAULT);
    x = UTOP_FMKS( EIER,     XCPE,DEFAULT);
    x = UTOP_FMKS( EIER,     XCFE,DEFAULT);
    x = UTOP_FMKS( EIER,     XQSE,DEFAULT);
    x = UTOP_FMKS( EIER,     RCPE,DEFAULT);
    x = UTOP_FMKS( EIER,     RCFE,DEFAULT);
    x = UTOP_FMKS( EIER,     RQSE,DEFAULT);
    x = UTOP_FMKS( EIPR,     XCPP,DEFAULT);
    x = UTOP_FMKS( EIPR,     XCFP,DEFAULT);
    x = UTOP_FMKS( EIPR,     XQSP,DEFAULT);
    x = UTOP_FMKS( EIPR,     RCPP,DEFAULT);
    x = UTOP_FMKS( EIPR,     RCFP,DEFAULT);
    x = UTOP_FMKS( EIPR,     RQSP,DEFAULT);

/*  Test FMKS Macro end */
/*  Test ADDR Macro start */

    x = UTOP_ADDR(  UCR);
	x = UTOP_ADDR(  PDR);
    x = UTOP_ADDR(XCAPR);
    x = UTOP_ADDR( UIER);
    x = UTOP_ADDR( UIPR);
    x = UTOP_ADDR(  CDR);
    x = UTOP_ADDR( EIER);
    x = UTOP_ADDR( EIPR);

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = UTOP_RGET(  UCR);
	x = UTOP_RGET(  PDR);
    x = UTOP_RGET(XCAPR);
    x = UTOP_RGET( UIER);
    x = UTOP_RGET( UIPR);
    x = UTOP_RGET(  CDR);
    x = UTOP_RGET( EIER);
    x = UTOP_RGET( EIPR);

/*  Test RGET Macro end */
/*  Test RSET Macro start */
    UTOP_RSET(  UCR,   UTOP_UCR_DEFAULT);
	UTOP_RSET(  PDR,   UTOP_PDR_DEFAULT);
    UTOP_RSET(XCAPR, UTOP_XCAPR_DEFAULT);
    UTOP_RSET( UIER,  UTOP_UIER_DEFAULT);
    UTOP_RSET( UIPR,  UTOP_UIPR_DEFAULT);
    UTOP_RSET(  CDR,   UTOP_CDR_DEFAULT);
    UTOP_RSET( EIER,  UTOP_EIER_DEFAULT);
    UTOP_RSET( EIPR,  UTOP_EIPR_DEFAULT);

/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = UTOP_FGET(  UCR,     BEND);
    x = UTOP_FGET(  UCR,SLIDSLEND);
    x = UTOP_FGET(  UCR,   UXMSTR);
    x = UTOP_FGET(  UCR,     UXEN);
    x = UTOP_FGET(  UCR,      ULB);
    x = UTOP_FGET(  UCR,     MPHY);
    x = UTOP_FGET(  UCR,     U16M);
    x = UTOP_FGET(  UCR,      UPM);
    x = UTOP_FGET(  UCR,   URMSTR);
    x = UTOP_FGET(  UCR,     UREN);
	x = UTOP_FGET(  PDR,      PHY);
    x = UTOP_FGET(XCAPR,      CAP);
    x = UTOP_FGET( UIER,     RQIE);
    x = UTOP_FGET( UIER,     XQIE);
    x = UTOP_FGET( UIPR,     RQIE);
    x = UTOP_FGET( UIPR,     XQIE);
    x = UTOP_FGET(  CDR,    XCCNT);
    x = UTOP_FGET(  CDR,    RCCNT);
    x = UTOP_FGET( EIER,     XCPE);
    x = UTOP_FGET( EIER,     XCFE);
    x = UTOP_FGET( EIER,     XQSE);
    x = UTOP_FGET( EIER,     RCPE);
    x = UTOP_FGET( EIER,     RCFE);
    x = UTOP_FGET( EIER,     RQSE);
    x = UTOP_FGET( EIPR,     XCPP);
    x = UTOP_FGET( EIPR,     XCFP);
    x = UTOP_FGET( EIPR,     XQSP);
    x = UTOP_FGET( EIPR,     RCPP);
    x = UTOP_FGET( EIPR,     RCFP);
    x = UTOP_FGET( EIPR,     RQSP);

/*  Test FGET Macro end */
/*  Test FSET Macro start */
    UTOP_FSET(  UCR,     BEND,     UTOP_UCR_BEND_DEFAULT);
    UTOP_FSET(  UCR,SLIDSLEND,UTOP_UCR_SLIDSLEND_DEFAULT);
    UTOP_FSET(  UCR,   UXMSTR,   UTOP_UCR_UXMSTR_DEFAULT);
    UTOP_FSET(  UCR,     UXEN,     UTOP_UCR_UXEN_DEFAULT);
    UTOP_FSET(  UCR,      ULB,      UTOP_UCR_ULB_DEFAULT);
    UTOP_FSET(  UCR,     MPHY,     UTOP_UCR_MPHY_DEFAULT);
    UTOP_FSET(  UCR,     U16M,     UTOP_UCR_U16M_DEFAULT);
    UTOP_FSET(  UCR,      UPM,      UTOP_UCR_UPM_DEFAULT);
    UTOP_FSET(  UCR,   URMSTR,   UTOP_UCR_URMSTR_DEFAULT);
    UTOP_FSET(  UCR,     UREN,     UTOP_UCR_UREN_DEFAULT);
	UTOP_FSET(  PDR,      PHY,      UTOP_PDR_PHY_DEFAULT);
    UTOP_FSET(XCAPR,      CAP,    UTOP_XCAPR_CAP_DEFAULT);
    UTOP_FSET( UIER,     RQIE,    UTOP_UIER_RQIE_DEFAULT);
    UTOP_FSET( UIER,     XQIE,    UTOP_UIER_XQIE_DEFAULT);
    UTOP_FSET( UIPR,     RQIE,    UTOP_UIPR_RQIE_DEFAULT);
    UTOP_FSET( UIPR,     XQIE,    UTOP_UIPR_XQIE_DEFAULT);
    UTOP_FSET(  CDR,    XCCNT,    UTOP_CDR_XCCNT_DEFAULT);
    UTOP_FSET(  CDR,    RCCNT,    UTOP_CDR_RCCNT_DEFAULT);
    UTOP_FSET( EIER,     XCPE,    UTOP_EIER_XCPE_DEFAULT);
    UTOP_FSET( EIER,     XCFE,    UTOP_EIER_XCFE_DEFAULT);
    UTOP_FSET( EIER,     XQSE,    UTOP_EIER_XQSE_DEFAULT);
    UTOP_FSET( EIER,     RCPE,    UTOP_EIER_RCPE_DEFAULT);
    UTOP_FSET( EIER,     RCFE,    UTOP_EIER_RCFE_DEFAULT);
    UTOP_FSET( EIER,     RQSE,    UTOP_EIER_RQSE_DEFAULT);
    UTOP_FSET( EIPR,     XCPP,    UTOP_EIPR_XCPP_DEFAULT);
    UTOP_FSET( EIPR,     XCFP,    UTOP_EIPR_XCFP_DEFAULT);
    UTOP_FSET( EIPR,     XQSP,    UTOP_EIPR_XQSP_DEFAULT);
    UTOP_FSET( EIPR,     RCPP,    UTOP_EIPR_RCPP_DEFAULT);
    UTOP_FSET( EIPR,     RCFP,    UTOP_EIPR_RCFP_DEFAULT);
    UTOP_FSET( EIPR,     RQSP,    UTOP_EIPR_RQSP_DEFAULT);

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    UTOP_FSETS(  UCR,     BEND,DEFAULT);
    UTOP_FSETS(  UCR,SLIDSLEND,DEFAULT);
    UTOP_FSETS(  UCR,   UXMSTR,DEFAULT);
    UTOP_FSETS(  UCR,     UXEN,DEFAULT);
    UTOP_FSETS(  UCR,      ULB,DEFAULT);
    UTOP_FSETS(  UCR,     MPHY,DEFAULT);
    UTOP_FSETS(  UCR,     U16M,DEFAULT);
    UTOP_FSETS(  UCR,      UPM,DEFAULT);
    UTOP_FSETS(  UCR,   URMSTR,DEFAULT);
    UTOP_FSETS(  UCR,     UREN,DEFAULT);
	UTOP_FSETS(  PDR,      PHY,DEFAULT);
    UTOP_FSETS(XCAPR,      CAP,DEFAULT);
    UTOP_FSETS( UIER,     RQIE,DEFAULT);
    UTOP_FSETS( UIER,     XQIE,DEFAULT);
    UTOP_FSETS( UIPR,     RQIE,DEFAULT);
    UTOP_FSETS( UIPR,     XQIE,DEFAULT);
    UTOP_FSETS(  CDR,    XCCNT,DEFAULT);
    UTOP_FSETS(  CDR,    RCCNT,DEFAULT);
    UTOP_FSETS( EIER,     XCPE,DEFAULT);
    UTOP_FSETS( EIER,     XCFE,DEFAULT);
    UTOP_FSETS( EIER,     XQSE,DEFAULT);
    UTOP_FSETS( EIER,     RCPE,DEFAULT);
    UTOP_FSETS( EIER,     RCFE,DEFAULT);
    UTOP_FSETS( EIER,     RQSE,DEFAULT);
    UTOP_FSETS( EIPR,     XCPP,DEFAULT);
    UTOP_FSETS( EIPR,     XCFP,DEFAULT);
    UTOP_FSETS( EIPR,     XQSP,DEFAULT);
    UTOP_FSETS( EIPR,     RCPP,DEFAULT);
    UTOP_FSETS( EIPR,     RCFP,DEFAULT);
    UTOP_FSETS( EIPR,     RQSP,DEFAULT);

/*  Test FSETS Macro end */
/*  Test RGETA Macro start */
    x = UTOP_RGETA(0,  UCR);
	x = UTOP_RGETA(0,  PDR);
    x = UTOP_RGETA(0,XCAPR);
    x = UTOP_RGETA(0, UIER);
    x = UTOP_RGETA(0, UIPR);
    x = UTOP_RGETA(0,  CDR);
    x = UTOP_RGETA(0, EIER);
    x = UTOP_RGETA(0, EIPR);

/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    UTOP_RSETA(0,  UCR,   UTOP_UCR_DEFAULT);
	UTOP_RSETA(0,  PDR,   UTOP_PDR_DEFAULT);
    UTOP_RSETA(0,XCAPR, UTOP_XCAPR_DEFAULT);
    UTOP_RSETA(0, UIER,  UTOP_UIER_DEFAULT);
    UTOP_RSETA(0, UIPR,  UTOP_UIPR_DEFAULT);
    UTOP_RSETA(0,  CDR,   UTOP_CDR_DEFAULT);
    UTOP_RSETA(0, EIER,  UTOP_EIER_DEFAULT);
    UTOP_RSETA(0, EIPR,  UTOP_EIPR_DEFAULT);

/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = UTOP_FGETA(0,  UCR,     BEND);
    x = UTOP_FGETA(0,  UCR,SLIDSLEND);
    x = UTOP_FGETA(0,  UCR,   UXMSTR);
    x = UTOP_FGETA(0,  UCR,     UXEN);
    x = UTOP_FGETA(0,  UCR,      ULB);
    x = UTOP_FGETA(0,  UCR,     MPHY);
    x = UTOP_FGETA(0,  UCR,     U16M);
    x = UTOP_FGETA(0,  UCR,      UPM);
    x = UTOP_FGETA(0,  UCR,   URMSTR);
    x = UTOP_FGETA(0,  UCR,     UREN);
	x = UTOP_FGETA(0,  PDR,      PHY);
    x = UTOP_FGETA(0,XCAPR,      CAP);
    x = UTOP_FGETA(0, UIER,     RQIE);
    x = UTOP_FGETA(0, UIER,     XQIE);
    x = UTOP_FGETA(0, UIPR,     RQIE);
    x = UTOP_FGETA(0, UIPR,     XQIE);
    x = UTOP_FGETA(0,  CDR,    XCCNT);
    x = UTOP_FGETA(0,  CDR,    RCCNT);
    x = UTOP_FGETA(0, EIER,     XCPE);
    x = UTOP_FGETA(0, EIER,     XCFE);
    x = UTOP_FGETA(0, EIER,     XQSE);
    x = UTOP_FGETA(0, EIER,     RCPE);
    x = UTOP_FGETA(0, EIER,     RCFE);
    x = UTOP_FGETA(0, EIER,     RQSE);
    x = UTOP_FGETA(0, EIPR,     XCPP);
    x = UTOP_FGETA(0, EIPR,     XCFP);
    x = UTOP_FGETA(0, EIPR,     XQSP);
    x = UTOP_FGETA(0, EIPR,     RCPP);
    x = UTOP_FGETA(0, EIPR,     RCFP);
    x = UTOP_FGETA(0, EIPR,     RQSP);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    UTOP_FSETA(0,  UCR,     BEND,     UTOP_UCR_BEND_DEFAULT);
    UTOP_FSETA(0,  UCR,SLIDSLEND,UTOP_UCR_SLIDSLEND_DEFAULT);
    UTOP_FSETA(0,  UCR,   UXMSTR,   UTOP_UCR_UXMSTR_DEFAULT);
    UTOP_FSETA(0,  UCR,     UXEN,     UTOP_UCR_UXEN_DEFAULT);
    UTOP_FSETA(0,  UCR,      ULB,      UTOP_UCR_ULB_DEFAULT);
    UTOP_FSETA(0,  UCR,     MPHY,     UTOP_UCR_MPHY_DEFAULT);
    UTOP_FSETA(0,  UCR,     U16M,     UTOP_UCR_U16M_DEFAULT);
    UTOP_FSETA(0,  UCR,      UPM,      UTOP_UCR_UPM_DEFAULT);
    UTOP_FSETA(0,  UCR,   URMSTR,   UTOP_UCR_URMSTR_DEFAULT);
    UTOP_FSETA(0,  UCR,     UREN,     UTOP_UCR_UREN_DEFAULT);
	UTOP_FSETA(0,  PDR,      PHY,      UTOP_PDR_PHY_DEFAULT);
    UTOP_FSETA(0,XCAPR,      CAP,    UTOP_XCAPR_CAP_DEFAULT);
    UTOP_FSETA(0, UIER,     RQIE,    UTOP_UIER_RQIE_DEFAULT);
    UTOP_FSETA(0, UIER,     XQIE,    UTOP_UIER_XQIE_DEFAULT);
    UTOP_FSETA(0, UIPR,     RQIE,    UTOP_UIPR_RQIE_DEFAULT);
    UTOP_FSETA(0, UIPR,     XQIE,    UTOP_UIPR_XQIE_DEFAULT);
    UTOP_FSETA(0,  CDR,    XCCNT,    UTOP_CDR_XCCNT_DEFAULT);
    UTOP_FSETA(0,  CDR,    RCCNT,    UTOP_CDR_RCCNT_DEFAULT);
    UTOP_FSETA(0, EIER,     XCPE,    UTOP_EIER_XCPE_DEFAULT);
    UTOP_FSETA(0, EIER,     XCFE,    UTOP_EIER_XCFE_DEFAULT);
    UTOP_FSETA(0, EIER,     XQSE,    UTOP_EIER_XQSE_DEFAULT);
    UTOP_FSETA(0, EIER,     RCPE,    UTOP_EIER_RCPE_DEFAULT);
    UTOP_FSETA(0, EIER,     RCFE,    UTOP_EIER_RCFE_DEFAULT);
    UTOP_FSETA(0, EIER,     RQSE,    UTOP_EIER_RQSE_DEFAULT);
    UTOP_FSETA(0, EIPR,     XCPP,    UTOP_EIPR_XCPP_DEFAULT);
    UTOP_FSETA(0, EIPR,     XCFP,    UTOP_EIPR_XCFP_DEFAULT);
    UTOP_FSETA(0, EIPR,     XQSP,    UTOP_EIPR_XQSP_DEFAULT);
    UTOP_FSETA(0, EIPR,     RCPP,    UTOP_EIPR_RCPP_DEFAULT);
    UTOP_FSETA(0, EIPR,     RCFP,    UTOP_EIPR_RCFP_DEFAULT);
    UTOP_FSETA(0, EIPR,     RQSP,    UTOP_EIPR_RQSP_DEFAULT);

/*  Test FSETA Macro end */
/*  Test FSETSA Macro start */
    UTOP_FSETSA(0,  UCR,     BEND,DEFAULT);
    UTOP_FSETSA(0,  UCR,SLIDSLEND,DEFAULT);
    UTOP_FSETSA(0,  UCR,   UXMSTR,DEFAULT);
    UTOP_FSETSA(0,  UCR,     UXEN,DEFAULT);
    UTOP_FSETSA(0,  UCR,      ULB,DEFAULT);
    UTOP_FSETSA(0,  UCR,     MPHY,DEFAULT);
    UTOP_FSETSA(0,  UCR,     U16M,DEFAULT);
    UTOP_FSETSA(0,  UCR,      UPM,DEFAULT);
    UTOP_FSETSA(0,  UCR,   URMSTR,DEFAULT);
    UTOP_FSETSA(0,  UCR,     UREN,DEFAULT);
	UTOP_FSETSA(0,  PDR,      PHY,DEFAULT);
    UTOP_FSETSA(0,XCAPR,      CAP,DEFAULT);
    UTOP_FSETSA(0, UIER,     RQIE,DEFAULT);
    UTOP_FSETSA(0, UIER,     XQIE,DEFAULT);
    UTOP_FSETSA(0, UIPR,     RQIE,DEFAULT);
    UTOP_FSETSA(0, UIPR,     XQIE,DEFAULT);
    UTOP_FSETSA(0,  CDR,    XCCNT,DEFAULT);
    UTOP_FSETSA(0,  CDR,    RCCNT,DEFAULT);
    UTOP_FSETSA(0, EIER,     XCPE,DEFAULT);
    UTOP_FSETSA(0, EIER,     XCFE,DEFAULT);
    UTOP_FSETSA(0, EIER,     XQSE,DEFAULT);
    UTOP_FSETSA(0, EIER,     RCPE,DEFAULT);
    UTOP_FSETSA(0, EIER,     RCFE,DEFAULT);
    UTOP_FSETSA(0, EIER,     RQSE,DEFAULT);
    UTOP_FSETSA(0, EIPR,     XCPP,DEFAULT);
    UTOP_FSETSA(0, EIPR,     XCFP,DEFAULT);
    UTOP_FSETSA(0, EIPR,     XQSP,DEFAULT);
    UTOP_FSETSA(0, EIPR,     RCPP,DEFAULT);
    UTOP_FSETSA(0, EIPR,     RCFP,DEFAULT);
    UTOP_FSETSA(0, EIPR,     RQSP,DEFAULT);

/*  Test FSETSA Macro end */
  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/
int TEST_xbus(int arg) {

  #if (XBUS_SUPPORT&&XBUS_BUILD)

/*  Test FMK Macro start */
    x = XBUS_FMK(  XBGC,    FMOD,0XFFFFFFFF);
    x = XBUS_FMK(  XBGC,   XFCEN,0XFFFFFFFF);
    x = XBUS_FMK(  XBGC,   XFRAT,0XFFFFFFFF);
    x = XBUS_FMK(  XBGC,    XARB,0XFFFFFFFF);
    x = XBUS_FMK(XCECTL, WRSETUP,0XFFFFFFFF);
    x = XBUS_FMK(XCECTL,WRSTROBE,0XFFFFFFFF);
    x = XBUS_FMK(XCECTL,  WRHOLD,0XFFFFFFFF);
    x = XBUS_FMK(XCECTL, RDSETUP,0XFFFFFFFF);
    x = XBUS_FMK(XCECTL,RDSTROBE,0XFFFFFFFF);
    x = XBUS_FMK(XCECTL,   MTYPE,0XFFFFFFFF);
    x = XBUS_FMK(XCECTL,  RDHOLD,0XFFFFFFFF);
    x = XBUS_FMK(  XBHC,   XFRCT,0XFFFFFFFF);
    x = XBUS_FMK(  XBHC,  INTSRC,0XFFFFFFFF);
    x = XBUS_FMK(  XBHC,   START,0XFFFFFFFF);
    x = XBUS_FMK(  XBHC,  DSPINT,0XFFFFFFFF);
    x = XBUS_FMK( XBIMA,   XBIMA,0XFFFFFFFF);
    x = XBUS_FMK(  XBEA,    XBEA,0XFFFFFFFF);

/*  Test FMK Macro end */
/*  Test FMKS Macro start */
    x = XBUS_FMKS(  XBGC,    FMOD,DEFAULT);
    x = XBUS_FMKS(  XBGC,   XFCEN,DEFAULT);
    x = XBUS_FMKS(  XBGC,   XFRAT,DEFAULT);
    x = XBUS_FMKS(  XBGC,    XARB,DEFAULT);
    x = XBUS_FMKS(XCECTL, WRSETUP,DEFAULT);
    x = XBUS_FMKS(XCECTL,WRSTROBE,DEFAULT);
    x = XBUS_FMKS(XCECTL,  WRHOLD,DEFAULT);
    x = XBUS_FMKS(XCECTL, RDSETUP,DEFAULT);
    x = XBUS_FMKS(XCECTL,RDSTROBE,DEFAULT);
    x = XBUS_FMKS(XCECTL,   MTYPE,DEFAULT);
    x = XBUS_FMKS(XCECTL,  RDHOLD,DEFAULT);
    x = XBUS_FMKS(  XBHC,   XFRCT,DEFAULT);
    x = XBUS_FMKS(  XBHC,  INTSRC,DEFAULT);
    x = XBUS_FMKS(  XBHC,   START,DEFAULT);
    x = XBUS_FMKS(  XBHC,  DSPINT,DEFAULT);
    x = XBUS_FMKS( XBIMA,   XBIMA,DEFAULT);
    x = XBUS_FMKS(  XBEA,    XBEA,DEFAULT);


/*  Test FMKS Macro end */
/*  Test ADDR Macro start */
    x = XBUS_ADDR(   XBGC);
    x = XBUS_ADDR(XCECTL0);
    x = XBUS_ADDR(XCECTL1);
    x = XBUS_ADDR(XCECTL2);
    x = XBUS_ADDR(XCECTL3);
    x = XBUS_ADDR(   XBHC);
    x = XBUS_ADDR(  XBIMA);
    x = XBUS_ADDR(   XBEA);

/*  Test ADDR Macro end */
/*  Test RGET Macro start */
    x = XBUS_RGET(   XBGC);
    x = XBUS_RGET(XCECTL0);
    x = XBUS_RGET(XCECTL1);
    x = XBUS_RGET(XCECTL2);
    x = XBUS_RGET(XCECTL3);
    x = XBUS_RGET(   XBHC);
    x = XBUS_RGET(  XBIMA);
    x = XBUS_RGET(   XBEA);


/*  Test RGET Macro end */
/*  Test RSET Macro start */
    XBUS_RSET(   XBGC,  XBUS_XBGC_DEFAULT);
    XBUS_RSET(XCECTL0,XBUS_XCECTL_DEFAULT);
    XBUS_RSET(XCECTL1,XBUS_XCECTL_DEFAULT);
    XBUS_RSET(XCECTL2,XBUS_XCECTL_DEFAULT);
    XBUS_RSET(XCECTL3,XBUS_XCECTL_DEFAULT);
    XBUS_RSET(   XBHC,  XBUS_XBHC_DEFAULT);
    XBUS_RSET(  XBIMA, XBUS_XBIMA_DEFAULT);
    XBUS_RSET(   XBEA,  XBUS_XBEA_DEFAULT);


/*  Test RSET Macro end */
/*  Test FGET Macro start */
    x = XBUS_FGET(  XBGC,    FMOD);
    x = XBUS_FGET(  XBGC,   XFCEN);
    x = XBUS_FGET(  XBGC,   XFRAT);
    x = XBUS_FGET(  XBGC,    XARB);

    x = XBUS_FGET(XCECTL0, WRSETUP);
    x = XBUS_FGET(XCECTL0,WRSTROBE);
    x = XBUS_FGET(XCECTL0,  WRHOLD);
    x = XBUS_FGET(XCECTL0, RDSETUP);
    x = XBUS_FGET(XCECTL0,RDSTROBE);
    x = XBUS_FGET(XCECTL0,   MTYPE);
    x = XBUS_FGET(XCECTL0,  RDHOLD);

    x = XBUS_FGET(XCECTL1, WRSETUP);
    x = XBUS_FGET(XCECTL1,WRSTROBE);
    x = XBUS_FGET(XCECTL1,  WRHOLD);
    x = XBUS_FGET(XCECTL1, RDSETUP);
    x = XBUS_FGET(XCECTL1,RDSTROBE);
    x = XBUS_FGET(XCECTL1,   MTYPE);
    x = XBUS_FGET(XCECTL1,  RDHOLD);

    x = XBUS_FGET(XCECTL2, WRSETUP);
    x = XBUS_FGET(XCECTL2,WRSTROBE);
    x = XBUS_FGET(XCECTL2,  WRHOLD);
    x = XBUS_FGET(XCECTL2, RDSETUP);
    x = XBUS_FGET(XCECTL2,RDSTROBE);
    x = XBUS_FGET(XCECTL2,   MTYPE);
    x = XBUS_FGET(XCECTL2,  RDHOLD);

    x = XBUS_FGET(XCECTL3, WRSETUP);
    x = XBUS_FGET(XCECTL3,WRSTROBE);
    x = XBUS_FGET(XCECTL3,  WRHOLD);
    x = XBUS_FGET(XCECTL3, RDSETUP);
    x = XBUS_FGET(XCECTL3,RDSTROBE);
    x = XBUS_FGET(XCECTL3,   MTYPE);
    x = XBUS_FGET(XCECTL3,  RDHOLD);

    x = XBUS_FGET(  XBHC,   XFRCT);
    x = XBUS_FGET(  XBHC,  INTSRC);
    x = XBUS_FGET(  XBHC,   START);
    x = XBUS_FGET(  XBHC,  DSPINT);
    x = XBUS_FGET( XBIMA,   XBIMA);
    x = XBUS_FGET(  XBEA,    XBEA);



/*  Test FGET Macro end */
/*  Test FSET Macro start */
    XBUS_FSET(  XBGC,     FMOD,      XBUS_XBGC_FMOD_DEFAULT);
    XBUS_FSET(  XBGC,    XFCEN,     XBUS_XBGC_XFCEN_DEFAULT);
    XBUS_FSET(  XBGC,    XFRAT,     XBUS_XBGC_XFRAT_DEFAULT);
    XBUS_FSET(  XBGC,     XARB,      XBUS_XBGC_XARB_DEFAULT);

    XBUS_FSET(XCECTL0, WRSETUP, XBUS_XCECTL_WRSETUP_DEFAULT);
    XBUS_FSET(XCECTL0,WRSTROBE,XBUS_XCECTL_WRSTROBE_DEFAULT);
    XBUS_FSET(XCECTL0,  WRHOLD,  XBUS_XCECTL_WRHOLD_DEFAULT);
    XBUS_FSET(XCECTL0, RDSETUP, XBUS_XCECTL_RDSETUP_DEFAULT);
    XBUS_FSET(XCECTL0,RDSTROBE,XBUS_XCECTL_RDSTROBE_DEFAULT);
    XBUS_FSET(XCECTL0,   MTYPE,   XBUS_XCECTL_MTYPE_DEFAULT);
    XBUS_FSET(XCECTL0,  RDHOLD,  XBUS_XCECTL_RDHOLD_DEFAULT);

    XBUS_FSET(XCECTL1, WRSETUP, XBUS_XCECTL_WRSETUP_DEFAULT);
    XBUS_FSET(XCECTL1,WRSTROBE,XBUS_XCECTL_WRSTROBE_DEFAULT);
    XBUS_FSET(XCECTL1,  WRHOLD,  XBUS_XCECTL_WRHOLD_DEFAULT);
    XBUS_FSET(XCECTL1, RDSETUP, XBUS_XCECTL_RDSETUP_DEFAULT);
    XBUS_FSET(XCECTL1,RDSTROBE,XBUS_XCECTL_RDSTROBE_DEFAULT);
    XBUS_FSET(XCECTL1,   MTYPE,   XBUS_XCECTL_MTYPE_DEFAULT);
    XBUS_FSET(XCECTL1,  RDHOLD,  XBUS_XCECTL_RDHOLD_DEFAULT);

    XBUS_FSET(XCECTL2, WRSETUP, XBUS_XCECTL_WRSETUP_DEFAULT);
    XBUS_FSET(XCECTL2,WRSTROBE,XBUS_XCECTL_WRSTROBE_DEFAULT);
    XBUS_FSET(XCECTL2,  WRHOLD,  XBUS_XCECTL_WRHOLD_DEFAULT);
    XBUS_FSET(XCECTL2, RDSETUP, XBUS_XCECTL_RDSETUP_DEFAULT);
    XBUS_FSET(XCECTL2,RDSTROBE,XBUS_XCECTL_RDSTROBE_DEFAULT);
    XBUS_FSET(XCECTL2,   MTYPE,   XBUS_XCECTL_MTYPE_DEFAULT);
    XBUS_FSET(XCECTL2,  RDHOLD,  XBUS_XCECTL_RDHOLD_DEFAULT);

    XBUS_FSET(XCECTL3, WRSETUP, XBUS_XCECTL_WRSETUP_DEFAULT);
    XBUS_FSET(XCECTL3,WRSTROBE,XBUS_XCECTL_WRSTROBE_DEFAULT);
    XBUS_FSET(XCECTL3,  WRHOLD,  XBUS_XCECTL_WRHOLD_DEFAULT);
    XBUS_FSET(XCECTL3, RDSETUP, XBUS_XCECTL_RDSETUP_DEFAULT);
    XBUS_FSET(XCECTL3,RDSTROBE,XBUS_XCECTL_RDSTROBE_DEFAULT);
    XBUS_FSET(XCECTL3,   MTYPE,   XBUS_XCECTL_MTYPE_DEFAULT);
    XBUS_FSET(XCECTL3,  RDHOLD,  XBUS_XCECTL_RDHOLD_DEFAULT);

    XBUS_FSET(  XBHC,    XFRCT,     XBUS_XBHC_XFRCT_DEFAULT);
    XBUS_FSET(  XBHC,   INTSRC,    XBUS_XBHC_INTSRC_DEFAULT);
    XBUS_FSET(  XBHC,    START,     XBUS_XBHC_START_DEFAULT);
    XBUS_FSET(  XBHC,   DSPINT,    XBUS_XBHC_DSPINT_DEFAULT);
    XBUS_FSET( XBIMA,    XBIMA,    XBUS_XBIMA_XBIMA_DEFAULT);
    XBUS_FSET(  XBEA,     XBEA,      XBUS_XBEA_XBEA_DEFAULT);

/*  Test FSET Macro end */
/*  Test FSETS Macro start */
    XBUS_FSETS(  XBGC,     FMOD,DEFAULT);
    XBUS_FSETS(  XBGC,    XFCEN,DEFAULT);
    XBUS_FSETS(  XBGC,    XFRAT,DEFAULT);
    XBUS_FSETS(  XBGC,     XARB,DEFAULT);

    XBUS_FSETS(XCECTL0, WRSETUP,DEFAULT);
    XBUS_FSETS(XCECTL0,WRSTROBE,DEFAULT);
    XBUS_FSETS(XCECTL0,  WRHOLD,DEFAULT);
    XBUS_FSETS(XCECTL0, RDSETUP,DEFAULT);
    XBUS_FSETS(XCECTL0,RDSTROBE,DEFAULT);
    XBUS_FSETS(XCECTL0,   MTYPE,DEFAULT);
    XBUS_FSETS(XCECTL0,  RDHOLD,DEFAULT);

    XBUS_FSETS(XCECTL1, WRSETUP,DEFAULT);
    XBUS_FSETS(XCECTL1,WRSTROBE,DEFAULT);
    XBUS_FSETS(XCECTL1,  WRHOLD,DEFAULT);
    XBUS_FSETS(XCECTL1, RDSETUP,DEFAULT);
    XBUS_FSETS(XCECTL1,RDSTROBE,DEFAULT);
    XBUS_FSETS(XCECTL1,   MTYPE,DEFAULT);
    XBUS_FSETS(XCECTL1,  RDHOLD,DEFAULT);

    XBUS_FSETS(XCECTL2, WRSETUP,DEFAULT);
    XBUS_FSETS(XCECTL2,WRSTROBE,DEFAULT);
    XBUS_FSETS(XCECTL2,  WRHOLD,DEFAULT);
    XBUS_FSETS(XCECTL2, RDSETUP,DEFAULT);
    XBUS_FSETS(XCECTL2,RDSTROBE,DEFAULT);
    XBUS_FSETS(XCECTL2,   MTYPE,DEFAULT);
    XBUS_FSETS(XCECTL2,  RDHOLD,DEFAULT);

    XBUS_FSETS(XCECTL3, WRSETUP,DEFAULT);
    XBUS_FSETS(XCECTL3,WRSTROBE,DEFAULT);
    XBUS_FSETS(XCECTL3,  WRHOLD,DEFAULT);
    XBUS_FSETS(XCECTL3, RDSETUP,DEFAULT);
    XBUS_FSETS(XCECTL3,RDSTROBE,DEFAULT);
    XBUS_FSETS(XCECTL3,   MTYPE,DEFAULT);
    XBUS_FSETS(XCECTL3,  RDHOLD,DEFAULT);

    XBUS_FSETS(  XBHC,    XFRCT,DEFAULT);
    XBUS_FSETS(  XBHC,   INTSRC,DEFAULT);
    XBUS_FSETS(  XBHC,    START,DEFAULT);
    XBUS_FSETS(  XBHC,   DSPINT,DEFAULT);
    XBUS_FSETS( XBIMA,    XBIMA,DEFAULT);
    XBUS_FSETS(  XBEA,     XBEA,DEFAULT);

/*  Test FSETS Macro end */
/*  Test RGETA Macro START */
    x = XBUS_RGETA(0,   XBGC);
    x = XBUS_RGETA(0,XCECTL0);
    x = XBUS_RGETA(0,XCECTL1);
    x = XBUS_RGETA(0,XCECTL2);
    x = XBUS_RGETA(0,XCECTL3);
    x = XBUS_RGETA(0,   XBHC);
    x = XBUS_RGETA(0,  XBIMA);
    x = XBUS_RGETA(0,   XBEA);


/*  Test RGETA Macro end */
/*  Test RSETA Macro start */
    XBUS_RSETA(0,   XBGC,  XBUS_XBGC_DEFAULT);
    XBUS_RSETA(0,XCECTL0,XBUS_XCECTL_DEFAULT);
    XBUS_RSETA(0,XCECTL1,XBUS_XCECTL_DEFAULT);
    XBUS_RSETA(0,XCECTL2,XBUS_XCECTL_DEFAULT);
    XBUS_RSETA(0,XCECTL3,XBUS_XCECTL_DEFAULT);
    XBUS_RSETA(0,   XBHC,  XBUS_XBHC_DEFAULT);
    XBUS_RSETA(0,  XBIMA, XBUS_XBIMA_DEFAULT);
    XBUS_RSETA(0,   XBEA,  XBUS_XBEA_DEFAULT);


/*  Test RSETA Macro end */
/*  Test FGETA Macro start */
    x = XBUS_FGETA(0,  XBGC,    FMOD);
    x = XBUS_FGETA(0,  XBGC,   XFCEN);
    x = XBUS_FGETA(0,  XBGC,   XFRAT);
    x = XBUS_FGETA(0,  XBGC,    XARB);

    x = XBUS_FGETA(0,XCECTL WRSETUP);
    x = XBUS_FGETA(0,XCECTL,WRSTROBE);
    x = XBUS_FGETA(0,XCECTL,  WRHOLD);
    x = XBUS_FGETA(0,XCECTL, RDSETUP);
    x = XBUS_FGETA(0,XCECTL,RDSTROBE);
    x = XBUS_FGETA(0,XCECTL,   MTYPE);
    x = XBUS_FGETA(0,XCECTL,  RDHOLD);

    x = XBUS_FGETA(0,  XBHC,   XFRCT);
    x = XBUS_FGETA(0,  XBHC,  INTSRC);
    x = XBUS_FGETA(0,  XBHC,   START);
    x = XBUS_FGETA(0,  XBHC,  DSPINT);
    x = XBUS_FGETA(0, XBIMA,   XBIMA);
    x = XBUS_FGETA(0,  XBEA,    XBEA);

/*  Test FGETA Macro end */
/*  Test FSETA Macro start */
    XBUS_FSETA(0,  XBGC,     FMOD,      XBUS_XBGC_FMOD_DEFAULT);
    XBUS_FSETA(0,  XBGC,    XFCEN,     XBUS_XBGC_XFCEN_DEFAULT);
    XBUS_FSETA(0,  XBGC,    XFRAT,     XBUS_XBGC_XFRAT_DEFAULT);
    XBUS_FSETA(0,  XBGC,     XARB,      XBUS_XBGC_XARB_DEFAULT);

    XBUS_FSETA(0,XCECTL, WRSETUP, XBUS_XCECTL_WRSETUP_DEFAULT);
    XBUS_FSETA(0,XCECTL,WRSTROBE,XBUS_XCECTL_WRSTROBE_DEFAULT);
    XBUS_FSETA(0,XCECTL,  WRHOLD,  XBUS_XCECTL_WRHOLD_DEFAULT);
    XBUS_FSETA(0,XCECTL, RDSETUP, XBUS_XCECTL_RDSETUP_DEFAULT);
    XBUS_FSETA(0,XCECTL,RDSTROBE,XBUS_XCECTL_RDSTROBE_DEFAULT);
    XBUS_FSETA(0,XCECTL,   MTYPE,   XBUS_XCECTL_MTYPE_DEFAULT);
    XBUS_FSETA(0,XCECTL,  RDHOLD,  XBUS_XCECTL_RDHOLD_DEFAULT);

    XBUS_FSETA(0,  XBHC,    XFRCT,     XBUS_XBHC_XFRCT_DEFAULT);
    XBUS_FSETA(0,  XBHC,   INTSRC,    XBUS_XBHC_INTSRC_DEFAULT);
    XBUS_FSETA(0,  XBHC,    START,     XBUS_XBHC_START_DEFAULT);
    XBUS_FSETA(0,  XBHC,   DSPINT,    XBUS_XBHC_DSPINT_DEFAULT);
    XBUS_FSETA(0, XBIMA,    XBIMA,    XBUS_XBIMA_XBIMA_DEFAULT);
    XBUS_FSETA(0,  XBEA,     XBEA,      XBUS_XBEA_XBEA_DEFAULT);

/*  Test FSETA Macro end */
/*  Test FSETS Macro start */
    XBUS_FSETSA(0,  XBGC,     FMOD,DEFAULT);
    XBUS_FSETSA(0,  XBGC,    XFCEN,DEFAULT);
    XBUS_FSETSA(0,  XBGC,    XFRAT,DEFAULT);
    XBUS_FSETSA(0,  XBGC,     XARB,DEFAULT);

    XBUS_FSETSA(0,XCECTL, WRSETUP,DEFAULT);
    XBUS_FSETSA(0,XCECTL,WRSTROBE,DEFAULT);
    XBUS_FSETSA(0,XCECTL,  WRHOLD,DEFAULT);
    XBUS_FSETSA(0,XCECTL, RDSETUP,DEFAULT);
    XBUS_FSETSA(0,XCECTL,RDSTROBE,DEFAULT);
    XBUS_FSETSA(0,XCECTL,   MTYPE,DEFAULT);
    XBUS_FSETSA(0,XCECTL,  RDHOLD,DEFAULT);

    XBUS_FSETSA(0,  XBHC,    XFRCT,DEFAULT);
    XBUS_FSETSA(0,  XBHC,   INTSRC,DEFAULT);
    XBUS_FSETSA(0,  XBHC,    START,DEFAULT);
    XBUS_FSETSA(0,  XBHC,   DSPINT,DEFAULT);
    XBUS_FSETSA(0, XBIMA,    XBIMA,DEFAULT);
    XBUS_FSETSA(0,  XBEA,     XBEA,DEFAULT);

/*  Test FSETS Macro end */

  #endif

  return 0;
}

/*----------------------------------------------------------------------------*/

/******************************************************************************\
* End of csl_test.c
\******************************************************************************/


